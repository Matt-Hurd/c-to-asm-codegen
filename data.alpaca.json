[
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nmaxPathSum__FP4nodei PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOV      r0,r1\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADD      r5,r1,r0\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,r5\n        BL       maxPathSum__FP4nodei\n        MOV      r6,r0\n        LDR      r0,[r4,#8]\n        MOV      r1,r5\n        BL       maxPathSum__FP4nodei\n        CMP      r6,r0\n        MOVGT    r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nint maxPathSum(struct node *root, int sum) {\n    if (!root) return sum;\n    sum += root->data;\n    if (!root->left && !root->right) return sum;\n    int leftSum = maxPathSum(root->left, sum);\n    int rightSum = maxPathSum(root->right, sum);\n    return (leftSum > rightSum) ? leftSum : rightSum;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\njulianDate__FiN21 PROC\n        LDR      r3,|L1.204|\n        STR      lr,[sp,#-4]!\n        RSB      r12,r1,#0xe\n        SMULL    lr,r12,r3,r12\n        MOV      r3,r12,ASR #1\n        SUB      r3,r3,r3,ASR #31\n        ADD      r0,r0,#0x12c0\n        SUB      r0,r0,r3\n        ADD      r3,r3,r3,LSL #1\n        ADD      r1,r1,r3,LSL #2\n        SUB      r1,r1,#3\n        ADD      r1,r1,r1,LSL #4\n        ADD      r1,r1,r1,LSL #3\n        ADD      r3,r1,#2\n        LDR      r1,|L1.208|\n        LDR      lr,[sp],#4\n        SMULL    r12,r3,r1,r3\n        MOV      r1,r3,ASR #1\n        SUB      r1,r1,r1,ASR #31\n        ADD      r1,r1,r2\n        ADD      r2,r0,r0,LSL #3\n        ADD      r2,r2,r0,LSL #6\n        ADD      r2,r2,r2,LSL #2\n        ADD      r1,r1,r2\n        MOV      r2,r0,ASR #31\n        ADD      r2,r0,r2,LSR #30\n        ADD      r1,r1,r2,ASR #2\n        LDR      r2,|L1.212|\n        SMULL    r12,r3,r2,r0\n        MOV      r3,r3,ASR #5\n        SUB      r3,r3,r3,ASR #31\n        SUB      r1,r1,r3\n        SMULL    r3,r0,r2,r0\n        MOV      r0,r0,ASR #7\n        SUB      r0,r0,r0,ASR #31\n        ADD      r0,r1,r0\n        SUB      r0,r0,#0x7d00\n        SUB      r0,r0,#0x2d\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint julianDate(int year, int month, int day) {\n    int a = (14 - month) / 12;\n    int y = year + 4800 - a;\n    int m = month + 12 * a - 3;\n    return day + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbubble_sort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        SUB      r6,r1,#1\n        CMP      r6,#0\n        MOV      lr,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.24|\n        SUB      r3,r1,lr\n        SUB      r5,r3,#1\n        CMP      r5,#0\n        MOV      r2,#0\n        BLE      |L1.80|\n|L1.44|\n        LDR      r3,[r0,r2,LSL #2]\n        ADD      r4,r0,r2,LSL #2\n        LDR      r12,[r4,#4]\n        CMP      r3,r12\n        STRGT    r12,[r0,r2,LSL #2]\n        STRGT    r3,[r4,#4]\n        ADD      r2,r2,#1\n        CMP      r5,r2\n        BGT      |L1.44|\n|L1.80|\n        ADD      lr,lr,#1\n        CMP      lr,r6\n        BLT      |L1.24|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid bubble_sort(int arr[], int n) {\n    int temp;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,#0\n        MOV      r5,r0\n        MOV      r4,#0\n|L1.64|\n        CMP      r5,#0\n        BEQ      |L1.100|\n        MOV      r0,#0xc\n        BL       malloc\n        LDR      r1,[r5,#0]\n        STMIA    r0,{r1,r4,r6}\n        LDR      r5,[r5,#4]\n        MOV      r4,r0\n        B        |L1.64|\n|L1.100|\n        CMP      r4,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDMIA    r4,{r1,r5}\n        ADR      r0,|L1.132|\n        BL       _printf\n        LDR      r4,[r4,#4]\n        B        |L1.64|\n|L1.132|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorderIterative(struct Node* root) {\n    if (root == NULL) return;\n    struct Node* current = root;\n    struct Node* stack = NULL;\n    while (1) {\n        if (current != NULL) {\n            struct Node* temp = (struct Node*)malloc(sizeof(struct Node));\n            temp->data = current->data;\n            temp->left = stack;\n            temp->right = NULL;\n            stack = temp;\n            current = current->left;\n        } else {\n            if (stack == NULL) break;\n            current = stack->left;\n            printf(\"%d \", stack->data);\n            stack = stack->left;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsearch__FPiiN22 PROC\n        CMP      r1,r2\n        BGT      |L1.76|\n|L1.48|\n        LDR      r12,[r0,r1,LSL #2]\n        CMP      r12,r3\n        MOVEQ    r0,r1\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLE      |L1.48|\n|L1.76|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nbuildTree__FPiT1iT3T1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#8\n        LDR      r5,[sp,#0x28]\n        CMP      r2,r3\n        ADDGT    sp,sp,#8\n        MOV      r9,r0\n        MOV      r8,r1\n        MOV      r7,r3\n        MOV      r6,r2\n        LDMGTFD  sp!,{r4-r10,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r0,[r5,#0]\n        LDR      r0,[r8,r0,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        LDR      r0,[r5,#0]\n        CMP      r6,r7\n        SUB      r0,r0,#1\n        STR      r0,[r5,#0]\n        ADDEQ    sp,sp,#8\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        MOV      r2,r7\n        MOV      r1,r6\n        MOV      r0,r9\n        LDR      r3,[r4,#0]\n        BL       search__FPiiN22\n        MOV      r10,r0\n        ADD      r2,r0,#1\n        MOV      r0,r9\n        MOV      r3,r7\n        MOV      r1,r8\n        STR      r5,[sp,#0]\n        BL       buildTree__FPiT1iT3T1\n        STR      r0,[r4,#8]\n        STR      r5,[sp,#0]\n        MOV      r0,r9\n        SUB      r3,r10,#1\n        MOV      r2,r6\n        MOV      r1,r8\n        BL       buildTree__FPiT1iT3T1\n        STR      r0,[r4,#4]\n        ADD      sp,sp,#8\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int data;\n    Node *left, *right;\n};\n\nNode* newNode(int data) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint search(int inorder[], int start, int end, int value) {\n    for (int i = start; i <= end; i++) {\n        if (inorder[i] == value) return i;\n    }\n    return -1;\n}\n\nNode* buildTree(int inorder[], int postorder[], int inStart, int inEnd, int* pIndex) {\n    if (inStart > inEnd) return NULL;\n\n    Node* node = newNode(postorder[*pIndex]);\n    (*pIndex)--;\n\n    if (inStart == inEnd) return node;\n\n    int inIndex = search(inorder, inStart, inEnd, node->data);\n    node->right = buildTree(inorder, postorder, inIndex + 1, inEnd, pIndex);\n    node->left = buildTree(inorder, postorder, inStart, inIndex - 1, pIndex);\n\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisBSTUtil__FP4NodeiT2 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLT      |L1.44|\n        CMP      r0,r5\n        BLE      |L1.56|\n|L1.44|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.56|\n        SUB      r2,r0,#1\n        LDR      r0,[r4,#4]\n        BL       isBSTUtil__FP4NodeiT2\n        CMP      r0,#0\n        BEQ      |L1.112|\n        LDR      r0,[r4,#0]\n        MOV      r2,r5\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#8]\n        BL       isBSTUtil__FP4NodeiT2\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.112|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nisBST__FP4Node PROC\n        MVN      r2,#0x80000000\n        MOV      r1,#0x80000000\n        B        isBSTUtil__FP4NodeiT2\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nint isBSTUtil(Node* node, int min, int max) {\n    if (node == NULL) return 1;\n    if (node->data < min || node->data > max) return 0;\n    return isBSTUtil(node->left, min, node->data - 1) && isBSTUtil(node->right, node->data + 1, max);\n}\n\n\nint isBST(Node* node) {\n    return isBSTUtil(node, -2147483648, 2147483647);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nlevelOrder__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        ADD      r7,sp,#4\n        STR      r0,[sp,#4]\n        MOV      r6,#0\n        MOV      r4,#1\n|L1.76|\n        MOV      r0,r6\n        LDR      r5,[r7,r0,LSL #2]\n        ADR      r0,|L1.164|\n        ADD      r6,r6,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r1,[r5,#4]\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        LDR      r1,[r5,#8]\n        ADDNE    r4,r4,#1\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        ADDNE    r4,r4,#1\n        CMP      r6,r4\n        BLT      |L1.76|\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.164|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid levelOrder(struct Node* root) {\n    if (root == NULL) return;\n    struct Node* queue[1000];\n    int front = 0, rear = 0;\n    queue[rear++] = root;\n    while (front < rear) {\n        struct Node* curr = queue[front++];\n        printf(\"%d \", curr->data);\n        if (curr->left) queue[rear++] = curr->left;\n        if (curr->right) queue[rear++] = curr->right;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncaesar_cipher__FPciT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r7,r2\n        MOV      r5,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        BL       __rt_ctype_table\n        RSB      r2,r8,#0\n        CMP      r7,#0\n        MOVNE    r2,r8\n        LDR      r1,|L1.264|\n        MOV      r8,r2\n|L1.64|\n        LDRB     r3,[r5,r4]\n        LDR      r2,[r0,#0]\n        LDRB     r2,[r2,r3]\n        TST      r2,#0x18\n        BEQ      |L1.144|\n        TST      r2,#8\n        MOVEQ    r2,#0x41\n        MOVNE    r2,#0x61\n        SUB      r3,r3,r2\n        ADD      r3,r3,r8\n        ADD      r3,r3,#0x1a\n        SMULL    lr,r12,r1,r3\n        MOV      r12,r12,ASR #3\n        SUB      lr,r12,r12,ASR #31\n        SUB      r12,lr,lr,LSL #1\n        ADD      r12,r12,r12,LSL #4\n        ADD      r12,r12,lr,LSL #2\n        ADD      r3,r3,r12,LSL #1\n        ADD      r2,r3,r2\n        STRB     r2,[r5,r4]\n|L1.144|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.64|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid caesar_cipher(char *str, int shift, int encode) {\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(str[i])) {\n            char base = islower(str[i]) ? 'a' : 'A';\n            str[i] = base + (str[i] - base + (encode ? shift : -shift) + 26) % 26;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__F8RationalT1 PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r5,sp,#0x44\n        LDMIA    r5,{r4,r5}\n        MOV      r0,r1\n        MOV      r1,r2\n        UMULL    r8,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r7,r3\n        ADD      r11,sp,#0x38\n        LDMIA    r11,{r6,r10,r11}\n        MLA      r3,r5,r0,r12\n        UMULL    r0,r12,r10,r7\n        MLA      r12,r7,r11,r12\n        MLA      r1,r6,r10,r12\n        ADDS     r8,r0,r8\n        UMULL    r0,r12,r7,r4\n        ADC      r9,r1,r3\n        MLA      r12,r4,r6,r12\n        LDR      r2,[sp,#0x28]\n        MLA      r1,r5,r7,r12\n        STMIA    r2,{r8,r9}\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\nsubtract__F8RationalT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r5,sp,#0x44\n        LDMIA    r5,{r4,r5}\n        MOV      r0,r1\n        MOV      r1,r2\n        UMULL    r8,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r7,r3\n        ADD      r11,sp,#0x38\n        LDMIA    r11,{r6,r10,r11}\n        MLA      r3,r5,r0,r12\n        UMULL    r0,r12,r10,r7\n        MLA      r12,r7,r11,r12\n        MLA      r1,r6,r10,r12\n        RSBS     r8,r0,r8\n        UMULL    r0,r12,r7,r4\n        RSC      r9,r1,r3\n        MLA      r12,r4,r6,r12\n        LDR      r2,[sp,#0x28]\n        MLA      r1,r5,r7,r12\n        STMIA    r2,{r8,r9}\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\nmultiply__F8RationalT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        UMULL    r7,r12,r0,r2\n        MLA      r12,r2,r1,r12\n        MLA      r8,r3,r0,r12\n        LDR      r6,[sp,#0x20]\n        UMULL    r0,r12,r9,r4\n        MLA      r12,r4,r6,r12\n        MLA      r1,r5,r9,r12\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ndivide__F8RationalT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r9,r3\n        ADD      r3,sp,#0x2c\n        MOV      r1,r2\n        LDMIA    r3,{r2,r3}\n        UMULL    r7,r12,r0,r2\n        MLA      r12,r2,r1,r12\n        ADD      r5,sp,#0x24\n        LDMIA    r5,{r4,r5}\n        MLA      r8,r3,r0,r12\n        LDR      r6,[sp,#0x20]\n        UMULL    r0,r12,r9,r4\n        MLA      r12,r4,r6,r12\n        MLA      r1,r5,r9,r12\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    long long num;\n    long long den;\n} Rational;\n\nRational add(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.den + r2.num * r1.den;\n    result.den = r1.den * r2.den;\n    return result;\n}\n\nRational subtract(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.den - r2.num * r1.den;\n    result.den = r1.den * r2.den;\n    return result;\n}\n\nRational multiply(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.num;\n    result.den = r1.den * r2.den;\n    return result;\n}\n\nRational divide(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.den;\n    result.den = r1.den * r2.num;\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStringList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\naddString__FP10StringListPCc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        CMPNE    r6,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        CMP      r1,r0\n        BLT      |L1.136|\n        CMP      r0,#0\n        MOVNE    r5,r0,LSL #1\n        MOVEQ    r5,#1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r5,[r4,#8]\n|L1.136|\n        MOV      r0,r6\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       strcpy\n        LDMIA    r4,{r0,r1}\n        STR      r5,[r0,r1,LSL #2]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nfreeStringList__FP10StringList PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#4]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.268|\n|L1.240|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        BL       free\n        LDR      r0,[r5,#4]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.240|\n|L1.268|\n        LDR      r0,[r5,#0]\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct StringList {\n    char** list;\n    int size;\n    int capacity;\n};\n\nStringList* createStringList() {\n    StringList* sl = (StringList*)malloc(sizeof(StringList));\n    if (sl == NULL) return NULL;\n    sl->list = NULL;\n    sl->size = 0;\n    sl->capacity = 0;\n    return sl;\n}\n\nint addString(StringList* sl, const char* str) {\n    if (sl == NULL || str == NULL) return 0;\n    if (sl->size >= sl->capacity) {\n        int newCapacity = sl->capacity == 0 ? 1 : sl->capacity * 2;\n        char** newList = (char**)realloc(sl->list, newCapacity * sizeof(char*));\n        if (newList == NULL) return 0;\n        sl->list = newList;\n        sl->capacity = newCapacity;\n    }\n    size_t len = strlen(str);\n    char* newStr = (char*)malloc((len + 1) * sizeof(char));\n    if (newStr == NULL) return 0;\n    strcpy(newStr, str);\n    sl->list[sl->size] = newStr;\n    sl->size++;\n    return 1;\n}\n\n\nvoid freeStringList(StringList* sl) {\n    if (sl == NULL) return;\n    for (int i = 0; i < sl->size; i++) {\n        free(sl->list[i]);\n    }\n    free(sl->list);\n    free(sl);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nshell_sort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        ADD      r2,r1,r1,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n|L1.24|\n        MOV      r12,r3\n        CMP      r3,r1\n        BGE      |L1.92|\n|L1.36|\n        LDR      lr,[r0,r12,LSL #2]\n        MOV      r2,r12\n        B        |L1.56|\n|L1.48|\n        STR      r5,[r0,r2,LSL #2]\n        MOV      r2,r4\n|L1.56|\n        CMP      r2,r3\n        SUBGE    r4,r2,r3\n        LDRGE    r5,[r0,r4,LSL #2]\n        CMPGE    r5,lr\n        BGT      |L1.48|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        STR      lr,[r0,r2,LSL #2]\n        BLT      |L1.36|\n|L1.92|\n        ADD      r2,r3,r3,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        BGT      |L1.24|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid shell_sort(int arr[], int n) {\n    int gap, i, j, temp;\n    for (gap = n / 2; gap > 0; gap /= 2) {\n        for (i = gap; i < n; i++) {\n            temp = arr[i];\n            j = i;\n            while (j >= gap && arr[j - gap] > temp) {\n                arr[j] = arr[j - gap];\n                j -= gap;\n            }\n            arr[j] = temp;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncatalan__Fi PROC\n        STMFD    sp!,{r3-r9,lr}\n        CMP      r0,#1\n        ADRLE    r1,|L1.116|\n        MOV      r7,r0\n        LDMLEIA  r1,{r0,r1}\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        MOV      r4,#0\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r5,r6}\n|L1.40|\n        MOV      r0,r4\n        BL       catalan__Fi\n        MOV      r8,r0\n        SUB      r0,r7,r4\n        SUB      r0,r0,#1\n        MOV      r9,r1\n        BL       catalan__Fi\n        UMULL    r2,r12,r0,r8\n        MLA      r12,r8,r1,r12\n        MLA      r3,r9,r0,r12\n        ADDS     r5,r5,r2\n        ADC      r6,r6,r3\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.40|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.116|\n        DCQ      0x0000000000000001\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long catalan(int n) {\n    if (n <= 1) return 1;\n    unsigned long long res = 0;\n    for (int i = 0; i < n; i++) {\n        res += catalan(i) * catalan(n - i - 1);\n    }\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngaussianElimination__FPPdPdi PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#8\n        CMP      r2,#0\n        ADDLE    sp,sp,#0x14\n        MOV      r8,r2\n        MOV      r6,r0\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n|L1.36|\n        ADD      r7,r4,#1\n        STR      r7,[sp,#4]\n        CMP      r7,r8\n        MOV      r5,r4\n        BGE      |L1.112|\n|L1.56|\n        LDR      r0,[r6,r7,LSL #2]\n        ADD      r0,r0,r4,LSL #3\n        LDR      r1,[r0,#4]\n        LDR      r2,[r0,#0]\n        LDR      r0,[r6,r5,LSL #2]\n        BIC      r3,r1,#0x80000000\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmple\n        MOVCC    r5,r7\n        ADD      r7,r7,#1\n        CMP      r7,r8\n        BLT      |L1.56|\n|L1.112|\n        LDR      r0,[r6,r5,LSL #2]\n        ADR      r2,|L1.456|\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        LDMIA    r2,{r2,r3}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmple\n        BCC      |L1.432|\n        LDR      r1,[r6,r5,LSL #2]\n        LDR      r0,[r6,r4,LSL #2]\n        STR      r1,[r6,r4,LSL #2]\n        STR      r0,[r6,r5,LSL #2]\n        LDR      r3,[sp,#0xc]\n        CMP      r4,r8\n        ADD      r2,r3,r4,LSL #3\n        STR      r2,[sp,#0]\n        ADD      r3,r3,r5,LSL #3\n        LDMIA    r3,{r12,lr}\n        LDMIA    r2,{r0,r1}\n        STMIA    r2,{r12,lr}\n        STMIA    r3,{r0,r1}\n        LDR      r0,[r6,r4,LSL #2]\n        MOV      r5,r4\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r9,r10}\n        BGE      |L1.256|\n|L1.216|\n        LDR      r0,[r6,r4,LSL #2]\n        MOV      r3,r10\n        ADD      r7,r0,r5,LSL #3\n        LDMIA    r7,{r0,r1}\n        MOV      r2,r9\n        BL       _ddiv\n        ADD      r5,r5,#1\n        CMP      r5,r8\n        STMIA    r7,{r0,r1}\n        BLT      |L1.216|\n|L1.256|\n        LDR      r5,[sp,#0]\n        MOV      r3,r10\n        MOV      r2,r9\n        LDMIA    r5,{r0,r1}\n        BL       _ddiv\n        MOV      r7,#0\n        CMP      r8,#0\n        STMIA    r5,{r0,r1}\n        BLE      |L1.432|\n|L1.292|\n        CMP      r7,r4\n        BEQ      |L1.420|\n        LDR      r0,[r6,r7,LSL #2]\n        MOV      r5,r4\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r10,r11}\n        CMP      r4,r8\n        BGE      |L1.380|\n|L1.324|\n        LDR      r0,[r6,r7,LSL #2]\n        MOV      r1,r11\n        ADD      r9,r0,r5,LSL #3\n        LDR      r0,[r6,r4,LSL #2]\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r10\n        BL       _dmul\n        LDMIA    r9,{r2,r3}\n        BL       _drsb\n        ADD      r5,r5,#1\n        CMP      r5,r8\n        STMIA    r9,{r0,r1}\n        BLT      |L1.324|\n|L1.380|\n        LDR      r2,[sp,#0]\n        MOV      r1,r11\n        MOV      r0,r10\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        LDR      r3,[sp,#0xc]\n        ADD      r5,r3,r7,LSL #3\n        LDMIA    r5,{r2,r3}\n        BL       _drsb\n        STMIA    r5,{r0,r1}\n|L1.420|\n        ADD      r7,r7,#1\n        CMP      r7,r8\n        BLT      |L1.292|\n|L1.432|\n        LDR      r4,[sp,#4]\n        CMP      r4,r8\n        BLT      |L1.36|\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.456|\n        DCFD     0x3ddb7cdfd9d7bdbb\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid gaussianElimination(double **A, double *b, int n) {\n    for (int i = 0; i < n; i++) {\n        int maxRow = i;\n        for (int k = i + 1; k < n; k++) {\n            if (fabs(A[k][i]) > fabs(A[maxRow][i])) {\n                maxRow = k;\n            }\n        }\n        if (fabs(A[maxRow][i]) < 1e-10) continue;\n\n        double *temp = A[i];\n        A[i] = A[maxRow];\n        A[maxRow] = temp;\n        double tempB = b[i];\n        b[i] = b[maxRow];\n        b[maxRow] = tempB;\n\n        double pivot = A[i][i];\n        for (int j = i; j < n; j++) {\n            A[i][j] /= pivot;\n        }\n        b[i] /= pivot;\n\n        for (int k = 0; k < n; k++) {\n            if (k != i) {\n                double factor = A[k][i];\n                for (int j = i; j < n; j++) {\n                    A[k][j] -= factor * A[i][j];\n                }\n                b[k] -= factor * b[i];\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnormalize__FPfi PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,#0\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        BLE      |L1.64|\n|L1.28|\n        LDR      r0,[r6,r4,LSL #2]\n        MOV      r1,r0\n        BL       _fmul\n        MOV      r1,r7\n        BL       _fadd\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r7,r0\n        BLT      |L1.28|\n|L1.64|\n        MOV      r0,r7\n        BL       _f2d\n        BL       __softfp_sqrt\n        BL       _d2f\n        MOV      r7,r0\n        MOV      r1,#0\n        BL       _fcmpge\n        LDMLSFD  sp!,{r3-r7,lr}\n        BXLS     lr\n        MOV      r4,#0\n        CMP      r5,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n|L1.116|\n        LDR      r0,[r6,r4,LSL #2]\n        MOV      r1,r7\n        BL       _fdiv\n        STR      r0,[r6,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.116|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid normalize(float *x, int n) {\n    float norm = 0;\n    for (int i = 0; i < n; i++) {\n        norm += x[i] * x[i];\n    }\n    norm = sqrt(norm);\n    if (norm > 0) {\n        for (int i = 0; i < n; i++) {\n            x[i] /= norm;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_prime__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r4,#3\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#1\n        BXLE     lr\n        TST      r4,#1\n        BEQ      |L1.72|\n        LDR      r1,|L1.224|\n        SMULL    r2,r0,r1,r4\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #2\n        ADDS     r0,r0,r4\n        BNE      |L1.84|\n|L1.72|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r5,#5\n        CMP      r4,#0x19\n        BLT      |L1.164|\n|L1.96|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BEQ      |L1.136|\n        MOV      r1,r4\n        ADD      r0,r5,#2\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.148|\n|L1.136|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.148|\n        ADD      r5,r5,#6\n        MUL      r0,r5,r5\n        CMP      r0,r4\n        BLE      |L1.96|\n|L1.164|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__FiT1 PROC\n|L1.0|\n        ADD      r0,r0,r1\n        BX       lr\n        ENDP\n\nsubtract__FiT1 PROC\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n\ncalculate__FiT1P8Strategy PROC\n        LDR      r2,[r2,#0]\n        BX       r2\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int (*operation)(int, int);\n} Strategy;\n\nint add(int a, int b) { return a + b; }\nint subtract(int a, int b) { return a - b; }\n\nint calculate(int a, int b, Strategy* strategy) {\n    return strategy->operation(a, b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbuildTree__FPiT1iT3T1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#8\n        LDR      r5,[sp,#0x28]\n        CMP      r2,r3\n        ADDGT    sp,sp,#8\n        MOV      r10,r0\n        MOV      r8,r1\n        MOV      r7,r2\n        MOV      r6,r3\n        LDMGTFD  sp!,{r4-r10,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r0,[r5,#0]\n        LDR      r4,[r10,r0,LSL #2]\n        MOV      r0,#0xc\n        BL       __nw__FUi\n        CMP      r0,#0\n        BEQ      |L1.88|\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n|L1.88|\n        MOV      r4,r0\n        LDR      r0,[r5,#0]\n        CMP      r7,r6\n        ADD      r0,r0,#1\n        STR      r0,[r5,#0]\n        ADDEQ    sp,sp,#8\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r9,#0\n        MOV      r0,r7\n|L1.136|\n        LDR      r2,[r8,r0,LSL #2]\n        CMP      r2,r1\n        MOVEQ    r9,r0\n        BEQ      |L1.164|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.136|\n|L1.164|\n        SUB      r3,r9,#1\n        MOV      r2,r7\n        MOV      r1,r8\n        MOV      r0,r10\n        STR      r5,[sp,#0]\n        BL       buildTree__FPiT1iT3T1\n        STR      r0,[r4,#4]\n        STR      r5,[sp,#0]\n        MOV      r0,r10\n        MOV      r3,r6\n        ADD      r2,r9,#1\n        MOV      r1,r8\n        BL       buildTree__FPiT1iT3T1\n        STR      r0,[r4,#8]\n        ADD      sp,sp,#8\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nNode* buildTree(int preorder[], int inorder[], int inStrt, int inEnd, int* preIndex) {\n    if (inStrt > inEnd) return NULL;\n\n    Node* node = new Node(preorder[*preIndex]);\n    (*preIndex)++;\n\n    if (inStrt == inEnd) return node;\n\n    int inIndex = 0;\n    for (int i = inStrt; i <= inEnd; i++) {\n        if (inorder[i] == node->data) {\n            inIndex = i;\n            break;\n        }\n    }\n\n    node->left = buildTree(preorder, inorder, inStrt, inIndex - 1, preIndex);\n    node->right = buildTree(preorder, inorder, inIndex + 1, inEnd, preIndex);\n\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_graph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MUL      r1,r0,r0\n        MOV      r5,r1,LSL #2\n        MOV      r0,r5\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FPiiN22 PROC\n        CMP      r1,#0\n        BXLT     lr\n        CMP      r1,r3\n        BXGE     lr\n        CMP      r2,#0\n        BXLT     lr\n        CMP      r2,r3\n        BXGE     lr\n        STR      lr,[sp,#-4]!\n        MLA      lr,r3,r1,r2\n        MOV      r12,#1\n        STR      r12,[r0,lr,LSL #2]\n        MLA      r1,r3,r2,r1\n        STR      r12,[r0,r1,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ndfs__FPiiT1T2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r0,#1\n        STR      r0,[r2,r3,LSL #2]\n        MOV      r8,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n|L1.164|\n        MLA      r0,r5,r8,r4\n        LDR      r0,[r7,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.212|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.212|\n        MOV      r3,r4\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r7\n        BL       dfs__FPiiT1T2\n|L1.212|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.164|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nis_connected__FPii PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r1\n        CMP      r0,#0\n        CMPNE    r5,#0\n        MOV      r7,r0\n        LDMLEFD  sp!,{r3-r7,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r6,r5,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r3,#0\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r7\n        BL       dfs__FPiiT1T2\n        MOV      r0,#0\n|L1.324|\n        LDR      r1,[r4,r0,LSL #2]\n        CMP      r1,#0\n        BNE      |L1.356|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.356|\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.324|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint* create_graph(int num_vertices){\n    int* graph = (int*)malloc(num_vertices * num_vertices * sizeof(int));\n    if(graph == NULL) return NULL;\n    memset(graph, 0, num_vertices * num_vertices * sizeof(int));\n    return graph;\n}\n\n\nvoid add_edge(int* graph, int u, int v, int num_vertices){\n    if(u < 0 || u >= num_vertices || v < 0 || v >= num_vertices) return;\n    graph[u * num_vertices + v] = 1;\n    graph[v * num_vertices + u] = 1;\n}\n\n\nvoid dfs(int* graph, int num_vertices, int* visited, int v){\n    visited[v] = 1;\n    for(int i = 0; i < num_vertices; i++){\n        if(graph[v * num_vertices + i] && !visited[i]){\n            dfs(graph, num_vertices, visited, i);\n        }\n    }\n}\n\n\nint is_connected(int* graph, int num_vertices){\n    if(graph == NULL || num_vertices <=0) return 0;\n    int* visited = (int*)malloc(num_vertices * sizeof(int));\n    if(visited == NULL) return 0;\n    memset(visited, 0, num_vertices * sizeof(int));\n    dfs(graph, num_vertices, visited, 0);\n    for(int i = 0; i < num_vertices; i++){\n        if(!visited[i]) {\n            free(visited);\n            return 0;\n        }\n    }\n    free(visited);\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhorner__FxT1Pc PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        ADR      r6,|L1.220|\n        LDMIA    r6,{r8,r9}\n        SUB      sp,sp,#4\n        LDR      r0,[sp,#0x38]\n        BL       strlen\n        MOV      r10,r0\n        LDMIA    r6,{r4,r5}\n        SUBS     r0,r4,r0\n        MOV      r11,#0\n        SBCS     r1,r5,r11\n        BGE      |L1.200|\n|L1.48|\n        MOV      r2,#1\n        SUBS     r0,r10,r2\n        SBC      r1,r11,#0\n        SUBS     r0,r0,r4\n        SBC      r1,r1,r5\n        LDR      r1,[sp,#0x38]\n        LDRB     r0,[r1,r0]\n        SUB      r0,r0,#0x30\n        MOV      r7,r0,ASR #31\n        MOV      r6,r0\n        ADR      r0,|L1.220|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r6,r2\n        SBCS     r1,r7,r3\n        BLT      |L1.128|\n        ADR      r0,|L1.228|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BGE      |L1.148|\n|L1.128|\n        ADR      r1,|L1.236|\n        LDMIA    r1,{r0,r1}\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.148|\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        UMULL    r0,r12,r8,r2\n        MLA      r12,r2,r9,r12\n        MLA      r1,r3,r8,r12\n        ADDS     r8,r0,r6\n        ADC      r9,r1,r7\n        MOV      r2,#1\n        ADDS     r4,r4,r2\n        ADC      r5,r5,#0\n        SUBS     r0,r4,r10\n        SBCS     r1,r5,r11\n        BLT      |L1.48|\n|L1.200|\n        MOV      r0,r8\n        MOV      r1,r9\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.220|\n        DCQ      0x0000000000000000\n|L1.228|\n        DCQ      0x0000000000000009\n|L1.236|\n        DCQ      0xffffffffffffffff\n        ENDP\n```",
        "output": "```cpp\n\nlong long horner(long long n, long long base, char* digits) {\n    long long result = 0;\n    long long len = strlen(digits);\n    for (long long i = 0; i < len; i++) {\n        long long digit = digits[len - 1 - i] - '0';\n        if (digit < 0 || digit > 9) return -1; //handle invalid digits\n        result = result * base + digit;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndistance__F7Point3DT1 PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r9,sp,#0x40\n        LDMIA    r9,{r2,r3,r6-r9}\n        ADD      r11,sp,#0x38\n        LDMIA    r11,{r10,r11}\n        BL       _dsub\n        MOV      r5,r1\n        ADD      r1,sp,#0x30\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dsub\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        B        __softfp_sqrt\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point3D {\n    double x;\n    double y;\n    double z;\n};\n\ndouble distance(Point3D p1, Point3D p2) {\n    double dx = p1.x - p2.x;\n    double dy = p1.y - p2.y;\n    double dz = p1.z - p2.z;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.476|\n        MOV      r1,r0\n        LDR      r0,[r2,#0]  ; top\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0]  ; top\n        LDR      r2,|L1.480|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.476|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.480|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\nstrongly_connected_components__FiPA100_iT1 PROC\n        STMFD    sp!,{r4-r11,lr}\n        LDR      r10,|L1.484|\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r11,|L1.488|\n        STR      r0,[r10,r5,LSL #2]\n        LDR      r0,[r11,#0]  ; index_counter\n        MOV      r7,r1\n        ADD      r1,r0,#1\n        LDR      r9,|L1.492|\n        STR      r1,[r11,#0]  ; index_counter\n        STR      r0,[r9,r5,LSL #2]\n        MOV      r0,r5\n        MOV      r6,r2\n        BL       push__Fi\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.248|\n        ADD      r0,r5,r5,LSL #3\n        ADD      r0,r0,r5,LSL #4\n        ADD      r8,r7,r0,LSL #4\n|L1.144|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.236|\n        LDR      r0,[r10,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.208|\n        MOV      r2,r6\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       strongly_connected_components__FiPA100_iT1\n        LDR      r0,[r9,r5,LSL #2]\n        LDR      r1,[r9,r4,LSL #2]\n        CMP      r0,r1\n        MOVGE    r0,r1\n        STR      r0,[r9,r5,LSL #2]\n        B        |L1.236|\n|L1.208|\n        CMP      r0,#1\n        BNE      |L1.236|\n        LDR      r0,[r9,r5,LSL #2]\n        LDR      r1,[r9,r4,LSL #2]\n        CMP      r0,r1\n        MOVGE    r0,r1\n        STR      r0,[r9,r5,LSL #2]\n|L1.236|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.144|\n|L1.248|\n        LDR      r0,[r10,r5,LSL #2]\n        LDR      r1,[r9,r5,LSL #2]\n        SUB      r0,r0,#1\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r11,lr}\n        BXNE     lr\n        MOV      r4,#2\n        LDR      r3,|L1.496|\n|L1.280|\n        BL       pop__Fv\n        STR      r4,[r10,r0,LSL #2]\n        LDR      r1,[r11,#4]  ; scc_index\n        CMP      r0,r5\n        STR      r1,[r3,r0,LSL #2]\n        BNE      |L1.280|\n        LDR      r0,[r11,#4]  ; scc_index\n        ADD      r0,r0,#1\n        STR      r0,[r11,#4]  ; scc_index\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint stack[MAX_VERTICES];\nint top = -1;\n\nvoid push(int v) {\n    stack[++top] = v;\n}\n\nint pop() {\n    return stack[top--];\n}\n\nint visited[MAX_VERTICES];\nint lowlink[MAX_VERTICES];\nint index_counter = 0;\nint scc_index = 0;\nint scc[MAX_VERTICES];\n\nvoid strongly_connected_components(int v, int adj[][MAX_VERTICES], int n) {\n    visited[v] = 1;\n    lowlink[v] = index_counter++;\n    push(v);\n\n    for (int i = 0; i < n; i++) {\n        if (adj[v][i]) {\n            if (!visited[i]) {\n                strongly_connected_components(i, adj, n);\n                lowlink[v] = (lowlink[v] < lowlink[i]) ? lowlink[v] : lowlink[i];\n            } else if (visited[i] == 1) {\n                lowlink[v] = (lowlink[v] < lowlink[i]) ? lowlink[v] : lowlink[i];\n            }\n        }\n    }\n\n    if (lowlink[v] == visited[v]-1) {\n        int w;\n        do {\n            w = pop();\n            visited[w] = 2;\n            scc[w] = scc_index;\n        } while (w != v);\n        scc_index++;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitList__FP10LinkedList PROC\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        BX       lr\n        ENDP\n\nappend__FP10LinkedListi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        STR      r6,[r4,#0]\n        LDR      r0,[r5,#0]\n        CMP      r0,#0\n        LDRNE    r0,[r5,#4]\n        STRNE    r4,[r0,#4]\n        STREQ    r4,[r5,#0]\n        STR      r4,[r5,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nstruct LinkedList {\n    Node *head;\n    Node *tail;\n};\n\nvoid initList(LinkedList *list) {\n    list->head = NULL;\n    list->tail = NULL;\n}\n\nvoid append(LinkedList *list, int data) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    if (newNode == NULL) {\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    if (list->head == NULL) {\n        list->head = newNode;\n        list->tail = newNode;\n    } else {\n        list->tail->next = newNode;\n        list->tail = newNode;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmerge__FP4NodeT1 PROC\n        STMFD    sp!,{r4,lr}\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,r1\n        BXEQ     lr\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        BGT      |L1.68|\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        BL       merge__FP4NodeT1\n        STR      r0,[r4,#4]\n        B        |L1.84|\n|L1.68|\n        MOV      r4,r1\n        LDR      r1,[r1,#4]\n        BL       merge__FP4NodeT1\n        STR      r0,[r4,#4]\n|L1.84|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetMiddle__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BXEQ     lr\n        B        |L1.132|\n|L1.116|\n        LDR      r0,[r0,#4]\n        LDR      r1,[r1,#4]\n        CMP      r1,#0\n        BXEQ     lr\n|L1.132|\n        LDR      r1,[r1,#4]\n        CMP      r1,#0\n        BNE      |L1.116|\n        BX       lr\n        ENDP\n\nmergeSort__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDRNE    r0,[r4,#4]\n        CMPNE    r0,#0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       getMiddle__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r0,#4]\n        MOV      r2,#0\n        STR      r2,[r1,#4]\n        BL       mergeSort__FP4Node\n        MOV      r5,r0\n        MOV      r0,r4\n        BL       mergeSort__FP4Node\n        MOV      r1,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        merge__FP4NodeT1\n        ENDP\n\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintList__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        BEQ      |L1.300|\n|L1.276|\n        ADR      r0,|L1.312|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r4,[r4,#4]\n        CMP      r4,#0\n        BNE      |L1.276|\n|L1.300|\n        ADR      r0,|L1.316|\n        LDMFD    sp!,{r4,lr}\n        B        _printf\n|L1.312|\n        DCB      \"%d \\0\"\n|L1.316|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nNode* merge(Node* a, Node* b) {\n    if (!a) return b;\n    if (!b) return a;\n    Node* result;\n    if (a->data <= b->data) {\n        result = a;\n        result->next = merge(a->next, b);\n    } else {\n        result = b;\n        result->next = merge(a, b->next);\n    }\n    return result;\n}\n\nNode* getMiddle(Node* head) {\n    if (!head || !head->next) return head;\n    Node *slow = head, *fast = head->next;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    return slow;\n}\n\nNode* mergeSort(Node* head) {\n    if (!head || !head->next) return head;\n    Node* middle = getMiddle(head);\n    Node* secondHalf = middle->next;\n    middle->next = 0;\n    return merge(mergeSort(head), mergeSort(secondHalf));\n}\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = 0;\n    return newNode;\n}\n\nvoid printList(Node* head){\n    while(head){\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nromanToDecimal__FPCc PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r4,#0\n        BL       strlen\n        MOV      r3,#0\n        CMP      r0,#0\n        BLE      |L1.284|\n|L1.28|\n        LDRB     r1,[r5,r3]\n        CMP      r1,#0x4c\n        MOVEQ    r1,#0x32\n        BEQ      |L1.124|\n        BGT      |L1.88|\n        CMP      r1,#0x43\n        MOVEQ    r1,#0x64\n        BEQ      |L1.124|\n        CMP      r1,#0x44\n        MOVEQ    r1,#0x1f4\n        BEQ      |L1.124|\n        CMP      r1,#0x49\n        MOVEQ    r1,#1\n        BEQ      |L1.124|\n        B        |L1.204|\n|L1.88|\n        CMP      r1,#0x4d\n        MOVEQ    r1,#0x3e8\n        BEQ      |L1.124|\n        CMP      r1,#0x56\n        MOVEQ    r1,#5\n        BEQ      |L1.124|\n        CMP      r1,#0x58\n        BNE      |L1.204|\n        MOV      r1,#0xa\n|L1.124|\n        ADD      r12,r3,#1\n        CMP      r12,r0\n        ADDGE    r4,r4,r1\n        BGE      |L1.272|\n        ADD      r2,r5,r3\n        LDRB     r2,[r2,#1]\n        CMP      r2,#0x4c\n        MOVEQ    r2,#0x32\n        BEQ      |L1.256|\n        BGT      |L1.216|\n        CMP      r2,#0x43\n        MOVEQ    r2,#0x64\n        BEQ      |L1.256|\n        CMP      r2,#0x44\n        MOVEQ    r2,#0x1f4\n        BEQ      |L1.256|\n        CMP      r2,#0x49\n        MOVEQ    r2,#1\n        BEQ      |L1.256|\n        B        |L1.252|\n|L1.204|\n        LDMFD    sp!,{r3-r5,lr}\n        MVN      r0,#0\n        BX       lr\n|L1.216|\n        CMP      r2,#0x4d\n        MOVEQ    r2,#0x3e8\n        BEQ      |L1.256|\n        CMP      r2,#0x56\n        MOVEQ    r2,#5\n        BEQ      |L1.256|\n        CMP      r2,#0x58\n        MOVEQ    r2,#0xa\n        BEQ      |L1.256|\n|L1.252|\n        MOV      r2,#0\n|L1.256|\n        CMP      r1,r2\n        ADDGE    r4,r4,r1\n        SUBLT    r4,r4,r1\n        MOVLT    r3,r12\n|L1.272|\n        ADD      r3,r3,#1\n        CMP      r3,r0\n        BLT      |L1.28|\n|L1.284|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint romanToDecimal(const char* roman) {\n    int decimal = 0;\n    int len = strlen(roman);\n    for (int i = 0; i < len; i++) {\n        char current = roman[i];\n        int value;\n        switch (current) {\n            case 'I': value = 1; break;\n            case 'V': value = 5; break;\n            case 'X': value = 10; break;\n            case 'L': value = 50; break;\n            case 'C': value = 100; break;\n            case 'D': value = 500; break;\n            case 'M': value = 1000; break;\n            default: return -1; \n        }\n        if (i + 1 < len) {\n            char next = roman[i + 1];\n            int nextValue;\n            switch (next) {\n                case 'I': nextValue = 1; break;\n                case 'V': nextValue = 5; break;\n                case 'X': nextValue = 10; break;\n                case 'L': nextValue = 50; break;\n                case 'C': nextValue = 100; break;\n                case 'D': nextValue = 500; break;\n                case 'M': nextValue = 1000; break;\n                default: nextValue = 0;\n            }\n            if (value < nextValue) {\n                decimal -= value;\n            } else {\n                decimal += value;\n            }\n            if (value < nextValue) i++;\n        } else {\n            decimal += value;\n        }\n    }\n    return decimal;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_static_library__FPc PROC\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0x100\n        MOV      r2,r0\n        MOV      r0,sp\n        MOV      r4,sp\n        ADR      r1,|L1.48|\n        BL       _sprintf\n        MOV      r0,r4\n        BL       system\n        ADD      sp,sp,#0x100\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.48|\n        DCB      \"ar r\"\n        DCB      \"cs %\"\n        DCB      \"s.a \"\n        DCB      \"*.o\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid create_static_library(char* library_name) {\n    char command[256];\n    sprintf(command, \"ar rcs %s.a *.o\", library_name);\n    system(command);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndeterminant__FP13SparseElementi PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r1,#1\n        ADDEQ    r1,r4,#8\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r4-r6,lr}\n        BEQ      _dfix\n        CMP      r1,#2\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r1,r4,#8\n        LDMIA    r1,{r0,r1}\n        ADD      r3,r4,#0x38\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r5,r0\n        MOV      r6,r1\n        ADD      r4,r4,#0x18\n        LDMIA    r4!,{r0,r1}\n        ADD      r3,r4,#8\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _drsb\n        LDMFD    sp!,{r4-r6,lr}\n        B        _dfix\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int row;\n    int col;\n    double val;\n} SparseElement;\n\n\nint determinant(SparseElement sparseMatrix[], int n) {\n    if (n == 1) return (int)sparseMatrix[0].val;\n    if (n == 2) return (int)(sparseMatrix[0].val * sparseMatrix[3].val - sparseMatrix[1].val * sparseMatrix[2].val);\n\n    //For larger matrices, a more sophisticated sparse matrix determinant algorithm is needed.\n    //This is a placeholder for demonstration only, and will not work for matrices larger than 2x2.\n    return 0; \n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlargest_element__FPii PROC\n        CMP      r0,#0\n        CMPNE    r1,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r2,#1\n        CMP      r1,#1\n        LDR      r3,[r0,#0]\n        BLE      |L1.56|\n|L1.32|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r12,r3\n        MOVGT    r3,r12\n        CMP      r2,r1\n        BLT      |L1.32|\n|L1.56|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint largest_element(int *arr, int size) {\n    if (arr == NULL || size <= 0) {\n        return 0; \n    }\n    int largest = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > largest) {\n            largest = arr[i];\n        }\n    }\n    return largest;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidArithmeticExpression__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOVS     r5,r0\n        BEQ      |L1.28|\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.40|\n|L1.28|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.40|\n        MOV      r6,#0\n        MOV      r8,#0\n        MOV      r9,#0\n        MOV      r4,#0\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        BLS      |L1.280|\n        BL       __rt_ctype_table\n        MOV      r7,r0\n|L1.80|\n        LDRB     r1,[r5,r4]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x20\n        BEQ      |L1.160|\n        ADD      r8,r8,#1\n        B        |L1.112|\n|L1.108|\n        MOV      r4,r1\n|L1.112|\n        MOV      r0,r5\n        BL       strlen\n        ADD      r1,r4,#1\n        CMP      r0,r1\n        BLS      |L1.224|\n        ADD      r0,r5,r4\n        LDRB     r2,[r0,#1]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r2]\n        TST      r0,#0x20\n        BNE      |L1.108|\n        B        |L1.224|\n|L1.160|\n        CMP      r1,#0x28\n        ADDEQ    r6,r6,#1\n        BEQ      |L1.224|\n        CMP      r1,#0x29\n        SUBEQ    r6,r6,#1\n        BEQ      |L1.224|\n        CMP      r1,#0x2b\n        CMPNE    r1,#0x2d\n        CMPNE    r1,#0x2a\n        CMPNE    r1,#0x2f\n        ADDEQ    r9,r9,#1\n        BEQ      |L1.224|\n        TST      r0,#1\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n|L1.224|\n        ADD      r4,r4,#1\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,r4\n        BHI      |L1.80|\n        CMP      r6,#0\n        BNE      |L1.280|\n        CMP      r8,#0\n        BLE      |L1.280|\n        SUB      r0,r8,#1\n        CMP      r9,r0\n        LDMGEFD  sp!,{r3-r9,lr}\n        MOVGE    r0,#1\n        BXGE     lr\n|L1.280|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isValidArithmeticExpression(char* expression) {\n    if (expression == 0 || strlen(expression) == 0) return 0;\n    int paren_count = 0;\n    int operand_count = 0;\n    int operator_count = 0;\n    for (unsigned int i = 0; i < strlen(expression); ++i) {\n        if (isdigit(expression[i])) {\n            operand_count++;\n            while (i + 1 < strlen(expression) && isdigit(expression[i+1]))\n                i++;\n        } else if (expression[i] == '(') {\n            paren_count++;\n        } else if (expression[i] == ')') {\n            paren_count--;\n        } else if (expression[i] == '+' || expression[i] == '-' || expression[i] == '*' || expression[i] == '/') {\n            operator_count++;\n        } else if (!isspace(expression[i])) {\n            return 0;\n        }\n    }\n    return paren_count == 0 && operand_count > 0 && operator_count >= operand_count -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x1d4\n        ADD      r0,r0,#0x9c00\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#0x1c40\n        ADD      r1,r1,#0x8000\n        STR      r5,[r4,#0]\n        ADD      r0,r4,#4\n        BL       __rt_memclr_w\n        ADD      r0,r4,#0x9c00\n        ADD      r0,r0,#0x44\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r3,[r0,#0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        ADD      r1,r0,r1,LSL #4\n        ADD      r1,r1,r2,LSL #2\n        ADD      r0,r0,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r1,#4]\n        ADD      r0,r0,#0x9000\n        LDR      r1,[r0,#0xc44]\n        ADD      r1,r1,r3\n        STR      r1,[r0,#0xc44]\n        BX       lr\n        ENDP\n\ntopologicalSort__FP5GraphPi PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOVS     r2,r0\n        MOV      r0,r1\n        CMPNE    r0,#0\n        SUB      sp,sp,#0x194\n        ADDEQ    sp,sp,#0x194\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r12,[r2,#0]\n        MOV      lr,#0\n        MOV      r3,#0\n        MOV      r1,#0\n        ADD      r5,sp,#4\n        CMP      r12,#0\n        BLE      |L1.268|\n|L1.224|\n        ADD      r12,r2,r1,LSL #2\n        ADD      r12,r12,#0x9000\n        LDR      r12,[r12,#0xc44]\n        CMP      r12,#0\n        MOVEQ    r12,r3\n        STREQ    r1,[r5,r12,LSL #2]\n        LDR      r12,[r2,#0]\n        ADD      r1,r1,#1\n        ADDEQ    r3,r3,#1\n        CMP      r12,r1\n        BGT      |L1.224|\n|L1.268|\n        MOV      r4,#0\n        CMP      lr,r3\n        BGE      |L1.408|\n|L1.280|\n        MOV      r1,lr\n        LDR      r12,[r5,r1,LSL #2]\n        MOV      r1,r4\n        STR      r12,[r0,r1,LSL #2]\n        LDR      r6,[r2,#0]\n        MOV      r1,#0\n        ADD      r4,r4,#1\n        ADD      lr,lr,#1\n        CMP      r6,#0\n        BLE      |L1.400|\n        MOV      r6,r12\n        ADD      r12,r6,r6,LSL #3\n        ADD      r12,r12,r6,LSL #4\n        ADD      r7,r2,r12,LSL #4\n|L1.336|\n        ADD      r12,r7,r1,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,#0\n        BEQ      |L1.384|\n        ADD      r12,r2,r1,LSL #2\n        ADD      r6,r12,#0x9000\n        LDR      r12,[r6,#0xc44]\n        SUBS     r12,r12,#1\n        STR      r12,[r6,#0xc44]\n        MOVEQ    r12,r3\n        STREQ    r1,[r5,r12,LSL #2]\n        ADDEQ    r3,r3,#1\n|L1.384|\n        LDR      r12,[r2,#0]\n        ADD      r1,r1,#1\n        CMP      r12,r1\n        BGT      |L1.336|\n|L1.400|\n        CMP      lr,r3\n        BLT      |L1.280|\n|L1.408|\n        LDR      r1,[r2,#0]\n        CMP      r1,r4\n        MOVNE    r2,r1,LSL #2\n        MVNNE    r1,#0\n        BLNE     __rt_memset\n        ADD      sp,sp,#0x194\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj[MAX_VERTICES][MAX_VERTICES];\n    int in_degree[MAX_VERTICES];\n} Graph;\n\nGraph* createGraph(int vertices) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == 0) return 0;\n    graph->vertices = vertices;\n    memset(graph->adj, 0, sizeof(graph->adj));\n    memset(graph->in_degree, 0, sizeof(graph->in_degree));\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int u, int v) {\n    if (graph == 0 || u < 0 || u >= graph->vertices || v < 0 || v >= graph->vertices) return;\n    graph->adj[u][v] = 1;\n    graph->in_degree[v]++;\n}\n\nvoid topologicalSort(Graph* graph, int* sorted) {\n    if (graph == 0 || sorted == 0) return;\n    int queue[MAX_VERTICES];\n    int head = 0, tail = 0;\n    for (int i = 0; i < graph->vertices; i++) {\n        if (graph->in_degree[i] == 0) {\n            queue[tail++] = i;\n        }\n    }\n    int count = 0;\n    while (head < tail) {\n        int u = queue[head++];\n        sorted[count++] = u;\n        for (int v = 0; v < graph->vertices; v++) {\n            if (graph->adj[u][v]) {\n                graph->in_degree[v]--;\n                if (graph->in_degree[v] == 0) {\n                    queue[tail++] = v;\n                }\n            }\n        }\n    }\n    if (count != graph->vertices) {\n        memset(sorted, -1, sizeof(int) * graph->vertices);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindMedianSortedArrays__FPiiT1T2 PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        ADD      r9,r1,r3\n        MOV      r7,r0\n        MOV      r0,r9,LSL #2\n        MOV      r8,r2\n        MOV      r6,r3\n        MOV      r5,r1\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0\n        MOV      r1,#0\n        MOV      r2,#0\n        B        |L1.120|\n|L1.52|\n        LDR      r3,[r7,r1,LSL #2]\n        LDR      r12,[r8,r2,LSL #2]\n        CMP      r3,r12\n        BGE      |L1.96|\n        MOV      r3,r1\n        LDR      r12,[r7,r3,LSL #2]\n        MOV      r3,r0\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r1,r1,#1\n        B        |L1.120|\n|L1.96|\n        MOV      r3,r2\n        LDR      r12,[r8,r3,LSL #2]\n        MOV      r3,r0\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r2,r2,#1\n|L1.120|\n        CMP      r1,r5\n        CMPLT    r2,r6\n        BLT      |L1.52|\n        CMP      r1,r5\n        BGE      |L1.172|\n|L1.140|\n        MOV      r3,r1\n        LDR      r12,[r7,r3,LSL #2]\n        MOV      r3,r0\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        BLT      |L1.140|\n|L1.172|\n        CMP      r2,r6\n        BGE      |L1.212|\n|L1.180|\n        MOV      r1,r2\n        LDR      r3,[r8,r1,LSL #2]\n        MOV      r1,r0\n        ADD      r2,r2,#1\n        CMP      r2,r6\n        STR      r3,[r4,r1,LSL #2]\n        ADD      r0,r0,#1\n        BLT      |L1.180|\n|L1.212|\n        ADD      r1,r5,r6\n        ADD      r1,r1,r1,LSR #31\n        MOV      r1,r1,ASR #1\n        TST      r9,#1\n        BNE      |L1.276|\n        ADD      r0,r4,r1,LSL #2\n        LDR      r0,[r0,#-4]\n        LDR      r1,[r4,r1,LSL #2]\n        ADD      r0,r0,r1\n        BL       _dflt\n        ADR      r2,|L1.316|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r5,r0\n        MOV      r6,r1\n        B        |L1.292|\n|L1.276|\n        LDR      r0,[r4,r1,LSL #2]\n        BL       _dflt\n        MOV      r5,r0\n        MOV      r6,r1\n|L1.292|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.316|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    int* merged = (int*)malloc((nums1Size + nums2Size) * sizeof(int));\n    int i = 0, j = 0, k = 0;\n    while (i < nums1Size && j < nums2Size) {\n        if (nums1[i] < nums2[j]) {\n            merged[k++] = nums1[i++];\n        } else {\n            merged[k++] = nums2[j++];\n        }\n    }\n    while (i < nums1Size) {\n        merged[k++] = nums1[i++];\n    }\n    while (j < nums2Size) {\n        merged[k++] = nums2[j++];\n    }\n    double median;\n    if ((nums1Size + nums2Size) % 2 == 0) {\n        median = (double)(merged[(nums1Size + nums2Size) / 2 - 1] + merged[(nums1Size + nums2Size) / 2]) / 2;\n    } else {\n        median = (double)merged[(nums1Size + nums2Size) / 2];\n    }\n    free(merged);\n    return median;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nremoveElement__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r12,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.52|\n|L1.20|\n        LDR      lr,[r0,r3,LSL #2]\n        ADD      r3,r3,#1\n        CMP      lr,r2\n        MOVNE    r4,r12\n        STRNE    lr,[r0,r4,LSL #2]\n        ADDNE    r12,r12,#1\n        CMP      r3,r1\n        BLT      |L1.20|\n|L1.52|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint removeElement(int arr[], int size, int element) {\n    int index = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] != element) {\n            arr[index++] = arr[i];\n        }\n    }\n    return index;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0x6c\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        MOV      r2,#0\n|L1.32|\n        STR      r2,[r0,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,#0x1a\n        BLT      |L1.32|\n        STR      r2,[r0,#0x68]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP8TrieNodePc PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        LDRB     r0,[r1,#0]\n        MOV      r7,r1\n        MOV      r6,#0\n        CMP      r0,#0\n        BEQ      |L1.168|\n|L1.88|\n        LDRB     r0,[r7,r6]\n        SUBS     r4,r0,#0x61\n        LDMMIFD  sp!,{r3-r7,lr}\n        BXMI     lr\n        CMP      r4,#0x1a\n        LDMGEFD  sp!,{r3-r7,lr}\n        BXGE     lr\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.148|\n        BL       createNode__Fv\n        STR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n|L1.148|\n        LDR      r5,[r5,r4,LSL #2]\n        ADD      r6,r6,#1\n        LDRB     r0,[r7,r6]\n        CMP      r0,#0\n        BNE      |L1.88|\n|L1.168|\n        MOV      r0,#1\n        STR      r0,[r5,#0x68]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nsearch__FP8TrieNodePc PROC\n        LDRB     r2,[r1,#0]\n        MOV      r3,r0\n        MOV      r0,#0\n        CMP      r2,#0\n        BEQ      |L1.264|\n|L1.204|\n        LDRB     r2,[r1,r0]\n        SUBS     r2,r2,#0x61\n        BMI      |L1.224|\n        CMP      r2,#0x1a\n        BLT      |L1.232|\n|L1.224|\n        MOV      r0,#0\n        BX       lr\n|L1.232|\n        LDR      r3,[r3,r2,LSL #2]\n        CMP      r3,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        LDRB     r2,[r1,r0]\n        CMP      r2,#0\n        BNE      |L1.204|\n|L1.264|\n        LDR      r0,[r3,#0x68]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_WORD_LENGTH 50\n#define ALPHABET_SIZE 26\n\ntypedef struct TrieNode {\n    struct TrieNode* children[ALPHABET_SIZE];\n    int isEndOfWord;\n} TrieNode;\n\nTrieNode* createNode() {\n    TrieNode* newNode = (TrieNode*)malloc(sizeof(TrieNode));\n    if (newNode == NULL) return NULL;\n    for (int i = 0; i < ALPHABET_SIZE; i++) {\n        newNode->children[i] = NULL;\n    }\n    newNode->isEndOfWord = 0;\n    return newNode;\n}\n\nvoid insert(TrieNode* root, char* key) {\n    TrieNode* curr = root;\n    for (int i = 0; key[i] != '\\0'; i++) {\n        int index = key[i] - 'a';\n        if (index < 0 || index >= ALPHABET_SIZE) return;\n        if (!curr->children[index]) {\n            curr->children[index] = createNode();\n            if (curr->children[index] == NULL) return;\n        }\n        curr = curr->children[index];\n    }\n    curr->isEndOfWord = 1;\n}\n\nint search(TrieNode* root, char* key) {\n    TrieNode* curr = root;\n    for (int i = 0; key[i] != '\\0'; i++) {\n        int index = key[i] - 'a';\n        if (index < 0 || index >= ALPHABET_SIZE) return 0;\n        if (!curr->children[index]) return 0;\n        curr = curr->children[index];\n    }\n    return curr->isEndOfWord;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_divisors__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,#0\n        MOV      r4,#1\n        CMP      r0,#1\n        BLT      |L1.76|\n|L1.24|\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.60|\n        MUL      r1,r4,r4\n        CMP      r1,r6\n        ADD      r5,r5,r4\n        ADDNE    r5,r0,r5\n|L1.60|\n        ADD      r4,r4,#1\n        MUL      r0,r4,r4\n        CMP      r0,r6\n        BLE      |L1.24|\n|L1.76|\n        SUB      r0,r5,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\namicable__FiT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       sum_divisors__Fi\n        CMP      r0,r5\n        BNE      |L1.144|\n        MOV      r0,r5\n        BL       sum_divisors__Fi\n        CMP      r0,r4\n        BNE      |L1.144|\n        CMP      r4,r5\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.144|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_divisors(int n) {\n    int sum = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            sum += i;\n            if (i * i != n) {\n                sum += n / i;\n            }\n        }\n    }\n    return sum - n;\n}\n\nint amicable(int a, int b) {\n    return sum_divisors(a) == b && sum_divisors(b) == a && a != b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\naddNode__FP4Listi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nflatten__FP4List PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r4,r0\n        BL       createList__Fv\n        LDR      r5,[r4,#0]\n        MOV      r6,r0\n        CMP      r5,#0\n        BEQ      |L1.228|\n        MOV      r9,#0\n|L1.104|\n        LDR      r1,[r5,#0]\n        CMP      r1,#0\n        BLE      |L1.128|\n        MOV      r0,r6\n        BL       addNode__FP4Listi\n        B        |L1.208|\n|L1.128|\n        MOV      r0,#4\n        BL       malloc\n        LDR      r1,[r5,#4]\n        STR      r1,[r0,#0]\n        STR      r9,[r5,#4]\n        BL       flatten__FP4List\n        LDR      r4,[r0,#0]\n        MOV      r8,r0\n        CMP      r4,#0\n        BEQ      |L1.200|\n|L1.168|\n        MOV      r0,r6\n        LDR      r1,[r4,#0]\n        BL       addNode__FP4Listi\n        LDR      r7,[r4,#4]\n        MOV      r0,r4\n        BL       free\n        MOVS     r4,r7\n        BNE      |L1.168|\n|L1.200|\n        MOV      r0,r8\n        BL       free\n|L1.208|\n        LDR      r4,[r5,#4]\n        MOV      r0,r5\n        BL       free\n        MOVS     r5,r4\n        BNE      |L1.104|\n|L1.228|\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct List {\n    Node* head;\n} List;\n\nList* createList() {\n    List* list = (List*)malloc(sizeof(List));\n    list->head = 0;\n    return list;\n}\n\n\nvoid addNode(List* list, int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->value = value;\n    newNode->next = list->head;\n    list->head = newNode;\n}\n\nList* flatten(List* list) {\n    List* flattenedList = createList();\n    Node* current = list->head;\n    while (current) {\n        if (current->value > 0) {\n            addNode(flattenedList, current->value);\n        } else {\n             List* nestedList = (List*)malloc(sizeof(List));\n             nestedList->head = current->next;\n             current->next = 0;\n             List* temp = flatten(nestedList);\n             Node* tempNode = temp->head;\n             while(tempNode){\n                addNode(flattenedList, tempNode->value);\n                Node* nextNode = tempNode->next;\n                free(tempNode);\n                tempNode = nextNode;\n             }\n             free(temp);\n        }\n        Node* next = current->next;\n        free(current);\n        current = next;\n    }\n    return flattenedList;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateInvertedIndex__FPPci PROC\n|L1.0|\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct WordEntry {\n    char* word;\n    int* docIds;\n    int docCount;\n};\n\n\nstruct InvertedIndex {\n    struct WordEntry* entries;\n    int entryCount;\n};\n\n\nstruct InvertedIndex createInvertedIndex(char* documents[], int numDocs) {\n    struct InvertedIndex index;\n    index.entryCount = 0;\n    index.entries = 0;\n    \n    return index;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndateDifference__F4DateT1 PROC\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r5,|L1.368|\n        RSB      r12,r1,#0xe\n        SMULL    r6,r12,r5,r12\n        MOV      r12,r12,ASR #1\n        SUB      r12,r12,r12,ASR #31\n        ADD      r0,r0,#0x12c0\n        SUB      r0,r0,r12\n        ADD      r12,r12,r12,LSL #1\n        ADD      r1,r1,r12,LSL #2\n        SUB      r1,r1,#3\n        ADD      r1,r1,r1,LSL #4\n        ADD      r1,r1,r1,LSL #3\n        ADD      r12,r1,#2\n        LDR      r1,|L1.372|\n        LDR      lr,[sp,#0x14]\n        SMULL    r6,r12,r1,r12\n        MOV      r12,r12,ASR #1\n        SUB      r12,r12,r12,ASR #31\n        ADD      r2,r12,r2\n        ADD      r12,r0,r0,LSL #3\n        ADD      r12,r12,r0,LSL #6\n        ADD      r12,r12,r12,LSL #2\n        ADD      r2,r2,r12\n        MOV      r12,r0,ASR #31\n        ADD      r12,r0,r12,LSR #30\n        ADD      r12,r2,r12,ASR #2\n        LDR      r2,|L1.376|\n        ADD      r3,r3,#0x12c0\n        SMULL    r7,r6,r2,r0\n        MOV      r6,r6,ASR #5\n        SUB      r6,r6,r6,ASR #31\n        SUB      r12,r12,r6\n        SMULL    r6,r0,r2,r0\n        MOV      r0,r0,ASR #7\n        SUB      r0,r0,r0,ASR #31\n        ADD      r0,r12,r0\n        RSB      r12,lr,#0xe\n        SMULL    r6,r12,r5,r12\n        MOV      r12,r12,ASR #1\n        SUB      r12,r12,r12,ASR #31\n        SUB      r3,r3,r12\n        ADD      r12,r12,r12,LSL #1\n        ADD      r12,lr,r12,LSL #2\n        SUB      r12,r12,#3\n        ADD      r12,r12,r12,LSL #4\n        ADD      r12,r12,r12,LSL #3\n        ADD      r12,r12,#2\n        SMULL    lr,r12,r1,r12\n        MOV      r1,r12,ASR #1\n        ADD      r12,r3,r3,LSL #3\n        LDR      r4,[sp,#0x18]\n        ADD      r12,r12,r3,LSL #6\n        SUB      r1,r1,r1,ASR #31\n        ADD      r1,r1,r4\n        ADD      r12,r12,r12,LSL #2\n        ADD      r1,r1,r12\n        MOV      r12,r3,ASR #31\n        ADD      r12,r3,r12,LSR #30\n        ADD      r1,r1,r12,ASR #2\n        SMULL    lr,r12,r2,r3\n        MOV      r12,r12,ASR #5\n        SUB      r12,r12,r12,ASR #31\n        SUB      r1,r1,r12\n        SMULL    r12,r3,r2,r3\n        MOV      r2,r3,ASR #7\n        SUB      r2,r2,r2,ASR #31\n        ADD      r1,r1,r2\n        SUB      r1,r1,#0x7d00\n        SUB      r0,r0,#0x7d00\n        SUB      r0,r0,#0x2d\n        SUB      r1,r1,#0x2d\n        LDMFD    sp!,{r4-r7,lr}\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Date {\n    int year;\n    int month;\n    int day;\n\n    Date(int y, int m, int d) : year(y), month(m), day(d) {}\n\n    long toJulian() {\n        long a = (14 - month) / 12;\n        long y = year + 4800 - a;\n        long m = month + 12 * a - 3;\n        return day + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045;\n    }\n};\n\n\nlong dateDifference(Date d1, Date d2) {\n    return d1.toJulian() - d2.toJulian();\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrotate_left__FUii PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x20\n        BL       __rt_sdiv\n        RSB      r0,r1,#0x20\n        MOV      r0,r4,ROR r0\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int rotate_left(unsigned int value, int shift) {\n    int size = sizeof(value) * 8;\n    shift %= size;\n    return (value << shift) | (value >> (size - shift));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.340|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\nlinear_probe__FP5EntryiPc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        MOV      r6,r2\n        MOV      r5,r1\n        BL       hash__Fi\n        LDR      r2,|L1.340|\n        MOV      r1,#0\n|L1.72|\n        LDR      r3,[r4,r0,LSL #3]\n        CMN      r3,#1\n        CMPNE    r3,r5\n        BNE      |L1.164|\n        STR      r5,[r4,r0,LSL #3]\n        ADD      r4,r4,r0,LSL #3\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BLNE     free\n        MOV      r0,r6\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        STR      r0,[r4,#4]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MVNEQ    r0,#1\n        BXEQ     lr\n        MOV      r1,r6\n        BL       strcpy\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.164|\n        ADD      r0,r0,#1\n        SMULL    r12,r3,r2,r0\n        MOV      r3,r3,ASR #2\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r1,r1,#1\n        CMP      r1,#0xa\n        ADD      r0,r0,r3,LSL #1\n        BLT      |L1.72|\n        LDMFD    sp!,{r4-r6,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\nstruct Entry {\n    int key;\n    char* value;\n};\n\nint hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nint linear_probe(struct Entry* table, int key, char* value) {\n    int index = hash(key);\n    int initial_index = index;\n    int i = 0;\n\n    while (i < TABLE_SIZE) {\n        if (table[index].key == -1 || table[index].key == key) {\n            table[index].key = key;\n            if (table[index].value != NULL) free(table[index].value);\n            table[index].value = (char*)malloc(strlen(value) + 1);\n            if(table[index].value == NULL) return -2;\n            strcpy(table[index].value, value);\n            return 0;\n        }\n        index = (index + 1) % TABLE_SIZE;\n        i++;\n\n    }\n    return -1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r)\n        printf(\"%s\\n\", a);\n    else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i)); \n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\naes_encrypt__FPUciN21 PROC\n|L1.0|\n        CMP      r0,#0\n        CMPNE    r2,#0\n        CMPNE    r3,#0\n        BXEQ     lr\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r3\n        B        __rt_memcpy\n        ENDP\n\naes_decrypt__FPUciN21 PROC\n        CMP      r0,#0\n        CMPNE    r2,#0\n        CMPNE    r3,#0\n        BXEQ     lr\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r3\n        B        __rt_memcpy\n        ENDP\n```",
        "output": "```cpp\n\n#define AES_BLOCK_SIZE 16\n\n// Placeholder for AES implementation.  This is NOT a real AES implementation.\n//  It would require a significant amount of code to implement AES correctly and securely.\n//  This is just a dummy function for the sake of compiling the code.\nvoid aes_encrypt(unsigned char *input, int input_len, unsigned char *key, unsigned char *output) {\n    if (input == NULL || key == NULL || output == NULL) return;\n    memcpy(output, input, input_len); // Simulate encryption; replace with actual AES implementation\n}\n\nvoid aes_decrypt(unsigned char *input, int input_len, unsigned char *key, unsigned char *output) {\n    if (input == NULL || key == NULL || output == NULL) return;\n    memcpy(output, input, input_len);  // Simulate decryption; replace with actual AES implementation\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_heap__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0xfa0\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.64|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        MOV      r0,#0x3e8\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nheapify_up__FP8min_heapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r1,#1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r4,r0,ASR #1\n        LDR      r0,[r5,#0]\n        LDR      r2,[r0,r1,LSL #2]\n        LDR      r3,[r0,r4,LSL #2]\n        CMP      r2,r3\n        LDMGEFD  sp!,{r4,r5,lr}\n        BXGE     lr\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify_up__FP8min_heapi\n        ENDP\n\ninsert__FP8min_heapi PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        B        heapify_up__FP8min_heapi\n        ENDP\n\nheapify_down__FP8min_heapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#4]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.300|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVLT    r4,r0\n|L1.300|\n        CMP      r3,r2\n        BLE      |L1.328|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVLT    r4,r2\n|L1.328|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify_down__FP8min_heapi\n        ENDP\n\ndelete_min__FP8min_heap PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MVNLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        BL       heapify_down__FP8min_heapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndecrease_key__FP8min_heapiT2 PROC\n        LDR      r3,[r0,#4]\n        CMP      r3,r1\n        BXLE     lr\n        LDR      r3,[r0,#0]\n        LDR      r12,[r3,r1,LSL #2]\n        CMP      r12,r2\n        STRGE    r2,[r3,r1,LSL #2]\n        BGE      heapify_up__FP8min_heapi\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 1000\n\ntypedef struct {\n    int* arr;\n    int size;\n    int capacity;\n} min_heap;\n\nmin_heap* create_heap() {\n    min_heap* heap = (min_heap*)malloc(sizeof(min_heap));\n    if (heap == NULL) return NULL;\n    heap->arr = (int*)malloc(sizeof(int) * MAX_SIZE);\n    if (heap->arr == NULL) {\n        free(heap);\n        return NULL;\n    }\n    heap->size = 0;\n    heap->capacity = MAX_SIZE;\n    return heap;\n}\n\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n\nvoid heapify_up(min_heap* heap, int index) {\n    if (index <= 0) return;\n    int parent = (index - 1) / 2;\n    if (heap->arr[index] < heap->arr[parent]) {\n        swap(&heap->arr[index], &heap->arr[parent]);\n        heapify_up(heap, parent);\n    }\n}\n\n\nvoid insert(min_heap* heap, int key) {\n    if (heap->size == heap->capacity) return;\n    heap->arr[heap->size] = key;\n    heap->size++;\n    heapify_up(heap, heap->size - 1);\n}\n\n\nvoid heapify_down(min_heap* heap, int index) {\n    int smallest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < heap->size && heap->arr[left] < heap->arr[smallest])\n        smallest = left;\n    if (right < heap->size && heap->arr[right] < heap->arr[smallest])\n        smallest = right;\n\n    if (smallest != index) {\n        swap(&heap->arr[index], &heap->arr[smallest]);\n        heapify_down(heap, smallest);\n    }\n}\n\n\nint delete_min(min_heap* heap) {\n    if (heap->size <=0) return -1;\n    int min = heap->arr[0];\n    heap->arr[0] = heap->arr[heap->size - 1];\n    heap->size--;\n    heapify_down(heap, 0);\n    return min;\n}\n\nvoid decrease_key(min_heap* heap, int index, int new_key) {\n    if (index >= heap->size || new_key > heap->arr[index]) return;\n    heap->arr[index] = new_key;\n    heapify_up(heap, index);\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnumberToString__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        CMP      r0,#0\n        MOV      r5,#0\n        MOVEQ    r5,#1\n        RSB      r6,r0,#0\n        MOV      r4,r0\n        MOVLT    r0,r6\n        ADDLT    r5,r5,#1\n        CMP      r0,#0\n        LDR      r7,|L1.328|\n        BLE      |L1.68|\n|L1.44|\n        SMULL    r1,r0,r7,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        CMP      r0,#0\n        ADD      r5,r5,#1\n        BGT      |L1.44|\n|L1.68|\n        ADD      r0,r5,#1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STRB     r1,[r0,r5]\n        SUB      r1,r5,#1\n        CMP      r4,#0\n        MOVEQ    r1,#0x30\n        STREQB   r1,[r0,#0]\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOVLT    r2,#0x2d\n        STRLTB   r2,[r0,#0]\n        MOVLT    r4,r6\n        CMP      r4,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n|L1.144|\n        SMULL    r3,r2,r7,r4\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r4,r2,LSL #1\n        ADD      r2,r2,#0x30\n        STRB     r2,[r0,r1]\n        SMULL    r3,r2,r7,r4\n        MOV      r2,r2,ASR #2\n        SUB      r4,r2,r2,ASR #31\n        CMP      r4,#0\n        SUB      r1,r1,#1\n        BGT      |L1.144|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* numberToString(int num) {\n    int len = 0;\n    int temp = num;\n    if (num == 0) len = 1;\n    if (num < 0) {\n        len++;\n        temp = -temp;\n    }\n    while (temp > 0) {\n        len++;\n        temp /= 10;\n    }\n\n    char* str = (char*)malloc(len + 1);\n    if (str == NULL) return NULL;\n    str[len] = '\\0';\n    int i = len -1;\n\n    if (num == 0) {\n        str[0] = '0';\n        return str;\n    }\n\n    if (num < 0) {\n        str[0] = '-';\n        num = -num;\n    }\n\n    while (num > 0) {\n        str[i] = num % 10 + '0';\n        num /= 10;\n        i--;\n    }\n    return str;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.388|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.416|\n|L1.388|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.416|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.520|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.572|\n|L1.520|\n        CMP      r0,#1\n        BLE      |L1.564|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.608|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.564|\n        CMN      r0,#1\n        BGE      |L1.608|\n|L1.572|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.608|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.608|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ngetTreeHeight__FP4Node PROC\n        B        height__FP4Node\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node* node) {\n    if (node == NULL)\n        return 0;\n    return node->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    return new Node(key);\n}\n\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\n\nNode* insert(Node* node, int key) {\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left),\n                           height(node->right));\n    int balance = getBalance(node);\n\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n\n    return node;\n}\n\n\nint getTreeHeight(Node *root){\n    return height(root);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlength__F4Vec3 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r1\n        MOV      r1,r0\n        MOV      r5,r2\n        BL       _fmul\n        MOV      r6,r0\n        MOV      r0,r4\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r1,r6\n        BL       _fadd\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r1,r5\n        BL       _fmul\n        MOV      r1,r4\n        BL       _fadd\n        BL       _f2d\n        BL       __softfp_sqrt\n        LDMFD    sp!,{r4-r6,lr}\n        B        _d2f\n        ENDP\n\nnormalize__F4Vec3 PROC\n        STMFD    sp!,{r0-r7,lr}\n        SUB      sp,sp,#4\n        ADD      r2,sp,#8\n        MOV      r5,r0\n        LDMIA    r2,{r0-r2}\n        BL       length__F4Vec3\n        MOV      r4,r0\n        MOV      r1,#0\n        BL       _fcmpeq\n        BNE      |L1.148|\n        ADD      r0,sp,#8\n        LDMIA    r0,{r1-r3}\n        STMIA    r5,{r1-r3}\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.148|\n        MOV      r1,r4\n        LDR      r0,[sp,#8]\n        BL       _fdiv\n        MOV      r6,r0\n        LDR      r0,[sp,#0xc]\n        MOV      r1,r4\n        BL       _fdiv\n        MOV      r7,r0\n        LDR      r0,[sp,#0x10]\n        MOV      r1,r4\n        BL       _fdiv\n        STMIA    r5,{r6,r7}\n        STR      r0,[r5,#8]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\npointAtParameter__F3Rayf PROC\n        STMFD    sp!,{r4-r10,lr}\n        LDR      r4,[sp,#0x2c]\n        ADD      r8,sp,#0x20\n        MOV      r5,r0\n        MOV      r6,r1\n        MOV      r1,r4\n        LDMIA    r8,{r0,r7,r8}\n        MOV      r10,r3\n        MOV      r9,r2\n        BL       _fmul\n        MOV      r1,r6\n        BL       _fadd\n        MOV      r6,r0\n        MOV      r0,r7\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r1,r9\n        BL       _fadd\n        MOV      r7,r0\n        MOV      r0,r8\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r1,r10\n        BL       _fadd\n        STMIA    r5,{r6,r7}\n        STR      r0,[r5,#8]\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Vec3 {\n    float x, y, z;\n    Vec3(float x = 0, float y = 0, float z = 0) : x(x), y(y), z(z) {}\n};\n\nstruct Ray {\n    Vec3 origin;\n    Vec3 direction;\n    Ray(Vec3 origin, Vec3 direction) : origin(origin), direction(direction) {}\n};\n\n\nfloat length(Vec3 v) {\n    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n}\n\nVec3 normalize(Vec3 v) {\n    float len = length(v);\n    if (len == 0) return v;\n    return Vec3(v.x / len, v.y / len, v.z / len);\n}\n\nVec3 pointAtParameter(Ray r, float t){\n    return Vec3(r.origin.x + r.direction.x * t, r.origin.y + r.direction.y * t, r.origin.z + r.direction.z * t);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlog_error__FPcT1i PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#0\n        SUB      sp,sp,#0x114\n        MOV      r7,r1\n        MOV      r5,r2\n        BL       time\n        STR      r0,[sp,#0x110]\n        ADD      r0,sp,#0x110\n        BL       ctime\n        MOV      r4,r0\n        BL       strlen\n        ADD      r0,r0,r4\n        MOV      r1,#0\n        STRB     r1,[r0,#-1]\n        STR      r5,[sp,#8]\n        MOV      r3,r4\n        ADD      r4,sp,#0x10\n        MOV      r0,r4\n        STMIA    sp,{r6,r7}\n        MOV      r1,#0x100\n        ADR      r2,|L1.116|\n        BL       _snprintf\n        MOV      r1,r4\n        ADR      r0,|L1.140|\n        BL       _printf\n        ADD      sp,sp,#0x114\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.116|\n        DCB      \"%s -\"\n        DCB      \" ERR\"\n        DCB      \"OR: \"\n        DCB      \"%s [\"\n        DCB      \"%s:%\"\n        DCB      \"d]\\0\\0\"\n|L1.140|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid log_error(char* message, char* file, int line) {\n    time_t now = time(0);\n    char* dt = ctime(&now);\n    dt[strlen(dt) - 1] = '\\0'; //remove trailing newline\n\n    char log_message[256];\n    snprintf(log_message, sizeof(log_message), \"%s - ERROR: %s [%s:%d]\", dt, message, file, line);\n\n    printf(\"%s\\n\", log_message);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.696|\n        MOV      r1,r0\n        LDR      r0,[r2,#0]  ; top\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0]  ; top\n        LDR      r2,|L1.700|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.696|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.700|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\ndfs1__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r7,|L1.704|\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r8,|L1.708|\n        STR      r0,[r7,r5,LSL #2]\n        LDR      r0,[r8,#0]  ; n\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.160|\n        ADD      r1,r5,r5,LSL #3\n        LDR      r0,|L1.712|\n        ADD      r1,r1,r5,LSL #4\n        ADD      r6,r0,r1,LSL #4\n|L1.116|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.144|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        BLEQ     dfs1__Fi\n|L1.144|\n        LDR      r0,[r8,#0]  ; n\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.116|\n|L1.160|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        B        push__Fi\n        ENDP\n\ndfs2__FiPiT1 PROC\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r8,|L1.704|\n        MOV      r5,r1\n        MOV      r1,#1\n        STR      r1,[r8,r0,LSL #2]\n        LDR      r9,|L1.708|\n        STR      r2,[r5,r0,LSL #2]\n        LDR      r1,[r9,#0]  ; n\n        MOV      r6,r2\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r9,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.716|\n        ADD      r7,r0,r1,LSL #4\n|L1.240|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.280|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.280|\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       dfs2__FiPiT1\n|L1.280|\n        LDR      r0,[r9,#0]  ; n\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.240|\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n\nfind_strongly_connected_components__FiPA100_iPi PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r2\n        LDR      r2,|L1.708|\n        LDR      r9,|L1.712|\n        STR      r0,[r2,#0]  ; n\n        MOV      r2,#0x1c40\n        MOV      r4,r0\n        MOV      r0,r9\n        ADD      r2,r2,#0x8000\n        BL       __rt_memcpy_w\n        LDR      r6,|L1.704|\n        MOV      r1,#0x190\n        MOV      r0,r6\n        BL       __rt_memclr_w\n        LDR      r7,|L1.716|\n        MOV      r1,#0x1c40\n        ADD      r1,r1,#0x8000\n        MOV      r0,r7\n        BL       __rt_memclr_w\n        LDR      r8,|L1.696|\n        MVN      r0,#0\n        STR      r0,[r8,#0]  ; top\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.484|\n        MOV      r1,r9\n        MOV      r2,#1\n|L1.412|\n        MOV      r3,#0\n        CMP      r4,#0\n        BLE      |L1.472|\n        ADD      r12,r0,r0,LSL #3\n        ADD      r12,r12,r0,LSL #4\n        ADD      lr,r1,r12,LSL #4\n|L1.436|\n        LDR      r12,[lr,r3,LSL #2]\n        CMP      r12,#0\n        ADDNE    r12,r3,r3,LSL #3\n        ADDNE    r12,r12,r3,LSL #4\n        ADDNE    r12,r7,r12,LSL #4\n        STRNE    r2,[r12,r0,LSL #2]\n        ADD      r3,r3,#1\n        CMP      r3,r4\n        BLT      |L1.436|\n|L1.472|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.412|\n|L1.484|\n        MOV      r7,#0\n        LDR      r0,|L1.708|\n        CMP      r4,#0\n        BLE      |L1.536|\n        MOV      r4,r0\n|L1.504|\n        LDR      r0,[r6,r7,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r7\n        BLEQ     dfs1__Fi\n        LDR      r0,[r4,#0]  ; n\n        ADD      r7,r7,#1\n        CMP      r7,r0\n        BLT      |L1.504|\n|L1.536|\n        MOV      r1,#0x190\n        MOV      r0,r6\n        BL       __rt_memclr_w\n        LDR      r0,[r8,#0]  ; top\n        MOV      r4,#0\n        CMN      r0,#1\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n|L1.568|\n        BL       pop__Fv\n        LDR      r1,[r6,r0,LSL #2]\n        CMP      r1,#0\n        BNE      |L1.600|\n        MOV      r2,r4\n        ADD      r4,r4,#1\n        MOV      r1,r5\n        BL       dfs2__FiPiT1\n|L1.600|\n        LDR      r0,[r8,#0]  ; top\n        CMN      r0,#1\n        BNE      |L1.568|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint stack[MAX_VERTICES];\nint top = -1;\nint adj[MAX_VERTICES][MAX_VERTICES];\nint rev_adj[MAX_VERTICES][MAX_VERTICES];\nint n;\n\nvoid push(int v) {\n    stack[++top] = v;\n}\n\nint pop() {\n    return stack[top--];\n}\n\nvoid dfs1(int v) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (adj[v][i] && !visited[i])\n            dfs1(i);\n    }\n    push(v);\n}\n\nvoid dfs2(int v, int *component, int index) {\n    visited[v] = 1;\n    component[v] = index;\n    for (int i = 0; i < n; i++) {\n        if (rev_adj[v][i] && !visited[i])\n            dfs2(i, component, index);\n    }\n}\n\nvoid find_strongly_connected_components(int num_vertices, int graph[][MAX_VERTICES], int *scc) {\n    n = num_vertices;\n    memcpy(adj, graph, sizeof(adj));\n    memset(visited, 0, sizeof(visited));\n    memset(rev_adj, 0, sizeof(rev_adj));\n    top = -1;\n\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (adj[i][j])\n                rev_adj[j][i] = 1;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i])\n            dfs1(i);\n    }\n\n    memset(visited, 0, sizeof(visited));\n\n    int index = 0;\n    while (top != -1) {\n        int v = pop();\n        if (!visited[v]) {\n            dfs2(v, scc, index++);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n        MOV      r2,r0\n        MOVS     r0,r1\n        STMFD    sp!,{r4,lr}\n        BEQ      |L1.40|\n|L1.16|\n        MOV      r4,r0\n        MOV      r1,r2\n        BL       __rt_sdiv\n        MOVS     r0,r1\n        MOV      r2,r4\n        BNE      |L1.16|\n|L1.40|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngetFlyweight__FPci PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r0,r5\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r1,r5\n        LDR      r0,[r4,#0]\n        BL       strcpy\n        STR      r6,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ncreateFlyweightContext__FP9FlyweightPc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        MOVS     r4,r0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r0,r5\n        STR      r6,[r4,#0]\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        STR      r0,[r4,#4]\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       strcpy\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    char* name;\n    int value;\n} Flyweight;\n\ntypedef struct {\n    Flyweight* flyweight;\n    char* external;\n} FlyweightContext;\n\n\nFlyweight* getFlyweight(char* name, int value) {\n    Flyweight* flyweight = (Flyweight*)malloc(sizeof(Flyweight));\n    if(flyweight == NULL) exit(1);\n    flyweight->name = (char*)malloc(strlen(name) + 1);\n    if(flyweight->name == NULL) exit(1);\n    strcpy(flyweight->name, name);\n    flyweight->value = value;\n    return flyweight;\n}\n\nFlyweightContext* createFlyweightContext(Flyweight* flyweight, char* external) {\n    FlyweightContext* context = (FlyweightContext*)malloc(sizeof(FlyweightContext));\n    if(context == NULL) exit(1);\n    context->flyweight = flyweight;\n    context->external = (char*)malloc(strlen(external) + 1);\n     if(context->external == NULL) exit(1);\n    strcpy(context->external, external);\n    return context;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x1d4\n        ADD      r0,r0,#0x9c00\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#0x1c40\n        ADD      r1,r1,#0x8000\n        STR      r5,[r4,#0]\n        ADD      r0,r4,#4\n        BL       __rt_memclr_w\n        ADD      r0,r4,#0x9c00\n        ADD      r0,r0,#0x44\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r3,[r0,#0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r12,r1,r1,LSL #3\n        ADD      r12,r12,r1,LSL #4\n        ADD      r12,r0,r12,LSL #4\n        ADD      r12,r12,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r12,#4]\n        ADD      r12,r2,r2,LSL #3\n        ADD      r2,r12,r2,LSL #4\n        ADD      r0,r0,r2,LSL #4\n        ADD      r0,r0,r1,LSL #2\n        STR      r3,[r0,#4]\n        BX       lr\n        ENDP\n\nDFS__FP5Graphi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r0,[r5,#0]\n        CMPGE    r0,r1\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        ADD      r0,r5,r1,LSL #2\n        ADD      r0,r0,#0x9000\n        LDR      r2,[r0,#0xc44]\n        CMP      r2,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        BXNE     lr\n        MOV      r2,#1\n        STR      r2,[r0,#0xc44]\n        LDR      r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        ADD      r0,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        ADD      r6,r5,r0,LSL #4\n|L1.264|\n        ADD      r0,r6,r4,LSL #2\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        MOVNE    r1,r4\n        MOVNE    r0,r5\n        BLNE     DFS__FP5Graphi\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.264|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nBFS__FP5Graphi PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x324\n        MOVS     r4,r0\n        ADDEQ    sp,sp,#0x324\n        MOV      r7,r1\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        CMP      r7,#0\n        LDRGE    r0,[r4,#0]\n        CMPGE    r0,r7\n        ADDLE    sp,sp,#0x324\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r6,sp,#4\n        MOV      r0,r6\n        MOV      r5,#0\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r2,#1\n        STR      r7,[sp,#0x194]\n        STR      r2,[r6,r7,LSL #2]\n        MOV      r1,#1\n        ADD      lr,sp,#0x194\n        MOV      r3,r6\n|L1.408|\n        MOV      r0,r5\n        LDR      r6,[lr,r0,LSL #2]\n        LDR      r12,[r4,#0]\n        MOV      r0,#0\n        ADD      r5,r5,#1\n        CMP      r12,#0\n        BLE      |L1.508|\n        ADD      r12,r6,r6,LSL #3\n        ADD      r12,r12,r6,LSL #4\n        ADD      r6,r4,r12,LSL #4\n|L1.448|\n        ADD      r12,r6,r0,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,#0\n        BEQ      |L1.492|\n        LDR      r12,[r3,r0,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.492|\n        MOV      r12,r1\n        STR      r0,[lr,r12,LSL #2]\n        STR      r2,[r3,r0,LSL #2]\n        ADD      r1,r1,#1\n|L1.492|\n        LDR      r12,[r4,#0]\n        ADD      r0,r0,#1\n        CMP      r12,r0\n        BGT      |L1.448|\n|L1.508|\n        CMP      r5,r1\n        BLT      |L1.408|\n        ADD      sp,sp,#0x324\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int matrix[MAX_VERTICES][MAX_VERTICES];\n    int visited[MAX_VERTICES];\n} Graph;\n\n\nGraph* createGraph(int vertices) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == NULL) return NULL;\n    graph->vertices = vertices;\n    memset(graph->matrix, 0, sizeof(graph->matrix));\n    memset(graph->visited, 0, sizeof(graph->visited));\n    return graph;\n}\n\n\nvoid addEdge(Graph* graph, int source, int destination) {\n    if (graph == NULL || source < 0 || source >= graph->vertices || destination < 0 || destination >= graph->vertices) return;\n    graph->matrix[source][destination] = 1;\n    graph->matrix[destination][source] = 1; //Assuming undirected graph\n\n}\n\n\nvoid DFS(Graph* graph, int vertex) {\n    if (graph == NULL || vertex < 0 || vertex >= graph->vertices || graph->visited[vertex]) return;\n    graph->visited[vertex] = 1;\n    for (int i = 0; i < graph->vertices; i++) {\n        if (graph->matrix[vertex][i]) {\n            DFS(graph, i);\n        }\n    }\n}\n\n\nvoid BFS(Graph* graph, int startVertex) {\n    if (graph == NULL || startVertex < 0 || startVertex >= graph->vertices) return;\n    int queue[MAX_VERTICES];\n    int head = 0;\n    int tail = 0;\n    int visited[MAX_VERTICES];\n    memset(visited, 0, sizeof(visited));\n\n    queue[tail++] = startVertex;\n    visited[startVertex] = 1;\n\n    while (head < tail) {\n        int vertex = queue[head++];\n        for (int i = 0; i < graph->vertices; i++) {\n            if (graph->matrix[vertex][i] && !visited[i]) {\n                queue[tail++] = i;\n                visited[i] = 1;\n            }\n        }\n    }\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateAccount__FP7AccountPcdT3 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADD      r7,sp,#0x20\n        LDMIA    r7,{r6,r7}\n        MOV      r5,r1\n        MOVS     r4,r0\n        CMPNE    r5,#0\n        MOV      r9,r3\n        MOV      r8,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0x32\n        LDMCSFD  sp!,{r3-r9,lr}\n        BXCS     lr\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       strcpy\n        ADD      r4,r4,#0x30\n        STMIB    r4!,{r8,r9}\n        STMIB    r4,{r6,r7}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n\ndeposit__FP7Accountd PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,r6\n        ADR      r0,|L1.180|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r5\n        BL       _dcmple\n        LDMCCFD  sp!,{r4-r6,lr}\n        BXCC     lr\n        ADD      r1,r4,#0x34\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r2,r4,#0x34\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.180|\n        DCFD     0x0000000000000000\n        ENDP\n\nwithdraw__FP7Accountd PROC\n        STMFD    sp!,{r3-r7,lr}\n        ADR      r7,|L1.180|\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMIA    r7,{r2,r3}\n        BL       _dcmple\n        LDMCCFD  sp!,{r3-r7,lr}\n        BXCC     lr\n        ADD      r1,r4,#0x34\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dsub\n        LDMIA    r7,{r2,r3}\n        BL       _dcmple\n        LDMCCFD  sp!,{r3-r7,lr}\n        BXCC     lr\n        ADD      r1,r4,#0x34\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dsub\n        ADD      r2,r4,#0x34\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\ncalculateInterest__FP7Account PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        ADD      r1,r4,#0x3c\n        ADR      r0,|L1.180|\n        LDMIA    r0,{r2,r3}\n        LDMIA    r1,{r0,r1}\n        BL       _dcmple\n        LDMCCFD  sp!,{r4,lr}\n        BXCC     lr\n        ADD      r1,r4,#0x3c\n        ADR      r0,|L1.404|\n        LDMIA    r0,{r2,r3}\n        LDMIA    r1,{r0,r1}\n        BL       _dadd\n        ADD      r3,r4,#0x34\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        ADD      r2,r4,#0x34\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.404|\n        DCFD     0x3ff0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct Account {\n    char name[50];\n    double balance;\n    double interestRate;\n};\n\nvoid createAccount(Account* acc, char* name, double balance, double interestRate) {\n    if (acc == NULL || name == NULL || strlen(name) >= 50) return;\n    strcpy(acc->name, name);\n    acc->balance = balance;\n    acc->interestRate = interestRate;\n}\n\n\nvoid deposit(Account* acc, double amount) {\n    if (acc == NULL || amount < 0) return;\n    acc->balance += amount;\n}\n\nvoid withdraw(Account* acc, double amount) {\n    if (acc == NULL || amount < 0 || acc->balance - amount < 0) return;\n    acc->balance -= amount;\n}\n\nvoid calculateInterest(Account* acc) {\n    if (acc == NULL || acc->interestRate < 0) return;\n    acc->balance *= (1 + acc->interestRate);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r6,r0\n        BL       strlen\n        SUB      r4,r0,#1\n        CMP      r4,#0\n        MOV      r8,r0\n        MOV      r5,#0\n        BLE      |L1.180|\n        BL       __rt_ctype_table\n        MOV      r7,r0\n        B        |L1.48|\n|L1.44|\n        ADD      r5,r5,#1\n|L1.48|\n        CMP      r5,r8\n        BGE      |L1.84|\n        LDRB     r1,[r6,r5]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.44|\n        B        |L1.84|\n|L1.80|\n        SUB      r4,r4,#1\n|L1.84|\n        CMP      r4,#0\n        BLT      |L1.112|\n        LDRB     r1,[r6,r4]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.80|\n|L1.112|\n        CMP      r5,r4\n        LDMGEFD  sp!,{r3-r9,lr}\n        MOVGE    r0,#1\n        BXGE     lr\n        LDRB     r0,[r6,r5]\n        BL       tolower\n        MOV      r9,r0\n        LDRB     r0,[r6,r4]\n        BL       tolower\n        CMP      r9,r0\n        LDMNEFD  sp!,{r3-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        CMP      r5,r4\n        BLT      |L1.48|\n|L1.180|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint isPalindrome(char* str) {\n    int len = strlen(str);\n    int i = 0;\n    int j = len -1;\n    while (i < j) {\n        while (i < len && !isalnum(str[i])) i++;\n        while (j >= 0 && !isalnum(str[j])) j--;\n        if (i >= j) return 1;\n        if (tolower(str[i]) != tolower(str[j])) return 0;\n        i++;\n        j--;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngeneratePascalsTriangle__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r7,#4\n        MOV      r8,#1\n|L1.56|\n        ADD      r0,r7,r4,LSL #2\n        BL       malloc\n        STR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.128|\n        MOV      r6,#0\n        CMP      r4,#0\n        BLE      |L1.108|\n|L1.88|\n        LDR      r0,[r5,r6,LSL #2]\n        BL       free\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        BLT      |L1.88|\n|L1.108|\n        MOV      r0,r5\n        BL       free\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.128|\n        STR      r8,[r0,#0]\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r4,#1\n        STR      r8,[r0,r4,LSL #2]\n        MOV      r0,#1\n        BLE      |L1.196|\n        ADD      r3,r5,r4,LSL #2\n|L1.156|\n        LDR      r1,[r3,#-4]\n        ADD      r2,r1,r0,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r1,[r1,r0,LSL #2]\n        ADD      r1,r2,r1\n        LDR      r2,[r5,r4,LSL #2]\n        STR      r1,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.156|\n|L1.196|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.56|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint** generatePascalsTriangle(int rows) {\n    if (rows <= 0) {\n        return NULL;\n    }\n\n    int** triangle = (int**)malloc(rows * sizeof(int*));\n    if (triangle == NULL) return NULL;\n\n    for (int i = 0; i < rows; i++) {\n        triangle[i] = (int*)malloc((i + 1) * sizeof(int));\n        if (triangle[i] == NULL) {\n            for (int j = 0; j < i; j++) {\n                free(triangle[j]);\n            }\n            free(triangle);\n            return NULL;\n        }\n        triangle[i][0] = 1;\n        triangle[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\n        }\n    }\n    return triangle;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndeepLearningModel__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x68\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,r5\n        ADR      r1,|L1.156|\n        BL       strstr\n        CMP      r0,#0\n        BEQ      |L1.68|\n        MOV      r0,#1\n        STR      r0,[r4,#0]\n        ADD      r0,r4,#4\n        MOV      r2,#9\n        ADR      r1,|L1.164|\n        BL       __rt_memcpy_w\n        B        |L1.144|\n|L1.68|\n        ADR      r1,|L1.176|\n        MOV      r0,r5\n        BL       strstr\n        CMP      r0,#0\n        BEQ      |L1.116|\n        MOV      r0,#2\n        STR      r0,[r4,#0]\n        ADD      r0,r4,#4\n        MOV      r2,#9\n        ADR      r1,|L1.184|\n        BL       __rt_memcpy_w\n        B        |L1.144|\n|L1.116|\n        MOV      r0,#0\n        STR      r0,[r4,#0]\n        ADR      r0,|L1.196|\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[r4,#8]\n        STR      r1,[r4,#4]\n|L1.144|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.156|\n        DCB      \"pers\"\n        DCB      \"onA\\0\"\n|L1.164|\n        DCB      \"Pers\"\n        DCB      \"on A\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.176|\n        DCB      \"pers\"\n        DCB      \"onB\\0\"\n|L1.184|\n        DCB      \"Pers\"\n        DCB      \"on B\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.196|\n        DCB      \"Unkn\"\n        DCB      \"own\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n\n// Placeholder structure for face data.  Replace with actual representation.\ntypedef struct {\n    int id;\n    char name[100];\n} FaceData;\n\n// Placeholder for deep learning model. Replace with actual model.\nFaceData* deepLearningModel(char* imagePath){\n    //Simulate Model\n    FaceData* fd = (FaceData*) malloc(sizeof(FaceData));\n    if(strstr(imagePath,\"personA\") != NULL){\n        fd->id = 1;\n        strcpy(fd->name,\"Person A\");\n    } else if (strstr(imagePath,\"personB\") != NULL){\n        fd->id = 2;\n        strcpy(fd->name,\"Person B\");\n    } else {\n        fd->id = 0;\n        strcpy(fd->name,\"Unknown\");\n    }\n    return fd;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreatePriorityQueue__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0x190\n        BL       malloc\n        MOV      r1,#0\n        STMIA    r4,{r0,r1}\n        MOV      r1,#0x64\n        STR      r1,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nheapifyUp__FP13PriorityQueuei PROC\n        SUB      r2,r1,#1\n        ADD      r2,r2,r2,LSR #31\n        MOV      r2,r2,ASR #1\n        STR      lr,[sp,#-4]!\n        B        |L1.100|\n|L1.72|\n        STR      r12,[lr,r1,LSL #2]\n        LDR      r1,[r0,#0]\n        STR      r3,[r1,r2,LSL #2]\n        MOV      r1,r2\n        SUB      r2,r2,#1\n        ADD      r2,r2,r2,LSR #31\n        MOV      r2,r2,ASR #1\n|L1.100|\n        CMP      r1,#0\n        LDRLE    lr,[sp],#4\n        BXLE     lr\n        LDR      lr,[r0,#0]\n        LDR      r3,[lr,r1,LSL #2]\n        LDR      r12,[lr,r2,LSL #2]\n        CMP      r3,r12\n        BGT      |L1.72|\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ninsert__FP13PriorityQueuei PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP13PriorityQueuei\n        ENDP\n\nheapifyDown__FP13PriorityQueuei PROC\n        STMFD    sp!,{r4,r5,lr}\n        LDR      lr,[r0,#4]\n        MOV      r3,#1\n        ADD      r3,r3,r1,LSL #1\n        MOV      r12,#2\n        ADD      r12,r12,r1,LSL #1\n        CMP      lr,r3\n        MOV      r2,r1\n        BLE      |L1.236|\n        LDR      r4,[r0,#0]\n        LDR      r5,[r4,r3,LSL #2]\n        LDR      r4,[r4,r1,LSL #2]\n        CMP      r5,r4\n        MOVGT    r1,r3\n|L1.236|\n        CMP      lr,r12\n        BLE      |L1.264|\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r12,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        CMP      lr,r3\n        MOVGT    r1,r12\n|L1.264|\n        CMP      r1,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r1,LSL #2]\n        LDR      r12,[r3,r2,LSL #2]\n        STR      lr,[r3,r2,LSL #2]\n        LDR      r2,[r0,#0]\n        STR      r12,[r2,r1,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP13PriorityQueuei\n        ENDP\n\nextractMax__FP13PriorityQueue PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        BL       heapifyDown__FP13PriorityQueuei\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define HEAP_SIZE 100\n\ntypedef struct {\n    int* arr;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nPriorityQueue* createPriorityQueue() {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    pq->arr = (int*)malloc(sizeof(int) * HEAP_SIZE);\n    pq->size = 0;\n    pq->capacity = HEAP_SIZE;\n    return pq;\n}\n\n\nvoid heapifyUp(PriorityQueue* pq, int index) {\n    int parent = (index - 1) / 2;\n    while (index > 0 && pq->arr[index] > pq->arr[parent]) {\n        int temp = pq->arr[index];\n        pq->arr[index] = pq->arr[parent];\n        pq->arr[parent] = temp;\n        index = parent;\n        parent = (index - 1) / 2;\n    }\n}\n\nvoid insert(PriorityQueue* pq, int value) {\n    if (pq->size == pq->capacity) return;\n    pq->arr[pq->size] = value;\n    pq->size++;\n    heapifyUp(pq, pq->size - 1);\n}\n\nvoid heapifyDown(PriorityQueue* pq, int index) {\n    int largest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < pq->size && pq->arr[left] > pq->arr[largest]) {\n        largest = left;\n    }\n    if (right < pq->size && pq->arr[right] > pq->arr[largest]) {\n        largest = right;\n    }\n\n    if (largest != index) {\n        int temp = pq->arr[index];\n        pq->arr[index] = pq->arr[largest];\n        pq->arr[largest] = temp;\n        heapifyDown(pq, largest);\n    }\n}\n\nint extractMax(PriorityQueue* pq) {\n    if (pq->size == 0) return 0;\n    int max = pq->arr[0];\n    pq->arr[0] = pq->arr[pq->size - 1];\n    pq->size--;\n    heapifyDown(pq, 0);\n    return max;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nnewBinaryNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nconvertTree__FP4Node PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       newBinaryNode__Fi\n        LDR      r4,[r4,#4]\n        MOV      r6,r0\n        MOV      r5,r0\n        CMP      r4,#0\n        BEQ      |L1.152|\n|L1.124|\n        MOV      r0,r4\n        BL       convertTree__FP4Node\n        STR      r0,[r5,#4]\n        LDR      r4,[r4,#8]\n        CMP      r4,#0\n        MOVNE    r5,r0\n        BNE      |L1.124|\n|L1.152|\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *firstChild;\n    struct Node *nextSibling;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->firstChild = NULL;\n    node->nextSibling = NULL;\n    return node;\n}\n\nstruct BinaryNode {\n    int data;\n    struct BinaryNode *left;\n    struct BinaryNode *right;\n};\n\nstruct BinaryNode* newBinaryNode(int data) {\n    struct BinaryNode* node = (struct BinaryNode*)malloc(sizeof(struct BinaryNode));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\n\nstruct BinaryNode* convertTree(struct Node* root) {\n    if (root == NULL) return NULL;\n\n    struct BinaryNode* binaryRoot = newBinaryNode(root->data);\n    struct BinaryNode* current = binaryRoot;\n    struct Node* sibling = root->firstChild;\n\n    while (sibling != NULL) {\n        current->left = convertTree(sibling);\n        sibling = sibling->nextSibling;\n        if(sibling != NULL){\n            current = current->left;\n        }\n    }\n\n    return binaryRoot;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.316|\n        MOV      r1,r0\n        LDR      r0,[r2,#0]  ; top\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0]  ; top\n        LDR      r2,|L1.320|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.316|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.320|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\ntopologicalSortUtil__FPA100_iiT2 PROC\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r9,|L1.324|\n        MOV      r7,r0\n        MOV      r0,#1\n        STR      r0,[r9,r1,LSL #2]\n        MOV      r6,r1\n        MOV      r5,r2\n        MOV      r4,#0\n        CMP      r2,#0\n        BLE      |L1.164|\n        ADD      r0,r6,r6,LSL #3\n        ADD      r0,r0,r6,LSL #4\n        ADD      r8,r7,r0,LSL #4\n|L1.112|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r0,[r9,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.152|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r7\n        BL       topologicalSortUtil__FPA100_iiT2\n|L1.152|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.112|\n|L1.164|\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r9,lr}\n        B        push__Fi\n        ENDP\n\ntopologicalSort__FPA100_ii PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r7,|L1.324|\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r1,#0x190\n        MOV      r0,r7\n        BL       __rt_memclr_w\n        LDR      r8,|L1.316|\n        MVN      r0,#0\n        STR      r0,[r8,#0]  ; top\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.268|\n|L1.228|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.256|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       topologicalSortUtil__FPA100_iiT2\n|L1.256|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.228|\n|L1.268|\n        LDR      r4,[r8,#0]  ; top\n        CMP      r4,#0\n        BLT      |L1.304|\n        LDR      r5,|L1.320|\n|L1.284|\n        LDR      r1,[r5,r4,LSL #2]\n        ADR      r0,|L1.328|\n        BL       _printf\n        SUBS     r4,r4,#1\n        BPL      |L1.284|\n|L1.304|\n        ADR      r0,|L1.332|\n        LDMFD    sp!,{r4-r8,lr}\n        B        _printf\n|L1.316|\n        DCD      top\n|L1.320|\n        DCD      ||.bss$2|| + 400\n|L1.324|\n        DCD      ||.bss$2||\n|L1.328|\n        DCB      \"%d \\0\"\n|L1.332|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint stack[MAX_VERTICES];\nint top = -1;\n\nvoid push(int v) {\n    stack[++top] = v;\n}\n\nint pop() {\n    return stack[top--];\n}\n\nvoid topologicalSortUtil(int graph[][MAX_VERTICES], int v, int n) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (graph[v][i] && !visited[i]) {\n            topologicalSortUtil(graph, i, n);\n        }\n    }\n    push(v);\n}\n\nvoid topologicalSort(int graph[][MAX_VERTICES], int n) {\n    memset(visited, 0, sizeof(visited));\n    top = -1;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            topologicalSortUtil(graph, i, n);\n        }\n    }\n    for (int i = top; i >= 0; i--) {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlargestPrimeFactor__Fx PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r4,r0\n        ADR      r0,|L1.360|\n        LDMIA    r0,{r8,r9}\n        ADR      r11,|L1.344|\n        LDMIA    r11,{r2,r3}\n        MOV      r0,r4\n        ADR      r10,|L1.352|\n        MOV      r5,r1\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r10,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.128|\n|L1.64|\n        LDMIA    r11,{r8,r9}\n        MOV      r2,r8\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r9\n        BL       _ll_sdiv\n        MOV      r4,r0\n        MOV      r5,r1\n        LDMIA    r11,{r2,r3}\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r10,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BEQ      |L1.64|\n|L1.128|\n        ADR      r0,|L1.368|\n        LDMIA    r0,{r6,r7}\n        ADR      r1,|L1.376|\n        LDMIA    r1,{r0,r1}\n        SUBS     r0,r4,r0\n        SBCS     r1,r5,r1\n        BLT      |L1.308|\n|L1.156|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r10,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.272|\n|L1.200|\n        MOV      r8,r6\n        MOV      r9,r7\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _ll_sdiv\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r10,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BEQ      |L1.200|\n|L1.272|\n        MOV      r2,#2\n        ADDS     r6,r6,r2\n        ADC      r7,r7,#0\n        UMULL    r0,r12,r6,r6\n        MLA      r12,r6,r7,r12\n        MLA      r1,r7,r6,r12\n        SUBS     r0,r4,r0\n        SBCS     r1,r5,r1\n        BGE      |L1.156|\n|L1.308|\n        LDMIA    r11,{r2,r3}\n        SUBS     r0,r2,r4\n        SBCS     r1,r3,r5\n        MOVLT    r8,r4\n        MOVLT    r9,r5\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.344|\n        DCQ      0x0000000000000002\n|L1.352|\n        DCQ      0x0000000000000000\n|L1.360|\n        DCQ      0x0000000000000001\n|L1.368|\n        DCQ      0x0000000000000003\n|L1.376|\n        DCQ      0x0000000000000009\n        ENDP\n```",
        "output": "```cpp\n\nlong long largestPrimeFactor(long long n) {\n    long long largestFactor = 1;\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n    for (long long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n    if (n > 2)\n        largestFactor = n;\n    return largestFactor;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbinarySearchRotated__FPiiN22 PROC\n|L1.0|\n        CMP      r2,r1\n        MVNLT    r0,#0\n        BXLT     lr\n        SUB      r12,r2,r1\n        ADD      r12,r12,r12,LSR #31\n        ADD      r12,r1,r12,ASR #1\n        STMFD    sp!,{r4,r5,lr}\n        LDR      r4,[r0,r12,LSL #2]\n        CMP      r4,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,r12\n        BXEQ     lr\n        SUB      r12,r2,r1\n        ADD      r12,r12,r12,LSR #31\n        ADD      lr,r1,r12,ASR #1\n        LDR      r5,[r0,r1,LSL #2]\n        ADD      r12,lr,#1\n        SUB      lr,lr,#1\n        CMP      r5,r4\n        BGT      |L1.116|\n        CMP      r5,r3\n        BGT      |L1.104|\n        CMP      r4,r3\n        MOVGT    r2,lr\n        LDMGTFD  sp!,{r4,r5,lr}\n        BGT      binarySearchRotated__FPiiN22\n|L1.104|\n        MOV      r1,r12\n        LDMFD    sp!,{r4,r5,lr}\n        B        binarySearchRotated__FPiiN22\n|L1.116|\n        CMP      r4,r3\n        BGE      |L1.144|\n        LDR      r4,[r0,r2,LSL #2]\n        CMP      r4,r3\n        MOVGE    r1,r12\n        LDMGEFD  sp!,{r4,r5,lr}\n        BGE      binarySearchRotated__FPiiN22\n|L1.144|\n        MOV      r2,lr\n        LDMFD    sp!,{r4,r5,lr}\n        B        binarySearchRotated__FPiiN22\n        ENDP\n```",
        "output": "```cpp\n\nint binarySearchRotated(int arr[], int left, int right, int target) {\n    if (right < left) return -1;\n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) return mid;\n    if (arr[left] <= arr[mid]) {\n        if (target >= arr[left] && target < arr[mid])\n            return binarySearchRotated(arr, left, mid - 1, target);\n        else\n            return binarySearchRotated(arr, mid + 1, right, target);\n    }\n    else {\n        if (target > arr[mid] && target <= arr[right])\n            return binarySearchRotated(arr, mid + 1, right, target);\n        else\n            return binarySearchRotated(arr, left, mid - 1, target);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0x28\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.64|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        MVN      r0,#0\n        STR      r0,[r4,#4]\n        MOV      r0,#0xa\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r2,[r4,#4]\n        SUB      r1,r0,#1\n        CMP      r1,r2\n        BNE      |L1.168|\n        MOV      r5,r0,LSL #1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r5,[r4,#8]\n|L1.168|\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r6,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMNNE    r1,#1\n        MOVEQ    r0,#0\n        BXEQ     lr\n        SUB      r2,r1,#1\n        STR      r2,[r0,#4]\n        LDR      r0,[r0,#0]\n        LDR      r0,[r0,r1,LSL #2]\n        BX       lr\n        ENDP\n\npeek__FP5Stack PROC\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMNNE    r1,#1\n        LDRNE    r0,[r0,#0]\n        LDRNE    r0,[r0,r1,LSL #2]\n        BXNE     lr\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\ndeleteStack__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define INITIAL_CAPACITY 10\n\ntypedef struct {\n    int* data;\n    int top;\n    int capacity;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    if (stack == NULL) return NULL;\n    stack->data = (int*)malloc(INITIAL_CAPACITY * sizeof(int));\n    if (stack->data == NULL) {\n        free(stack);\n        return NULL;\n    }\n    stack->top = -1;\n    stack->capacity = INITIAL_CAPACITY;\n    return stack;\n}\n\nint push(Stack* stack, int value) {\n    if (stack == NULL) return 0;\n    if (stack->top == stack->capacity - 1) {\n        int newCapacity = stack->capacity * 2;\n        int* newData = (int*)realloc(stack->data, newCapacity * sizeof(int));\n        if (newData == NULL) return 0;\n        stack->data = newData;\n        stack->capacity = newCapacity;\n    }\n    stack->data[++stack->top] = value;\n    return 1;\n}\n\nint pop(Stack* stack) {\n    if (stack == NULL || stack->top == -1) return 0;\n    return stack->data[stack->top--];\n}\n\nint peek(Stack* stack) {\n    if (stack == NULL || stack->top == -1) return 0;\n    return stack->data[stack->top];\n}\n\nvoid deleteStack(Stack* stack) {\n    if (stack == NULL) return;\n    free(stack->data);\n    free(stack);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateArray2D__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MUL      r0,r6,r5\n        MOV      r0,r0,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        STMNEIB  r4,{r5,r6}\n        MOVNE    r0,r4\n        LDMNEFD  sp!,{r4-r6,lr}\n        BXNE     lr\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfreeArray2D__FP7Array2D PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\ngetArray2DValue__FP7Array2DiT2 PROC\n        CMP      r0,#0\n        BEQ      |L1.176|\n        CMP      r1,#0\n        LDRGE    r3,[r0,#4]\n        CMPGE    r3,r1\n        BLE      |L1.176|\n        CMP      r2,#0\n        LDRGE    r3,[r0,#8]\n        CMPGE    r3,r2\n        LDRGT    r0,[r0,#0]\n        MLAGT    r1,r3,r1,r2\n        LDRGT    r0,[r0,r1,LSL #2]\n        BXGT     lr\n|L1.176|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nsetArray2DValue__FP7Array2DiN22 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r12,[r0,#4]\n        CMPGE    r12,r1\n        BXLE     lr\n        CMP      r2,#0\n        LDRGE    r12,[r0,#8]\n        CMPGE    r12,r2\n        BXLE     lr\n        LDR      r0,[r0,#0]\n        MLA      r1,r12,r1,r2\n        STR      r3,[r0,r1,LSL #2]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* data;\n    int rows;\n    int cols;\n} Array2D;\n\nArray2D* createArray2D(int rows, int cols) {\n    Array2D* arr = (Array2D*)malloc(sizeof(Array2D));\n    if (arr == NULL) return NULL;\n    arr->data = (int*)malloc(rows * cols * sizeof(int));\n    if (arr->data == NULL) {\n        free(arr);\n        return NULL;\n    }\n    arr->rows = rows;\n    arr->cols = cols;\n    return arr;\n}\n\nvoid freeArray2D(Array2D* arr) {\n    if (arr != NULL) {\n        free(arr->data);\n        free(arr);\n    }\n}\n\nint getArray2DValue(Array2D* arr, int row, int col) {\n    if (arr == NULL || row < 0 || row >= arr->rows || col < 0 || col >= arr->cols) {\n        return 0; // Or handle error appropriately\n    }\n    return arr->data[row * arr->cols + col];\n}\n\nvoid setArray2DValue(Array2D* arr, int row, int col, int value) {\n    if (arr != NULL && row >= 0 && row < arr->rows && col >= 0 && col < arr->cols) {\n        arr->data[row * arr->cols + col] = value;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x44\n        ADD      r0,r0,#0x9c00\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,#0x1c40\n        ADD      r0,r0,#0x8000\n        STR      r5,[r0,r4]\n        MOV      r1,r0\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        MOVGE    r3,#0x1c40\n        ADDGE    r3,r3,#0x8000\n        LDRGE    r3,[r3,r0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r12,r1,r1,LSL #3\n        ADD      r12,r12,r1,LSL #4\n        ADD      r12,r0,r12,LSL #4\n        MOV      r3,#1\n        STR      r3,[r12,r2,LSL #2]\n        ADD      r12,r2,r2,LSL #3\n        ADD      r2,r12,r2,LSL #4\n        ADD      r0,r0,r2,LSL #4\n        STR      r3,[r0,r1,LSL #2]\n        BX       lr\n        ENDP\n\nisConnected__FP5GraphiT2 PROC\n        CMP      r0,#0\n        BEQ      |L1.212|\n        CMP      r1,#0\n        MOVGE    r3,#0x1c40\n        ADDGE    r3,r3,#0x8000\n        LDRGE    r3,[r3,r0]\n        CMPGE    r3,r1\n        BLE      |L1.212|\n        CMP      r2,#0\n        CMPGE    r3,r2\n        ADDGT    r12,r1,r1,LSL #3\n        ADDGT    r1,r12,r1,LSL #4\n        ADDGT    r0,r0,r1,LSL #4\n        LDRGT    r0,[r0,r2,LSL #2]\n        BXGT     lr\n|L1.212|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int matrix[MAX_VERTICES][MAX_VERTICES];\n    int numVertices;\n} Graph;\n\nGraph* createGraph(int numVertices) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == NULL) return NULL;\n    graph->numVertices = numVertices;\n    memset(graph->matrix, 0, sizeof(graph->matrix));\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int u, int v) {\n    if (graph == NULL || u < 0 || u >= graph->numVertices || v < 0 || v >= graph->numVertices) return;\n    graph->matrix[u][v] = 1;\n    graph->matrix[v][u] = 1; \n}\n\nint isConnected(Graph* graph, int u, int v) {\n    if (graph == NULL || u < 0 || u >= graph->numVertices || v < 0 || v >= graph->numVertices) return 0;\n    return graph->matrix[u][v];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndaysInMonth__FiT1 PROC\n        CMP      r0,#1\n        BLT      |L1.16|\n        CMP      r0,#0xc\n        BLE      |L1.24|\n|L1.16|\n        MOV      r0,#0\n        BX       lr\n|L1.24|\n        CMP      r0,#2\n        BNE      |L1.120|\n        TST      r1,#3\n        LDR      r0,|L1.216|\n        BNE      |L1.76|\n        SMULL    r3,r2,r0,r1\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r1,r2,LSL #2\n        BNE      |L1.112|\n|L1.76|\n        SMULL    r3,r2,r0,r1\n        MOV      r0,r2,ASR #7\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r0,r0,LSL #2\n        ADDS     r0,r1,r0,LSL #4\n        MOVNE    r0,#0x1c\n        BXNE     lr\n|L1.112|\n        MOV      r0,#0x1d\n        BX       lr\n|L1.120|\n        CMP      r0,#4\n        CMPNE    r0,#6\n        CMPNE    r0,#9\n        CMPNE    r0,#0xb\n        MOVNE    r0,#0x1f\n        BXNE     lr\n        MOV      r0,#0x1e\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint daysInMonth(int month, int year) {\n    if (month < 1 || month > 12) return 0;\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        else\n            return 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    else\n        return 31;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nconvert_to_base__FiT1 PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x34\n        CMP      r1,#2\n        ADDLT    sp,sp,#0x34\n        MOV      r5,r1\n        LDMLTFD  sp!,{r4-r7,lr}\n        BXLT     lr\n        CMP      r5,#0x10\n        ADDGT    sp,sp,#0x34\n        LDMGTFD  sp!,{r4-r7,lr}\n        BXGT     lr\n        CMP      r0,#0\n        MOVEQ    r1,#0x30\n        MOV      r4,#0\n        MOVEQ    r4,#1\n        STREQB   r1,[sp,#0]\n        MOV      r6,sp\n        BEQ      |L1.92|\n        BGE      |L1.92|\n        MOV      r1,#0x2d\n        STRB     r1,[sp,#0]\n        MOV      r4,#1\n        RSB      r0,r0,#0\n|L1.92|\n        CMP      r0,#0\n        BLE      |L1.164|\n|L1.100|\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0xa\n        BGE      |L1.140|\n        ADD      r2,r1,#0x30\n        MOV      r1,r4\n        STRB     r2,[r6,r1]\n        ADD      r4,r4,#1\n        B        |L1.156|\n|L1.140|\n        ADD      r2,r1,#0x37\n        MOV      r1,r4\n        STRB     r2,[r6,r1]\n        ADD      r4,r4,#1\n|L1.156|\n        CMP      r0,#0\n        BGT      |L1.100|\n|L1.164|\n        MOV      r7,#0\n        STRB     r7,[r6,r4]\n        ADD      r0,r4,#1\n        BL       malloc\n        MOVS     r5,r0\n        ADDEQ    sp,sp,#0x34\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.236|\n        SUB      r1,r4,#1\n|L1.212|\n        SUB      r2,r1,r0\n        LDRB     r2,[r6,r2]\n        STRB     r2,[r5,r0]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.212|\n|L1.236|\n        STRB     r7,[r5,r4]\n        MOV      r1,r5\n        ADR      r0,|L1.272|\n        BL       _printf\n        MOV      r0,r5\n        BL       free\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.272|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid convert_to_base(int num, int base) {\n    if (base < 2 || base > 16) {\n        return;\n    }\n    char buffer[50];\n    int i = 0;\n    if (num == 0) {\n        buffer[i++] = '0';\n    } else if (num < 0) {\n        buffer[i++] = '-';\n        num = -num;\n    }\n    while (num > 0) {\n        int remainder = num % base;\n        if (remainder < 10) {\n            buffer[i++] = remainder + '0';\n        } else {\n            buffer[i++] = remainder - 10 + 'A';\n        }\n        num /= base;\n    }\n    buffer[i] = '\\0';\n    char* reversed = (char*)malloc(i + 1);\n    if (reversed == NULL) return;\n    for (int j = 0; j < i; j++) {\n        reversed[j] = buffer[i - 1 - j];\n    }\n    reversed[i] = '\\0';\n    printf(\"%s\\n\", reversed);\n    free(reversed);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmedian__FPiiT1T2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r1\n        CMP      r4,r3\n        MOV      r1,r3\n        MOV      lr,r0\n        MOV      r12,r2\n        BLE      |L1.48|\n        MOV      r3,r4\n        MOV      r2,lr\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r12\n        B        median__FPiiT1T2\n|L1.48|\n        ADD      r0,r1,r1,LSR #31\n        MOV      r5,r0,ASR #1\n        CMP      r4,#0\n        LDREQ    r0,[r12,r5,LSL #2]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        ADD      r3,r12,r0,LSL #2\n        CMP      r4,#1\n        BNE      |L1.172|\n        CMP      r1,#1\n        BNE      |L1.128|\n        LDR      r0,[lr,#0]\n        LDR      r1,[r12,#0]\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r0,r1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r0,r0,ASR #1\n        BX       lr\n|L1.128|\n        LDR      r1,[r12,r5,LSL #2]\n        LDR      r2,[lr,#0]\n        MOV      r0,r1\n        CMP      r1,r2\n        LDMGEFD  sp!,{r4,r5,lr}\n        BXGE     lr\n        LDR      r0,[r3,#-4]\n        LDMFD    sp!,{r4,r5,lr}\n        CMP      r0,r2\n        MOVGT    r0,r2\n        BX       lr\n|L1.172|\n        ADD      r0,r4,r4,LSR #31\n        MOV      r2,r0,ASR #1\n        ADD      r0,lr,r2,LSL #2\n        LDR      r0,[r0,#-4]\n        LDR      r12,[r12,r5,LSL #2]\n        ADD      r1,r4,r1\n        CMP      r0,r12\n        BGT      |L1.252|\n        LDR      r0,[lr,r2,LSL #2]\n        LDR      r2,[r3,#-4]\n        CMP      r0,r2\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        TST      r1,#1\n        ADDEQ    r0,r0,r2\n        ADDEQ    r0,r0,r0,LSR #31\n        LDMFD    sp!,{r4,r5,lr}\n        MOVEQ    r0,r0,ASR #1\n        MOVNE    r0,r2\n        BX       lr\n|L1.252|\n        TST      r1,#1\n        ADDEQ    r0,r0,r12\n        ADDEQ    r0,r0,r0,LSR #31\n        LDMFD    sp!,{r4,r5,lr}\n        MOVEQ    r0,r0,ASR #1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint median(int a[], int m, int b[], int n) {\n    if (m > n) return median(b, n, a, m);\n    if (m == 0) return b[n / 2];\n    if (m == 1) {\n        if (n == 1) return (a[0] + b[0]) / 2;\n        if (a[0] <= b[n / 2]) return b[n / 2];\n        if (a[0] >= b[n / 2 -1 ]) return b[n / 2 - 1];\n        return a[0];\n    }\n    int i = m / 2;\n    int j = n / 2;\n    if (a[i -1] <= b[j]) {\n        if (a[i] <= b[j-1]) return a[i];\n        if ( (m+n)%2 == 0) return (a[i] + b[j-1])/2;\n        return b[j-1];\n    }\n    if ((m+n)%2 == 0) return (a[i -1] + b[j])/2;\n    return a[i-1];\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndistance3D__F7Point3DT1 PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r12,r0\n        ADD      r9,sp,#0x40\n        MOV      r3,r1\n        LDMIA    r9,{r0,r1,r6-r9}\n        ADD      r11,sp,#0x38\n        LDMIA    r11,{r10,r11}\n        MOV      r2,r12\n        BL       _dsub\n        ADD      r3,sp,#0x30\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r3,{r2,r3}\n        BL       _dsub\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dsub\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        B        __softfp_sqrt\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point3D {\n    double x, y, z;\n};\n\ndouble distance3D(Point3D p1, Point3D p2) {\n    double dx = p2.x - p1.x;\n    double dy = p2.y - p1.y;\n    double dz = p2.z - p1.z;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndot_product__FPdT1i PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r8,r0\n        ADR      r0,|L1.104|\n        LDMIA    r0,{r5,r6}\n        MOV      r9,r1\n        MOV      r7,r2\n        MOV      r4,#0\n        CMP      r2,#0\n        BLE      |L1.88|\n|L1.36|\n        ADD      r1,r9,r4,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r8,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        MOV      r5,r0\n        MOV      r6,r1\n        BLT      |L1.36|\n|L1.88|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.104|\n        DCFD     0x0000000000000000\n        ENDP\n\nclassify__F3SVMPdi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r2\n        LDR      r2,[sp,#0x10]\n        MOV      r1,r3\n        BL       dot_product__FPdT1i\n        MOV      r3,r4\n        MOV      r2,r5\n        BL       _dadd\n        ADR      r2,|L1.104|\n        LDMIA    r2,{r2,r3}\n        BL       _dcmpge\n        LDMFD    sp!,{r3-r5,lr}\n        MVNCC    r0,#0\n        MOVCS    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct SVM {\n    double *w;\n    double b;\n};\n\n\ndouble dot_product(double *v1, double *v2, int n) {\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += v1[i] * v2[i];\n    }\n    return result;\n}\n\n\nint classify(SVM svm, double *x, int n) {\n    return (dot_product(svm.w, x, n) + svm.b >= 0) ? 1 : -1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nf__Fd PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        ADR      r8,|L1.76|\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMIA    r8,{r2,r3}\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _drsb\n        LDMIA    r8,{r2,r3}\n        LDMFD    sp!,{r4-r8,lr}\n        B        _dadd\n|L1.76|\n        DCFD     0x4010000000000000\n        ENDP\n\ngolden_section_search__FdN21 PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r5,r3\n        MOV      r4,r2\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r7,r1\n        MOV      r6,r0\n        MOV      r0,r4\n        MOV      r1,r5\n        SUB      sp,sp,#0x1c\n        ADR      r8,|L1.452|\n        BL       _dsub\n        STR      r0,[sp,#0x18]\n        STR      r1,[sp,#0x14]\n        ADR      r2,|L1.452|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      r9,r1\n        LDR      r1,[sp,#0x14]\n        MOV      r8,r0\n        LDR      r0,[sp,#0x18]\n        ADD      r3,sp,#0x40\n        LDMIA    r3,{r2,r3}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmpge\n        BLS      |L1.412|\n|L1.236|\n        MOV      r1,r11\n        MOV      r0,r10\n        BL       f__Fd\n        STMIB    sp,{r0,r1}\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       f__Fd\n        LDMIB    sp,{r2,r3}\n        BL       _dcmpge\n        MOVLS    r6,r10\n        MOVLS    r7,r11\n        MOVHI    r4,r8\n        MOVHI    r5,r9\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dsub\n        STR      r0,[sp,#0x10]\n        STR      r1,[sp,#0xc]\n        ADR      r2,|L1.452|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      r9,r1\n        LDR      r1,[sp,#0xc]\n        MOV      r8,r0\n        LDR      r0,[sp,#0x10]\n        ADD      r3,sp,#0x40\n        LDMIA    r3,{r2,r3}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmpge\n        BHI      |L1.236|\n|L1.412|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dadd\n        ADR      r2,|L1.460|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dmul\n|L1.452|\n        DCFD     0x3ff9e3779b97f681\n|L1.460|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define GOLDEN_RATIO (1.61803398875)\n\ndouble f(double x) {\n    return x * x - 4 * x + 4;\n}\n\ndouble golden_section_search(double a, double b, double tolerance) {\n    double c = b - (b - a) / GOLDEN_RATIO;\n    double d = a + (b - a) / GOLDEN_RATIO;\n    while (fabs(b - a) > tolerance) {\n        if (f(c) < f(d)) {\n            b = d;\n        } else {\n            a = c;\n        }\n        c = b - (b - a) / GOLDEN_RATIO;\n        d = a + (b - a) / GOLDEN_RATIO;\n    }\n    return (a + b) / 2.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrgbToHex__FiN21 PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#8\n        STR      r2,[sp,#0]\n        LDR      r4,|L1.68|\n        MOV      r2,r0\n        MOV      r3,r1\n        ADR      r1,|L1.52|\n        MOV      r0,r4\n        BL       _sprintf\n        MOV      r0,r4\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.52|\n        DCB      \"#%02\"\n        DCB      \"X%02\"\n        DCB      \"X%02\"\n        DCB      \"X\\0\\0\\0\"\n|L1.68|\n        DCD      ||.bss$2||\n        ENDP\n```",
        "output": "```cpp\n\nchar* rgbToHex(int r, int g, int b) {\n    static char hex[8];\n    sprintf(hex, \"#%02X%02X%02X\", r, g, b);\n    return hex;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x14\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r4,[r0,#0]\n        STRB     r1,[r0,#4]\n        STR      r1,[r0,#0x10]\n        STR      r1,[r0,#0xc]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrotateLeft__FPP4nodeP4node PROC\n        LDR      r2,[r1,#0xc]\n        LDR      r3,[r2,#8]\n        STR      r3,[r1,#0xc]\n        LDR      r3,[r2,#8]\n        CMP      r3,#0\n        STRNE    r1,[r3,#0x10]\n        LDR      r3,[r1,#0x10]\n        STR      r3,[r2,#0x10]\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.124|\n        LDR      r0,[r3,#8]\n        CMP      r0,r1\n        STRNE    r2,[r3,#0xc]\n        STREQ    r2,[r3,#8]\n|L1.124|\n        STR      r1,[r2,#8]\n        STR      r2,[r1,#0x10]\n        BX       lr\n        ENDP\n\nrotateRight__FPP4nodeP4node PROC\n        LDR      r2,[r1,#8]\n        LDR      r3,[r2,#0xc]\n        STR      r3,[r1,#8]\n        LDR      r3,[r2,#0xc]\n        CMP      r3,#0\n        STRNE    r1,[r3,#0x10]\n        LDR      r3,[r1,#0x10]\n        STR      r3,[r2,#0x10]\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.200|\n        LDR      r0,[r3,#0xc]\n        CMP      r0,r1\n        STRNE    r2,[r3,#8]\n        STREQ    r2,[r3,#0xc]\n|L1.200|\n        STR      r1,[r2,#0xc]\n        STR      r2,[r1,#0x10]\n        BX       lr\n        ENDP\n\ninsertFixup__FPP4nodeP4node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,#0\n        MOV      r6,#1\n        MOV      r5,r0\n        MOV      r4,r1\n        B        |L1.492|\n|L1.236|\n        LDR      r2,[r0,#0x10]\n        LDR      r1,[r2,#8]\n        CMP      r0,r1\n        BNE      |L1.376|\n        LDR      r1,[r2,#0xc]\n        CMP      r1,#0\n        BEQ      |L1.308|\n        LDRB     r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.308|\n        STRB     r6,[r0,#4]\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r4,[r0,#0x10]\n        B        |L1.492|\n|L1.308|\n        LDR      r1,[r0,#0xc]\n        CMP      r1,r4\n        BNE      |L1.336|\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n|L1.336|\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0x10]\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n        B        |L1.492|\n|L1.376|\n        CMP      r1,#0\n        BEQ      |L1.428|\n        LDRB     r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.428|\n        STRB     r6,[r0,#4]\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r4,[r0,#0x10]\n        B        |L1.492|\n|L1.428|\n        LDR      r1,[r0,#8]\n        CMP      r1,r4\n        BNE      |L1.456|\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n|L1.456|\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0x10]\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n|L1.492|\n        LDR      r0,[r5,#0]\n        CMP      r0,r4\n        BEQ      |L1.520|\n        LDR      r0,[r4,#0x10]\n        LDRB     r1,[r0,#4]\n        CMP      r1,#0\n        BEQ      |L1.236|\n|L1.520|\n        LDR      r0,[r5,#0]\n        STRB     r6,[r0,#4]\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\ninsert__FPP4nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        BL       createNode__Fi\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        MOV      r1,#0\n        CMP      r0,#0\n        BEQ      |L1.612|\n        LDR      r2,[r4,#0]\n|L1.584|\n        LDR      r3,[r0,#0]\n        MOV      r1,r0\n        CMP      r2,r3\n        LDRGE    r0,[r0,#0xc]\n        LDRLT    r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.584|\n|L1.612|\n        STR      r1,[r4,#0x10]\n        CMP      r1,#0\n        STREQ    r4,[r5,#0]\n        BEQ      |L1.648|\n        LDR      r0,[r4,#0]\n        LDR      r2,[r1,#0]\n        CMP      r0,r2\n        STRGE    r4,[r1,#0xc]\n        STRLT    r4,[r1,#8]\n|L1.648|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       insertFixup__FPP4nodeP4node\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nminimum__FP4node PROC\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BXEQ     lr\n|L1.684|\n        LDR      r0,[r0,#8]\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BNE      |L1.684|\n        BX       lr\n        ENDP\n\ntransplant__FPP4nodeP4nodeT2 PROC\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.736|\n        LDR      r0,[r3,#8]\n        CMP      r0,r1\n        STRNE    r2,[r3,#0xc]\n        STREQ    r2,[r3,#8]\n|L1.736|\n        CMP      r2,#0\n        LDRNE    r0,[r1,#0x10]\n        STRNE    r0,[r2,#0x10]\n        BX       lr\n        ENDP\n\ndeleteFixup__FPP4nodeP4node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,#0\n        MOV      r6,#1\n        MOV      r5,r0\n        MOV      r4,r1\n        B        |L1.1168|\n|L1.776|\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#8]\n        CMP      r1,r4\n        BNE      |L1.988|\n        LDR      r1,[r0,#0xc]\n        LDRB     r0,[r1,#4]\n        CMP      r0,#0\n        BNE      |L1.840|\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r1,[r4,#0x10]\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0xc]\n|L1.840|\n        LDR      r0,[r1,#8]\n        CMP      r0,#0\n        LDRNEB   r2,[r0,#4]\n        CMPNE    r2,#1\n        BNE      |L1.892|\n        LDR      r0,[r1,#0xc]\n        CMP      r0,#0\n        LDRNEB   r0,[r0,#4]\n        CMPNE    r0,#1\n        STREQB   r7,[r1,#4]\n        LDREQ    r4,[r4,#0x10]\n        BEQ      |L1.1168|\n        B        |L1.936|\n|L1.892|\n        LDR      r2,[r1,#0xc]\n        CMP      r2,#0\n        LDRNEB   r2,[r2,#4]\n        CMPNE    r2,#1\n        BNE      |L1.936|\n        STRB     r6,[r0,#4]\n        STRB     r7,[r1,#4]\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0xc]\n|L1.936|\n        LDR      r0,[r4,#0x10]\n        LDRB     r0,[r0,#4]\n        STRB     r0,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r1,#0xc]\n        CMP      r0,#0\n        STRNEB   r6,[r0,#4]\n        LDR      r1,[r4,#0x10]\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n        LDR      r4,[r5,#0]\n        B        |L1.1168|\n|L1.988|\n        LDRB     r0,[r1,#4]\n        CMP      r0,#0\n        BNE      |L1.1032|\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r1,[r4,#0x10]\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#8]\n|L1.1032|\n        LDR      r0,[r1,#8]\n        CMP      r0,#0\n        LDRNEB   r2,[r0,#4]\n        CMPNE    r2,#1\n        BNE      |L1.1120|\n        LDR      r2,[r1,#0xc]\n        CMP      r2,#0\n        LDRNEB   r3,[r2,#4]\n        CMPNE    r3,#1\n        STREQB   r7,[r1,#4]\n        LDREQ    r4,[r4,#0x10]\n        BEQ      |L1.1168|\n        CMP      r0,#0\n        LDRNEB   r0,[r0,#4]\n        CMPNE    r0,#1\n        BNE      |L1.1120|\n        STRB     r6,[r2,#4]\n        STRB     r7,[r1,#4]\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#8]\n|L1.1120|\n        LDR      r0,[r4,#0x10]\n        LDRB     r0,[r0,#4]\n        STRB     r0,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r1,#8]\n        CMP      r0,#0\n        STRNEB   r6,[r0,#4]\n        LDR      r1,[r4,#0x10]\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n        LDR      r4,[r5,#0]\n|L1.1168|\n        LDR      r0,[r5,#0]\n        CMP      r0,r4\n        BEQ      |L1.1192|\n        LDRB     r0,[r4,#4]\n        CMP      r0,#1\n        BEQ      |L1.776|\n|L1.1192|\n        STRB     r6,[r4,#4]\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nremoveNode__FPP4nodei PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r0\n        LDR      r0,[r0,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n|L1.1232|\n        LDR      r2,[r0,#0]\n        CMP      r2,r1\n        MOVEQ    r4,r0\n        BEQ      |L1.1264|\n        LDRLE    r0,[r0,#0xc]\n        LDRGT    r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.1232|\n|L1.1264|\n        CMP      r4,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDRB     r8,[r4,#4]\n        LDR      r7,[r4,#8]\n        CMP      r7,#0\n        BNE      |L1.1316|\n        LDR      r7,[r4,#0xc]\n        MOV      r1,r4\n        MOV      r0,r6\n        MOV      r2,r7\n        BL       transplant__FPP4nodeP4nodeT2\n        B        |L1.1444|\n|L1.1316|\n        LDR      r0,[r4,#0xc]\n        CMP      r0,#0\n        BNE      |L1.1348|\n        MOV      r2,r7\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       transplant__FPP4nodeP4nodeT2\n        B        |L1.1444|\n|L1.1348|\n        BL       minimum__FP4node\n        MOV      r5,r0\n        LDRB     r8,[r0,#4]\n        LDR      r2,[r0,#0xc]\n        LDR      r0,[r0,#0x10]\n        MOV      r7,r2\n        CMP      r0,r4\n        STREQ    r5,[r7,#0x10]\n        BEQ      |L1.1408|\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       transplant__FPP4nodeP4nodeT2\n        LDR      r0,[r4,#0xc]\n        STR      r0,[r5,#0xc]\n        STR      r5,[r0,#0x10]\n|L1.1408|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       transplant__FPP4nodeP4nodeT2\n        LDR      r0,[r4,#8]\n        STR      r0,[r5,#8]\n        STR      r5,[r0,#0x10]\n        LDRB     r0,[r4,#4]\n        STRB     r0,[r5,#4]\n|L1.1444|\n        CMP      r8,#1\n        MOVEQ    r1,r7\n        MOVEQ    r0,r6\n        BLEQ     deleteFixup__FPP4nodeP4node\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef enum { RED, BLACK } color;\n\ntypedef struct node {\n    int key;\n    color col;\n    struct node *left, *right, *parent;\n} node;\n\nnode* createNode(int key) {\n    node* newNode = (node*)malloc(sizeof(node));\n    if (!newNode) return 0;\n    newNode->key = key;\n    newNode->col = RED;\n    newNode->left = newNode->right = newNode->parent = 0;\n    return newNode;\n}\n\nvoid rotateLeft(node** root, node* x) {\n    node* y = x->right;\n    x->right = y->left;\n    if (y->left != 0) y->left->parent = x;\n    y->parent = x->parent;\n    if (x->parent == 0) *root = y;\n    else if (x == x->parent->left) x->parent->left = y;\n    else x->parent->right = y;\n    y->left = x;\n    x->parent = y;\n}\n\nvoid rotateRight(node** root, node* x) {\n    node* y = x->left;\n    x->left = y->right;\n    if (y->right != 0) y->right->parent = x;\n    y->parent = x->parent;\n    if (x->parent == 0) *root = y;\n    else if (x == x->parent->right) x->parent->right = y;\n    else x->parent->left = y;\n    y->right = x;\n    x->parent = y;\n}\n\nvoid insertFixup(node** root, node* z) {\n    while (z != *root && z->parent->col == RED) {\n        if (z->parent == z->parent->parent->left) {\n            node* y = z->parent->parent->right;\n            if (y && y->col == RED) {\n                z->parent->col = BLACK;\n                y->col = BLACK;\n                z->parent->parent->col = RED;\n                z = z->parent->parent;\n            } else {\n                if (z == z->parent->right) {\n                    z = z->parent;\n                    rotateLeft(root, z);\n                }\n                z->parent->col = BLACK;\n                z->parent->parent->col = RED;\n                rotateRight(root, z->parent->parent);\n            }\n        } else {\n            node* y = z->parent->parent->left;\n            if (y && y->col == RED) {\n                z->parent->col = BLACK;\n                y->col = BLACK;\n                z->parent->parent->col = RED;\n                z = z->parent->parent;\n            } else {\n                if (z == z->parent->left) {\n                    z = z->parent;\n                    rotateRight(root, z);\n                }\n                z->parent->col = BLACK;\n                z->parent->parent->col = RED;\n                rotateLeft(root, z->parent->parent);\n            }\n        }\n    }\n    (*root)->col = BLACK;\n}\n\n\nnode* insert(node** root, int key) {\n    node* z = createNode(key);\n    if (!z) return 0;\n    node* y = 0;\n    node* x = *root;\n    while (x != 0) {\n        y = x;\n        if (z->key < x->key) x = x->left;\n        else x = x->right;\n    }\n    z->parent = y;\n    if (y == 0) *root = z;\n    else if (z->key < y->key) y->left = z;\n    else y->right = z;\n    insertFixup(root, z);\n    return z;\n}\n\nnode* minimum(node* node) {\n    while (node->left != 0)\n        node = node->left;\n    return node;\n}\n\nvoid transplant(node** root, node* u, node* v) {\n    if (u->parent == 0) *root = v;\n    else if (u == u->parent->left) u->parent->left = v;\n    else u->parent->right = v;\n    if (v != 0) v->parent = u->parent;\n}\n\nvoid deleteFixup(node** root, node* x) {\n    while (x != *root && x->col == BLACK) {\n        if (x == x->parent->left) {\n            node* w = x->parent->right;\n            if (w->col == RED) {\n                w->col = BLACK;\n                x->parent->col = RED;\n                rotateLeft(root, x->parent);\n                w = x->parent->right;\n            }\n            if ((w->left == 0 || w->left->col == BLACK) && (w->right == 0 || w->right->col == BLACK)) {\n                w->col = RED;\n                x = x->parent;\n            } else {\n                if (w->right == 0 || w->right->col == BLACK) {\n                    w->left->col = BLACK;\n                    w->col = RED;\n                    rotateRight(root, w);\n                    w = x->parent->right;\n                }\n                w->col = x->parent->col;\n                x->parent->col = BLACK;\n                if (w->right) w->right->col = BLACK;\n                rotateLeft(root, x->parent);\n                x = *root;\n            }\n        } else {\n            node* w = x->parent->left;\n            if (w->col == RED) {\n                w->col = BLACK;\n                x->parent->col = RED;\n                rotateRight(root, x->parent);\n                w = x->parent->left;\n            }\n            if ((w->left == 0 || w->left->col == BLACK) && (w->right == 0 || w->right->col == BLACK)) {\n                w->col = RED;\n                x = x->parent;\n            } else {\n                if (w->left == 0 || w->left->col == BLACK) {\n                    w->right->col = BLACK;\n                    w->col = RED;\n                    rotateLeft(root, w);\n                    w = x->parent->left;\n                }\n                w->col = x->parent->col;\n                x->parent->col = BLACK;\n                if (w->left) w->left->col = BLACK;\n                rotateRight(root, x->parent);\n                x = *root;\n            }\n        }\n    }\n    x->col = BLACK;\n}\n\nvoid removeNode(node** root, int key) {\n    node* z = 0;\n    node* x = 0;\n    node* y = 0;\n    for (node* curr = *root; curr;){\n        if (curr->key == key){\n            z = curr;\n            break;\n        } else if (curr->key > key) curr = curr->left;\n        else curr = curr->right;\n    }\n\n    if (!z) return;\n\n    y = z;\n    color y_original_color = y->col;\n    if (z->left == 0) {\n        x = z->right;\n        transplant(root, z, z->right);\n    } else if (z->right == 0) {\n        x = z->left;\n        transplant(root, z, z->left);\n    } else {\n        y = minimum(z->right);\n        y_original_color = y->col;\n        x = y->right;\n        if (y->parent == z) {\n            x->parent = y;\n        } else {\n            transplant(root, y, y->right);\n            y->right = z->right;\n            y->right->parent = y;\n        }\n        transplant(root, z, y);\n        y->left = z->left;\n        y->left->parent = y;\n        y->col = z->col;\n\n    }\n    if (y_original_color == BLACK) deleteFixup(root, x);\n    free(z);\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncelsiusToFahrenheit__Fd PROC\n        STMFD    sp!,{r3,lr}\n        ADR      r2,|L1.48|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.56|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        ADR      r2,|L1.64|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDR      lr,[sp],#4\n        B        _dadd\n|L1.48|\n        DCFD     0x4022000000000000\n|L1.56|\n        DCFD     0x4014000000000000\n|L1.64|\n        DCFD     0x4040000000000000\n        ENDP\n\nfahrenheitToCelsius__Fd PROC\n        STMFD    sp!,{r3,lr}\n        ADR      r2,|L1.64|\n        LDMIA    r2,{r2,r3}\n        BL       _dsub\n        ADR      r2,|L1.56|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.48|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDR      lr,[sp],#4\n        B        _ddiv\n        ENDP\n```",
        "output": "```cpp\n\ndouble celsiusToFahrenheit(double celsius) {\n    return (celsius * 9.0 / 5.0) + 32.0;\n}\n\ndouble fahrenheitToCelsius(double fahrenheit) {\n    return (fahrenheit - 32.0) * 5.0 / 9.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhandle_one__Fi PROC\n|L1.0|\n        CMP      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nhandle_two__Fi PROC\n        CMP      r0,#2\n        MOVNE    r0,#0\n        MOVEQ    r0,#2\n        BX       lr\n        ENDP\n\nhandle_three__Fi PROC\n        CMP      r0,#3\n        MOVNE    r0,#0\n        MOVEQ    r0,#3\n        BX       lr\n        ENDP\n\nprocess__FP7Handleri PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BXEQ     lr\n|L1.72|\n        LDR      r1,[r4,#0]\n        MOV      r0,r5\n        MOV      lr,pc\n        BX       r1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r5,lr}\n        BXNE     lr\n        LDR      r4,[r4,#4]\n        CMP      r4,#0\n        BNE      |L1.72|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Handler {\n    int (*handle)(int);\n    struct Handler *next;\n} Handler;\n\nint handle_one(int num) {\n    if (num == 1) return 1;\n    return 0;\n}\n\nint handle_two(int num) {\n    if (num == 2) return 2;\n    return 0;\n}\n\nint handle_three(int num) {\n    if (num == 3) return 3;\n    return 0;\n}\n\n\nint process(Handler *handler, int num) {\n    int result = 0;\n    while (handler != 0) {\n        result = handler->handle(num);\n        if (result) break;\n        handler = handler->next;\n    }\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nradixSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r6,r0\n        MOV      r0,r1,LSL #2\n        SUB      sp,sp,#0x2c\n        MOV      r7,r1\n        BL       malloc\n        MOV      r9,r0\n        MOV      r0,#0\n        MOV      r11,sp\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r4,#0\n        MOV      r5,#0\n        MOV      r8,#0\n        MOV      r10,#0\n        MOV      r12,#0\n        MOV      lr,#0\n        STMIA    r11,{r0-r5,r8,r10,r12,lr}\n        SUB      r4,r7,#1\n        STR      r4,[sp,#0x28]\n        MOV      r10,#0\n        MOV      r5,#1\n|L1.92|\n        MOV      r4,#0\n        CMP      r7,#0\n        BLE      |L1.172|\n        LDR      r8,|L1.516|\n|L1.108|\n        LDR      r1,[r6,r4,LSL #2]\n        MOV      r0,r5\n        BL       __rt_sdiv\n        SMULL    r2,r1,r8,r0\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        ADD      r0,r11,r0,LSL #2\n        LDR      r1,[r0,#0]\n        ADD      r4,r4,#1\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        CMP      r4,r7\n        BLT      |L1.108|\n|L1.172|\n        MOV      r0,#1\n|L1.176|\n        ADD      r2,r11,r0,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r1,[r11,r0,LSL #2]\n        ADD      r1,r1,r2\n        STR      r1,[r11,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,#0xa\n        BLT      |L1.176|\n        LDR      r4,[sp,#0x28]\n        CMP      r4,#0\n        BLT      |L1.340|\n|L1.220|\n        LDR      r8,[r6,r4,LSL #2]\n        MOV      r0,r5\n        MOV      r1,r8\n        BL       __rt_sdiv\n        LDR      r3,|L1.516|\n        SMULL    r2,r1,r3,r0\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        LDR      r0,[r11,r0,LSL #2]\n        ADD      r0,r9,r0,LSL #2\n        STR      r8,[r0,#-4]\n        LDR      r1,[r6,r4,LSL #2]\n        MOV      r0,r5\n        BL       __rt_sdiv\n        LDR      r3,|L1.516|\n        SUBS     r4,r4,#1\n        SMULL    r2,r1,r3,r0\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        ADD      r0,r11,r0,LSL #2\n        LDR      r1,[r0,#0]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#0]\n        BPL      |L1.220|\n|L1.340|\n        MOV      r0,#0\n        CMP      r7,#0\n        BLE      |L1.372|\n|L1.352|\n        LDR      r1,[r9,r0,LSL #2]\n        STR      r1,[r6,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r7\n        BLT      |L1.352|\n|L1.372|\n        MOV      r0,#0\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r4,#0\n        MOV      r8,#0\n        MOV      r12,#0\n        MOV      lr,#0\n        STMIA    r11!,{r0-r4,r8,r12,lr}\n        STMIA    r11,{r0,r1}\n        ADD      r5,r5,r5,LSL #2\n        ADD      r10,r10,#1\n        CMP      r10,#0xa\n        MOV      r5,r5,LSL #1\n        SUB      r11,r11,#0x20\n        BLT      |L1.92|\n        MOV      r0,r9\n        BL       free\n        ADD      sp,sp,#0x2c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_EXP 10\n\nvoid radixSort(int arr[], int n) {\n    int *output = (int *)malloc(n * sizeof(int));\n    int count[10] = {0};\n    int exp = 1;\n\n    for (int i = 0; i < MAX_EXP; i++) {\n        for (int j = 0; j < n; j++) {\n            count[(arr[j] / exp) % 10]++;\n        }\n        for (int j = 1; j < 10; j++) {\n            count[j] += count[j - 1];\n        }\n        for (int j = n - 1; j >= 0; j--) {\n            output[count[(arr[j] / exp) % 10] - 1] = arr[j];\n            count[(arr[j] / exp) % 10]--;\n        }\n        for (int j = 0; j < n; j++) {\n            arr[j] = output[j];\n        }\n        memset(count, 0, sizeof(count));\n        exp *= 10;\n    }\n    free(output);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        CMP      r0,#0\n        MOVNE    r1,#0\n        STRNE    r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#0]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#0]\n        LDR      r2,[r0,#4]\n        LDR      r4,[r0,#0]\n        STR      r2,[r1,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    if (stack == NULL) return NULL;\n    stack->top = NULL;\n    return stack;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == NULL;\n}\n\nvoid push(Stack* stack, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) return;\n    newNode->data = data;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nint pop(Stack* stack) {\n    if (isEmpty(stack)) return -1; \n    Node* temp = stack->top;\n    int data = temp->data;\n    stack->top = stack->top->next;\n    free(temp);\n    return data;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fci PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        MOV      r5,r1\n        BL       malloc\n        STRB     r4,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#0xc]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nminHeapify__FPP4nodeiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        MOV      r0,#1\n        ADD      r0,r0,r1,LSL #1\n        MOV      r3,#2\n        ADD      r3,r3,r1,LSL #1\n        CMP      r0,r2\n        LDR      r12,[r4,r1,LSL #2]\n        MOV      r5,r1\n        BGE      |L1.108|\n        LDR      lr,[r4,r0,LSL #2]\n        LDR      lr,[lr,#0]\n        LDR      r6,[r12,#0]\n        CMP      lr,r6\n        MOVLT    r1,r0\n|L1.108|\n        CMP      r3,r2\n        BGE      |L1.140|\n        LDR      r0,[r4,r3,LSL #2]\n        LDR      lr,[r4,r1,LSL #2]\n        LDR      r0,[r0,#0]\n        LDR      lr,[lr,#0]\n        CMP      r0,lr\n        MOVLT    r1,r3\n|L1.140|\n        CMP      r1,r5\n        BEQ      |L1.168|\n        LDR      r0,[r4,r1,LSL #2]\n        STR      r12,[r4,r1,LSL #2]\n        STR      r0,[r4,r5,LSL #2]\n        MOV      r0,r4\n        BL       minHeapify__FPP4nodeiT2\n|L1.168|\n        LDR      r0,[r4,r5,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nbuildHuffmanTree__FPcPii PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r0,r2,LSL #2\n        MOV      r8,r1\n        MOV      r6,r2\n        BL       malloc\n        MOV      r4,r0\n        MOV      r5,#0\n        CMP      r6,#0\n        BLE      |L1.248|\n|L1.220|\n        LDR      r1,[r8,r5,LSL #2]\n        LDRB     r0,[r7,r5]\n        BL       newNode__Fci\n        STR      r0,[r4,r5,LSL #2]\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.220|\n|L1.248|\n        SUB      r0,r6,#1\n        ADD      r0,r0,r0,LSR #31\n        MOVS     r5,r0,ASR #1\n        BMI      |L1.288|\n|L1.264|\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       minHeapify__FPP4nodeiT2\n        SUBS     r5,r5,#1\n        BPL      |L1.264|\n|L1.288|\n        CMP      r6,#1\n        BLE      |L1.396|\n|L1.296|\n        MOV      r2,r6\n        MOV      r1,#0\n        LDR      r5,[r4,#0]\n        MOV      r0,r4\n        BL       minHeapify__FPP4nodeiT2\n        SUB      r2,r6,#1\n        MOV      r6,r2\n        MOV      r1,#0\n        LDR      r7,[r4,#0]\n        MOV      r0,r4\n        BL       minHeapify__FPP4nodeiT2\n        LDR      r0,[r5,#0]\n        LDR      r1,[r7,#0]\n        ADD      r1,r0,r1\n        MOV      r0,#0x24\n        BL       newNode__Fci\n        ADD      r1,r0,#8\n        STMIA    r1,{r5,r7}\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        MOV      r1,#0\n        MOV      r2,r6\n        BL       minHeapify__FPP4nodeiT2\n        CMP      r6,#1\n        BGT      |L1.296|\n|L1.396|\n        LDR      r0,[r4,#0]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int freq;\n    char ch;\n    struct node *left, *right;\n};\n\nstruct node* newNode(char ch, int freq) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->ch = ch;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct node* minHeapify(struct node** harr, int i, int heapSize) {\n    int smallest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < heapSize && harr[l]->freq < harr[smallest]->freq)\n        smallest = l;\n\n    if (r < heapSize && harr[r]->freq < harr[smallest]->freq)\n        smallest = r;\n\n    if (smallest != i) {\n        struct node* temp = harr[smallest];\n        harr[smallest] = harr[i];\n        harr[i] = temp;\n        minHeapify(harr, smallest, heapSize);\n    }\n    return harr[i];\n}\n\nstruct node* buildHuffmanTree(char data[], int freq[], int size) {\n    struct node** harr = (struct node**)malloc(size * sizeof(struct node*));\n    for (int i = 0; i < size; i++)\n        harr[i] = newNode(data[i], freq[i]);\n\n    int heapSize = size;\n    for (int i = (heapSize - 1) / 2; i >= 0; --i)\n        minHeapify(harr, i, heapSize);\n\n    while (heapSize > 1) {\n        struct node* left = harr[0];\n        minHeapify(harr, 0, heapSize);\n        struct node* right = harr[0];\n        minHeapify(harr, 0, heapSize - 1);\n\n        struct node* top = newNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n\n        harr[0] = top;\n        minHeapify(harr, 0, heapSize - 1);\n        heapSize--;\n    }\n    return harr[0];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nareIdentical__FP4NodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#4]\n        BL       areIdentical__FP4NodeT1\n        CMP      r0,#0\n        BEQ      |L1.160|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#8]\n        BL       areIdentical__FP4NodeT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.160|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint areIdentical(struct Node* root1, struct Node* root2) {\n    if (root1 == NULL && root2 == NULL)\n        return 1;\n    if (root1 == NULL || root2 == NULL)\n        return 0;\n    if (root1->data != root2->data)\n        return 0;\n    return areIdentical(root1->left, root2->left) &&\n           areIdentical(root1->right, root2->right);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsearch__FP4Nodei PROC\n|L1.0|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#8]\n        LDRGT    r0,[r0,#4]\n        B        |L1.0|\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int val) : data(val), left(NULL), right(NULL) {}\n};\n\n\nNode* search(Node* root, int key) {\n    if (root == NULL || root->data == key)\n        return root;\n\n    if (key < root->data)\n        return search(root->left, key);\n\n    return search(root->right, key);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__FxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r8,|L1.232|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        ADR      r10,|L1.224|\n        MOV      r7,r1\n        LDMEQIA  r10,{r0,r1}\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOVEQ    r0,r6\n        MOVEQ    r1,r7\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        LDMIA    r8,{r2,r3}\n        SUBS     r0,r4,r2\n        SBCS     r1,r5,r3\n        LDMLTIA  r8,{r0,r1}\n        LDMLTFD  sp!,{r4-r10,lr}\n        BXLT     lr\n        MOV      r1,r5\n        ADR      r0,|L1.240|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        BL       _ll_sdiv\n        MOV      r9,r3\n        MOV      r8,r2\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       power__FxT1\n        UMULL    r4,r12,r0,r0\n        MLA      r12,r0,r1,r12\n        LDMIA    r10,{r2,r3}\n        MLA      r5,r1,r0,r12\n        MOV      r0,r8\n        CMP      r9,r3\n        CMPEQ    r0,r2\n        BNE      |L1.208|\n        UMULL    r0,r12,r4,r6\n        MLA      r12,r6,r5,r12\n        MLA      r5,r7,r4,r12\n        MOV      r4,r0\n|L1.208|\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.224|\n        DCQ      0x0000000000000001\n|L1.232|\n        DCQ      0x0000000000000000\n|L1.240|\n        DCQ      0x0000000000000002\n        ENDP\n```",
        "output": "```cpp\n\nlong long power(long long base, long long exp) {\n    if (exp == 0) return 1;\n    if (exp == 1) return base;\n    if (exp < 0) return 0; // Handle negative exponents (returning 0 for simplicity)\n\n    long long halfPower = power(base, exp / 2);\n    long long result = halfPower * halfPower;\n    if (exp % 2 == 1) result *= base;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP12SparseMatrixiN22 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0xc]\n        STMIA    r0,{r5-r7}\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        LDR      r2,[r1,#0xc]\n        CMP      r2,#0\n        BEQ      |L1.116|\n|L1.100|\n        LDR      r1,[r1,#0xc]\n        LDR      r2,[r1,#0xc]\n        CMP      r2,#0\n        BNE      |L1.100|\n|L1.116|\n        STR      r0,[r1,#0xc]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int row;\n    int col;\n    int val;\n    Node *next;\n};\n\nstruct SparseMatrix {\n    Node *head;\n};\n\nSparseMatrix* createMatrix() {\n    SparseMatrix *matrix = (SparseMatrix*)malloc(sizeof(SparseMatrix));\n    matrix->head = NULL;\n    return matrix;\n}\n\n\nvoid insert(SparseMatrix *matrix, int row, int col, int val) {\n    Node *newNode = (Node*)malloc(sizeof(Node));\n    newNode->row = row;\n    newNode->col = col;\n    newNode->val = val;\n    newNode->next = NULL;\n\n    if (matrix->head == NULL) {\n        matrix->head = newNode;\n        return;\n    }\n\n    Node *current = matrix->head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    current->next = newNode;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npreorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        STR      r0,[sp,#0]\n        MOV      r4,#0\n|L1.68|\n        MOV      r0,r4\n        LDR      r5,[r6,r0,LSL #2]\n        ADR      r0,|L1.144|\n        SUB      r4,r4,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r0,[r5,#8]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        LDR      r0,[r5,#4]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        CMP      r4,#0\n        BGE      |L1.68|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.144|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nvoid preorderIterative(struct Node* root) {\n    if (root == NULL)\n        return;\n\n    struct Node* stack[1000];\n    int top = -1;\n\n    stack[++top] = root;\n\n    while (top >= 0) {\n        struct Node* node = stack[top--];\n        printf(\"%d \", node->data);\n\n        if (node->right != NULL)\n            stack[++top] = node->right;\n        if (node->left != NULL)\n            stack[++top] = node->left;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x14\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        MVN      r1,#0\n        STMIB    r4,{r0,r1,r5}\n        STR      r0,[r4,#0x10]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#0x10]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        ADD      r1,r0,#0xc\n        LDMIA    r1,{r0,r1}\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#8]\n        LDR      r0,[r4,#0]\n        STR      r5,[r0,r1,LSL #2]\n        LDR      r0,[r4,#0x10]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0x10]\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5QueuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDMIA    r4,{r0,r2}\n        LDR      r0,[r0,r2,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#4]\n        LDR      r0,[r4,#0x10]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#0x10]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndeleteQueue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* buffer;\n    int head;\n    int tail;\n    int capacity;\n    int size;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    if (q == NULL) return NULL;\n    q->buffer = (int*)malloc(sizeof(int) * capacity);\n    if (q->buffer == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->head = 0;\n    q->tail = -1;\n    q->capacity = capacity;\n    q->size = 0;\n    return q;\n}\n\nint isEmpty(Queue* q) {\n    return q->size == 0;\n}\n\nint isFull(Queue* q) {\n    return q->size == q->capacity;\n}\n\nint enqueue(Queue* q, int value) {\n    if (isFull(q)) return 0;\n    q->tail = (q->tail + 1) % q->capacity;\n    q->buffer[q->tail] = value;\n    q->size++;\n    return 1;\n}\n\nint dequeue(Queue* q, int* value) {\n    if (isEmpty(q)) return 0;\n    *value = q->buffer[q->head];\n    q->head = (q->head + 1) % q->capacity;\n    q->size--;\n    return 1;\n}\n\nvoid deleteQueue(Queue* q) {\n    free(q->buffer);\n    free(q);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightViewUtil__FP4NodeiPiT3 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r3\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        MOV      r3,r6\n        CMP      r0,r1\n        LDRLT    r0,[r4,#0]\n        MOV      r2,r5\n        STRLT    r0,[r6,r1,LSL #2]\n        STRLT    r1,[r5,#0]\n        ADD      r1,r1,#1\n        MOV      r7,r1\n        LDR      r0,[r4,#8]\n        BL       rightViewUtil__FP4NodeiPiT3\n        MOV      r3,r6\n        MOV      r2,r5\n        MOV      r1,r7\n        LDR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r7,lr}\n        B        rightViewUtil__FP4NodeiPiT3\n        ENDP\n\nrightView__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        MOV      r1,#0\n        STR      r1,[sp,#0xfa0]\n        MOV      r5,sp\n        MOV      r3,sp\n        ADD      r2,sp,#0xfa0\n        BL       rightViewUtil__FP4NodeiPiT3\n        LDR      r0,[sp,#0xfa0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLT      |L1.220|\n|L1.192|\n        LDR      r1,[r5,r4,LSL #2]\n        ADR      r0,|L1.244|\n        BL       _printf\n        LDR      r0,[sp,#0xfa0]\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLE      |L1.192|\n|L1.220|\n        ADR      r0,|L1.248|\n        BL       _printf\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.244|\n        DCB      \"%d \\0\"\n|L1.248|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid rightViewUtil(struct Node *root, int level, int *max_level, int *arr) {\n    if (root == NULL) return;\n\n    if (*max_level < level) {\n        arr[level] = root->data;\n        *max_level = level;\n    }\n    rightViewUtil(root->right, level + 1, max_level, arr);\n    rightViewUtil(root->left, level + 1, max_level, arr);\n}\n\nvoid rightView(struct Node *root) {\n    if (root == NULL) return;\n    int max_level = 0;\n    int arr[1000];\n    rightViewUtil(root, 0, &max_level, arr);\n    for (int i = 0; i <= max_level; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindNthOccurrence__FPCcci PROC\n|L1.0|\n        CMP      r0,#0\n        CMPNE    r2,#0\n        MVNLE    r0,#0\n        BXLE     lr\n        STR      lr,[sp,#-4]!\n        LDRB     lr,[r0,#0]\n        MOV      r12,#0\n        MOV      r3,#0\n        CMP      lr,#0\n        BEQ      |L1.84|\n|L1.40|\n        LDRB     lr,[r0,r3]\n        CMP      lr,r1\n        ADDEQ    r12,r12,#1\n        CMPEQ    r12,r2\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,r3\n        BXEQ     lr\n        ADD      r3,r3,#1\n        LDRB     lr,[r0,r3]\n        CMP      lr,#0\n        BNE      |L1.40|\n|L1.84|\n        LDR      lr,[sp],#4\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findNthOccurrence(const char* str, char ch, int n) {\n    if (str == 0 || n <= 0) return -1;\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (str[i] == ch) {\n            count++;\n            if (count == n) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisBipartiteUtil__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r8,|L1.312|\n        ADD      r2,r0,r0,LSL #3\n        ADD      r2,r2,r0,LSL #4\n        MOV      r5,r0\n        STR      r1,[r8,r0,LSL #2]\n        LDR      r0,|L1.316|\n        RSB      r7,r1,#1\n        MOV      r4,#0\n        ADD      r6,r0,r2,LSL #4\n|L1.40|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.112|\n        LDR      r0,[r8,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.92|\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       isBipartiteUtil__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        B        |L1.112|\n|L1.92|\n        LDR      r1,[r8,r5,LSL #2]\n        CMP      r0,r1\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n|L1.112|\n        ADD      r4,r4,#1\n        CMP      r4,#0x64\n        BLT      |L1.40|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nisBipartite__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r6,|L1.312|\n        MOV      r5,r0\n        MOV      r0,r6\n        MOV      r2,#0x190\n        MVN      r1,#0\n        BL       __rt_memset\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.224|\n|L1.176|\n        LDR      r0,[r6,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.212|\n        MOV      r1,#0\n        MOV      r0,r4\n        BL       isBipartiteUtil__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n|L1.212|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.176|\n|L1.224|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint graph[MAX_VERTICES][MAX_VERTICES];\nint color[MAX_VERTICES];\n\nint isBipartiteUtil(int v, int c) {\n    color[v] = c;\n    for (int i = 0; i < MAX_VERTICES; i++) {\n        if (graph[v][i]) {\n            if (color[i] == -1) {\n                if (!isBipartiteUtil(i, 1 - c))\n                    return 0;\n            } else if (color[i] == color[v]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint isBipartite(int V) {\n    memset(color, -1, sizeof(color));\n    for (int i = 0; i < V; i++) {\n        if (color[i] == -1) {\n            if (!isBipartiteUtil(i, 0))\n                return 0;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidURL__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOVS     r4,r0\n        BEQ      |L1.28|\n        MOV      r0,r4\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.40|\n|L1.28|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.40|\n        MOV      r0,r4\n        BL       strlen\n        MOV      r6,r0\n        CMP      r0,#4\n        LDMLTFD  sp!,{r4-r8,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r7,#0\n        MOV      r5,#0\n        BL       __rt_ctype_table\n        MOV      r8,r0\n|L1.84|\n        LDRB     r1,[r4,r5]\n        CMP      r1,#0x3a\n        BNE      |L1.184|\n        MOV      r2,#4\n        ADR      r1,|L1.356|\n        MOV      r0,r4\n        BL       strncmp\n        CMP      r0,#0\n        BEQ      |L1.176|\n        MOV      r2,#5\n        ADR      r1,|L1.364|\n        MOV      r0,r4\n        BL       strncmp\n        CMP      r0,#0\n        BEQ      |L1.176|\n        MOV      r2,#3\n        ADR      r1,|L1.372|\n        MOV      r0,r4\n        BL       strncmp\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.176|\n        MOV      r7,r5\n        B        |L1.228|\n|L1.184|\n        LDR      r0,[r8,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BNE      |L1.216|\n        CMP      r1,#0x2e\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.216|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.84|\n|L1.228|\n        MOVS     r0,r7\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        SUB      r0,r6,#1\n        CMP      r7,r0\n        LDMGEFD  sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BXGE     lr\n        ADD      r1,r7,#3\n        CMP      r1,r6\n        BGE      |L1.344|\n        LDR      r3,[r8,#0]\n|L1.276|\n        LDRB     r2,[r4,r1]\n        LDRB     r12,[r3,r2]\n        CMP      r2,#0x2e\n        ADDEQ    r0,r0,#1\n        TST      r12,#0x38\n        BNE      |L1.316|\n        CMP      r2,#0x2e\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.316|\n        ADD      r1,r1,#1\n        CMP      r1,r6\n        BLT      |L1.276|\n        CMP      r0,#0\n        LDMGTFD  sp!,{r4-r8,lr}\n        MOVGT    r0,#1\n        BXGT     lr\n|L1.344|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.356|\n        DCB      \"http\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.364|\n        DCB      \"http\"\n        DCB      \"s\\0\\0\\0\"\n|L1.372|\n        DCB      \"ftp\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint isValidURL(char* url) {\n    if (url == NULL || strlen(url) == 0) return 0;\n\n    int len = strlen(url);\n    if (len < 4) return 0;\n\n    int protocolEnd = 0;\n    for (int i = 0; i < len; ++i) {\n        if (url[i] == ':') {\n            if (strncmp(url, \"http\", 4) == 0 || strncmp(url, \"https\", 5) == 0 || strncmp(url, \"ftp\", 3) ==0)\n            {\n                protocolEnd = i;\n                break;\n            } else {\n                return 0;\n            }\n        }\n        if (!isalnum(url[i]) && url[i] != '.') return 0;\n    }\n    if(protocolEnd == 0) return 0;\n    if (protocolEnd >= len -1) return 0;\n\n\n    int dotCount = 0;\n    for (int i = protocolEnd + 3; i < len; ++i) {\n        if (url[i] == '.') dotCount++;\n        if (!isalnum(url[i]) && url[i] != '.') return 0;\n    }\n\n    return dotCount > 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nencode__FPcT1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r9,r1\n        MOV      r5,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        BL       __rt_ctype_table\n        MOV      r8,r0\n|L1.44|\n        LDRB     r1,[r5,r4]\n        LDR      r0,[r8,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x18\n        BEQ      |L1.104|\n        TST      r0,#0x10\n        MOVEQ    r7,#0x61\n        MOVNE    r7,#0x41\n        MOV      r0,r1\n        BL       tolower\n        SUB      r0,r0,#0x61\n        LDRB     r0,[r9,r0]\n        ADD      r0,r0,r7\n        SUB      r0,r0,#0x61\n        STRB     r0,[r5,r4]\n|L1.104|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.44|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n\ndecode__FPcT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        BL       strlen\n        MOV      r7,r0\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        BL       __rt_ctype_table\n|L1.164|\n        LDRB     r1,[r5,r4]\n        LDR      r2,[r0,#0]\n        LDRB     r2,[r2,r1]\n        TST      r2,#0x18\n        BEQ      |L1.236|\n        TST      r2,#0x10\n        MOVEQ    r2,#0x61\n        MOVNE    r2,#0x41\n        SUB      r3,r1,r2\n        MOV      r1,#0\n|L1.204|\n        LDRB     r12,[r6,r1]\n        SUB      r12,r12,#0x61\n        CMP      r12,r3\n        ADDNE    r1,r1,#1\n        CMPNE    r1,#0x1a\n        BLT      |L1.204|\n        ADD      r1,r2,r1\n        STRB     r1,[r5,r4]\n|L1.236|\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.164|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define ALPHABET_SIZE 26\n\nvoid encode(char* message, char* key) {\n    int len = strlen(message);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(message[i])) {\n            char base = isupper(message[i]) ? 'A' : 'a';\n            int index = tolower(message[i]) - 'a';\n            message[i] = base + (key[index] - 'a');\n\n        }\n    }\n}\n\nvoid decode(char* message, char* key) {\n    int len = strlen(message);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(message[i])) {\n            char base = isupper(message[i]) ? 'A' : 'a';\n            int index = message[i] - base;\n            \n            int kIndex = 0;\n            for (kIndex = 0; kIndex < ALPHABET_SIZE; kIndex++){\n                if (key[kIndex] - 'a' == index){\n                    break;\n                }\n            }\n            message[i] = base + kIndex;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r1\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,r0\n        MOV      r0,r4\n        BL       __rt_sdiv\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        gcd__FiT1\n        ENDP\n```",
        "output": "```cpp\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbitwiseShiftAndRotate__FUiiT2 PROC\n        MOV      r0,r0,LSR r1\n        RSB      r1,r2,#0x20\n        MOV      r0,r0,ROR r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int bitwiseShiftAndRotate(unsigned int value, int shift, int rotate) {\n    unsigned int shifted = value >> shift;\n    unsigned int rotated = (shifted >> (sizeof(unsigned int) * 8 - rotate)) | (shifted << rotate);\n    return rotated;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndepthFirstSearch__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.48|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       depthFirstSearch__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        depthFirstSearch__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nvoid depthFirstSearch(Node* node) {\n    if (node == NULL) return;\n    printf(\"%d \", node->data);\n    depthFirstSearch(node->left);\n    depthFirstSearch(node->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__FUi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MVN      r0,#0\n        STR      r0,[r4,#8]\n        STR      r5,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisFull__FP5Stack PROC\n        LDR      r1,[r0,#4]\n        LDR      r0,[r0,#8]\n        SUB      r1,r1,#1\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#8]\n        CMN      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\npush__FP5StackUi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r4,r0\n        BL       isFull__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.200|\n        LDR      r0,[r4,#4]\n        MOV      r5,r0,LSL #1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STMIA    r4,{r0,r5}\n|L1.200|\n        LDR      r0,[r4,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDR      r1,[r4,#0]\n        STR      r6,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#8]\n        SUB      r2,r0,#1\n        STR      r2,[r1,#8]\n        LDR      r1,[r1,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ndeleteStack__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned int uint;\n\nstruct Stack {\n    uint* data;\n    uint capacity;\n    uint top;\n};\n\nstruct Stack* createStack(uint capacity) {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    if (!stack) return 0;\n    stack->data = (uint*)malloc(capacity * sizeof(uint));\n    if (!stack->data) {\n        free(stack);\n        return 0;\n    }\n    stack->capacity = capacity;\n    stack->top = -1;\n    return stack;\n}\n\nint isFull(struct Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n\nvoid push(struct Stack* stack, uint item) {\n    if (isFull(stack)) {\n        uint newCapacity = stack->capacity * 2;\n        uint* newData = (uint*)realloc(stack->data, newCapacity * sizeof(uint));\n        if (!newData) return;\n        stack->data = newData;\n        stack->capacity = newCapacity;\n    }\n    stack->data[++stack->top] = item;\n}\n\nuint pop(struct Stack* stack) {\n    if (isEmpty(stack)) return 0; \n    return stack->data[stack->top--];\n}\n\nvoid deleteStack(struct Stack* stack) {\n    free(stack->data);\n    free(stack);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisEven__Fi PROC\n        AND      r0,r0,#1\n        RSB      r0,r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\nint isEven(int num) {\n    return num % 2 == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlongest_increasing_subsequence__FPii PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        MOV      r5,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r6,r7,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r4,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r6,#1\n        MOV      r0,#1\n        CMP      r7,#1\n        BLE      |L1.156|\n|L1.72|\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.132|\n|L1.84|\n        LDR      r2,[r5,r0,LSL #2]\n        LDR      r3,[r5,r1,LSL #2]\n        CMP      r2,r3\n        BLE      |L1.120|\n        LDR      r3,[r4,r0,LSL #2]\n        LDR      r2,[r4,r1,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        STRLT    r2,[r4,r0,LSL #2]\n|L1.120|\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.84|\n|L1.132|\n        LDR      r1,[r4,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r1,r6\n        MOVGT    r6,r1\n        CMP      r0,r7\n        BLT      |L1.72|\n|L1.156|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint longest_increasing_subsequence(int arr[], int n) {\n    if (n <= 0) return 0;\n    int *dp = (int *)malloc(n * sizeof(int));\n    memset(dp, 1, n * sizeof(int));\n    int max_len = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1;\n            }\n        }\n        if (dp[i] > max_len) {\n            max_len = dp[i];\n        }\n    }\n    free(dp);\n    return max_len;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FUxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        BEQ      |L1.108|\n|L1.44|\n        MOV      r8,r4\n        MOV      r9,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_udiv\n        MOV      r4,r2\n        MOV      r5,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r8\n        MOV      r7,r9\n        BNE      |L1.44|\n|L1.108|\n        MOV      r0,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n\nlcm__FUxT1 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADR      r8,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r7,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r6,r0\n        BEQ      |L1.192|\n        LDMIA    r8,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BNE      |L1.204|\n|L1.192|\n        LDMIA    r8,{r0,r1}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.204|\n        UMULL    r8,r12,r6,r4\n        MLA      r12,r4,r7,r12\n        MLA      r9,r5,r6,r12\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       gcd__FUxT1\n        MOV      r3,r9\n        MOV      r2,r8\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _ll_urdv\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n    while (b) {\n        unsigned long long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nunsigned long long lcm(unsigned long long a, unsigned long long b) {\n    if (a == 0 || b == 0) return 0;\n    return (a * b) / gcd(a, b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountTrailingZeros__Fi PROC\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BXEQ     lr\n        RSBLT    r0,r0,#0\n        MOV      r1,#0\n        LDR      r3,|L1.188|\n        B        |L1.44|\n|L1.28|\n        SMULL    r2,r0,r3,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        ADD      r1,r1,#1\n|L1.44|\n        CMP      r0,#0\n        BLE      |L1.80|\n        SMULL    r12,r2,r3,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #1\n        BEQ      |L1.28|\n|L1.80|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countTrailingZeros(int n) {\n    if (n == 0) return 1;\n    if (n < 0) n = -n;\n    int count = 0;\n    while (n > 0 && n % 10 == 0) {\n        count++;\n        n /= 10;\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountNodes__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       countNodes__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       countNodes__FP4Node\n        ADD      r0,r5,r0\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nint countNodes(Node* node) {\n    if (node == NULL) return 0;\n    return 1 + countNodes(node->left) + countNodes(node->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npartition__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        SUB      r5,r2,#1\n        CMP      r1,r5\n        LDR      r4,[r0,r2,LSL #2]\n        SUB      r3,r1,#1\n        BGT      |L1.64|\n|L1.24|\n        LDR      lr,[r0,r1,LSL #2]\n        CMP      lr,r4\n        BGE      |L1.52|\n        ADD      r3,r3,#1\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r1,LSL #2]\n|L1.52|\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        BLE      |L1.24|\n|L1.64|\n        ADD      r12,r0,r3,LSL #2\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r1,[r12,#4]\n        STR      lr,[r12,#4]\n        STR      r1,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r3,#1\n        BX       lr\n        ENDP\n\nquickSelect__FPiiN22 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,r2\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,r3\n        CMP      r3,#0\n        BLE      |L1.236|\n        SUB      r0,r7,r5\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.236|\n        MOV      r2,r7\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       partition__FPiiT2\n        SUB      r1,r0,r5\n        SUB      r2,r4,#1\n        CMP      r1,r2\n        LDREQ    r0,[r6,r0,LSL #2]\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        BLE      |L1.208|\n        SUB      r2,r0,#1\n        MOV      r0,r6\n        MOV      r3,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r4-r7,lr}\n        B        quickSelect__FPiiN22\n|L1.208|\n        ADD      r1,r1,#1\n        SUB      r3,r4,r1\n        ADD      r1,r0,#1\n        MOV      r0,r6\n        MOV      r2,r7\n        LDMFD    sp!,{r4-r7,lr}\n        B        quickSelect__FPiiN22\n|L1.236|\n        LDMFD    sp!,{r4-r7,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nint quickSelect(int arr[], int low, int high, int k) {\n    if (k > 0 && k <= high - low + 1) {\n        int pivotIndex = partition(arr, low, high);\n        if (pivotIndex - low == k - 1)\n            return arr[pivotIndex];\n        if (pivotIndex - low > k - 1)\n            return quickSelect(arr, low, pivotIndex - 1, k);\n        return quickSelect(arr, pivotIndex + 1, high, k - (pivotIndex - low + 1));\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MVN      r1,#0\n        STMIB    r0,{r1,r5}\n        MOV      r4,r0\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#4]\n        CMN      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisFull__FP5Stack PROC\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#4]\n        SUB      r1,r1,#1\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       isFull__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.164|\n        LDR      r0,[r4,#8]\n        MOV      r0,r0,LSL #1\n        STR      r0,[r4,#8]\n        MOV      r1,r0,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BLEQ     exit\n|L1.164|\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#4]\n        SUB      r2,r0,#1\n        STR      r2,[r1,#4]\n        LDR      r1,[r1,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Stack {\n    int* data;\n    int top;\n    int capacity;\n};\n\nstruct Stack* createStack(int capacity) {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->data = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\n\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n\nint isFull(struct Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nvoid push(struct Stack* stack, int item) {\n    if (isFull(stack)) {\n        stack->capacity *= 2;\n        stack->data = (int*)realloc(stack->data, stack->capacity * sizeof(int));\n        if(stack->data == NULL) exit(1);\n    }\n    stack->data[++stack->top] = item;\n}\n\nint pop(struct Stack* stack) {\n    if (isEmpty(stack)) return -1;\n    return stack->data[stack->top--];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndeterminant__FdN31 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r9,r3\n        ADD      r3,sp,#0x28\n        MOV      r8,r2\n        LDMIA    r3,{r2,r3}\n        ADD      r7,sp,#0x20\n        LDMIA    r7,{r6,r7}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _drsb\n        ENDP\n\ninvertMatrix__FdN31PdN35 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x50\n        ADD      r9,sp,#0x48\n        LDMIA    r9,{r8,r9}\n        LDMIA    r7,{r6,r7}\n        ADD      r4,sp,#8\n        STMIA    r4,{r6,r7}\n        STMIA    sp,{r8,r9}\n        ADD      r1,sp,#0x14\n        MOV      r10,r2\n        MOV      r2,r10\n        LDMIA    r1,{r0,r1}\n        MOV      r11,r3\n        BL       determinant__FdN31\n        ADR      r2,|L1.300|\n        MOV      r5,r1\n        BIC      r1,r1,#0x80000000\n        LDMIA    r2,{r2,r3}\n        MOV      r4,r0\n        BL       _dcmple\n        ADDCC    sp,sp,#0x24\n        LDMCCFD  sp!,{r4-r11,lr}\n        BXCC     lr\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ddiv\n        LDR      r2,[sp,#0x58]\n        MOV      r3,r5\n        STMIA    r2,{r0,r1}\n        MOV      r2,r4\n        EOR      r1,r11,#0x80000000\n        MOV      r0,r10\n        BL       _ddiv\n        LDR      r2,[sp,#0x5c]\n        MOV      r3,r5\n        STMIA    r2,{r0,r1}\n        MOV      r2,r4\n        EOR      r1,r9,#0x80000000\n        MOV      r0,r8\n        BL       _ddiv\n        LDR      r2,[sp,#0x60]\n        MOV      r3,r5\n        STMIA    r2,{r0,r1}\n        ADD      r1,sp,#0x14\n        LDMIA    r1,{r0,r1}\n        MOV      r2,r4\n        BL       _ddiv\n        LDR      r2,[sp,#0x64]\n        STMIA    r2,{r0,r1}\n        ADD      sp,sp,#0x24\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.300|\n        DCFD     0x3e112e0be826d695\n        ENDP\n```",
        "output": "```cpp\n\ndouble determinant(double a, double b, double c, double d) {\n    return a * d - b * c;\n}\n\nvoid invertMatrix(double a, double b, double c, double d, double* ia, double* ib, double* ic, double* id) {\n    double det = determinant(a, b, c, d);\n    if (fabs(det) < 1e-9) return;\n    *ia = d / det;\n    *ib = -b / det;\n    *ic = -c / det;\n    *id = a / det;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlastSetBitIndex__Fi PROC\n        CMP      r0,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        MOV      r1,#0\n        TST      r0,#1\n        BNE      |L1.40|\n|L1.24|\n        MOV      r0,r0,ASR #1\n        TST      r0,#1\n        ADD      r1,r1,#1\n        BEQ      |L1.24|\n|L1.40|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint lastSetBitIndex(int n) {\n    if (n == 0) return -1;\n    int index = 0;\n    while ((n & 1) == 0) {\n        n >>= 1;\n        index++;\n    }\n    return index;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncomplex_add__F7complexT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_sub__F7complexT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dsub\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dsub\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_mul__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x4c\n        LDMIA    r7,{r4-r7}\n        MOV      r10,r2\n        MOV      r9,r1\n        MOV      r11,r3\n        MOV      r3,r5\n        MOV      r0,r9\n        MOV      r1,r10\n        MOV      r2,r4\n        LDR      r8,[sp,#0x48]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r2,r6\n        ADD      r6,sp,#0xc\n        STMIA    r6,{r0,r1}\n        MOV      r1,r10\n        MOV      r0,r9\n        MOV      r3,r7\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x38]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDR      r1,[sp,#0x10]\n        STR      r1,[r2,#4]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r2,#0]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\ncomplex_div__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x4c\n        LDMIA    r7,{r4-r7}\n        MOV      r11,r1\n        MOV      r1,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r0,r4\n        LDR      r10,[sp,#0x48]\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        MOV      r8,r0\n        ADR      r0,|L1.700|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r9,r1\n        BL       _dcmpeq\n        BNE      |L1.524|\n        ADR      r3,|L1.700|\n        LDMIA    r3,{r0,r1}\n        LDR      r12,[sp,#0x38]\n        ADD      r2,r12,#8\n        STMIA    r2,{r0,r1}\n        STMIA    r12,{r0,r1}\n|L1.508|\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.524|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r0,r11\n        LDR      r1,[sp,#0x40]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        LDR      r0,[sp,#0x44]\n        MOV      r1,r10\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _dadd\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n        MOV      r2,r4\n        ADD      r4,sp,#0xc\n        STMIA    r4,{r0,r1}\n        LDR      r0,[sp,#0x44]\n        MOV      r1,r10\n        MOV      r3,r5\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        LDR      r1,[sp,#0x40]\n        MOV      r0,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n        LDR      r12,[sp,#0x38]\n        ADD      r2,r12,#8\n        STMIA    r2,{r0,r1}\n        LDR      r1,[sp,#0x10]\n        STR      r1,[r12,#4]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r12,#0]\n        B        |L1.508|\n|L1.700|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    double real;\n    double imag;\n} complex;\n\ncomplex complex_add(complex a, complex b) {\n    complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\ncomplex complex_sub(complex a, complex b) {\n    complex result;\n    result.real = a.real - b.real;\n    result.imag = a.imag - b.imag;\n    return result;\n}\n\ncomplex complex_mul(complex a, complex b) {\n    complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\ncomplex complex_div(complex a, complex b) {\n    complex result;\n    double denominator = b.real * b.real + b.imag * b.imag;\n    if (denominator == 0) {\n        result.real = 0;\n        result.imag = 0;\n        return result;\n    }\n    result.real = (a.real * b.real + a.imag * b.imag) / denominator;\n    result.imag = (a.imag * b.real - a.real * b.imag) / denominator;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0x14\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0x190\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.64|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        MOV      r1,#0x64\n        ADD      r2,r4,#8\n        STMIA    r2,{r0,r1}\n        STR      r0,[r4,#0x10]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#0x10]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        ADD      r1,r0,#0xc\n        LDMIA    r1,{r0,r1}\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r2,r1\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r4,#8]\n        STR      r2,[r0,r1,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#8]\n        LDR      r0,[r4,#0x10]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0x10]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5QueuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDMIA    r4,{r0,r2}\n        LDR      r0,[r0,r2,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#4]\n        LDR      r0,[r4,#0x10]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#0x10]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndeleteQueue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int* buffer;\n    int head;\n    int tail;\n    int size;\n    int count;\n} Queue;\n\n\nQueue* createQueue() {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    if (q == NULL) return NULL;\n    q->buffer = (int*)malloc(MAX_SIZE * sizeof(int));\n    if (q->buffer == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->head = 0;\n    q->tail = 0;\n    q->size = MAX_SIZE;\n    q->count = 0;\n    return q;\n}\n\nint isEmpty(Queue* q) {\n    return q->count == 0;\n}\n\nint isFull(Queue* q) {\n    return q->count == q->size;\n}\n\n\nint enqueue(Queue* q, int value) {\n    if (isFull(q)) return 0;\n    q->buffer[q->tail] = value;\n    q->tail = (q->tail + 1) % q->size;\n    q->count++;\n    return 1;\n}\n\nint dequeue(Queue* q, int* value) {\n    if (isEmpty(q)) return 0;\n    *value = q->buffer[q->head];\n    q->head = (q->head + 1) % q->size;\n    q->count--;\n    return 1;\n}\n\nvoid deleteQueue(Queue* q) {\n    free(q->buffer);\n    free(q);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfft__FP7Complexi PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        CMP      r1,#1\n        SUB      sp,sp,#0x1c\n        MOV      r4,r0\n        MOVLE    r0,r4\n        ADDLE    sp,sp,#0x1c\n        MOV      r8,r1\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n        ADD      r0,r8,r8,LSR #31\n        MOV      r7,r0,ASR #1\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       fft__FP7Complexi\n        MOV      r6,r0\n        ADD      r0,r4,#8\n        MOV      r1,r7\n        BL       fft__FP7Complexi\n        STR      r0,[sp,#8]\n        MOV      r0,r8,LSL #3\n        BL       malloc\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r7,#0\n        BLE      |L1.400|\n        MOV      r0,r8\n        BL       _dflt\n        STR      r0,[sp,#0x18]\n        STR      r1,[sp,#0x14]\n|L1.116|\n        MOV      r0,r4\n        BL       _dflt\n        ADR      r2,|L1.432|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r2,r0\n        MOV      r3,r1\n        LDR      r1,[sp,#0x14]\n        LDR      r0,[sp,#0x18]\n        BL       _drdiv\n        BL       _d2f\n        BL       _f2d\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       ||__softfp_cos||\n        BL       _d2f\n        MOV      r10,r0\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       ||__softfp_sin||\n        BL       _d2f\n        MOV      r11,r0\n        LDR      r0,[sp,#8]\n        LDR      r8,[r0,r4,LSL #3]\n        MOV      r0,r10\n        MOV      r1,r8\n        BL       _fmul\n        STR      r0,[sp,#0x10]\n        LDR      r0,[sp,#8]\n        ADD      r0,r0,r4,LSL #3\n        LDR      r9,[r0,#4]\n        MOV      r0,r11\n        MOV      r1,r9\n        BL       _fmul\n        LDR      r1,[sp,#0x10]\n        BL       _frsb\n        STR      r0,[sp,#0xc]\n        STR      r0,[sp,#4]\n        MOV      r0,r10\n        MOV      r1,r9\n        BL       _fmul\n        MOV      r9,r0\n        MOV      r0,r11\n        MOV      r1,r8\n        BL       _fmul\n        MOV      r1,r9\n        BL       _fadd\n        MOV      r8,r0\n        LDR      r0,[r6,r4,LSL #3]\n        LDR      r1,[sp,#0xc]\n        BL       _fadd\n        STR      r0,[r5,r4,LSL #3]\n        ADD      r9,r6,r4,LSL #3\n        LDR      r0,[r9,#4]\n        MOV      r1,r8\n        BL       _fadd\n        ADD      r1,r5,r4,LSL #3\n        STR      r0,[r1,#4]\n        LDR      r1,[sp,#4]\n        LDR      r0,[r6,r4,LSL #3]\n        BL       _fsub\n        ADD      r10,r7,r4\n        STR      r0,[r5,r10,LSL #3]\n        LDR      r0,[r9,#4]\n        MOV      r1,r8\n        BL       _fsub\n        ADD      r1,r5,r10,LSL #3\n        ADD      r4,r4,#1\n        CMP      r7,r4\n        STR      r0,[r1,#4]\n        BGT      |L1.116|\n|L1.400|\n        MOV      r0,r6\n        BL       free\n        LDR      r0,[sp,#8]\n        BL       free\n        MOV      r0,r5\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.432|\n        DCFD     0xc01921fb54442d18\n        ENDP\n```",
        "output": "```cpp\n\n#define PI 3.14159265358979323846\n\ntypedef struct {\n    float real;\n    float imag;\n} Complex;\n\n\nComplex* fft(Complex* x, int n) {\n    if (n <= 1) return x;\n\n    Complex* even = fft(x, n / 2);\n    Complex* odd = fft(x + 1, n / 2);\n    Complex* y = (Complex*)malloc(n * sizeof(Complex));\n\n\n    for (int k = 0; k < n / 2; k++) {\n        float angle = -2 * PI * k / n;\n        Complex wk;\n        wk.real = cos(angle);\n        wk.imag = sin(angle);\n\n        Complex t;\n        t.real = wk.real * odd[k].real - wk.imag * odd[k].imag;\n        t.imag = wk.real * odd[k].imag + wk.imag * odd[k].real;\n\n\n        y[k].real = even[k].real + t.real;\n        y[k].imag = even[k].imag + t.imag;\n        y[k + n / 2].real = even[k].real - t.real;\n        y[k + n / 2].imag = even[k].imag - t.imag;\n    }\n    free(even);\n    free(odd);\n    return y;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMinHeap__Fi PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        MOV      r1,#0\n        STMIA    r4,{r0,r1,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nminHeapify__FP7MinHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        LDR      lr,[r0,#4]\n        MOV      r3,#1\n        ADD      r3,r3,r1,LSL #1\n        MOV      r12,#2\n        ADD      r12,r12,r1,LSL #1\n        CMP      lr,r3\n        MOV      r2,r1\n        BLE      |L1.104|\n        LDR      r4,[r0,#0]\n        LDR      r5,[r4,r3,LSL #2]\n        LDR      r4,[r4,r1,LSL #2]\n        CMP      r5,r4\n        MOVLT    r1,r3\n|L1.104|\n        CMP      lr,r12\n        BLE      |L1.132|\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r12,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        CMP      lr,r3\n        MOVLT    r1,r12\n|L1.132|\n        CMP      r1,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r1,LSL #2]\n        LDR      r12,[r3,r2,LSL #2]\n        STR      lr,[r3,r2,LSL #2]\n        LDR      r2,[r0,#0]\n        STR      r12,[r2,r1,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        minHeapify__FP7MinHeapi\n        ENDP\n\ninsert__FP7MinHeapi PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        STR      lr,[sp,#-4]!\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        B        |L1.224|\n|L1.208|\n        STR      r3,[lr,r1,LSL #2]\n        LDR      r1,[r0,#0]\n        STR      r12,[r1,r2,LSL #2]\n        MOV      r1,r2\n|L1.224|\n        CMP      r1,#0\n        BLE      |L1.264|\n        SUB      r2,r1,#1\n        ADD      r2,r2,r2,LSR #31\n        LDR      lr,[r0,#0]\n        MOV      r2,r2,ASR #1\n        LDR      r3,[lr,r2,LSL #2]\n        LDR      r12,[lr,r1,LSL #2]\n        CMP      r3,r12\n        BGT      |L1.208|\n|L1.264|\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nextractMin__FP7MinHeap PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        BL       minHeapify__FP7MinHeapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nfindKthLargest__FPiiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r7,r0\n        MOV      r6,r2\n        CMP      r2,#0\n        BLE      |L1.388|\n        CMP      r6,r8\n        BLE      |L1.400|\n|L1.388|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.400|\n        MOV      r0,r6\n        BL       createMinHeap__Fi\n        MOV      r4,r0\n        MOV      r5,#0\n|L1.416|\n        LDR      r1,[r7,r5,LSL #2]\n        MOV      r0,r4\n        BL       insert__FP7MinHeapi\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.416|\n        CMP      r6,r8\n        BGE      |L1.500|\n|L1.448|\n        LDR      r1,[r4,#0]\n        LDR      r0,[r7,r6,LSL #2]\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        BLE      |L1.488|\n        MOV      r0,r4\n        BL       extractMin__FP7MinHeap\n        LDR      r1,[r7,r6,LSL #2]\n        MOV      r0,r4\n        BL       insert__FP7MinHeapi\n|L1.488|\n        ADD      r6,r6,#1\n        CMP      r6,r8\n        BLT      |L1.448|\n|L1.500|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        extractMin__FP7MinHeap\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int *heap;\n    int size;\n    int capacity;\n} MinHeap;\n\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));\n    heap->heap = (int*)malloc(capacity * sizeof(int));\n    heap->size = 0;\n    heap->capacity = capacity;\n    return heap;\n}\n\nvoid minHeapify(MinHeap* heap, int index) {\n    int smallest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < heap->size && heap->heap[left] < heap->heap[smallest])\n        smallest = left;\n    if (right < heap->size && heap->heap[right] < heap->heap[smallest])\n        smallest = right;\n\n    if (smallest != index) {\n        int temp = heap->heap[index];\n        heap->heap[index] = heap->heap[smallest];\n        heap->heap[smallest] = temp;\n        minHeapify(heap, smallest);\n    }\n}\n\nvoid insert(MinHeap* heap, int value) {\n    if (heap->size == heap->capacity) return;\n    heap->heap[heap->size] = value;\n    int i = heap->size;\n    while (i > 0 && heap->heap[(i - 1) / 2] > heap->heap[i]) {\n        int temp = heap->heap[i];\n        heap->heap[i] = heap->heap[(i - 1) / 2];\n        heap->heap[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size++;\n}\n\nint extractMin(MinHeap* heap) {\n    if (heap->size <= 0) return 0;\n    int min = heap->heap[0];\n    heap->heap[0] = heap->heap[heap->size - 1];\n    heap->size--;\n    minHeapify(heap, 0);\n    return min;\n}\n\nint findKthLargest(int arr[], int n, int k) {\n    if (k <= 0 || k > n) return 0;\n    MinHeap* heap = createMinHeap(k);\n    for (int i = 0; i < k; i++) {\n        insert(heap, arr[i]);\n    }\n    for (int i = k; i < n; i++) {\n        if (arr[i] > heap->heap[0]) {\n            extractMin(heap);\n            insert(heap, arr[i]);\n        }\n    }\n    return extractMin(heap);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitQueue__FP5Queue PROC\n        MVN      r1,#0\n        STR      r1,[r0,#0x190]\n        STR      r1,[r0,#0x194]\n        MOV      r1,#0\n        STR      r1,[r0,#0x198]\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#0x198]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        LDR      r0,[r0,#0x198]\n        CMP      r0,#0x64\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        BXNE     lr\n        MOV      r0,r2\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        MOVNE    r0,#0\n        STRNE    r0,[r2,#0x190]\n        LDR      r0,[r2,#0x194]\n        LDR      r3,|L1.424|\n        ADD      r0,r0,#1\n        SMULL    lr,r12,r3,r0\n        MOV      r3,r12,ASR #5\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r0,r0,r3,LSL #2\n        STR      r0,[r2,#0x194]\n        STR      r1,[r2,r0,LSL #2]\n        LDR      r0,[r2,#0x198]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0x198]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ndequeue__FP5Queue PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r2,[r1,#0x190]\n        LDR      r0,[r1,r2,LSL #2]\n        LDR      r3,[r1,#0x194]\n        CMP      r2,r3\n        MVNEQ    r2,#0\n        STREQ    r2,[r1,#0x190]\n        STREQ    r2,[r1,#0x194]\n        BEQ      |L1.272|\n        LDR      r3,|L1.424|\n        ADD      r2,r2,#1\n        SMULL    lr,r12,r3,r2\n        MOV      r3,r12,ASR #5\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r2,r2,r3,LSL #2\n        STR      r2,[r1,#0x190]\n|L1.272|\n        LDR      r2,[r1,#0x198]\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0x198]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int arr[MAX_SIZE];\n    int front;\n    int rear;\n    int size;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n    q->size = 0;\n}\n\nint isEmpty(Queue* q) {\n    return q->size == 0;\n}\n\nint isFull(Queue* q) {\n    return q->size == MAX_SIZE;\n}\n\nvoid enqueue(Queue* q, int value) {\n    if (isFull(q)) return;\n    if (isEmpty(q)) q->front = 0;\n    q->rear = (q->rear + 1) % MAX_SIZE;\n    q->arr[q->rear] = value;\n    q->size++;\n}\n\nint dequeue(Queue* q) {\n    if (isEmpty(q)) return -1; \n    int value = q->arr[q->front];\n    if (q->front == q->rear) {\n        q->front = -1;\n        q->rear = -1;\n    } else {\n        q->front = (q->front + 1) % MAX_SIZE;\n    }\n    q->size--;\n    return value;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhammingDistance__FiT1 PROC\n        MOV      r2,r0\n        EOR      r1,r2,r1\n        CMP      r1,#0\n        MOV      r0,#0\n        BXLE     lr\n|L1.20|\n        AND      r2,r1,#1\n        MOV      r1,r1,ASR #1\n        CMP      r1,#0\n        ADD      r0,r2,r0\n        BGT      |L1.20|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint hammingDistance(int x, int y) {\n    int dist = 0;\n    int val = x ^ y;\n    while (val > 0) {\n        dist += val & 1;\n        val >>= 1;\n    }\n    return dist;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npreorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.48|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       preorder__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        preorder__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid preorder(Node *root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    preorder(root->left);\n    preorder(root->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_graph__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        STR      r6,[r5,#4]\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        STR      r0,[r5,#0]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r5\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.216|\n        MOV      r7,#0\n|L1.88|\n        MOV      r0,#0xc\n        BL       malloc\n        LDR      r1,[r5,#0]\n        CMP      r0,#0\n        STR      r0,[r1,r4,LSL #2]\n        BNE      |L1.176|\n        MOV      r6,#0\n        CMP      r4,#0\n        BLE      |L1.148|\n|L1.124|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r6,LSL #2]\n        BL       free\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        BLT      |L1.124|\n|L1.148|\n        LDR      r0,[r5,#0]\n        BL       free\n        MOV      r0,r5\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.176|\n        STR      r4,[r0,#0]\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        STR      r7,[r0,#8]\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        STR      r7,[r0,#4]\n        BLT      |L1.88|\n|L1.216|\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP6_GraphiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r5,#0\n        LDRGE    r0,[r4,#4]\n        CMPGE    r0,r5\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        CMP      r6,#0\n        CMPGE    r0,r6\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[r0,#8]!\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#4]\n        MOV      r1,r1,LSL #2\n        BL       realloc\n        LDR      r1,[r4,#0]\n        CMP      r0,#0\n        LDR      r1,[r1,r5,LSL #2]\n        STR      r0,[r1,#4]\n        LDR      r1,[r4,#0]\n        LDR      r2,[r1,r5,LSL #2]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r2,[r2,#8]\n        LDR      r1,[r1,r6,LSL #2]\n        ADD      r0,r0,r2,LSL #2\n        STR      r1,[r0,#-4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndfs_recursive__FP5_NodePi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r5,r0\n        LDRNE    r0,[r5,#0]\n        MOV      r6,r1\n        LDRNE    r1,[r6,r0,LSL #2]\n        CMPNE    r1,#1\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r6,r0,LSL #2]\n        LDR      r0,[r5,#8]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.448|\n        LDR      r0,[r5,#4]\n        MOV      r1,r6\n        LDR      r0,[r0,r4,LSL #2]\n        BL       dfs_recursive__FP5_NodePi\n        LDR      r0,[r5,#8]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.448|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct _Node {\n    int data;\n    struct _Node** adj;\n    int adj_size;\n} Node;\n\ntypedef struct _Graph {\n    Node** nodes;\n    int num_nodes;\n} Graph;\n\n\nGraph* create_graph(int num_nodes) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == 0) return 0;\n    graph->num_nodes = num_nodes;\n    graph->nodes = (Node**)malloc(num_nodes * sizeof(Node*));\n    if (graph->nodes == 0) {\n        free(graph);\n        return 0;\n    }\n    for (int i = 0; i < num_nodes; i++) {\n        graph->nodes[i] = (Node*)malloc(sizeof(Node));\n        if (graph->nodes[i] == 0) {\n            for (int j = 0; j < i; j++) free(graph->nodes[j]);\n            free(graph->nodes);\n            free(graph);\n            return 0;\n        }\n        graph->nodes[i]->data = i;\n        graph->nodes[i]->adj_size = 0;\n        graph->nodes[i]->adj = 0;\n    }\n    return graph;\n}\n\nvoid add_edge(Graph* graph, int u, int v) {\n    if (graph == 0 || u < 0 || u >= graph->num_nodes || v < 0 || v >= graph->num_nodes) return;\n\n    graph->nodes[u]->adj_size++;\n    graph->nodes[u]->adj = (Node**)realloc(graph->nodes[u]->adj, graph->nodes[u]->adj_size * sizeof(Node*));\n    if (graph->nodes[u]->adj == 0) return;\n    graph->nodes[u]->adj[graph->nodes[u]->adj_size - 1] = graph->nodes[v];\n}\n\n\nvoid dfs_recursive(Node* node, int* visited) {\n    if (node == 0 || visited[node->data] == 1) return;\n    visited[node->data] = 1;\n    for (int i = 0; i < node->adj_size; i++) {\n        dfs_recursive(node->adj[i], visited);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintTopView__FP4Node PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x2c00\n        SUB      sp,sp,#0x2e4\n        MOVS     r8,r0\n        ADDEQ    sp,sp,#0x2c00\n        ADDEQ    sp,sp,#0x2e4\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r2,#0\n        ADD      r12,sp,#0x1000\n        STR      r8,[r12,#0xf44]\n        LDR      r0,|L1.268|\n        ADD      r9,sp,#0x1c00\n        UMULL    r3,r1,r0,r2\n        MOV      r0,r1,LSR #3\n        ADD      r1,sp,#0xc00\n        ADD      r1,r1,#0x3a4\n        STR      r2,[r1,r0,LSL #2]\n        ADD      r10,sp,#4\n        MOV      r0,r10\n        MOV      r1,#0xfa0\n        ADD      r9,r9,#0x344\n        MOV      r6,#0\n        MOV      r4,#1\n        BL       __rt_memclr_w\n        MOV      r11,#1\n|L1.144|\n        MOV      r0,r6\n        LDR      r5,[r9,r0,LSL #2]\n        LDR      r2,|L1.272|\n        SUB      r0,r5,r8\n        SMULL    r1,r0,r2,r0\n        MOV      r0,r0,ASR #1\n        SUB      r7,r0,r0,ASR #31\n        LDR      r0,[r10,r7,LSL #2]\n        ADD      r6,r6,#1\n        CMP      r0,#0\n        BNE      |L1.204|\n        ADR      r0,|L1.276|\n        LDR      r1,[r5,#0]\n        BL       _printf\n        STR      r11,[r10,r7,LSL #2]\n|L1.204|\n        LDR      r1,[r5,#4]\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r9,r0,LSL #2]\n        LDR      r1,[r5,#8]\n        ADDNE    r4,r4,#1\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r9,r0,LSL #2]\n        ADDNE    r4,r4,#1\n        CMP      r6,r4\n        BLT      |L1.144|\n        ADD      sp,sp,#0x2c00\n        ADD      sp,sp,#0x2e4\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.268|\n        DCD      0xaaaaaaab\n|L1.272|\n        DCD      0x2aaaaaab\n|L1.276|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid printTopView(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* q[1000];\n    int hd[1000];\n    int head = 0, tail = 0;\n\n    q[tail++] = root;\n    hd[root - root] = 0;\n    int min_hd = 0, max_hd = 0;\n    int visited_hd[1000] = {0};\n\n    while (head < tail) {\n        struct Node *curr = q[head++];\n        int h_d = curr-root;\n\n        if (visited_hd[h_d] == 0) {\n            printf(\"%d \", curr->data);\n            visited_hd[h_d] = 1;\n        }\n\n        if (curr->left) {\n            q[tail++] = curr->left;\n        }\n        if (curr->right) {\n            q[tail++] = curr->right;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitialize__FP5Queue PROC\n        MVN      r1,#0\n        STR      r1,[r0,#0x190]\n        STR      r1,[r0,#0x194]\n        MOV      r1,#0\n        STR      r1,[r0,#0x198]\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#0x198]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        LDR      r0,[r0,#0x198]\n        CMP      r0,#0x64\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        BXNE     lr\n        MOV      r0,r2\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        MOVNE    r0,#0\n        STRNE    r0,[r2,#0x190]\n        LDR      r0,[r2,#0x194]\n        LDR      r3,|L1.404|\n        ADD      r0,r0,#1\n        SMULL    lr,r12,r3,r0\n        MOV      r3,r12,ASR #5\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r0,r0,r3,LSL #2\n        STR      r0,[r2,#0x194]\n        STR      r1,[r2,r0,LSL #2]\n        LDR      r0,[r2,#0x198]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0x198]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ndequeue__FP5Queue PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r2,[r1,#0x190]\n        LDR      r0,[r1,r2,LSL #2]\n        LDR      r3,[r1,#0x194]\n        CMP      r2,r3\n        MVNEQ    r2,#0\n        STREQ    r2,[r1,#0x190]\n        STREQ    r2,[r1,#0x194]\n        BEQ      |L1.272|\n        LDR      r3,|L1.404|\n        ADD      r2,r2,#1\n        SMULL    lr,r12,r3,r2\n        MOV      r3,r12,ASR #5\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r2,r2,r3,LSL #2\n        STR      r2,[r1,#0x190]\n|L1.272|\n        LDR      r2,[r1,#0x198]\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0x198]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int arr[MAX_SIZE];\n    int front;\n    int rear;\n    int size;\n} Queue;\n\nvoid initialize(Queue* q) {\n    q->front = -1;\n    q->rear = -1;\n    q->size = 0;\n}\n\nint isEmpty(Queue* q) {\n    return q->size == 0;\n}\n\nint isFull(Queue* q) {\n    return q->size == MAX_SIZE;\n}\n\nvoid enqueue(Queue* q, int value) {\n    if (isFull(q)) return;\n    if (isEmpty(q)) q->front = 0;\n    q->rear = (q->rear + 1) % MAX_SIZE;\n    q->arr[q->rear] = value;\n    q->size++;\n}\n\nint dequeue(Queue* q) {\n    if (isEmpty(q)) return -1; \n    int value = q->arr[q->front];\n    if (q->front == q->rear) {\n        q->front = -1;\n        q->rear = -1;\n    } else {\n        q->front = (q->front + 1) % MAX_SIZE;\n    }\n    q->size--;\n    return value;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreatePath__Fv PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        MOV      r2,#1\n        STMIA    r4,{r0-r2}\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nresizePath__FP4Path PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        MOV      r0,r0,LSL #1\n        STR      r0,[r4,#8]\n        MOV      r1,r0,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nfreePath__F4Path PROC\n        B        free\n        ENDP\n\naddPointToPath__FP4Pathi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        MOV      r5,r1\n        LDR      r1,[r4,#8]\n        CMP      r0,r1\n        MOVEQ    r0,r4\n        BLEQ     resizePath__FP4Path\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisSafe__FiT1 PROC\n        CMP      r0,#0\n        BLT      |L1.192|\n        LDR      r3,|L1.752|\n        LDR      r2,[r3,#0]  ; matrix_rows\n        CMP      r0,r2\n        BGE      |L1.192|\n        CMP      r1,#0\n        BLT      |L1.192|\n        LDR      r0,[r3,#4]  ; matrix_cols\n        CMP      r1,r0\n        MOVLT    r0,#1\n        BXLT     lr\n|L1.192|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfindPaths__FiT14Path PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r10,lr}\n        LDR      r4,|L1.752|\n        MOV      r7,r0\n        LDR      r0,[r4,#4]  ; matrix_cols\n        MOV      r8,r1\n        SUB      sp,sp,#0x28\n        ADD      r5,sp,#0x50\n        MLA      r1,r0,r7,r1\n        MOV      r0,r5\n        BL       addPointToPath__FP4Pathi\n        LDR      r0,[r4,#0]  ; matrix_rows\n        SUB      r0,r0,#1\n        CMP      r0,r7\n        LDREQ    r0,[r4,#4]  ; matrix_cols\n        SUBEQ    r0,r0,#1\n        CMPEQ    r0,r8\n        BNE      |L1.368|\n        LDR      r2,|L1.756|\n        LDR      r1,[r4,#0xc]  ; paths_count\n        LDR      r0,[r2,#0]  ; all_paths_capacity\n        CMP      r1,r0\n        BNE      |L1.320|\n        MOV      r0,r0,LSL #1\n        ADD      r1,r0,r0,LSL #1\n        STR      r0,[r2,#0]  ; all_paths_capacity\n        LDR      r0,[r4,#0x10]  ; all_paths\n        MOV      r1,r1,LSL #2\n        BL       realloc\n        STR      r0,[r4,#0x10]  ; all_paths\n|L1.320|\n        LDR      r0,[r4,#0xc]  ; paths_count\n        ADD      r1,r0,#1\n        STR      r1,[r4,#0xc]  ; paths_count\n        LDR      r1,[r4,#0x10]  ; all_paths\n        ADD      r0,r0,r0,LSL #1\n        ADD      r0,r1,r0,LSL #2\n        LDMIA    r5,{r1-r3}\n        STMIA    r0,{r1-r3}\n|L1.352|\n        ADD      sp,sp,#0x28\n        LDMFD    sp!,{r4-r10}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.368|\n        LDR      r0,|L1.760|\n        ADD      r10,sp,#0x18\n        LDMIA    r0,{r1-r4}\n        STMIA    r10,{r1-r4}\n        LDR      r0,|L1.764|\n        ADD      r9,sp,#8\n        LDMIA    r0,{r1-r4}\n        STMIA    r9,{r1-r4}\n        MOV      r4,#0\n|L1.404|\n        LDR      r0,[r10,r4,LSL #2]\n        ADD      r5,r0,r7\n        LDR      r0,[r9,r4,LSL #2]\n        ADD      r6,r0,r8\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       isSafe__FiT1\n        CMP      r0,#0\n        BEQ      |L1.468|\n        LDR      r0,[sp,#0x58]\n        ADD      r3,sp,#0x50\n        STR      r0,[sp,#0]\n        LDMIA    r3,{r2,r3}\n        MOV      r0,r5\n        MOV      r1,r6\n        BL       findPaths__FiT14Path\n|L1.468|\n        ADD      r4,r4,#1\n        CMP      r4,#4\n        BLT      |L1.404|\n        B        |L1.352|\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_PATH_LENGTH 1000\n\ntypedef struct {\n    int *path;\n    int path_length;\n    int capacity;\n} Path;\n\nPath createPath() {\n    Path p;\n    p.path = (int*)malloc(sizeof(int));\n    p.path_length = 0;\n    p.capacity = 1;\n    return p;\n}\n\nvoid resizePath(Path *p) {\n    p->capacity *= 2;\n    p->path = (int*)realloc(p->path, p->capacity * sizeof(int));\n}\n\nvoid freePath(Path p) {\n    free(p.path);\n}\n\nvoid addPointToPath(Path *p, int point) {\n    if (p->path_length == p->capacity) resizePath(p);\n    p->path[p->path_length++] = point;\n}\n\n\nint matrix_rows, matrix_cols;\nint** matrix;\n\nint isSafe(int row, int col) {\n    return row >= 0 && row < matrix_rows && col >= 0 && col < matrix_cols;\n}\n\nint paths_count = 0;\nPath* all_paths;\nint all_paths_capacity = 1;\n\n\nvoid findPaths(int row, int col, Path current_path) {\n    addPointToPath(&current_path, row * matrix_cols + col);\n\n\n    if (row == matrix_rows -1 && col == matrix_cols - 1) {\n        if (paths_count == all_paths_capacity){\n            all_paths_capacity *= 2;\n            all_paths = (Path*)realloc(all_paths, all_paths_capacity * sizeof(Path));\n        }\n\n        all_paths[paths_count++] = current_path;\n    \n    } else {\n        int row_moves[] = {-1, 1, 0, 0};\n        int col_moves[] = {0, 0, -1, 1};\n        \n        for (int i = 0; i < 4; i++) {\n            int new_row = row + row_moves[i];\n            int new_col = col + col_moves[i];\n            if (isSafe(new_row, new_col)) {\n                findPaths(new_row, new_col, current_path);\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateSparseMatrix__FiN21 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,#0x14\n        MOV      r7,r1\n        MOV      r6,r2\n        BL       malloc\n        MOV      r4,r0\n        STMIA    r0,{r5,r7}\n        MOV      r0,#4\n        ADD      r0,r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#8]\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0xc]\n        MOV      r0,r6,LSL #3\n        BL       malloc\n        STR      r0,[r4,#0x10]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nfreeSparseMatrix__FP12SparseMatrix PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        BL       free\n        LDR      r0,[r4,#0xc]\n        BL       free\n        LDR      r0,[r4,#0x10]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nsparseMatrixMultiply__FP12SparseMatrixT1 PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r10,r0\n        LDR      r0,[r0,#4]\n        MOV      r8,r1\n        LDR      r1,[r1,#0]\n        SUB      sp,sp,#0x1c\n        CMP      r0,r1\n        ADDNE    sp,sp,#0x1c\n        LDMNEFD  sp!,{r4-r11,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r10,#0]\n        MOV      r2,#0\n        MOV      lr,#0\n        CMP      r0,#0\n        BLE      |L1.288|\n        LDR      r7,[r10,#8]\n|L1.196|\n        LDR      r3,[r7,lr,LSL #2]\n        ADD      r1,r7,lr,LSL #2\n        LDR      r5,[r1,#4]\n        CMP      r5,r3\n        BLE      |L1.276|\n        LDR      r4,[r8,#8]\n        LDR      r6,[r10,#0xc]\n|L1.224|\n        LDR      r12,[r6,r3,LSL #2]\n        LDR      r1,[r4,r12,LSL #2]\n        ADD      r12,r4,r12,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,r1\n        BLE      |L1.264|\n|L1.248|\n        ADD      r1,r1,#1\n        CMP      r12,r1\n        ADD      r2,r2,#1\n        BGT      |L1.248|\n|L1.264|\n        ADD      r3,r3,#1\n        CMP      r5,r3\n        BGT      |L1.224|\n|L1.276|\n        ADD      lr,lr,#1\n        CMP      r0,lr\n        BGT      |L1.196|\n|L1.288|\n        LDR      r1,[r8,#4]\n        BL       createSparseMatrix__FiN21\n        MOV      r1,#0\n        STR      r1,[sp,#4]\n        STR      r1,[sp,#0]\n        STR      r0,[sp,#8]\n        LDR      r0,[r10,#0]\n        CMP      r0,#0\n        BLE      |L1.664|\n|L1.324|\n        LDR      r0,[r8,#4]\n        MOV      r9,#0\n        CMP      r0,#0\n        BLE      |L1.616|\n|L1.340|\n        ADR      r0,|L1.680|\n        LDMIA    r0,{r6,r7}\n        LDR      r0,[r10,#8]\n        LDR      r1,[sp,#0]\n        LDR      r5,[r0,r1,LSL #2]\n        ADD      r0,r0,r1,LSL #2\n        LDR      r0,[r0,#4]\n        STR      r0,[sp,#0x18]\n        CMP      r0,r5\n        BLE      |L1.528|\n        LDR      r1,[r8,#8]\n        STR      r1,[sp,#0x14]\n        LDR      r0,[r10,#0xc]\n        STR      r0,[sp,#0x10]\n|L1.396|\n        LDR      r0,[sp,#0x10]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[sp,#0x14]\n        LDR      r4,[r1,r0,LSL #2]\n        ADD      r0,r1,r0,LSL #2\n        LDR      r0,[r0,#4]\n        STR      r0,[sp,#0xc]\n        CMP      r0,r4\n        BLE      |L1.512|\n        LDR      r11,[r8,#0xc]\n|L1.436|\n        LDR      r0,[r11,r4,LSL #2]\n        CMP      r0,r9\n        BNE      |L1.496|\n        LDR      r0,[r8,#0x10]\n        ADD      r1,r0,r4,LSL #3\n        LDR      r0,[r10,#0x10]\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      r6,r0\n        MOV      r7,r1\n|L1.496|\n        LDR      r0,[sp,#0xc]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.436|\n|L1.512|\n        LDR      r0,[sp,#0x18]\n        ADD      r5,r5,#1\n        CMP      r0,r5\n        BGT      |L1.396|\n|L1.528|\n        ADR      r0,|L1.680|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dcmpeq\n        BEQ      |L1.600|\n        LDR      r0,[sp,#8]\n        LDR      r0,[r0,#0xc]\n        LDR      r1,[sp,#4]\n        STR      r9,[r0,r1,LSL #2]\n        LDR      r0,[sp,#8]\n        LDR      r0,[r0,#0x10]\n        LDR      r1,[sp,#4]\n        ADD      r0,r0,r1,LSL #3\n        STMIA    r0,{r6,r7}\n        LDR      r1,[sp,#4]\n        ADD      r1,r1,#1\n        STR      r1,[sp,#4]\n|L1.600|\n        LDR      r0,[r8,#4]\n        ADD      r9,r9,#1\n        CMP      r0,r9\n        BGT      |L1.340|\n|L1.616|\n        LDR      r0,[sp,#8]\n        LDR      r1,[sp,#4]\n        LDR      r0,[r0,#8]\n        LDR      r2,[sp,#0]\n        ADD      r0,r0,r2,LSL #2\n        STR      r1,[r0,#4]\n        LDR      r1,[sp,#0]\n        ADD      r1,r1,#1\n        STR      r1,[sp,#0]\n        LDR      r0,[r10,#0]\n        CMP      r0,r1\n        BGT      |L1.324|\n|L1.664|\n        LDR      r0,[sp,#8]\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.680|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct SparseMatrix {\n    int rows;\n    int cols;\n    int* rowPtr;\n    int* colIdx;\n    double* values;\n};\n\n\nSparseMatrix* createSparseMatrix(int rows, int cols, int nnz) {\n    SparseMatrix* matrix = (SparseMatrix*)malloc(sizeof(SparseMatrix));\n    matrix->rows = rows;\n    matrix->cols = cols;\n    matrix->rowPtr = (int*)malloc((rows + 1) * sizeof(int));\n    matrix->colIdx = (int*)malloc(nnz * sizeof(int));\n    matrix->values = (double*)malloc(nnz * sizeof(double));\n    return matrix;\n}\n\n\nvoid freeSparseMatrix(SparseMatrix* matrix) {\n    free(matrix->rowPtr);\n    free(matrix->colIdx);\n    free(matrix->values);\n    free(matrix);\n}\n\nSparseMatrix* sparseMatrixMultiply(SparseMatrix* a, SparseMatrix* b) {\n    if (a->cols != b->rows) return 0;\n\n    int nnz = 0;\n    for (int i = 0; i < a->rows; ++i) {\n        for (int k = a->rowPtr[i]; k < a->rowPtr[i + 1]; ++k) {\n            for (int j = b->rowPtr[a->colIdx[k]]; j < b->rowPtr[a->colIdx[k] + 1]; ++j) {\n                nnz++;\n            }\n        }\n    }\n\n    SparseMatrix* c = createSparseMatrix(a->rows, b->cols, nnz);\n    int k=0;\n    for (int i = 0; i < a->rows; ++i) {\n        for (int j = 0; j < b->cols; ++j) {\n            double sum = 0;\n            for (int l = a->rowPtr[i]; l < a->rowPtr[i + 1]; ++l) {\n                for (int m = b->rowPtr[a->colIdx[l]]; m < b->rowPtr[a->colIdx[l] + 1]; ++m) {\n                    if(b->colIdx[m] == j){\n                        sum += a->values[l] * b->values[m];\n                    }\n                }\n            }\n            if (sum != 0) {\n                c->colIdx[k] = j;\n                c->values[k] = sum;\n                k++;\n            }\n\n        }\n        c->rowPtr[i+1] = k;\n    }\n    return c;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_queue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        ADD      r1,r4,#8\n        STMIA    r1,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nenqueue__FP5queuei PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r5,[r4,#8]\n        LDR      r0,[r4,#0xc]\n        ADD      r1,r5,#1\n        BL       __rt_sdiv\n        LDR      r0,[r4,#4]\n        CMP      r1,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        STR      r6,[r0,r5,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#8]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5queuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMNEIB  r4,{r0,r2}\n        CMPNE    r0,r2\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,[r4,#0]\n        LDR      r0,[r2,r0,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#4]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndestroy_queue__FP5queue PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* data;\n    int head;\n    int tail;\n    int capacity;\n} queue;\n\nqueue* create_queue(int capacity) {\n    queue* q = (queue*)malloc(sizeof(queue));\n    if (q == NULL) return NULL;\n    q->data = (int*)malloc(capacity * sizeof(int));\n    if (q->data == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->head = 0;\n    q->tail = 0;\n    q->capacity = capacity;\n    return q;\n}\n\nint enqueue(queue* q, int value) {\n    if (q == NULL) return 0;\n    if ((q->tail + 1) % q->capacity == q->head) return 0; \n    q->data[q->tail] = value;\n    q->tail = (q->tail + 1) % q->capacity;\n    return 1;\n}\n\nint dequeue(queue* q, int* value) {\n    if (q == NULL || q->head == q->tail) return 0;\n    *value = q->data[q->head];\n    q->head = (q->head + 1) % q->capacity;\n    return 1;\n}\n\nvoid destroy_queue(queue* q) {\n    if (q == NULL) return;\n    free(q->data);\n    free(q);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsearch__FPiiN22 PROC\n        CMP      r1,r2\n        BGT      |L1.76|\n|L1.48|\n        LDR      r12,[r0,r1,LSL #2]\n        CMP      r12,r3\n        MOVEQ    r0,r1\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLE      |L1.48|\n|L1.76|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nbuildTree__FPiT1iT3 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r8,r0\n        MOV      r7,r1\n        MOV      r6,r3\n        MOV      r5,r2\n        CMP      r2,r3\n        LDMGTFD  sp!,{r3-r9,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r1,|L1.316|\n        LDR      r0,[r1,#0]  ; postIdx@buildTree__FPiT1iT3_0\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; postIdx@buildTree__FPiT1iT3_0\n        LDR      r0,[r7,r0,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        CMP      r5,r6\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r8\n        LDR      r3,[r4,#0]\n        BL       search__FPiiN22\n        MOV      r9,r0\n        ADD      r2,r0,#1\n        MOV      r0,r8\n        MOV      r3,r6\n        MOV      r1,r7\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#8]\n        MOV      r0,r8\n        SUB      r3,r9,#1\n        MOV      r2,r5\n        MOV      r1,r7\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint search(int inorder[], int start, int end, int value) {\n    for (int i = start; i <= end; i++) {\n        if (inorder[i] == value) return i;\n    }\n    return -1;\n}\n\nstruct Node* buildTree(int inorder[], int postorder[], int l, int r) {\n    static int postIdx = sizeof(postorder) / sizeof(postorder[0]) -1;\n    if (l > r) return NULL;\n\n    struct Node* node = newNode(postorder[postIdx--]);\n    if (l == r) return node;\n\n    int inIndex = search(inorder, l, r, node->data);\n    node->right = buildTree(inorder, postorder, inIndex + 1, r);\n    node->left = buildTree(inorder, postorder, l, inIndex - 1);\n    \n    return node;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringToInt__FPc PROC\n|L1.0|\n        LDRB     r3,[r0,#0]\n        MOV      r1,#0\n        MOV      r12,#1\n        CMP      r3,#0x2d\n        MOVEQ    r1,#1\n        LDRB     r3,[r0,r1]\n        MVNEQ    r12,#0\n        MOV      r2,#0\n        CMP      r3,#0\n        BEQ      |L1.96|\n|L1.40|\n        LDRB     r3,[r0,r1]\n        CMP      r3,#0x30\n        BCC      |L1.60|\n        CMP      r3,#0x39\n        BLS      |L1.68|\n|L1.60|\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r3,r2,LSL #1\n        ADD      r1,r1,#1\n        LDRB     r3,[r0,r1]\n        SUB      r2,r2,#0x30\n        CMP      r3,#0\n        BNE      |L1.40|\n|L1.96|\n        MUL      r0,r12,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint stringToInt(char *str) {\n    int sign = 1;\n    int result = 0;\n    int i = 0;\n\n    if (str[0] == '-') {\n        sign = -1;\n        i++;\n    }\n\n    for (; str[i] != '\\0'; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return 0; // Handle non-digit characters\n        }\n        result = result * 10 + (str[i] - '0');\n    }\n\n    return result * sign;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_number__Fi PROC\n        CMP      r0,#0\n        MOV      r12,#1\n        MVNLT    r12,#0\n        RSBLT    r0,r0,#0\n        CMP      r0,#0\n        STR      lr,[sp,#-4]!\n        MOV      r1,#0\n        BLE      |L1.88|\n        LDR      r3,|L1.140|\n|L1.36|\n        SMULL    lr,r2,r3,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r0,r2,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r2,r1,LSL #1\n        SMULL    r2,r0,r3,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        CMP      r0,#0\n        BGT      |L1.36|\n|L1.88|\n        LDR      lr,[sp],#4\n        MUL      r0,r12,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint reverse_number(int n) {\n    int reversed = 0;\n    int sign = 1;\n    if (n < 0) {\n        sign = -1;\n        n = -n;\n    }\n    while (n > 0) {\n        reversed = reversed * 10 + n % 10;\n        n /= 10;\n    }\n    return reversed * sign;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.408|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0xa\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP9HashTableiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       hash__Fi\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        STMIA    r0,{r6,r7}\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #2]\n        STR      r1,[r0,#8]\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nsearch__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r4,r1\n        BL       hash__Fi\n        LDR      r1,[r5,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.220|\n|L1.188|\n        LDR      r1,[r0,#0]\n        CMP      r1,r4\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.188|\n|L1.220|\n        LDMFD    sp!,{r4,r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nfreeHashTable__FP9HashTable PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r4,#0\n|L1.244|\n        LDR      r0,[r6,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.276|\n|L1.260|\n        LDR      r5,[r0,#8]\n        BL       free\n        MOVS     r0,r5\n        BNE      |L1.260|\n|L1.276|\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        BLT      |L1.244|\n        LDR      r0,[r6,#0]\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct Node {\n    int key;\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct HashTable {\n    Node** table;\n} HashTable;\n\nunsigned int hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    ht->table = (Node**)calloc(TABLE_SIZE, sizeof(Node*));\n    return ht;\n}\n\nvoid insert(HashTable* ht, int key, int value) {\n    unsigned int index = hash(key);\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->value = value;\n    newNode->next = ht->table[index];\n    ht->table[index] = newNode;\n}\n\nint search(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    Node* current = ht->table[index];\n    while (current != NULL) {\n        if (current->key == key) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return -1; \n}\n\nvoid freeHashTable(HashTable* ht) {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        Node* current = ht->table[i];\n        while (current != NULL) {\n            Node* next = current->next;\n            free(current);\n            current = next;\n        }\n    }\n    free(ht->table);\n    free(ht);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhanoi__FiN31 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r3\n        MOV      r5,r2\n        MOV      r4,r1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        SUB      r0,r0,#1\n        MOV      r7,r0\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r4\n        BL       hanoi__FiN31\n        MOV      r2,r5\n        MOV      r1,r4\n        ADR      r0,|L1.96|\n        BL       _printf\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r7\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        hanoi__FiN31\n|L1.96|\n        DCB      \"%d %\"\n        DCB      \"d\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid hanoi(int n, int source, int destination, int auxiliary) {\n    if (n > 0) {\n        hanoi(n - 1, source, auxiliary, destination);\n        printf(\"%d %d\\n\", source, destination);\n        hanoi(n - 1, auxiliary, destination, source);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nkthSmallest__FP4Nodei PROC\n        CMP      r0,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STR      lr,[sp,#-4]!\n        MOV      lr,#0\n        MOV      r3,#0\n|L1.24|\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        BNE      |L1.68|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        LDRNE    r0,[r0,#8]\n        BNE      |L1.128|\n        LDR      r0,[r0,#0]\n        LDR      lr,[sp],#4\n        BX       lr\n|L1.64|\n        MOV      r2,r12\n|L1.68|\n        LDR      r12,[r2,#8]\n        CMP      r12,#0\n        STREQ    r0,[r2,#8]\n        LDREQ    r0,[r0,#4]\n        BEQ      |L1.128|\n        CMP      r12,r0\n        BNE      |L1.64|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        STR      lr,[r2,#8]\n        LDRNE    r0,[r0,#8]\n        BNE      |L1.128|\n        LDR      r0,[r0,#0]\n        LDR      lr,[sp],#4\n        BX       lr\n|L1.128|\n        CMP      r0,#0\n        BNE      |L1.24|\n        LDR      lr,[sp],#4\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nint kthSmallest(Node* root, int k) {\n    if (root == NULL) return -1;\n\n    Node* curr = root;\n    int count = 0;\n    while (curr != NULL) {\n        if (curr->left == NULL) {\n            count++;\n            if (count == k) return curr->data;\n            curr = curr->right;\n        } else {\n            Node* pred = curr->left;\n            while (pred->right != NULL && pred->right != curr)\n                pred = pred->right;\n            if (pred->right == NULL) {\n                pred->right = curr;\n                curr = curr->left;\n            } else {\n                pred->right = NULL;\n                count++;\n                if (count == k) return curr->data;\n                curr = curr->right;\n            }\n        }\n\n    }\n\n    return -1; \n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewton__F9Equations5Point PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x34\n        ADD      r3,sp,#0x74\n        LDMIA    r3,{r0-r3}\n        ADD      r4,sp,#0x24\n        STMIA    r4,{r0-r3}\n        MOV      r6,#0\n|L1.32|\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r0-r3}\n        LDR      r12,[sp,#0x5c]\n        MOV      lr,pc\n        BX       r12\n        ADD      r2,sp,#0x1c\n        STMIA    r2,{r0,r1}\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r0-r3}\n        LDR      r12,[sp,#0x60]\n        MOV      lr,pc\n        BX       r12\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r0-r3}\n        LDR      r12,[sp,#0x64]\n        MOV      lr,pc\n        BX       r12\n        ADD      r2,sp,#0xc\n        STMIA    r2,{r0,r1}\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r0-r3}\n        LDR      r12,[sp,#0x68]\n        MOV      lr,pc\n        BX       r12\n        MOV      r11,r0\n        STR      r1,[sp,#8]\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r0-r3}\n        LDR      r12,[sp,#0x6c]\n        MOV      lr,pc\n        BX       r12\n        MOV      r9,r0\n        MOV      r10,r1\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r0-r3}\n        LDR      r12,[sp,#0x70]\n        MOV      lr,pc\n        BX       r12\n        MOV      r8,r1\n        MOV      r3,r1\n        ADD      r1,sp,#0xc\n        MOV      r7,r0\n        MOV      r2,r0\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        LDR      r1,[sp,#8]\n        MOV      r0,r11\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        ADR      r2,|L1.612|\n        MOV      r5,r1\n        BIC      r1,r1,#0x80000000\n        LDMIA    r2,{r2,r3}\n        MOV      r4,r0\n        BL       _dcmple\n        BCS      |L1.320|\n        ADD      r12,sp,#0x24\n        LDR      r0,[sp,#0x58]\n        LDMIA    r12,{r1-r3,lr}\n        STMIA    r0,{r1-r3,lr}\n|L1.304|\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.320|\n        ADD      r1,sp,#0x1c\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dmul\n        MOV      r8,r1\n        ADD      r1,sp,#0x14\n        MOV      r7,r0\n        LDMIA    r1,{r0,r1}\n        LDR      r3,[sp,#8]\n        MOV      r2,r11\n        BL       _dmul\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ddiv\n        MOV      r8,r1\n        ADD      r1,sp,#0x14\n        MOV      r7,r0\n        LDMIA    r1,{r0,r1}\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        STR      r1,[sp,#4]\n        ADD      r1,sp,#0x1c\n        MOV      r11,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r2,r11\n        LDR      r3,[sp,#4]\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ddiv\n        MOV      r5,r1\n        ADD      r1,sp,#0x24\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dsub\n        ADD      r9,sp,#0x24\n        STMIA    r9,{r0,r1}\n        ADD      r1,sp,#0x2c\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dsub\n        ADD      r2,sp,#0x2c\n        STMIA    r2,{r0,r1}\n        MOV      r0,r7\n        ADR      r7,|L1.612|\n        LDMIA    r7,{r2,r3}\n        BIC      r1,r8,#0x80000000\n        BL       _dcmple\n        BCS      |L1.580|\n        MOV      r0,r4\n        BIC      r1,r5,#0x80000000\n        LDMIA    r7,{r2,r3}\n        BL       _dcmple\n        BCC      |L1.592|\n|L1.580|\n        ADD      r6,r6,#1\n        CMP      r6,#0x64\n        BLT      |L1.32|\n|L1.592|\n        ADD      r12,sp,#0x24\n        LDR      r0,[sp,#0x58]\n        LDMIA    r12,{r1-r4}\n        STMIA    r0,{r1-r4}\n        B        |L1.304|\n|L1.612|\n        DCFD     0x3eb0c6f7a0b5ed8d\n        ENDP\n\nf1__F5Point PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r3\n        MOV      r4,r2\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        ADR      r2,|L1.676|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dsub\n|L1.676|\n        DCFD     0x4026000000000000\n        ENDP\n\nf2__F5Point PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r0,r2\n        MOV      r1,r3\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        ADR      r2,|L1.740|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dsub\n|L1.740|\n        DCFD     0x401c000000000000\n        ENDP\n\ndf1dx__F5Point PROC\n        ADR      r2,|L1.760|\n        LDMIA    r2,{r2,r3}\n        B        _dmul\n|L1.760|\n        DCFD     0x4000000000000000\n        ENDP\n\ndf1dy__F5Point PROC\n        ADR      r1,|L1.780|\n        LDMIA    r1,{r0,r1}\n        BX       lr\n|L1.780|\n        DCFD     0x3ff0000000000000\n        ENDP\n\ndf2dx__F5Point PROC\n        ADR      r1,|L1.780|\n        LDMIA    r1,{r0,r1}\n        BX       lr\n        ENDP\n\ndf2dy__F5Point PROC\n        MOV      r0,r2\n        ADR      r2,|L1.760|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        B        _dmul\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_ITER 100\n#define TOLERANCE 1e-6\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ntypedef struct {\n    double (*f1)(Point);\n    double (*f2)(Point);\n    double (*df1dx)(Point);\n    double (*df1dy)(Point);\n    double (*df2dx)(Point);\n    double (*df2dy)(Point);\n} Equations;\n\n\nPoint newton(Equations eqs, Point initial) {\n    Point x = initial;\n    Point dx;\n    double det;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        double f1 = eqs.f1(x);\n        double f2 = eqs.f2(x);\n        double df1dx = eqs.df1dx(x);\n        double df1dy = eqs.df1dy(x);\n        double df2dx = eqs.df2dx(x);\n        double df2dy = eqs.df2dy(x);\n\n        det = df1dx * df2dy - df1dy * df2dx;\n        if (fabs(det) < TOLERANCE) return x;\n\n        dx.x = (f1 * df2dy - f2 * df1dy) / det;\n        dx.y = (f2 * df1dx - f1 * df2dx) / det;\n\n\n        x.x -= dx.x;\n        x.y -= dx.y;\n\n        if (fabs(dx.x) < TOLERANCE && fabs(dx.y) < TOLERANCE) break;\n    }\n    return x;\n}\n\n\ndouble f1(Point p) { return p.x*p.x + p.y - 11; }\ndouble f2(Point p) { return p.x + p.y*p.y - 7; }\ndouble df1dx(Point p) { return 2*p.x; }\ndouble df1dy(Point p) { return 1; }\ndouble df2dx(Point p) { return 1; }\ndouble df2dy(Point p) { return 2*p.y; }\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmatrix_multiply__FPA10_dN21i PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#4\n        CMP      r3,#0\n        ADDLE    sp,sp,#0x14\n        MOV      r10,r1\n        MOV      r9,#0\n        MOV      r6,r3\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n|L1.36|\n        MOV      r5,#0\n        CMP      r6,#0\n        BLE      |L1.160|\n        LDR      r1,[sp,#4]\n        ADD      r0,r9,r9,LSL #2\n        ADD      r8,r1,r0,LSL #4\n        LDR      r1,[sp,#0xc]\n        ADD      r11,r1,r0,LSL #4\n|L1.68|\n        ADR      r1,|L1.184|\n        LDMIA    r1,{r0,r1}\n        ADD      r7,r11,r5,LSL #3\n        STMIA    r7,{r0,r1}\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.148|\n|L1.96|\n        ADD      r0,r4,r4,LSL #2\n        ADD      r0,r10,r0,LSL #4\n        ADD      r1,r0,r5,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r8,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDMIA    r7,{r2,r3}\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        STMIA    r7,{r0,r1}\n        BLT      |L1.96|\n|L1.148|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.68|\n|L1.160|\n        ADD      r9,r9,#1\n        CMP      r9,r6\n        BLT      |L1.36|\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.184|\n        DCFD     0x0000000000000000\n        ENDP\n\nmatrix_transpose__FPA10_dT1i PROC\n        STMFD    sp!,{r4-r6,lr}\n        CMP      r2,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOV      r12,#0\n        BXLE     lr\n|L1.212|\n        MOV      r3,#0\n        CMP      r2,#0\n        BLE      |L1.276|\n        ADD      lr,r12,r12,LSL #2\n        ADD      r6,r1,lr,LSL #4\n|L1.232|\n        ADD      r4,r3,r3,LSL #2\n        ADD      r4,r0,r4,LSL #4\n        ADD      r4,r4,r12,LSL #3\n        LDR      r5,[r4,#0]\n        ADD      lr,r6,r3,LSL #3\n        LDR      r4,[r4,#4]\n        ADD      r3,r3,#1\n        STR      r4,[lr,#4]\n        STR      r5,[lr,#0]\n        CMP      r3,r2\n        BLT      |L1.232|\n|L1.276|\n        ADD      r12,r12,#1\n        CMP      r12,r2\n        BLT      |L1.212|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndeterminant__FPA10_di PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r6,r0\n        MOV      r4,r1\n        CMP      r1,#1\n        LDMEQIA  r6,{r0,r1}\n        SUB      sp,sp,#0x32c\n        ADDEQ    sp,sp,#0x32c\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        CMP      r4,#2\n        BNE      |L1.404|\n        LDMIA    r6,{r0,r1}\n        ADD      r3,r6,#0x58\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        ADD      r6,r6,#8\n        LDMIA    r6!,{r0,r1}\n        ADD      r3,r6,#0x40\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        ADD      sp,sp,#0x32c\n        LDMFD    sp!,{r4-r11,lr}\n        B        _drsb\n|L1.404|\n        ADR      r0,|L1.184|\n        LDR      r1,[r0,#4]\n        LDR      r8,[r0,#0]\n        STR      r1,[sp,#0x324]\n        MOV      r7,#1\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.652|\n        SUB      r1,r4,#1\n        STR      r1,[sp,#0x328]\n|L1.444|\n        MOV      r9,#0\n        MOV      r12,#1\n        CMP      r4,#1\n        BLE      |L1.564|\n|L1.460|\n        MOV      r3,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.548|\n        ADD      r1,r12,r12,LSL #2\n        ADD      r10,r6,r1,LSL #4\n        ADD      r1,r9,r9,LSL #2\n        ADD      r2,sp,#4\n        ADD      r11,r2,r1,LSL #4\n|L1.496|\n        CMP      r0,r5\n        BEQ      |L1.536|\n        ADD      r2,r10,r0,LSL #3\n        LDR      lr,[r2,#0]\n        MOV      r1,r3\n        LDR      r2,[r2,#4]\n        ADD      r1,r11,r1,LSL #3\n        STR      r2,[r1,#4]\n        STR      lr,[r1,#0]\n        ADD      r3,r3,#1\n|L1.536|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.496|\n|L1.548|\n        ADD      r12,r12,#1\n        CMP      r12,r4\n        ADD      r9,r9,#1\n        BLT      |L1.460|\n|L1.564|\n        MOV      r0,r7\n        BL       _dflt\n        ADD      r2,r6,r5,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r9,r0\n        MOV      r10,r1\n        LDR      r1,[sp,#0x328]\n        ADD      r0,sp,#4\n        BL       determinant__FPA10_di\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r2,r8\n        LDR      r3,[sp,#0x324]\n        BL       _dadd\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        MOV      r8,r0\n        RSB      r7,r7,#0\n        STR      r1,[sp,#0x324]\n        BLT      |L1.444|\n|L1.652|\n        LDR      r1,[sp,#0x324]\n        ADD      sp,sp,#0x32c\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\ncofactor__FPA10_dT1i PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#0x328\n        MOV      r8,r0\n        MOV      r4,r2\n        CMP      r2,#1\n        BNE      |L1.732|\n        LDR      r1,[sp,#0x32c]\n        ADR      r0,|L1.1012|\n        LDR      r2,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[r1,#4]\n        STR      r2,[r1,#0]\n        ADD      sp,sp,#0x334\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.732|\n        CMP      r4,#0\n        ADDLE    sp,sp,#0x334\n        MOV      r7,#1\n        MOV      r6,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n        SUB      r1,r4,#1\n        STR      r1,[sp,#0x324]\n|L1.764|\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.988|\n        LDR      r1,[sp,#0x32c]\n        ADD      r0,r6,r6,LSL #2\n        ADD      r2,r1,r0,LSL #4\n        STR      r2,[sp,#0x320]\n|L1.792|\n        MOV      r9,#0\n        MOV      r3,#0\n        CMP      r4,#0\n        BLE      |L1.916|\n|L1.808|\n        CMP      r3,r6\n        BEQ      |L1.904|\n        MOV      r12,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.900|\n        ADD      r1,r3,r3,LSL #2\n        ADD      r10,r8,r1,LSL #4\n        ADD      r1,r9,r9,LSL #2\n        ADD      r11,sp,r1,LSL #4\n|L1.848|\n        CMP      r0,r5\n        BEQ      |L1.888|\n        ADD      r2,r10,r0,LSL #3\n        LDR      lr,[r2,#0]\n        MOV      r1,r12\n        LDR      r2,[r2,#4]\n        ADD      r1,r11,r1,LSL #3\n        STR      r2,[r1,#4]\n        STR      lr,[r1,#0]\n        ADD      r12,r12,#1\n|L1.888|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.848|\n|L1.900|\n        ADD      r9,r9,#1\n|L1.904|\n        ADD      r3,r3,#1\n        CMP      r3,r4\n        BLT      |L1.808|\n|L1.916|\n        MOV      r0,r7\n        BL       _dflt\n        MOV      r9,r0\n        MOV      r10,r1\n        LDR      r1,[sp,#0x324]\n        MOV      r0,sp\n        BL       determinant__FPA10_di\n        LDR      r2,[sp,#0x320]\n        MOV      r3,r10\n        ADD      r12,r2,r5,LSL #3\n        MOV      r2,r9\n        MOV      r9,r12\n        BL       _dmul\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        RSB      r7,r7,#0\n        STMIA    r9,{r0,r1}\n        BLT      |L1.792|\n|L1.988|\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        BLT      |L1.764|\n        ADD      sp,sp,#0x334\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.1012|\n        DCFD     0x3ff0000000000000\n        ENDP\n\ninverse__FPA10_dT1i PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#0x640\n        MOV      r5,r2\n        MOV      r4,r0\n        MOV      r1,r2\n        BL       determinant__FPA10_di\n        ADR      r2,|L1.1244|\n        MOV      r9,r1\n        BIC      r1,r1,#0x80000000\n        LDMIA    r2,{r2,r3}\n        MOV      r8,r0\n        BL       _dcmple\n        ADDCC    sp,sp,#0x400\n        ADDCC    sp,sp,#0x24c\n        LDMCCFD  sp!,{r4-r11,lr}\n        BXCC     lr\n        ADD      r6,sp,#0x320\n        MOV      r1,r6\n        MOV      r2,r5\n        MOV      r0,r4\n        BL       cofactor__FPA10_dT1i\n        MOV      r2,r5\n        MOV      r4,sp\n        MOV      r1,sp\n        MOV      r0,r6\n        BL       matrix_transpose__FPA10_dT1i\n        CMP      r5,#0\n        ADDLE    sp,sp,#0x400\n        ADDLE    sp,sp,#0x24c\n        MOV      r7,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n|L1.1148|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.1216|\n        ADD      r0,r7,r7,LSL #2\n        LDR      r1,[sp,#0x644]\n        ADD      r11,sp,r0,LSL #4\n        ADD      r10,r1,r0,LSL #4\n|L1.1176|\n        ADD      r0,r11,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        ADD      r6,r10,r4,LSL #3\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        STMIA    r6,{r0,r1}\n        BLT      |L1.1176|\n|L1.1216|\n        ADD      r7,r7,#1\n        CMP      r7,r5\n        BLT      |L1.1148|\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#0x24c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.1244|\n        DCFD     0x3eb0c6f7a0b5ed8d\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_SIZE 10\n\nvoid matrix_multiply(double a[][MAX_SIZE], double b[][MAX_SIZE], double c[][MAX_SIZE], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            c[i][j] = 0;\n            for (int k = 0; k < n; k++) {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }\n    }\n}\n\nvoid matrix_transpose(double a[][MAX_SIZE], double b[][MAX_SIZE], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            b[i][j] = a[j][i];\n        }\n    }\n}\n\ndouble determinant(double a[][MAX_SIZE], int n) {\n    if (n == 1) return a[0][0];\n    if (n == 2) return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    double det = 0;\n    double submatrix[MAX_SIZE][MAX_SIZE];\n    int sign = 1;\n    for (int i = 0; i < n; i++) {\n        int subi = 0;\n        for (int j = 1; j < n; j++) {\n            int subj = 0;\n            for (int k = 0; k < n; k++) {\n                if (k == i) continue;\n                submatrix[subi][subj++] = a[j][k];\n            }\n            subi++;\n        }\n        det += sign * a[0][i] * determinant(submatrix, n - 1);\n        sign *= -1;\n    }\n    return det;\n}\n\n\nvoid cofactor(double a[][MAX_SIZE], double b[][MAX_SIZE], int n){\n    if(n == 1){\n        b[0][0] = 1;\n        return;\n    }\n    double submatrix[MAX_SIZE][MAX_SIZE];\n    int sign = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            int subi = 0;\n            for(int k = 0; k < n; k++){\n                if(k == i) continue;\n                int subj = 0;\n                for(int l = 0; l < n; l++){\n                    if(l == j) continue;\n                    submatrix[subi][subj++] = a[k][l];\n                }\n                subi++;\n            }\n            b[i][j] = sign * determinant(submatrix, n - 1);\n            sign *= -1;\n        }\n    }\n}\n\n\nvoid inverse(double a[][MAX_SIZE], double b[][MAX_SIZE], int n) {\n    double det = determinant(a, n);\n    if (abs(det) < 1e-6) return;\n    double cof[MAX_SIZE][MAX_SIZE];\n    cofactor(a, cof,n);\n    double adj[MAX_SIZE][MAX_SIZE];\n    matrix_transpose(cof, adj, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            b[i][j] = adj[i][j] / det;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndot_product__FPiT1i PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r12,#0\n        MOV      r3,#0\n        CMP      r2,#0\n        BLE      |L1.44|\n|L1.20|\n        LDR      lr,[r0,r3,LSL #2]\n        LDR      r4,[r1,r3,LSL #2]\n        ADD      r3,r3,#1\n        CMP      r3,r2\n        MLA      r12,r4,lr,r12\n        BLT      |L1.20|\n|L1.44|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint dot_product(int* v1, int* v2, int size) {\n    int result = 0;\n    for (int i = 0; i < size; i++) {\n        result += v1[i] * v2[i];\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhanoi__FiN31 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r3\n        MOV      r5,r2\n        MOV      r4,r1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        SUB      r0,r0,#1\n        MOV      r7,r0\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r4\n        BL       hanoi__FiN31\n        MOV      r2,r5\n        MOV      r1,r4\n        ADR      r0,|L1.96|\n        BL       _printf\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r7\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        hanoi__FiN31\n|L1.96|\n        DCB      \"%d %\"\n        DCB      \"d\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid hanoi(int n, int src, int dest, int aux) {\n    if (n > 0) {\n        hanoi(n - 1, src, aux, dest);\n        printf(\"%d %d\\n\", src, dest);\n        hanoi(n - 1, aux, dest, src);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsigmoid__Fd PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        EOR      r1,r1,#0x80000000\n        BL       __softfp_exp\n        ADR      r4,|L1.36|\n        LDMIA    r4,{r2,r3}\n        BL       _dadd\n        LDMIA    r4,{r2,r3}\n        LDMFD    sp!,{r4,lr}\n        B        _drdiv\n|L1.36|\n        DCFD     0x3ff0000000000000\n        ENDP\n\ncost_function__FPC9DataPointidT3 PROC\n        STMFD    sp!,{r0-r11,lr}\n        ADR      r0,|L1.296|\n        LDMIA    r0,{r5,r6}\n        SUB      sp,sp,#0xc\n        MOV      r9,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        BLE      |L1.268|\n|L1.76|\n        LDR      r0,[sp,#0xc]\n        ADD      r1,sp,#0x40\n        ADD      r10,r0,r4,LSL #4\n        LDMIA    r10,{r2,r3}\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        ADD      r3,sp,#0x14\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        BL       sigmoid__Fd\n        MOV      r8,r1\n        ADD      r10,r10,#8\n        LDR      r1,[r10,#4]\n        LDR      r11,[r10,#0]\n        EOR      r1,r1,#0x80000000\n        STR      r1,[sp,#0]\n        MOV      r1,r8\n        MOV      r7,r0\n        BL       __softfp_log\n        MOV      r2,r11\n        LDR      r3,[sp,#0]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        ADR      r0,|L1.36|\n        LDMIA    r0,{r2,r3}\n        LDMIA    r10,{r0,r1}\n        BL       _drsb\n        MOV      r10,r0\n        ADR      r0,|L1.36|\n        LDMIA    r0,{r2,r3}\n        MOV      r11,r1\n        MOV      r1,r8\n        MOV      r0,r7\n        BL       _drsb\n        BL       __softfp_log\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r9\n        MOV      r5,r0\n        MOV      r6,r1\n        BLT      |L1.76|\n|L1.268|\n        MOV      r0,r9\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        B        _drdiv\n|L1.296|\n        DCFD     0x0000000000000000\n        ENDP\n\nlogistic_regression__FPC9DataPointiPdT3 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x3c\n        LDR      r2,[sp,#0x44]\n        ADR      r3,|L1.296|\n        LDMIA    r3,{r0,r1}\n        STMIA    r2,{r0,r1}\n        LDR      r2,[sp,#0x48]\n        LDMIA    r3,{r0,r1}\n        STMIA    r2,{r0,r1}\n        LDMIA    r3,{r8,r9}\n        MOV      r0,#0\n        ADD      r1,sp,#0x18\n        STMIA    r1,{r0,r8,r9}\n        LDR      r0,[sp,#0x40]\n        BL       _dflt\n        STR      r0,[sp,#0x38]\n        STR      r1,[sp,#0x34]\n|L1.372|\n        ADR      r0,|L1.296|\n        LDR      r1,[r0,#4]\n        LDR      r2,[r0,#0]\n        STR      r1,[sp,#0x14]\n        STR      r2,[sp,#0x10]\n        LDR      r1,[r0,#4]\n        LDR      r11,[r0,#0]\n        STR      r1,[sp,#0xc]\n        LDMIA    r0,{r8,r9}\n        LDR      r0,[sp,#0x40]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.708|\n|L1.424|\n        LDR      r0,[sp,#0x3c]\n        ADD      r7,r0,r4,LSL #4\n        LDMIA    r7,{r2,r3}\n        LDR      r0,[sp,#0x48]\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDR      r2,[sp,#0x44]\n        LDMIA    r2,{r2,r3}\n        BL       _dadd\n        BL       sigmoid__Fd\n        LDR      r3,[r7,#0xc]\n        MOV      r5,r0\n        STR      r3,[sp,#0x30]\n        LDR      r2,[r7,#8]\n        MOV      r6,r1\n        ADD      r10,r7,#8\n        STR      r2,[sp,#0x2c]\n        BL       _dsub\n        STR      r0,[sp,#0x28]\n        STR      r1,[sp,#0x24]\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        ADD      r2,sp,#0x10\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x28]\n        LDR      r1,[sp,#0x24]\n        LDMIA    r7,{r2,r3}\n        BL       _dmul\n        MOV      r2,r11\n        LDR      r3,[sp,#0xc]\n        BL       _dadd\n        STR      r1,[sp,#0xc]\n        LDR      r1,[sp,#0x30]\n        MOV      r11,r0\n        EOR      r1,r1,#0x80000000\n        STR      r1,[sp,#0]\n        MOV      r1,r6\n        MOV      r0,r5\n        LDR      r7,[sp,#0x2c]\n        BL       __softfp_log\n        MOV      r2,r7\n        LDR      r3,[sp,#0]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        ADR      r0,|L1.36|\n        LDMIA    r0,{r2,r3}\n        LDMIA    r10,{r0,r1}\n        BL       _drsb\n        MOV      r7,r0\n        ADR      r0,|L1.36|\n        LDMIA    r0,{r2,r3}\n        MOV      r10,r1\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       _drsb\n        BL       __softfp_log\n        MOV      r3,r10\n        MOV      r2,r7\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        MOV      r8,r0\n        LDR      r0,[sp,#0x40]\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        MOV      r9,r1\n        BLT      |L1.424|\n|L1.708|\n        LDR      r0,[sp,#0x38]\n        LDR      r1,[sp,#0x34]\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        ADR      r4,|L1.948|\n        LDMIA    r4,{r2,r3}\n        BL       _dmul\n        LDR      r2,[sp,#0x44]\n        LDMIA    r2,{r2,r3}\n        BL       _drsb\n        LDR      r2,[sp,#0x44]\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x38]\n        LDR      r1,[sp,#0x34]\n        LDR      r3,[sp,#0xc]\n        MOV      r2,r11\n        BL       _drdiv\n        LDMIA    r4,{r2,r3}\n        BL       _dmul\n        LDR      r2,[sp,#0x48]\n        LDMIA    r2,{r2,r3}\n        BL       _drsb\n        LDR      r2,[sp,#0x48]\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x18]\n        CMP      r0,#0\n        BLE      |L1.908|\n        MOV      r3,r9\n        MOV      r2,r8\n        LDR      r0,[sp,#0x38]\n        LDR      r1,[sp,#0x34]\n        BL       _drdiv\n        MOV      r4,r0\n        MOV      r5,r1\n        LDR      r1,[sp,#0x34]\n        LDR      r0,[sp,#0x38]\n        ADD      r3,sp,#0x1c\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        ADR      r2,|L1.956|\n        LDMIA    r2,{r2,r3}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmple\n        ADDCC    sp,sp,#0x4c\n        LDMCCFD  sp!,{r4-r11,lr}\n        BXCC     lr\n|L1.908|\n        ADD      r0,sp,#0x1c\n        STMIA    r0,{r8,r9}\n        LDR      r0,[sp,#0x18]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0x18]\n        CMP      r0,#0x3e8\n        BLT      |L1.372|\n        ADD      sp,sp,#0x4c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.948|\n        DCFD     0x3f847ae147ae147b\n|L1.956|\n        DCFD     0x3eb0c6f7a0b5ed8d\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_ITER 1000\n#define LEARNING_RATE 0.01\n#define CONVERGENCE_THRESHOLD 1e-6\n\nstruct DataPoint {\n    double x;\n    double y;\n};\n\ndouble sigmoid(double z) {\n    return 1.0 / (1.0 + exp(-z));\n}\n\ndouble cost_function(const DataPoint* data, int n, double theta0, double theta1) {\n    double cost = 0.0;\n    for (int i = 0; i < n; ++i) {\n        double prediction = sigmoid(theta0 + theta1 * data[i].x);\n        cost += -data[i].y * log(prediction) - (1.0 - data[i].y) * log(1.0 - prediction);\n    }\n    return cost / n;\n}\n\n\nvoid logistic_regression(const DataPoint* data, int n, double* theta0, double* theta1) {\n    *theta0 = 0.0;\n    *theta1 = 0.0;\n\n    double prev_cost = 0;\n    for (int iter = 0; iter < MAX_ITER; ++iter) {\n        double theta0_grad = 0.0;\n        double theta1_grad = 0.0;\n        double current_cost = 0.0;\n\n        for (int i = 0; i < n; ++i) {\n            double prediction = sigmoid(*theta0 + *theta1 * data[i].x);\n            theta0_grad += (prediction - data[i].y);\n            theta1_grad += (prediction - data[i].y) * data[i].x;\n            current_cost += -data[i].y * log(prediction) - (1.0 - data[i].y) * log(1.0 - prediction);\n        }\n\n        *theta0 -= LEARNING_RATE * (theta0_grad / n);\n        *theta1 -= LEARNING_RATE * (theta1_grad / n);\n\n        if (iter > 0 && fabs(current_cost/n - prev_cost/n) < CONVERGENCE_THRESHOLD) break;\n        prev_cost = current_cost;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsetBit__FUiT1 PROC\n        MOV      r2,#1\n        ORR      r0,r0,r2,LSL r1\n        BX       lr\n        ENDP\n\nclearBit__FUiT1 PROC\n        MOV      r2,#1\n        BIC      r0,r0,r2,LSL r1\n        BX       lr\n        ENDP\n\ntoggleBit__FUiT1 PROC\n        MOV      r2,#1\n        EOR      r0,r0,r2,LSL r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int setBit(unsigned int num, unsigned int bit) {\n    return num | (1 << bit);\n}\n\nunsigned int clearBit(unsigned int num, unsigned int bit) {\n    return num & ~(1 << bit);\n}\n\nunsigned int toggleBit(unsigned int num, unsigned int bit) {\n    return num ^ (1 << bit);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__F8FractionT1 PROC\n|L1.0|\n        LDR      r12,[sp,#0]\n        MUL      r1,r12,r1\n        MLA      r1,r2,r3,r1\n        MUL      r2,r12,r2\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n\nsubtract__F8FractionT1 PROC\n        LDR      r12,[sp,#0]\n        MUL      r3,r2,r3\n        MUL      r1,r12,r1\n        SUB      r1,r1,r3\n        MUL      r2,r12,r2\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n\nmultiply__F8FractionT1 PROC\n        LDR      r12,[sp,#0]\n        MUL      r1,r3,r1\n        MUL      r2,r12,r2\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n\ndivide__F8FractionT1 PROC\n        LDR      r12,[sp,#0]\n        MUL      r2,r3,r2\n        MUL      r1,r12,r1\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int num;\n    int den;\n} Fraction;\n\nFraction add(Fraction f1, Fraction f2) {\n    Fraction result;\n    result.num = f1.num * f2.den + f2.num * f1.den;\n    result.den = f1.den * f2.den;\n    return result;\n}\n\nFraction subtract(Fraction f1, Fraction f2) {\n    Fraction result;\n    result.num = f1.num * f2.den - f2.num * f1.den;\n    result.den = f1.den * f2.den;\n    return result;\n}\n\nFraction multiply(Fraction f1, Fraction f2) {\n    Fraction result;\n    result.num = f1.num * f2.num;\n    result.den = f1.den * f2.den;\n    return result;\n}\n\nFraction divide(Fraction f1, Fraction f2) {\n    Fraction result;\n    result.num = f1.num * f2.den;\n    result.den = f1.den * f2.num;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncoinChange__FiPiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r6,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MVNEQ    r0,#0\n        BXEQ     lr\n        MOV      r0,#4\n        ADD      r0,r0,r4,LSL #2\n        BL       malloc\n        MOV      r1,#0\n        CMP      r4,#0\n        BLT      |L1.88|\n        ADD      r2,r4,#1\n|L1.72|\n        STR      r2,[r0,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLE      |L1.72|\n|L1.88|\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        MOV      r1,#1\n        CMP      r4,#1\n        BLT      |L1.180|\n|L1.108|\n        MOV      r2,#0\n        CMP      r5,#0\n        BLE      |L1.168|\n|L1.120|\n        LDR      r3,[r6,r2,LSL #2]\n        SUBS     r12,r1,r3\n        BMI      |L1.156|\n        LDR      r12,[r0,r12,LSL #2]\n        LDR      r3,[r0,r1,LSL #2]\n        ADD      r12,r12,#1\n        CMP      r3,r12\n        MOVGE    r3,r12\n        STR      r3,[r0,r1,LSL #2]\n|L1.156|\n        ADD      r2,r2,#1\n        CMP      r2,r5\n        BLT      |L1.120|\n|L1.168|\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLE      |L1.108|\n|L1.180|\n        LDR      r1,[r0,r4,LSL #2]\n        CMP      r1,r4\n        MVNGT    r1,#0\n        MOV      r4,r1\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint coinChange(int amount, int* coins, int coinsSize) {\n    if (amount == 0) return 0;\n    if (coins == 0 || coinsSize == 0) return -1;\n\n    int* dp = (int*)malloc((amount + 1) * sizeof(int));\n    for (int i = 0; i <= amount; i++) dp[i] = amount + 1;\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; i++) {\n        for (int j = 0; j < coinsSize; j++) {\n            if (i - coins[j] >= 0) {\n                dp[i] = (dp[i] < dp[i - coins[j]] + 1) ? dp[i] : dp[i - coins[j]] + 1;\n            }\n        }\n    }\n\n    int result = dp[amount] > amount ? -1 : dp[amount];\n    free(dp);\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_sorted__FPii PROC\n|L1.0|\n        CMP      r1,#1\n        MOVLE    r0,#1\n        BXLE     lr\n        MOV      r2,#1\n|L1.16|\n        LDR      r3,[r0,r2,LSL #2]\n        ADD      r12,r0,r2,LSL #2\n        LDR      r12,[r12,#-4]\n        CMP      r3,r12\n        MOVLT    r0,#0\n        BXLT     lr\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.16|\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_sorted(int arr[], int len) {\n    if (len <= 1) return 1;\n    for (int i = 1; i < len; i++) {\n        if (arr[i] < arr[i - 1]) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfilter_words__FPA50_cicT1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r11,r2\n        MOV      r10,r3\n        MOV      r9,r1\n        MOV      r6,r0\n        MOV      r5,#0\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r3-r11,lr}\n        BXLE     lr\n|L1.40|\n        ADD      r7,r4,r4,LSL #3\n        ADD      r7,r7,r4,LSL #4\n        LDRB     r0,[r6,r7,LSL #1]\n        BL       tolower\n        MOV      r8,r0\n        MOV      r0,r11\n        BL       tolower\n        CMP      r8,r0\n        BNE      |L1.100|\n        ADD      r0,r5,r5,LSL #3\n        ADD      r0,r0,r5,LSL #4\n        ADD      r0,r10,r0,LSL #1\n        ADD      r1,r6,r7,LSL #1\n        BL       strcpy\n        ADD      r5,r5,#1\n|L1.100|\n        ADD      r4,r4,#1\n        CMP      r4,r9\n        BLT      |L1.40|\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid filter_words(char words[][50], int num_words, char start_char, char output[][50]) {\n    int output_index = 0;\n    for (int i = 0; i < num_words; i++) {\n        if (tolower(words[i][0]) == tolower(start_char)) {\n            strcpy(output[output_index], words[i]);\n            output_index++;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r1\n        LDMEQFD  sp!,{r4,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.88|\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.104|\n|L1.88|\n        BGE      |L1.104|\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.104|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nclosestValue__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        LDR      lr,[r0,#0]\n        SUB      r12,lr,r1\n        CMP      r12,#0\n        RSBLT    r12,r12,#0\n        CMP      r0,#0\n        BEQ      |L1.208|\n|L1.144|\n        LDR      r3,[r0,#0]\n        SUB      r4,r3,r1\n        MOV      r2,r4\n        CMP      r4,#0\n        RSBLT    r2,r2,#0\n        CMP      r2,r12\n        BGE      |L1.180|\n        MOV      r12,r2\n        MOV      lr,r3\n|L1.180|\n        CMP      r3,r1\n        LDRGT    r0,[r0,#4]\n        BGT      |L1.200|\n        BGE      |L1.208|\n        LDR      r0,[r0,#8]\n|L1.200|\n        CMP      r0,#0\n        BNE      |L1.144|\n|L1.208|\n        MOV      r0,lr\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) return newNode(data);\n    if (data < node->data)\n        node->left  = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    return node;\n}\n\nint closestValue(struct Node* root, int target) {\n    int closest = root->data;\n    int diff = abs(root->data - target);\n\n    while (root != NULL) {\n        if (abs(root->data - target) < diff) {\n            diff = abs(root->data - target);\n            closest = root->data;\n        }\n        if (target < root->data)\n            root = root->left;\n        else if (target > root->data)\n            root = root->right;\n        else\n            break;\n    }\n    return closest;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerate_image__FiN21 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r9,r0\n        MUL      r6,r2,r1\n        MOV      r0,r6,LSL #2\n        MOV      r8,r2\n        MOV      r7,r1\n        MOV      r4,r3\n        BL       malloc\n        MOVS     r5,r0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r0,r4\n        BL       srand\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.100|\n|L1.64|\n        BL       rand\n        MOV      r1,r0,ASR #31\n        ADD      r1,r0,r1,LSR #24\n        MOV      r1,r1,ASR #8\n        SUB      r0,r0,r1,LSL #8\n        STR      r0,[r5,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r6,r4\n        BGT      |L1.64|\n|L1.100|\n        STMIA    r9,{r7,r8}\n        STR      r5,[r9,#8]\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n//Simplified GAN structure -  No actual neural network implementation.  Simulates output.\ntypedef struct {\n    int width;\n    int height;\n    int* data; //Simplified representation: integer values for pixel intensities\n} Image;\n\nImage generate_image(int width, int height, int seed) {\n    Image img;\n    img.width = width;\n    img.height = height;\n    img.data = (int*)malloc(width * height * sizeof(int));\n    if (img.data == NULL) {\n        exit(1); //Error handling: Exit if malloc fails.\n    }\n\n    srand(seed); // Seed the random number generator.\n    for (int i = 0; i < width * height; i++) {\n        img.data[i] = rand() % 256; //Generate random pixel intensities.\n    }\n    return img;\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x14\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#8]\n        STR      r5,[r4,#4]\n        STR      r0,[r4,#0xc]\n        MVN      r0,#0\n        STR      r0,[r4,#0x10]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#8]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        LDMIB    r0,{r0,r1}\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r4,#0x10]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#4]\n        BL       __rt_sdiv\n        STR      r1,[r4,#0x10]\n        LDR      r0,[r4,#0]\n        STR      r5,[r0,r1,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5QueuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r4,#0]\n        LDR      r2,[r4,#0xc]\n        LDR      r0,[r0,r2,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#0xc]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#4]\n        BL       __rt_sdiv\n        STR      r1,[r4,#0xc]\n        LDR      r0,[r4,#8]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\npeek__FP5QueuePi PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r2,#0]\n        LDR      r2,[r2,#0xc]\n        LDR      r0,[r0,r2,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndeleteQueue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* arr;\n    int capacity;\n    int size;\n    int head;\n    int tail;\n} Queue;\n\n\nQueue* createQueue(int capacity) {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    if (q == NULL) return NULL;\n    q->arr = (int*)malloc(capacity * sizeof(int));\n    if (q->arr == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->capacity = capacity;\n    q->size = 0;\n    q->head = 0;\n    q->tail = -1;\n    return q;\n}\n\nint isEmpty(Queue* q) {\n    return q->size == 0;\n}\n\nint isFull(Queue* q) {\n    return q->size == q->capacity;\n}\n\nint enqueue(Queue* q, int item) {\n    if (isFull(q)) return 0;\n    q->tail = (q->tail + 1) % q->capacity;\n    q->arr[q->tail] = item;\n    q->size++;\n    return 1;\n}\n\nint dequeue(Queue* q, int* item) {\n    if (isEmpty(q)) return 0;\n    *item = q->arr[q->head];\n    q->head = (q->head + 1) % q->capacity;\n    q->size--;\n    return 1;\n}\n\nint peek(Queue* q, int* item) {\n    if (isEmpty(q)) return 0;\n    *item = q->arr[q->head];\n    return 1;\n}\n\nvoid deleteQueue(Queue* q) {\n    free(q->arr);\n    free(q);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompareStrings__FPcT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x6c\n        MOV      r6,r1\n        MOV      r5,r0\n        BL       strlen\n        MOV      r4,r0\n        MOV      r0,r6\n        BL       strlen\n        CMP      r4,r0\n        ADDNE    sp,sp,#0x6c\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r7,sp,#4\n        MOV      r0,r7\n        MOV      r1,#0x68\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.132|\n|L1.80|\n        LDRB     r1,[r5,r0]\n        ADD      r1,r7,r1,LSL #2\n        LDR      r2,[r1,#-0x184]!\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        LDRB     r1,[r6,r0]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        ADD      r1,r7,r1,LSL #2\n        LDR      r2,[r1,#-0x184]!\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0]\n        BLT      |L1.80|\n|L1.132|\n        MOV      r0,#0\n|L1.136|\n        LDR      r1,[r7,r0,LSL #2]\n        CMP      r1,#0\n        ADDNE    sp,sp,#0x6c\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r0,r0,#1\n        CMP      r0,#0x1a\n        BLT      |L1.136|\n        ADD      sp,sp,#0x6c\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint compareStrings(char* a, char* b) {\n    int la = strlen(a);\n    int lb = strlen(b);\n    if (la != lb) return 0;\n    int letters[26] = {0};\n    for (int i = 0; i < la; i++) {\n        letters[a[i] - 'a']++;\n        letters[b[i] - 'a']--;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (letters[i] != 0) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmysqrt__Fd PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADR      r4,|L1.240|\n        LDMIA    r4,{r2,r3}\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       _dcmple\n        ADRCC    r1,|L1.248|\n        LDMCCIA  r1,{r0,r1}\n        LDMCCFD  sp!,{r3-r11,lr}\n        BXCC     lr\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMIA    r4,{r2,r3}\n        BL       _dcmpeq\n        LDMEQIA  r4,{r0,r1}\n        LDMEQFD  sp!,{r3-r11,lr}\n        BXEQ     lr\n        MOV      r4,r8\n        MOV      r5,r9\n        ADR      r0,|L1.256|\n        LDMIA    r0,{r6,r7}\n        ADR      r10,|L1.272|\n        ADR      r11,|L1.264|\n        B        |L1.160|\n|L1.96|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dadd\n        LDMIA    r11,{r2,r3}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       _ddiv\n        MOV      r6,r0\n        MOV      r7,r1\n|L1.160|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dsub\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpge\n        BHI      |L1.96|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dsub\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpge\n        BHI      |L1.96|\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.240|\n        DCFD     0x0000000000000000\n|L1.248|\n        DCFD     0xbff0000000000000\n|L1.256|\n        DCFD     0x3ff0000000000000\n|L1.264|\n        DCFD     0x3fe0000000000000\n|L1.272|\n        DCFD     0x3ee4f8b588e368f1\n        ENDP\n```",
        "output": "```cpp\n\ndouble mysqrt(double n) {\n    if (n < 0) return -1; // Handle negative input.  Could throw an exception in a more robust implementation.\n    if (n == 0) return 0;\n    double x = n;\n    double y = 1;\n    while (x - y > 0.00001 || y - x > 0.00001) {\n        x = (x + y) / 2;\n        y = n / x;\n    }\n    return x;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.708|\n        MOV      r1,r0\n        LDR      r0,[r2,#0]  ; top\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0]  ; top\n        LDR      r2,|L1.712|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.708|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.712|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\ndfs1__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r7,|L1.716|\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r8,|L1.720|\n        STR      r0,[r7,r5,LSL #2]\n        LDR      r0,[r8,#0]  ; num_vertices\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.160|\n        ADD      r1,r5,r5,LSL #3\n        LDR      r0,|L1.724|\n        ADD      r1,r1,r5,LSL #4\n        ADD      r6,r0,r1,LSL #4\n|L1.116|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.144|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        BLEQ     dfs1__Fi\n|L1.144|\n        LDR      r0,[r8,#0]  ; num_vertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.116|\n|L1.160|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        B        push__Fi\n        ENDP\n\ndfs2__FiPi PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r7,|L1.716|\n        MOV      r5,r1\n        MOV      r1,#1\n        STR      r1,[r7,r0,LSL #2]\n        LDR      r8,|L1.720|\n        STR      r1,[r5,r0,LSL #2]\n        LDR      r1,[r8,#0]  ; num_vertices\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.728|\n        ADD      r6,r0,r1,LSL #4\n|L1.236|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.268|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r1,r5\n        MOVEQ    r0,r4\n        BLEQ     dfs2__FiPi\n|L1.268|\n        LDR      r0,[r8,#0]  ; num_vertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.236|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nfind_strongly_connected_components__FiPA100_iPPi PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r4,r1\n        LDR      r1,|L1.720|\n        LDR      r6,|L1.716|\n        STR      r0,[r1,#0]  ; num_vertices\n        MOV      r7,r0\n        MOV      r0,r6\n        MOV      r1,#0x190\n        MOV      r5,r2\n        BL       __rt_memclr_w\n        MOV      r1,#0x190\n        LDR      r0,|L1.712|\n        BL       __rt_memclr_w\n        LDR      r8,|L1.708|\n        MVN      r0,#0\n        LDR      r9,|L1.724|\n        STR      r0,[r8,#0]  ; top\n        MOV      r2,#0x1c40\n        ADD      r2,r2,#0x8000\n        MOV      r0,r9\n        MOV      r1,r4\n        BL       __rt_memcpy_w\n        MOV      r4,#0\n        CMP      r7,#0\n        BLE      |L1.428|\n        LDR      r7,|L1.720|\n|L1.396|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        BLEQ     dfs1__Fi\n        LDR      r0,[r7,#0]  ; num_vertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.396|\n|L1.428|\n        LDR      r1,|L1.720|\n        MOV      r0,#0\n        LDR      r4,[r1,#0]  ; num_vertices\n        CMP      r4,#0\n        BLE      |L1.520|\n        LDR      r1,|L1.728|\n|L1.452|\n        MOV      r2,#0\n        CMP      r4,#0\n        BLE      |L1.508|\n        ADD      r3,r0,r0,LSL #3\n        ADD      r3,r3,r0,LSL #4\n        ADD      r3,r1,r3,LSL #4\n|L1.476|\n        ADD      r12,r2,r2,LSL #3\n        ADD      r12,r12,r2,LSL #4\n        ADD      r12,r9,r12,LSL #4\n        LDR      r12,[r12,r0,LSL #2]\n        STR      r12,[r3,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r2,r4\n        BLT      |L1.476|\n|L1.508|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.452|\n|L1.520|\n        MOV      r1,#0x190\n        MOV      r0,r6\n        BL       __rt_memclr_w\n        MOV      r0,r4,LSL #2\n        BL       malloc\n        STR      r0,[r5,#0]\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        LDR      r0,[r8,#0]  ; top\n        CMP      r0,#0\n        LDMLTFD  sp!,{r3-r9,lr}\n        BXLT     lr\n|L1.572|\n        BL       pop__Fv\n        LDR      r1,[r6,r0,LSL #2]\n        CMP      r1,#0\n        LDREQ    r1,[r5,#0]\n        BLEQ     dfs2__FiPi\n        LDR      r0,[r8,#0]  ; top\n        CMP      r0,#0\n        BGE      |L1.572|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint stack[MAX_VERTICES];\nint top = -1;\nint adj[MAX_VERTICES][MAX_VERTICES];\nint transpose[MAX_VERTICES][MAX_VERTICES];\nint num_vertices;\n\n\nvoid push(int v) {\n    stack[++top] = v;\n}\n\nint pop() {\n    return stack[top--];\n}\n\nvoid dfs1(int v) {\n    visited[v] = 1;\n    for (int i = 0; i < num_vertices; i++) {\n        if (adj[v][i] && !visited[i]) {\n            dfs1(i);\n        }\n    }\n    push(v);\n}\n\n\nvoid dfs2(int v, int* component) {\n    visited[v] = 1;\n    component[v] = 1;\n    for (int i = 0; i < num_vertices; i++) {\n        if (transpose[v][i] && !visited[i]) {\n            dfs2(i, component);\n        }\n    }\n}\n\nvoid find_strongly_connected_components(int num_vertices_input, int adj_matrix[][MAX_VERTICES], int** components) {\n    num_vertices = num_vertices_input;\n    memset(visited, 0, sizeof(visited));\n    memset(stack, 0, sizeof(stack));\n    top = -1;\n    memcpy(adj, adj_matrix, sizeof(adj));\n\n    for (int i = 0; i < num_vertices; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    for (int i = 0; i < num_vertices; i++) {\n        for (int j = 0; j < num_vertices; j++) {\n            transpose[i][j] = adj[j][i];\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n\n    *components = (int*)malloc(num_vertices * sizeof(int));\n    if (*components == NULL) exit(1);\n\n    int component_id = 0;\n    while (top >= 0) {\n        int v = pop();\n        if (!visited[v]) {\n            component_id++;\n            dfs2(v, *components);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r)\n        printf(\"%s\\n\", a);\n    else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i)); \n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndist__F5PointT1 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADD      r7,sp,#0x20\n        MOV      r9,r3\n        MOV      r8,r2\n        LDMIA    r7,{r2,r3,r6,r7}\n        BL       _dsub\n        MOV      r4,r0\n        MOV      r0,#2\n        MOV      r5,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __softfp_pow\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dsub\n        MOV      r6,r0\n        MOV      r0,#2\n        MOV      r7,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       __softfp_pow\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        LDMFD    sp!,{r3-r9,lr}\n        B        __softfp_sqrt\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point {\n    double x, y;\n};\n\ndouble dist(Point p1, Point p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsertAtBeginning__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STRNE    r0,[r1,#8]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ninsertAtEnd__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        MOV      r2,#0\n        STR      r2,[r0,#4]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r2,[r0,#8]\n        STREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        BEQ      |L1.176|\n|L1.160|\n        LDR      r1,[r1,#4]\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.160|\n|L1.176|\n        STR      r0,[r1,#4]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ndeleteAtBeginning__FP16DoublyLinkedList PROC\n        LDR      r2,[r0,#0]\n        CMP      r2,#0\n        BXEQ     lr\n        LDR      r1,[r2,#4]\n        STR      r1,[r0,#0]\n        CMP      r1,#0\n        MOVNE    r0,#0\n        STRNE    r0,[r1,#8]\n        MOV      r0,r2\n        B        free\n        ENDP\n\ndeleteAtEnd__FP16DoublyLinkedList PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r1,[r0,#4]\n        MOV      r5,#0\n        CMP      r1,#0\n        BNE      |L1.288|\n        BL       free\n        STR      r5,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.288|\n        LDR      r0,[r0,#4]\n        LDR      r1,[r0,#4]\n        CMP      r1,#0\n        BNE      |L1.288|\n        LDR      r1,[r0,#8]\n        STR      r5,[r1,#4]\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\nstruct DoublyLinkedList {\n    struct Node* head;\n};\n\n\nstruct DoublyLinkedList* createList() {\n    struct DoublyLinkedList* list = (struct DoublyLinkedList*)malloc(sizeof(struct DoublyLinkedList));\n    list->head = NULL;\n    return list;\n}\n\nvoid insertAtBeginning(struct DoublyLinkedList* list, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = list->head;\n    newNode->prev = NULL;\n    if (list->head != NULL)\n        list->head->prev = newNode;\n    list->head = newNode;\n}\n\nvoid insertAtEnd(struct DoublyLinkedList* list, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    if (list->head == NULL) {\n        newNode->prev = NULL;\n        list->head = newNode;\n        return;\n    }\n    struct Node* lastNode = list->head;\n    while (lastNode->next != NULL)\n        lastNode = lastNode->next;\n    lastNode->next = newNode;\n    newNode->prev = lastNode;\n}\n\n\nvoid deleteAtBeginning(struct DoublyLinkedList* list) {\n    if (list->head == NULL) return;\n    struct Node* temp = list->head;\n    list->head = list->head->next;\n    if (list->head != NULL)\n        list->head->prev = NULL;\n    free(temp);\n}\n\n\nvoid deleteAtEnd(struct DoublyLinkedList* list) {\n    if (list->head == NULL) return;\n    if (list->head->next == NULL) {\n        free(list->head);\n        list->head = NULL;\n        return;\n    }\n    struct Node* lastNode = list->head;\n    while (lastNode->next != NULL)\n        lastNode = lastNode->next;\n    lastNode->prev->next = NULL;\n    free(lastNode);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r6,r0\n        BL       strlen\n        MOV      r8,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r3-r9,lr}\n        MOVLE    r0,#1\n        BXLE     lr\n        SUB      r4,r8,#1\n        CMP      r4,#0\n        MOV      r5,#0\n        BLE      |L1.196|\n        BL       __rt_ctype_table\n        MOV      r7,r0\n        B        |L1.64|\n|L1.60|\n        ADD      r5,r5,#1\n|L1.64|\n        CMP      r5,r8\n        BGE      |L1.100|\n        LDRB     r1,[r6,r5]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.60|\n        B        |L1.100|\n|L1.96|\n        SUB      r4,r4,#1\n|L1.100|\n        CMP      r4,#0\n        BLT      |L1.128|\n        LDRB     r1,[r6,r4]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.96|\n|L1.128|\n        CMP      r5,r4\n        LDMGEFD  sp!,{r3-r9,lr}\n        MOVGE    r0,#1\n        BXGE     lr\n        LDRB     r0,[r6,r5]\n        BL       tolower\n        MOV      r9,r0\n        LDRB     r0,[r6,r4]\n        BL       tolower\n        CMP      r9,r0\n        LDMNEFD  sp!,{r3-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        CMP      r5,r4\n        BLT      |L1.64|\n|L1.196|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    if (len <= 1) return 1;\n    int left = 0;\n    int right = len -1;\n    while (left < right) {\n        while (left < len && !isalnum(str[left])) left++;\n        while (right >=0 && !isalnum(str[right])) right--;\n        if (left >= right) return 1;\n        if (tolower(str[left]) != tolower(str[right])) return 0;\n        left++;\n        right--;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValid__FiN31 PROC\n|L1.0|\n        CMP      r0,#0\n        BLT      |L1.60|\n        CMP      r0,r2\n        BGE      |L1.60|\n        CMP      r1,#0\n        BLT      |L1.60|\n        CMP      r1,r3\n        BGE      |L1.60|\n        LDR      r2,|L1.544|\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r2,r0,LSL #3\n        LDR      r0,[r0,r1,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.60|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfindPaths__FiN31PcT1 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x34\n        MOV      r8,r1\n        LDR      r1,[sp,#0x34]\n        SUB      r0,r2,#1\n        CMP      r0,r1\n        ADD      r11,sp,#0x68\n        MOV      r10,r3\n        SUBEQ    r0,r10,#1\n        CMPEQ    r0,r8\n        LDMIA    r11,{r5,r11}\n        MOV      r9,r2\n        BNE      |L1.176|\n        MOV      r0,#0\n        LDR      r1,|L1.548|\n        STRB     r0,[r5,r11]\n        LDR      r0,[r1,#0]  ; pathCount\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; pathCount\n        LDR      r1,|L1.552|\n        ADD      r12,r0,r0,LSL #3\n        ADD      r0,r12,r0,LSL #4\n        ADD      r0,r1,r0,LSL #2\n        MOV      r1,r5\n        ADD      sp,sp,#0x44\n        LDMFD    sp!,{r4-r11,lr}\n        B        strcpy\n|L1.176|\n        LDR      r1,[sp,#0x34]\n        MOV      r0,#1\n        ADD      r2,r1,r1,LSL #2\n        LDR      r1,|L1.544|\n        ADD      lr,sp,#0xc\n        ADD      r1,r1,r2,LSL #3\n        STR      r1,[sp,#0x30]\n        STR      r0,[r1,r8,LSL #2]\n        LDR      r1,|L1.556|\n        ADD      r0,sp,#0x1c\n        LDMIA    r1,{r2-r4,r6}\n        STMIA    r0,{r2-r4,r6}\n        LDR      r1,|L1.560|\n        LDMIA    r1,{r2-r4,r6}\n        STMIA    lr,{r2-r4,r6}\n        LDR      r1,|L1.564|\n        ADD      r3,r11,#1\n        LDR      r1,[r1,#0]  ; <Anon4_line_32>\n        STR      r3,[sp,#0x2c]\n        MOV      r4,#0\n        STR      r1,[sp,#8]\n|L1.260|\n        ADD      r0,sp,#0x1c\n        LDR      r0,[r0,r4,LSL #2]\n        LDR      r1,[sp,#0x34]\n        MOV      r3,r10\n        ADD      r6,r0,r1\n        ADD      r0,sp,#0xc\n        LDR      r0,[r0,r4,LSL #2]\n        MOV      r2,r9\n        ADD      r7,r0,r8\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       isValid__FiN31\n        CMP      r0,#0\n        BEQ      |L1.360|\n        ADD      r0,sp,#8\n        LDRB     r0,[r0,r4]\n        MOV      r2,r9\n        MOV      r1,r7\n        STRB     r0,[r5,r11]\n        LDR      r3,[sp,#0x2c]\n        STR      r5,[sp,#0]\n        STR      r3,[sp,#4]\n        MOV      r3,r10\n        MOV      r0,r6\n        BL       findPaths__FiN31PcT1\n|L1.360|\n        ADD      r4,r4,#1\n        CMP      r4,#4\n        BLT      |L1.260|\n        LDR      r1,[sp,#0x30]\n        MOV      r0,#0\n        STR      r0,[r1,r8,LSL #2]\n        ADD      sp,sp,#0x44\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_PATH 1000\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint maze[10][10];\nint pathCount = 0;\nchar paths[MAX_PATH][100];\n\n\nint isValid(int x, int y, int rows, int cols) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && maze[x][y] == 0;\n}\n\nvoid findPaths(int x, int y, int rows, int cols, char path[], int pathIndex) {\n    if (x == rows - 1 && y == cols - 1) {\n        path[pathIndex] = '\\0';\n        strcpy(paths[pathCount++], path);\n        return;\n    }\n\n    maze[x][y] = 1; \n\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    char dir[] = {'R', 'L', 'D', 'U'};\n\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx[i];\n        int newY = y + dy[i];\n        if (isValid(newX, newY, rows, cols)) {\n            path[pathIndex] = dir[i];\n            findPaths(newX, newY, rows, cols, path, pathIndex + 1);\n        }\n    }\n\n    maze[x][y] = 0; \n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n|L1.0|\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        LDR      r0,[r0,#0xc]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.328|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.328|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.360|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.388|\n|L1.360|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.388|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        BLE      |L1.460|\n        LDR      r1,[r4,#0xc]\n        LDR      r1,[r1,#0]\n        CMP      r1,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n|L1.460|\n        CMN      r0,#1\n        BGE      |L1.496|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        B        |L1.548|\n|L1.496|\n        CMP      r0,#1\n        BLE      |L1.540|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.584|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.540|\n        CMN      r0,#1\n        BGE      |L1.584|\n|L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.584|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.584|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbuildAvlTreeFromSorted__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BXLE     lr\n|L1.628|\n        LDR      r1,[r6,r4,LSL #2]\n        BL       insert__FP4Nodei\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.628|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    return N ? N->height : 0;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    return height(N->right) - height(N->left);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else \n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n\n    if (balance > 1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance < -1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance > 1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    if (balance < -1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    return node;\n}\n\nNode* buildAvlTreeFromSorted(int arr[], int n) {\n    Node* root = NULL;\n    for (int i = 0; i < n; i++)\n        root = insert(root, arr[i]);\n    return root;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npolygonArea__FP5Pointi PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r8,r0\n        ADR      r0,|L1.168|\n        LDMIA    r0,{r4,r5}\n        MOV      r7,r1\n        MOV      r6,#0\n        CMP      r1,#0\n        BLE      |L1.140|\n|L1.32|\n        ADD      r1,r6,#1\n        MOV      r10,r1\n        MOV      r0,r7\n        BL       __rt_sdiv\n        ADD      r11,r8,r1,LSL #4\n        ADD      r3,r11,#8\n        LDMIA    r3,{r2,r3}\n        ADD      r6,r8,r6,LSL #4\n        LDMIA    r6,{r0,r1}\n        BL       _dmul\n        MOV      r9,r0\n        STR      r1,[sp,#0]\n        LDMIA    r11,{r0,r1}\n        ADD      r3,r6,#8\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r2,r9\n        LDR      r3,[sp,#0]\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r6,r10\n        CMP      r10,r7\n        BLT      |L1.32|\n|L1.140|\n        ADR      r2,|L1.176|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        MOV      r0,r4\n        BIC      r1,r5,#0x80000000\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dmul\n|L1.168|\n        DCFD     0x0000000000000000\n|L1.176|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point {\n    double x, y;\n};\n\ndouble polygonArea(Point* points, int numPoints) {\n    double area = 0.0;\n    for (int i = 0; i < numPoints; ++i) {\n        area += (points[i].x * points[(i + 1) % numPoints].y -\n                 points[(i + 1) % numPoints].x * points[i].y);\n    }\n    return fabs(area) / 2.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FxT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        ADR      r0,|L1.96|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        MOVEQ    r1,r7\n        MOVEQ    r0,r6\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_sdiv\n        MOV      r1,r5\n        MOV      r0,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        gcd__FxT1\n|L1.96|\n        DCQ      0x0000000000000000\n        ENDP\n\nlcm__FxT1 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADR      r8,|L1.96|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r7,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r6,r0\n        BEQ      |L1.164|\n        LDMIA    r8,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BNE      |L1.176|\n|L1.164|\n        LDMIA    r8,{r0,r1}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.176|\n        UMULL    r8,r12,r6,r4\n        MLA      r12,r4,r7,r12\n        MLA      r9,r5,r6,r12\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       gcd__FxT1\n        MOV      r3,r9\n        MOV      r2,r8\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _ll_srdv\n        ENDP\n```",
        "output": "```cpp\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nlong long lcm(long long a, long long b) {\n    if (a == 0 || b == 0) return 0;\n    return (a * b) / gcd(a, b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhandle_error__Fi PROC\n|L1.0|\n        CMP      r0,#1\n        ADREQ    r0,|L1.28|\n        BEQ      _printf\n        CMP      r0,#2\n        ADREQ    r0,|L1.56|\n        ADRNE    r0,|L1.80|\n        B        _printf\n|L1.28|\n        DCB      \"Erro\"\n        DCB      \"r 1:\"\n        DCB      \" Div\"\n        DCB      \"isio\"\n        DCB      \"n by\"\n        DCB      \" zer\"\n        DCB      \"o\\n\\0\\0\"\n|L1.56|\n        DCB      \"Erro\"\n        DCB      \"r 2:\"\n        DCB      \" Out\"\n        DCB      \" of \"\n        DCB      \"boun\"\n        DCB      \"ds\\n\\0\"\n|L1.80|\n        DCB      \"Unkn\"\n        DCB      \"own \"\n        DCB      \"erro\"\n        DCB      \"r\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid handle_error(int error_code) {\n    switch (error_code) {\n        case 1:\n            printf(\"Error 1: Division by zero\\n\");\n            break;\n        case 2:\n            printf(\"Error 2: Out of bounds\\n\");\n            break;\n        default:\n            printf(\"Unknown error\\n\");\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nprojectPointOntoPlane__F5Point5Plane PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        ADD      r9,sp,#0x4c\n        LDMIA    r9,{r4-r9}\n        ADD      r3,sp,#0x34\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dmul\n        ADD      r3,sp,#0x3c\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        ADD      r3,sp,#0x44\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        ADD      r3,sp,#0x64\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        STMIB    sp,{r0,r1}\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        BL       __softfp_sqrt\n        LDMIB    sp,{r2,r3}\n        BL       _drdiv\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        ADD      r3,sp,#0x34\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        ADD      r3,sp,#0x3c\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        ADD      r3,sp,#0x44\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        LDR      r2,[sp,#0x30]\n        STMIA    r2,{r4-r7}\n        ADD      r3,r2,#0x10\n        STMIA    r3,{r0,r1}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point {\n    double x, y, z;\n};\n\nstruct Plane {\n    double a, b, c, d;\n};\n\nPoint projectPointOntoPlane(Point p, Plane plane) {\n    double v = plane.a * p.x + plane.b * p.y + plane.c * p.z + plane.d;\n    double dist = v / sqrt(plane.a * plane.a + plane.b * plane.b + plane.c * plane.c);\n    Point projectedPoint;\n    projectedPoint.x = p.x - dist * plane.a;\n    projectedPoint.y = p.y - dist * plane.b;\n    projectedPoint.z = p.z - dist * plane.c;\n    return projectedPoint;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhasCycleUtil__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r0\n        LDR      r8,|L1.320|\n        MOV      r0,#1\n        STR      r0,[r8,r5,LSL #2]\n        MOV      r7,r1\n        ADD      r1,r5,r5,LSL #3\n        LDR      r0,|L1.324|\n        ADD      r1,r1,r5,LSL #4\n        ADD      r6,r0,r1,LSL #4\n        MOV      r4,#0\n|L1.44|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.100|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       hasCycleUtil__FiT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n        B        |L1.116|\n|L1.100|\n        CMP      r4,r7\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.116|\n        ADD      r4,r4,#1\n        CMP      r4,#0x64\n        BLT      |L1.44|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nhasCycle__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r6,|L1.320|\n        MOV      r5,r0\n        MOV      r0,r6\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.228|\n|L1.176|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.216|\n        MVN      r1,#0\n        MOV      r0,r4\n        BL       hasCycleUtil__FiT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.216|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.176|\n|L1.228|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_VERTICES 100\n\nint graph[MAX_VERTICES][MAX_VERTICES];\nint visited[MAX_VERTICES];\n\nint hasCycleUtil(int v, int parent) {\n    visited[v] = 1;\n    for (int i = 0; i < MAX_VERTICES; i++) {\n        if (graph[v][i]) {\n            if (!visited[i]) {\n                if (hasCycleUtil(i, v))\n                    return 1;\n            } else if (i != parent)\n                return 1;\n        }\n    }\n    return 0;\n}\n\n\nint hasCycle(int V) {\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            if (hasCycleUtil(i, -1))\n                return 1;\n        }\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncollaborativeFiltering__FP9DataPointiN22 PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        MOV      r6,r1\n        ADR      r1,|L1.676|\n        MOV      r4,r0\n        LDR      r0,[r1,#4]\n        LDR      r2,[r1,#0]\n        SUB      sp,sp,#0x2c\n        STR      r0,[sp,#0x1c]\n        STR      r2,[sp,#0x18]\n        LDR      r0,[r1,#4]\n        LDR      r2,[r1,#0]\n        STR      r0,[sp,#0x14]\n        STR      r2,[sp,#0x10]\n        LDMIA    r1,{r0,r1}\n        ADD      r2,sp,#8\n        STMIA    r2,{r0,r1}\n        CMP      r6,#0\n        MOV      r7,#0\n        MOV      r5,#0\n        BLE      |L1.180|\n|L1.80|\n        LDR      r0,[r4,r5,LSL #4]\n        LDR      r2,[sp,#0x34]\n        CMP      r0,r2\n        BNE      |L1.132|\n        ADD      r0,r4,r5,LSL #4\n        ADD      r0,r0,#8\n        LDMIA    r0,{r2,r3}\n        ADD      r1,sp,#8\n        LDMIA    r1,{r0,r1}\n        BL       _dadd\n        ADD      r2,sp,#8\n        STMIA    r2,{r0,r1}\n        ADD      r7,r7,#1\n|L1.132|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.80|\n        CMP      r7,#0\n        BLE      |L1.180|\n        MOV      r0,r7\n        BL       _dflt\n        ADD      r3,sp,#8\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        ADD      r2,sp,#8\n        STMIA    r2,{r0,r1}\n|L1.180|\n        MOV      r10,#0\n        CMP      r6,#0\n        BLE      |L1.604|\n|L1.192|\n        LDR      r1,[r4,r10,LSL #4]\n        LDR      r2,[sp,#0x34]\n        STR      r1,[sp,#0x28]\n        CMP      r1,r2\n        BEQ      |L1.592|\n        ADD      r0,r4,r10,LSL #4\n        STR      r0,[sp,#0x24]\n        LDR      r2,[r0,#4]\n        LDR      r0,[sp,#0x38]\n        STR      r2,[sp,#0x20]\n        CMP      r2,r0\n        BNE      |L1.592|\n        ADR      r1,|L1.676|\n        LDR      r0,[r1,#4]\n        LDR      r11,[r1,#0]\n        STR      r0,[sp,#4]\n        MOV      r0,#0\n        STR      r0,[sp,#0]\n        LDMIA    r1,{r7,r8}\n        MOV      r9,#0\n        MOV      r5,#0\n        CMP      r6,#0\n        BLE      |L1.384|\n|L1.284|\n        LDR      r0,[r4,r5,LSL #4]\n        LDR      r1,[sp,#0x28]\n        CMP      r0,r1\n        BNE      |L1.336|\n        ADD      r0,r4,r5,LSL #4\n        ADD      r0,r0,#8\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r7\n        MOV      r1,r8\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n        ADD      r9,r9,#1\n|L1.336|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.284|\n        CMP      r9,#0\n        BLE      |L1.384|\n        MOV      r0,r9\n        BL       _dflt\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _drdiv\n        MOV      r7,r0\n        MOV      r8,r1\n|L1.384|\n        MOV      r0,#0\n        CMP      r6,#0\n        BLE      |L1.456|\n|L1.396|\n        LDR      r1,[r4,r0,LSL #4]\n        LDR      r2,[sp,#0x34]\n        CMP      r1,r2\n        BNE      |L1.444|\n        ADD      r1,r4,r0,LSL #4\n        LDR      r1,[r1,#4]\n        LDR      r2,[sp,#0x20]\n        CMP      r1,r2\n        LDREQ    r0,[sp,#0]\n        ADDEQ    r0,r0,#1\n        STREQ    r0,[sp,#0]\n        BEQ      |L1.456|\n|L1.444|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.396|\n|L1.456|\n        LDR      r0,[sp,#0]\n        CMP      r0,#0\n        BLE      |L1.484|\n        ADR      r0,|L1.684|\n        LDR      r11,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[sp,#4]\n|L1.484|\n        ADR      r1,|L1.676|\n        LDMIA    r1,{r2,r3}\n        LDR      r1,[sp,#4]\n        MOV      r0,r11\n        BL       _dcmpge\n        BLS      |L1.592|\n        ADD      r1,sp,#0x18\n        LDMIA    r1,{r0,r1}\n        LDR      r3,[sp,#4]\n        MOV      r2,r11\n        BL       _dadd\n        ADD      r2,sp,#0x18\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x24]\n        MOV      r2,r7\n        ADD      r0,r0,#8\n        LDMIA    r0,{r0,r1}\n        MOV      r3,r8\n        BL       _dsub\n        MOV      r2,r11\n        LDR      r3,[sp,#4]\n        BL       _dmul\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        ADD      r2,sp,#0x10\n        STMIA    r2,{r0,r1}\n|L1.592|\n        ADD      r10,r10,#1\n        CMP      r10,r6\n        BLT      |L1.192|\n|L1.604|\n        ADR      r1,|L1.676|\n        LDMIA    r1,{r2,r3}\n        ADD      r1,sp,#0x18\n        LDMIA    r1,{r0,r1}\n        BL       _dcmpge\n        ADDLS    r1,sp,#8\n        LDMLSIA  r1,{r0,r1}\n        ADDLS    sp,sp,#0x3c\n        LDMLSFD  sp!,{r4-r11,lr}\n        BXLS     lr\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r0-r3}\n        BL       _ddiv\n        ADD      r3,sp,#8\n        LDMIA    r3,{r2,r3}\n        ADD      sp,sp,#0x3c\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dadd\n|L1.676|\n        DCFD     0x0000000000000000\n|L1.684|\n        DCFD     0x3ff0000000000000\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct DataPoint {\n    int userId;\n    int itemId;\n    double rating;\n};\n\n\ndouble collaborativeFiltering(struct DataPoint* data, int dataSize, int userId, int itemId) {\n    double sum_sim = 0;\n    double sum_weighted_rating = 0;\n    double avg_rating = 0;\n    int count = 0;\n\n\n    for (int i = 0; i < dataSize; i++){\n        if (data[i].userId == userId){\n            avg_rating += data[i].rating;\n            count++;\n        }\n    }\n    if (count > 0) avg_rating /= count;\n\n\n    for (int i = 0; i < dataSize; i++) {\n        if (data[i].userId != userId && data[i].itemId == itemId) {\n            double similarity = 0;\n            double userRating = 0;\n            int common_items = 0;\n            double userAvg = 0;\n            int userCount = 0;\n\n\n            for (int k = 0; k < dataSize; k++){\n                if (data[k].userId == data[i].userId){\n                    userAvg += data[k].rating;\n                    userCount++;\n                }\n            }\n            if(userCount > 0) userAvg /= userCount;\n\n\n            for (int j = 0; j < dataSize; j++) {\n                if (data[j].userId == userId && data[j].itemId == data[i].itemId) {\n                    userRating = data[j].rating;\n                    common_items++;\n                    break;\n                }\n            }\n\n\n            if (common_items > 0) {\n                similarity = 1.0; \n            }\n\n\n            if (similarity > 0) {\n                sum_sim += similarity;\n                sum_weighted_rating += similarity * (data[i].rating - userAvg);\n            }\n        }\n    }\n\n\n    if (sum_sim > 0) {\n        return avg_rating + sum_weighted_rating / sum_sim;\n    } else {\n        return avg_rating;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntoLower__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDRNEB   r0,[r5,#0]\n        MOVNE    r4,#0\n        CMPNE    r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n|L1.28|\n        LDRB     r0,[r5,r4]\n        BL       tolower\n        STRB     r0,[r5,r4]\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.28|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid toLower(char* str) {\n    if (str == 0) return;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = tolower(str[i]);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.292|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.292|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.324|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.352|\n|L1.324|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.352|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        SUB      r0,r1,r0\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.472|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.524|\n|L1.472|\n        CMP      r0,#1\n        BLE      |L1.516|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.560|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.516|\n        CMN      r0,#1\n        BGE      |L1.560|\n|L1.524|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.560|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.560|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = height(node->left) - height(node->right);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fci PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        MOV      r5,r1\n        BL       malloc\n        STRB     r4,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#0xc]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nminHeap__FPP4nodei PROC\n        STMFD    sp!,{r4,r5,lr}\n        LDR      r3,[r0,#0]\n        MOV      r12,#0\n        MOV      r2,#1\n        CMP      r1,#1\n        BLE      |L1.108|\n|L1.72|\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r4,[lr,#0]\n        LDR      r5,[r3,#0]\n        CMP      r4,r5\n        MOVLT    r12,r2\n        ADD      r2,r2,#1\n        MOVLT    r3,lr\n        CMP      r2,r1\n        BLT      |L1.72|\n|L1.108|\n        ADD      r1,r0,r1,LSL #2\n        LDR      r1,[r1,#-4]\n        STR      r1,[r0,r12,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r3\n        BX       lr\n        ENDP\n\nbuildHuffmanTree__FPcPii PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r0,r2,LSL #2\n        MOV      r8,r1\n        MOV      r6,r2\n        BL       malloc\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.200|\n|L1.172|\n        LDR      r1,[r8,r4,LSL #2]\n        LDRB     r0,[r7,r4]\n        BL       newNode__Fci\n        STR      r0,[r5,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.172|\n|L1.200|\n        CMP      r6,#1\n        BEQ      |L1.292|\n|L1.208|\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       minHeap__FPP4nodei\n        MOV      r4,r0\n        SUB      r7,r6,#1\n        MOV      r1,r7\n        MOV      r0,r5\n        BL       minHeap__FPP4nodei\n        MOV      r6,r0\n        LDR      r0,[r4,#0]\n        LDR      r1,[r6,#0]\n        SUB      r7,r7,#1\n        ADD      r1,r0,r1\n        MOV      r0,#0x24\n        BL       newNode__Fci\n        ADD      r1,r0,#8\n        STMIA    r1,{r4,r6}\n        ADD      r6,r7,#1\n        CMP      r6,#1\n        STR      r0,[r5,r7,LSL #2]\n        BNE      |L1.208|\n|L1.292|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int freq;\n    char ch;\n    struct node *left, *right;\n};\n\nstruct node* newNode(char ch, int freq) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->ch = ch;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct node* minHeap(struct node** harr, int heapSize) {\n    struct node* min = harr[0];\n    int min_idx = 0;\n    for (int i = 1; i < heapSize; i++) {\n        if (harr[i]->freq < min->freq) {\n            min = harr[i];\n            min_idx = i;\n        }\n    }\n    harr[min_idx] = harr[heapSize - 1];\n    return min;\n}\n\nvoid buildHuffmanTree(char data[], int freq[], int size) {\n    struct node** harr = (struct node**)malloc(size * sizeof(struct node*));\n    for (int i = 0; i < size; i++)\n        harr[i] = newNode(data[i], freq[i]);\n    int heapSize = size;\n    while (heapSize != 1) {\n        struct node* left = minHeap(harr, heapSize);\n        heapSize--;\n        struct node* right = minHeap(harr, heapSize);\n        heapSize--;\n        struct node* top = newNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        harr[heapSize] = top;\n        heapSize++;\n    }\n    free(harr);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbinaryToDecimal__FUx PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.144|\n        LDMIA    r10,{r8,r9}\n        MOV      r4,r0\n        ADR      r0,|L1.152|\n        LDMIA    r0,{r6,r7}\n        MOV      r0,r4\n        MOV      r2,r8\n        CMP      r1,r9\n        CMPEQ    r0,r2\n        MOV      r5,r1\n        BLS      |L1.128|\n|L1.48|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _ll_udiv10\n        MOV      r4,r0\n        MOV      r0,r2\n        UMULL    lr,r12,r0,r6\n        MOV      r5,r1\n        MOV      r1,r3\n        MLA      r12,r6,r1,r12\n        MLA      r3,r7,r2,r12\n        ADDS     r8,r8,lr\n        ADC      r9,r9,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r1,r7,LSL #1\n        ORR      r7,r1,r6,LSR #31\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r6,LSL #1\n        BHI      |L1.48|\n|L1.128|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.144|\n        DCQ      0x0000000000000000\n|L1.152|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long binaryToDecimal(unsigned long long n) {\n    unsigned long long decimal = 0;\n    unsigned long long base = 1;\n    while (n > 0) {\n        decimal += (n % 10) * base;\n        base *= 2;\n        n /= 10;\n    }\n    return decimal;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmodpow__FUxN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r4,r2\n        ADR      r2,|L1.240|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.240|\n        LDMIA    r2,{r8,r9}\n        MOV      r5,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r6,r2\n        MOV      r7,r3\n        ADR      r0,|L1.248|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BLS      |L1.224|\n|L1.76|\n        ADR      r0,|L1.256|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _ll_udiv\n        MOV      r0,r2\n        ADR      r2,|L1.240|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.156|\n        UMULL    r0,r12,r8,r6\n        MLA      r12,r6,r9,r12\n        MLA      r1,r7,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.156|\n        UMULL    r0,r12,r6,r6\n        MLA      r12,r6,r7,r12\n        MLA      r1,r7,r6,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r0,r4,LSR #1\n        ORR      r4,r0,r5,LSL #31\n        ADR      r0,|L1.248|\n        MOV      r6,r2\n        MOV      r7,r3\n        LDMIA    r0,{r2,r3}\n        MOV      r5,r5,LSR #1\n        CMP      r5,r3\n        MOV      r0,r4\n        CMPEQ    r0,r2\n        BHI      |L1.76|\n|L1.224|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.240|\n        DCQ      0x0000000000000001\n|L1.248|\n        DCQ      0x0000000000000000\n|L1.256|\n        DCQ      0x0000000000000002\n        ENDP\n\ndiffieHellman__FUxN31PUx PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        ADD      r10,sp,#0x30\n        LDMIA    r10,{r6,r7,r10}\n        LDR      r11,[sp,#0x40]\n        STMIA    sp,{r0,r1}\n        MOV      r9,r3\n        MOV      r8,r2\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r0,r8\n        MOV      r1,r9\n        MOV      r2,r6\n        MOV      r3,r7\n        BL       modpow__FUxN21\n        STMIA    sp,{r4,r5}\n        LDR      r3,[sp,#0x3c]\n        MOV      r2,r10\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       modpow__FUxN21\n        MOV      r3,r7\n        MOV      r2,r6\n        STMIA    sp,{r4,r5}\n        BL       modpow__FUxN21\n        STMIA    r11,{r0,r1}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long modpow(unsigned long long base, unsigned long long exp, unsigned long long modulus) {\n    unsigned long long result = 1;\n    base %= modulus;\n    while (exp > 0) {\n        if (exp % 2 == 1) result = (result * base) % modulus;\n        base = (base * base) % modulus;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid diffieHellman(unsigned long long p, unsigned long long g, unsigned long long a, unsigned long long b, unsigned long long *sharedSecret) {\n    unsigned long long A = modpow(g, a, p);\n    unsigned long long B = modpow(g, b, p);\n    *sharedSecret = modpow(B, a, p);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerateSubsets__FPcUiPPPcPUi PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r9,r0\n        MOV      r0,#1\n        MOV      r8,r0,LSL r1\n        MOV      r0,r8,LSL #2\n        MOV      r7,r2\n        MOV      r6,r1\n        MOV      r4,r3\n        BL       malloc\n        STR      r0,[r7,#0]\n        STR      r8,[r4,#0]\n        MOV      r4,#0\n        CMP      r8,#0\n        LDMLSFD  sp!,{r4-r10,lr}\n        BXLS     lr\n        MOV      r10,#0\n|L1.64|\n        MOV      r5,#0\n        MOV      r0,#0\n        CMP      r6,#0\n        BLS      |L1.104|\n|L1.80|\n        MOV      r1,r4,LSR r0\n        TST      r1,#1\n        ADDNE    r5,r5,#1\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BCC      |L1.80|\n|L1.104|\n        ADD      r0,r5,#1\n        BL       malloc\n        LDR      r1,[r7,#0]\n        MOV      r2,#0\n        STR      r0,[r1,r4,LSL #2]\n        STRB     r10,[r0,r5]\n        MOV      r0,#0\n        CMP      r6,#0\n        BLS      |L1.188|\n|L1.140|\n        MOV      r1,r4,LSR r0\n        TST      r1,#1\n        BEQ      |L1.176|\n        LDR      r1,[r7,#0]\n        LDRB     r3,[r9,r0]\n        LDR      r12,[r1,r4,LSL #2]\n        MOV      r1,r2\n        STRB     r3,[r12,r1]\n        ADD      r2,r2,#1\n|L1.176|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BCC      |L1.140|\n|L1.188|\n        ADD      r4,r4,#1\n        CMP      r4,r8\n        BCC      |L1.64|\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned int uint;\n\nvoid generateSubsets(char* set, uint n, char*** subsets, uint* subsetCount) {\n    uint numSubsets = 1 << n;\n    *subsets = (char**)malloc(numSubsets * sizeof(char*));\n    *subsetCount = numSubsets;\n\n    for (uint i = 0; i < numSubsets; ++i) {\n        uint subsetLen = 0;\n        for (uint j = 0; j < n; ++j) {\n            if ((i >> j) & 1) {\n                subsetLen++;\n            }\n        }\n        (*subsets)[i] = (char*)malloc((subsetLen + 1) * sizeof(char));\n        (*subsets)[i][subsetLen] = '\\0';\n        uint k = 0;\n        for (uint j = 0; j < n; ++j) {\n            if ((i >> j) & 1) {\n                (*subsets)[i][k++] = set[j];\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#4]\n        BL       height__FP4node\n        MOV      r4,r0\n        CMN      r0,#1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#8]\n        BL       height__FP4node\n        CMN      r0,#1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        SUB      r1,r4,r0\n        ADD      r1,r1,#1\n        CMP      r1,#2\n        LDMHIFD  sp!,{r4,r5,lr}\n        MVNHI    r0,#0\n        BXHI     lr\n        CMP      r4,r0\n        MOVGT    r0,r4\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r0,#1\n        BX       lr\n        ENDP\n\nisBalanced__FP4node PROC\n        STR      lr,[sp,#-4]!\n        BL       height__FP4node\n        ADDS     r0,r0,#1\n        LDR      lr,[sp],#4\n        MOVNE    r0,#1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nint height(struct node *node) {\n    if (node == NULL)\n        return 0;\n    int lh = height(node->left);\n    if (lh == -1)\n        return -1;\n    int rh = height(node->right);\n    if (rh == -1)\n        return -1;\n    if (abs(lh - rh) > 1)\n        return -1;\n    return 1 + (lh > rh ? lh : rh);\n}\n\nint isBalanced(struct node *root) {\n    return height(root) != -1;\n}\n\n\nstruct node* newNode(int data) {\n  struct node* node = (struct node*)malloc(sizeof(struct node));\n  node->data = data;\n  node->left = NULL;\n  node->right = NULL;\n  return(node);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r1\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,r0\n        MOV      r0,r4\n        BL       __rt_sdiv\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        gcd__FiT1\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nxor_cipher__FPcc PROC\n|L1.0|\n        LDRB     r3,[r0,#0]\n        MOV      r2,#0\n        CMP      r3,#0\n        BXEQ     lr\n|L1.16|\n        LDRB     r3,[r0,r2]\n        EOR      r3,r3,r1\n        STRB     r3,[r0,r2]\n        ADD      r2,r2,#1\n        LDRB     r3,[r0,r2]\n        CMP      r3,#0\n        BNE      |L1.16|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid xor_cipher(char* text, char key) {\n    for (int i = 0; text[i] != '\\0'; i++) {\n        text[i] ^= key;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nquadratic_probing__FiPi PROC\n        LDR      r3,|L1.272|\n        STR      lr,[sp,#-4]!\n        SMULL    r12,r2,r3,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r0,r0,r2,LSL #1\n        LDR      r12,[r1,r0,LSL #2]\n        MOV      r2,#1\n        CMP      r12,#0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n|L1.52|\n        MLA      r0,r2,r2,r0\n        SMULL    lr,r12,r3,r0\n        MOV      r12,r12,ASR #2\n        SUB      r12,r12,r12,ASR #31\n        SUB      r12,r12,r12,LSL #1\n        ADD      r2,r2,#1\n        CMP      r2,#0xa\n        ADD      r12,r12,r12,LSL #2\n        ADD      r0,r0,r12,LSL #1\n        LDRGT    lr,[sp],#4\n        MVNGT    r0,#0\n        BXGT     lr\n        LDR      r12,[r1,r0,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.52|\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\nint quadratic_probing(int key, int table[]) {\n    int index = key % TABLE_SIZE;\n    int i = 1;\n    while (table[index] != 0) {\n        index = (index + i * i) % TABLE_SIZE;\n        i++;\n        if (i > TABLE_SIZE) return -1; // Table full\n    }\n    return index;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__FiT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#0xc\n        MOV      r7,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        STMIA    r4,{r6,r7}\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        STR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.76|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.76|\n        MOV      r5,#0\n        CMP      r6,#0\n        BLE      |L1.192|\n        MOV      r7,r7,LSL #2\n|L1.92|\n        MOV      r0,r7\n        BL       malloc\n        LDR      r1,[r4,#8]\n        CMP      r0,#0\n        STR      r0,[r1,r5,LSL #2]\n        BNE      |L1.180|\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.152|\n|L1.128|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,r6,LSL #2]\n        BL       free\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        BLT      |L1.128|\n|L1.152|\n        LDR      r0,[r4,#8]\n        BL       free\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.180|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.92|\n|L1.192|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nfreeMatrix__FP6Matrix PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.256|\n|L1.228|\n        LDR      r0,[r5,#8]\n        LDR      r0,[r0,r4,LSL #2]\n        BL       free\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.228|\n|L1.256|\n        LDR      r0,[r5,#8]\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n\naddMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r4,#4]\n        LDREQ    r2,[r5,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r2,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.360|\n        LDR      r3,[r4,#4]\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.432|\n|L1.376|\n        LDR      r3,[r4,#8]\n        LDR      r12,[r5,#8]\n        LDR      r3,[r3,r2,LSL #2]\n        LDR      r12,[r12,r2,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        LDR      r12,[r12,r1,LSL #2]\n        ADD      r3,r3,r12\n        LDR      r12,[r0,#8]\n        LDR      r12,[r12,r2,LSL #2]\n        STR      r3,[r12,r1,LSL #2]\n        LDR      r3,[r4,#4]\n        ADD      r1,r1,#1\n        CMP      r3,r1\n        BGT      |L1.376|\n|L1.432|\n        LDR      r1,[r4,#0]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.360|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsubtractMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r4,#4]\n        LDREQ    r2,[r5,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r2,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.540|\n        LDR      r3,[r4,#4]\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.612|\n|L1.556|\n        LDR      r3,[r4,#8]\n        LDR      r12,[r5,#8]\n        LDR      r3,[r3,r2,LSL #2]\n        LDR      r12,[r12,r2,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        LDR      r12,[r12,r1,LSL #2]\n        SUB      r3,r3,r12\n        LDR      r12,[r0,#8]\n        LDR      r12,[r12,r2,LSL #2]\n        STR      r3,[r12,r1,LSL #2]\n        LDR      r3,[r4,#4]\n        ADD      r1,r1,#1\n        CMP      r3,r1\n        BGT      |L1.556|\n|L1.612|\n        LDR      r1,[r4,#0]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.540|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nmultiplyMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#0]\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r3,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        MOV      r8,#0\n|L1.720|\n        LDR      r1,[r5,#4]\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.844|\n|L1.736|\n        LDR      r1,[r0,#8]\n        LDR      r1,[r1,r3,LSL #2]\n        STR      r8,[r1,r2,LSL #2]\n        LDR      r12,[r4,#4]\n        MOV      r1,#0\n        CMP      r12,#0\n        BLE      |L1.828|\n|L1.764|\n        LDR      r12,[r0,#8]\n        LDR      lr,[r4,#8]\n        LDR      r6,[r5,#8]\n        LDR      r12,[r12,r3,LSL #2]\n        LDR      lr,[lr,r3,LSL #2]\n        LDR      r6,[r6,r1,LSL #2]\n        ADD      r12,r12,r2,LSL #2\n        LDR      r7,[r12,#0]\n        LDR      lr,[lr,r1,LSL #2]\n        LDR      r6,[r6,r2,LSL #2]\n        ADD      r1,r1,#1\n        MLA      lr,r6,lr,r7\n        STR      lr,[r12,#0]\n        LDR      r12,[r4,#4]\n        CMP      r12,r1\n        BGT      |L1.764|\n|L1.828|\n        LDR      r1,[r5,#4]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.736|\n|L1.844|\n        LDR      r1,[r4,#0]\n        ADD      r3,r3,#1\n        CMP      r1,r3\n        BGT      |L1.720|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Matrix {\n    int rows;\n    int cols;\n    int** data;\n};\n\nMatrix* createMatrix(int rows, int cols) {\n    Matrix* matrix = (Matrix*)malloc(sizeof(Matrix));\n    if (matrix == NULL) return NULL;\n    matrix->rows = rows;\n    matrix->cols = cols;\n    matrix->data = (int**)malloc(rows * sizeof(int*));\n    if (matrix->data == NULL) {\n        free(matrix);\n        return NULL;\n    }\n    for (int i = 0; i < rows; i++) {\n        matrix->data[i] = (int*)malloc(cols * sizeof(int));\n        if (matrix->data[i] == NULL) {\n            for (int j = 0; j < i; j++) free(matrix->data[j]);\n            free(matrix->data);\n            free(matrix);\n            return NULL;\n        }\n    }\n    return matrix;\n}\n\nvoid freeMatrix(Matrix* matrix) {\n    for (int i = 0; i < matrix->rows; i++) free(matrix->data[i]);\n    free(matrix->data);\n    free(matrix);\n}\n\n\nMatrix* addMatrices(Matrix* a, Matrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix* result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < a->cols; j++) {\n            result->data[i][j] = a->data[i][j] + b->data[i][j];\n        }\n    }\n    return result;\n}\n\nMatrix* subtractMatrices(Matrix* a, Matrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix* result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < a->cols; j++) {\n            result->data[i][j] = a->data[i][j] - b->data[i][j];\n        }\n    }\n    return result;\n}\n\nMatrix* multiplyMatrices(Matrix* a, Matrix* b) {\n    if (a->cols != b->rows) return NULL;\n    Matrix* result = createMatrix(a->rows, b->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < b->cols; j++) {\n            result->data[i][j] = 0;\n            for (int k = 0; k < a->cols; k++) {\n                result->data[i][j] += a->data[i][k] * b->data[k][j];\n            }\n        }\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nprint_to_n__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4,lr}\n        BXLE     lr\n        SUB      r0,r4,#1\n        BL       print_to_n__Fi\n        MOV      r1,r4\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.44|\n        B        _printf\n|L1.44|\n        DCB      \"%d\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid print_to_n(int n) {\n    if (n > 0) {\n        print_to_n(n - 1);\n        printf(\"%d\\n\", n);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateLockFreeList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        CMP      r0,#0\n        MOVNE    r1,#0\n        STRNE    r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\naddNode__FP12LockFreeListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        BEQ      |L1.120|\n|L1.92|\n        MOV      r2,r1\n        LDR      r1,[r1,#4]\n        CMP      r1,#0\n        BNE      |L1.92|\n        CMP      r2,#0\n        STRNE    r0,[r2,#4]\n        BNE      |L1.124|\n|L1.120|\n        STR      r0,[r4,#0]\n|L1.124|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct LockFreeList {\n    Node* head;\n} LockFreeList;\n\n\nLockFreeList* createLockFreeList() {\n    LockFreeList* list = (LockFreeList*)malloc(sizeof(LockFreeList));\n    if (list == NULL) return NULL;\n    list->head = NULL;\n    return list;\n}\n\n\nint addNode(LockFreeList* list, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) return 0;\n    newNode->data = data;\n    newNode->next = NULL;\n\n    Node* current = list->head;\n    Node* previous = NULL;\n\n    while (current != NULL) {\n        previous = current;\n        current = current->next;\n    }\n\n    if (previous == NULL) {\n        list->head = newNode;\n    } else {\n        previous->next = newNode;\n    }\n    return 1;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntriangle_area__FdN51 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r5,sp,#0x40\n        LDMIA    r5,{r4,r5}\n        ADD      r7,sp,#0x30\n        LDMIA    r7,{r6,r7}\n        MOV      r11,r1\n        MOV      r10,r0\n        MOV      r9,r3\n        MOV      r8,r2\n        MOV      r2,r4\n        MOV      r3,r5\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dsub\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        ADD      r3,sp,#0x28\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dsub\n        ADD      r3,sp,#0x38\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        ADR      r2,|L1.196|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r11,lr}\n        BIC      r1,r1,#0x80000000\n        B        _dmul\n|L1.196|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble triangle_area(double x1, double y1, double x2, double y2, double x3, double y3) {\n    return 0.5 * fabs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nkthSmallest__FP4Nodei PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STR      lr,[sp,#-4]!\n        MOV      lr,#0\n        MOV      r3,#0\n|L1.60|\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        BNE      |L1.104|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        LDRNE    r0,[r0,#8]\n        BNE      |L1.164|\n        LDR      r0,[r0,#0]\n        LDR      lr,[sp],#4\n        BX       lr\n|L1.100|\n        MOV      r2,r12\n|L1.104|\n        LDR      r12,[r2,#8]\n        CMP      r12,#0\n        STREQ    r0,[r2,#8]\n        LDREQ    r0,[r0,#4]\n        BEQ      |L1.164|\n        CMP      r12,r0\n        BNE      |L1.100|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        STR      lr,[r2,#8]\n        LDRNE    r0,[r0,#8]\n        BNE      |L1.164|\n        LDR      r0,[r0,#0]\n        LDR      lr,[sp],#4\n        BX       lr\n|L1.164|\n        CMP      r0,#0\n        BNE      |L1.60|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return(node);\n}\n\n\nint kthSmallest(struct Node* root, int k) {\n    if (root == NULL) return 0;\n    int count = 0;\n    struct Node* current = root;\n    while (current != NULL) {\n        if (current->left == NULL) {\n            count++;\n            if (count == k) return current->data;\n            current = current->right;\n        } else {\n            struct Node* predecessor = current->left;\n            while (predecessor->right != NULL && predecessor->right != current)\n                predecessor = predecessor->right;\n            if (predecessor->right == NULL) {\n                predecessor->right = current;\n                current = current->left;\n            } else {\n                predecessor->right = NULL;\n                count++;\n                if (count == k) return current->data;\n                current = current->right;\n            }\n        }\n    }\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountOccurrences__FPiiT2 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r12,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.44|\n|L1.20|\n        LDR      lr,[r0,r3,LSL #2]\n        ADD      r3,r3,#1\n        CMP      lr,r2\n        ADDEQ    r12,r12,#1\n        CMP      r3,r1\n        BLT      |L1.20|\n|L1.44|\n        LDR      lr,[sp],#4\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countOccurrences(int arr[], int size, int element) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            count++;\n        }\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        STR      r5,[r0,#0]\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#4]\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.72|\n        MOV      r1,#0\n|L1.52|\n        LDR      r2,[r4,#4]\n        STR      r1,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.52|\n|L1.72|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r6,r2\n        MOV      r5,r1\n        BL       malloc\n        STR      r6,[r0,#0]\n        LDR      r1,[r4,#4]\n        LDR      r1,[r1,r5,LSL #2]\n        STR      r1,[r0,#4]\n        LDR      r1,[r4,#4]\n        STR      r0,[r1,r5,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nremoveEdge__FP5GraphiT2 PROC\n        STMFD    sp!,{r3,lr}\n        LDR      lr,[r0,#4]\n        MOV      r3,#0\n        LDR      r0,[lr,r1,LSL #2]\n        B        |L1.168|\n|L1.160|\n        MOV      r3,r0\n        LDR      r0,[r0,#4]\n|L1.168|\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3,lr}\n        BXEQ     lr\n        LDR      r12,[r0,#0]\n        CMP      r12,r2\n        BNE      |L1.160|\n        CMP      r3,#0\n        LDREQ    r2,[r0,#4]\n        STREQ    r2,[lr,r1,LSL #2]\n        LDRNE    r1,[r0,#4]\n        STRNE    r1,[r3,#4]\n        LDMFD    sp!,{r3,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct Edge {\n    int dest;\n    struct Edge* next;\n};\n\nstruct Graph {\n    int numVertices;\n    struct Edge** adjList;\n};\n\nstruct Graph* createGraph(int vertices) {\n    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n    graph->adjList = (struct Edge**)malloc(vertices * sizeof(struct Edge*));\n    for (int i = 0; i < vertices; i++)\n        graph->adjList[i] = NULL;\n    return graph;\n}\n\nvoid addEdge(struct Graph* graph, int src, int dest) {\n    struct Edge* newEdge = (struct Edge*)malloc(sizeof(struct Edge));\n    newEdge->dest = dest;\n    newEdge->next = graph->adjList[src];\n    graph->adjList[src] = newEdge;\n}\n\n\nvoid removeEdge(struct Graph* graph, int src, int dest) {\n    struct Edge* current = graph->adjList[src];\n    struct Edge* previous = NULL;\n    while (current != NULL && current->dest != dest) {\n        previous = current;\n        current = current->next;\n    }\n    if (current != NULL) {\n        if (previous != NULL)\n            previous->next = current->next;\n        else\n            graph->adjList[src] = current->next;\n        free(current);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nconvert__FUxiT2 PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r10,r3\n        CMP      r2,#1\n        CMPGT    r10,#1\n        ADR      r11,|L1.512|\n        LDMLEIA  r11,{r0,r1}\n        SUB      sp,sp,#0xcc\n        ADDLE    sp,sp,#0xcc\n        MOV      r9,r2\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n        MOV      r3,r1\n        MOV      r2,r0\n        ADD      r6,sp,#0x88\n        MOV      r0,r6\n        ADR      r1,|L1.520|\n        BL       _sprintf\n        ADR      r0,|L1.528|\n        LDMIA    r11,{r4,r5}\n        LDMIA    r0,{r7,r8}\n        MOV      r0,r6\n        BL       strlen\n        SUBS     r6,r0,#1\n        BMI      |L1.240|\n|L1.96|\n        ADD      r0,sp,#0x88\n        LDRB     r0,[r0,r6]\n        SUB      r1,r0,#0x30\n        CMP      r1,#9\n        BLS      |L1.164|\n        SUB      r1,r0,#0x41\n        CMP      r1,#5\n        SUBLS    r1,r0,#0x37\n        BLS      |L1.164|\n        SUB      r1,r0,#0x61\n        CMP      r1,#5\n        SUBLS    r1,r0,#0x57\n        BLS      |L1.164|\n        LDMIA    r11,{r0,r1}\n        ADD      sp,sp,#0xcc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.164|\n        CMP      r1,r9\n        LDMGEIA  r11,{r0,r1}\n        ADDGE    sp,sp,#0xcc\n        LDMGEFD  sp!,{r4-r11,lr}\n        BXGE     lr\n        MOV      r2,r1\n        MOV      r3,r2,ASR #31\n        UMULL    r2,r12,r7,r1\n        MLA      r12,r1,r8,r12\n        MLA      r3,r7,r3,r12\n        UMULL    r0,r12,r7,r9\n        ADDS     r4,r4,r2\n        ADC      r5,r5,r3\n        MOV      r3,r9,ASR #31\n        MLA      r12,r9,r8,r12\n        MLA      r8,r3,r7,r12\n        MOV      r7,r0\n        SUBS     r6,r6,#1\n        BPL      |L1.96|\n|L1.240|\n        MOV      r1,#0x44\n        ADD      r7,sp,r1\n        MOV      r0,r7\n        BL       __rt_memclr_w\n        LDMIA    r11,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,#0\n        BNE      |L1.308|\n        MOV      r0,#0x30\n        STRB     r0,[sp,#0x44]\n        MOV      r0,r7\n        BL       atoll\n        ADD      sp,sp,#0xcc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.308|\n        LDMIA    r11,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BLS      |L1.440|\n        MOV      r9,r10,ASR #31\n        MOV      r8,r10\n        MOV      r10,r11\n|L1.340|\n        MOV      r2,r8\n        MOV      r3,r9\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _ll_udiv\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r0,r2\n        MOV      r1,r3\n        CMP      r2,#0xa\n        BGE      |L1.404|\n        ADD      r1,r0,#0x30\n        MOV      r0,r6\n        STRB     r1,[r7,r0]\n        ADD      r6,r6,#1\n        B        |L1.420|\n|L1.404|\n        ADD      r1,r0,#0x37\n        MOV      r0,r6\n        STRB     r1,[r7,r0]\n        ADD      r6,r6,#1\n|L1.420|\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BHI      |L1.340|\n|L1.440|\n        MOV      r1,#0x44\n        MOV      r4,sp\n        MOV      r0,sp\n        BL       __rt_memclr_w\n        SUB      r0,r6,#1\n        MOV      r1,r0\n        CMP      r0,#0\n        BLT      |L1.492|\n|L1.472|\n        LDRB     r2,[r7,r0]\n        SUB      r3,r1,r0\n        SUBS     r0,r0,#1\n        STRB     r2,[r4,r3]\n        BPL      |L1.472|\n|L1.492|\n        MOV      r0,r4\n        BL       atoll\n        ADD      sp,sp,#0xcc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.512|\n        DCQ      0x0000000000000000\n|L1.520|\n        DCB      \"%llu\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.528|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long convert(unsigned long long num, int fromBase, int toBase) {\n    if (fromBase <= 1 || toBase <= 1) return 0;\n\n    char buf[65];\n    sprintf(buf, \"%llu\", num);\n    unsigned long long dec = 0;\n    unsigned long long p = 1;\n\n    for (int i = strlen(buf) - 1; i >= 0; --i) {\n        int val;\n        if (buf[i] >= '0' && buf[i] <= '9') val = buf[i] - '0';\n        else if (buf[i] >= 'A' && buf[i] <= 'F') val = buf[i] - 'A' + 10;\n        else if (buf[i] >= 'a' && buf[i] <= 'f') val = buf[i] - 'a' + 10;\n        else return 0;\n\n        if (val >= fromBase) return 0;\n        dec += val * p;\n        p *= fromBase;\n    }\n\n\n    char res[65] = {0};\n    int i = 0;\n    if(dec == 0) {\n        res[0] = '0';\n        return atoll(res);\n    }\n\n    while (dec > 0) {\n        int rem = dec % toBase;\n        if (rem < 10) res[i++] = rem + '0';\n        else res[i++] = rem - 10 + 'A';\n        dec /= toBase;\n    }\n\n    char final[65] = {0};\n    for (int j = i - 1; j >= 0; --j) final[i - 1 - j] = res[j];\n\n    return atoll(final);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheuristic__FPi PROC\n|L1.0|\n        MOV      r12,r0\n        MOV      r0,#0\n        MOV      r1,#0\n|L1.12|\n        LDR      r2,[r12,r1,LSL #2]\n        CMP      r2,#0\n        ADDNE    r3,r1,#1\n        CMPNE    r2,r3\n        ADDNE    r0,r0,#1\n        ADD      r1,r1,#1\n        CMP      r1,#9\n        BLT      |L1.12|\n        BX       lr\n        ENDP\n\ncompare__FPCvT1 PROC\n        LDR      r0,[r0,#0x30]\n        LDR      r1,[r1,#0x30]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n\nsolve_npuzzle__FPi PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x6c\n        ADD      lr,sp,#0x38\n        MOV      r8,#0\n        MOV      r7,#0\n        MOV      r6,#0\n        MOV      r5,#0\n        MOV      r4,#0\n        MOV      r9,#0\n        MOV      r11,#0\n        MOV      r10,#0\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r12,#0\n        STMIA    lr!,{r1-r12}\n        STR      r1,[lr,#0]\n        LDMIA    r0,{r1-r9}\n        SUB      lr,lr,#0x30\n        STMIA    lr,{r1-r9}\n        MOV      r0,#0\n|L1.148|\n        LDR      r1,[lr,r0,LSL #2]\n        CMP      r1,#0\n        STREQ    r0,[sp,#0x5c]\n        ADD      r0,r0,#1\n        CMP      r0,#9\n        BLT      |L1.148|\n        MOV      r0,#0\n        STR      r0,[sp,#0x60]\n        MOV      r0,lr\n        MOV      r4,lr\n        BL       heuristic__FPi\n        STR      r0,[sp,#0x64]\n        ADD      r1,sp,#0x60\n        LDMIA    r1,{r0,r1}\n        ADD      r0,r0,r1\n        STR      r0,[sp,#0x68]\n        MOV      r0,#0x34\n        BL       malloc\n        LDMIA    r4!,{r1-r3,r5-r12,lr}\n        STMIA    r0!,{r1-r3,r5-r12,lr}\n        LDR      r1,[r4,#0]\n        SUB      r4,r4,#0x30\n        STR      r1,[r0,#0]\n        MOV      r0,#0x34\n        BL       malloc\n        MOV      r5,r0\n        LDMIA    r4!,{r1-r3,r6-r12,lr}\n        STMIA    r0!,{r1-r3,r6-r12,lr}\n        LDMIA    r4,{r1,r2}\n        STMIA    r0,{r1,r2}\n        SUB      r0,r0,#0x2c\n        LDR      r10,|L1.556|\n        ADD      r9,r0,#0x34\n        MOV      r4,#1\n        MVN      r11,#0x33\n        ADD      r8,sp,#4\n        MOV      r7,#0\n        MOV      r6,#0\n|L1.300|\n        MOV      r3,r10\n        MOV      r2,#0x34\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       qsort\n        LDMIA    r5!,{r0-r3,r12,lr}\n        STMIA    r8!,{r0-r3,r12,lr}\n        LDMIA    r5!,{r0-r3,r12,lr}\n        STMIA    r8!,{r0-r3,r12,lr}\n        LDR      r0,[r5,#0]\n        SUB      r5,r5,#0x30\n        STR      r0,[r8,#0]\n        LDR      r0,[sp,#0x30]\n        SUB      r8,r8,#0x30\n        CMP      r0,#0\n        MOVEQ    r0,r8\n        ADDEQ    sp,sp,#0x6c\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        ADD      r0,r4,r4,LSL #2\n        ADD      r0,r0,r4,LSL #3\n        ADD      r2,r11,r0,LSL #2\n        MOV      r0,r5\n        MOV      r1,r9\n        BL       __rt_memmove_w\n        ADD      r6,r6,#1\n        ADD      r1,r6,r6,LSL #2\n        ADD      r1,r1,r6,LSL #3\n        MOV      r1,r1,LSL #2\n        SUB      r4,r4,#1\n        MOV      r0,r7\n        BL       realloc\n        MOV      r7,r0\n        ADD      r0,r6,r6,LSL #2\n        ADD      r0,r0,r6,LSL #3\n        ADD      r0,r7,r0,LSL #2\n        SUB      r0,r0,#0x34\n        LDMIA    r8!,{r1-r3,r12,lr}\n        STMIA    r0!,{r1-r3,r12,lr}\n        LDMIA    r8!,{r1-r3,r12,lr}\n        STMIA    r0!,{r1-r3,r12,lr}\n        LDMIA    r8,{r1-r3}\n        STMIA    r0,{r1-r3}\n        SUB      r8,r8,#0x28\n        CMP      r4,#0\n        BGT      |L1.300|\n        ADD      sp,sp,#0x6c\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define N 3\n\ntypedef struct {\n    int board[N * N];\n    int blank;\n    int g;\n    int h;\n    int f;\n} state;\n\nint heuristic(int *board) {\n    int h = 0;\n    for (int i = 0; i < N * N; i++) {\n        if (board[i] != 0 && board[i] != i + 1) {\n            h++;\n        }\n    }\n    return h;\n}\n\nint compare(const void *a, const void *b) {\n    return ((state *)a)->f - ((state *)b)->f;\n}\n\nstate* solve_npuzzle(int *initial_board) {\n    state initial = { {0}, 0, 0, 0, 0 };\n    memcpy(initial.board, initial_board, sizeof(initial.board));\n    for (int i = 0; i < N * N; i++) {\n        if (initial.board[i] == 0) {\n            initial.blank = i;\n        }\n    }\n    initial.g = 0;\n    initial.h = heuristic(initial.board);\n    initial.f = initial.g + initial.h;\n\n    state *q = (state*)malloc(sizeof(state));\n    memcpy(q, &initial, sizeof(initial));\n\n\n    state *open = (state*)malloc(sizeof(state));\n    memcpy(open, &initial, sizeof(initial));\n\n    state *closed = NULL;\n    int open_size = 1;\n    int closed_size = 0;\n\n    while (open_size > 0) {\n        qsort(open, open_size, sizeof(state), compare);\n        state current = open[0];\n        \n        if (current.h == 0) return &current;\n\n        \n        memmove(open + 0, open + 1, sizeof(state)*(open_size-1));\n        open_size--;\n\n        closed_size++;\n        closed = (state*)realloc(closed, closed_size*sizeof(state));\n        memcpy(closed + closed_size - 1, &current, sizeof(state));\n\n\n        // Implement moves here\n\n    }\n    return NULL;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmatrix_multiply__FPA100_iN21i PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r9,#0\n        CMP      r3,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n        MOV      r10,#0\n|L1.24|\n        MOV      r4,#0\n        CMP      r3,#0\n        BLE      |L1.128|\n        ADD      r12,r9,r9,LSL #3\n        ADD      r12,r12,r9,LSL #4\n        ADD      r8,r1,r12,LSL #4\n        ADD      r7,r0,r12,LSL #4\n|L1.52|\n        STR      r10,[r7,r4,LSL #2]\n        MOV      lr,#0\n        CMP      r3,#0\n        BLE      |L1.116|\n        ADD      r5,r7,r4,LSL #2\n|L1.72|\n        ADD      r12,lr,lr,LSL #3\n        ADD      r12,r12,lr,LSL #4\n        ADD      r12,r2,r12,LSL #4\n        LDR      r6,[r8,lr,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        LDR      r11,[r5,#0]\n        ADD      lr,lr,#1\n        MLA      r6,r12,r6,r11\n        STR      r6,[r5,#0]\n        CMP      lr,r3\n        BLT      |L1.72|\n|L1.116|\n        ADD      r4,r4,#1\n        CMP      r4,r3\n        BLT      |L1.52|\n|L1.128|\n        ADD      r9,r9,#1\n        CMP      r9,r3\n        BLT      |L1.24|\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\nmatrix_power__FPA100_iT1iT3 PROC\n        STMFD    sp!,{r4-r8,lr}\n        SUB      sp,sp,#0x13c00\n        MOV      r7,r1\n        MOVS     r6,r3\n        MOV      r5,r0\n        MOV      r4,r2\n        BNE      |L1.272|\n        CMP      r4,#0\n        ADDLE    sp,sp,#0x13c00\n        LDMLEFD  sp!,{r4-r8,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.196|\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.248|\n        ADD      r2,r1,r1,LSL #3\n        ADD      r2,r2,r1,LSL #4\n        ADD      r3,r5,r2,LSL #4\n|L1.220|\n        CMP      r1,r0\n        MOVNE    r2,#0\n        MOVEQ    r2,#1\n        STR      r2,[r3,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.220|\n|L1.248|\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLT      |L1.196|\n        ADD      sp,sp,#0x13c00\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.272|\n        CMP      r6,#1\n        BNE      |L1.372|\n        CMP      r4,#0\n        ADDLE    sp,sp,#0x13c00\n        LDMLEFD  sp!,{r4-r8,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.300|\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.348|\n        ADD      r3,r1,r1,LSL #3\n        ADD      r3,r3,r1,LSL #4\n        ADD      r2,r5,r3,LSL #4\n        ADD      lr,r7,r3,LSL #4\n|L1.328|\n        LDR      r3,[lr,r0,LSL #2]\n        STR      r3,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.328|\n|L1.348|\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLT      |L1.300|\n        ADD      sp,sp,#0x13c00\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.372|\n        ADD      r0,r6,r6,LSR #31\n        ADD      r8,sp,#0x8000\n        ADD      r8,r8,#0x1fc0\n        MOV      r3,r0,ASR #1\n        MOV      r0,r8\n        MOV      r2,r4\n        MOV      r1,r7\n        BL       matrix_power__FPA100_iT1iT3\n        MOV      r3,r4\n        MOV      r2,r8\n        MOV      r1,r8\n        MOV      r0,r5\n        BL       matrix_multiply__FPA100_iN21i\n        AND      r0,r6,#0x80000001\n        CMP      r0,#1\n        ADDNE    sp,sp,#0x13c00\n        LDMNEFD  sp!,{r4-r8,lr}\n        BXNE     lr\n        MOV      r3,r4\n        ADD      r4,sp,#0x380\n        MOV      r0,r4\n        MOV      r2,r7\n        MOV      r1,r5\n        BL       matrix_multiply__FPA100_iN21i\n        MOV      r2,#0x1c40\n        ADD      r2,r2,#0x8000\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_memcpy_w\n        ADD      sp,sp,#0x13c00\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef int matrix_t[100][100];\n\nvoid matrix_multiply(matrix_t c, matrix_t a, matrix_t b, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            c[i][j] = 0;\n            for (int k = 0; k < n; k++) {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }\n    }\n}\n\n\nvoid matrix_power(matrix_t result, matrix_t base, int n, int exp) {\n    if (exp == 0) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = (i == j);\n            }\n        }\n        return;\n    }\n    if (exp == 1) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = base[i][j];\n            }\n        }\n        return;\n    }\n\n    matrix_t temp;\n    matrix_power(temp, base, n, exp / 2);\n    matrix_multiply(result, temp, temp, n);\n    if (exp % 2 == 1) {\n        matrix_t temp2;\n        matrix_multiply(temp2, result, base, n);\n        memcpy(result, temp2, sizeof(matrix_t));\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_string__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       strlen\n        ADD      r0,r4,r0\n        SUB      r0,r0,#1\n        CMP      r4,r0\n        LDMCSFD  sp!,{r4,lr}\n        BXCS     lr\n|L1.44|\n        LDRB     r2,[r0,#0]\n        LDRB     r1,[r4,#0]\n        STRB     r2,[r4],#1\n        STRB     r1,[r0],#-1\n        CMP      r4,r0\n        BCC      |L1.44|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverse_string(char *str) {\n    if (str == 0) return;\n    int n = strlen(str);\n    char *start = str;\n    char *end = str + n - 1;\n    char temp;\n    while (start < end) {\n        temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateFlight__FiT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x2d8\n        MOV      r4,r1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        STR      r5,[r0,#0x2d0]\n        STR      r4,[r0,#0x2d4]\n        CMP      r5,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOV      r2,#0\n        BXLE     lr\n|L1.56|\n        MOV      r1,#0\n        CMP      r4,#0\n        BLE      |L1.116|\n        ADD      r3,r2,r2,LSL #3\n        ADD      r12,r0,r3,LSL #3\n|L1.76|\n        ADD      r3,r1,r1,LSL #1\n        STR      r2,[r12,r3,LSL #2]\n        ADD      r3,r12,r3,LSL #2\n        STR      r1,[r3,#4]\n        LDR      lr,[r3,#8]!\n        ADD      r1,r1,#1\n        BIC      lr,lr,#1\n        STR      lr,[r3,#0]\n        CMP      r1,r4\n        BLT      |L1.76|\n|L1.116|\n        ADD      r2,r2,#1\n        CMP      r2,r5\n        BLT      |L1.56|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbookSeat__FP6FlightiT2 PROC\n        CMP      r0,#0\n        BEQ      |L1.204|\n        CMP      r1,#0\n        LDRGE    r3,[r0,#0x2d0]\n        CMPGE    r3,r1\n        BLE      |L1.204|\n        CMP      r2,#0\n        LDRGE    r3,[r0,#0x2d4]\n        CMPGE    r3,r2\n        BLE      |L1.204|\n        ADD      r1,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #3\n        ADD      r1,r2,r2,LSL #1\n        ADD      r0,r0,r1,LSL #2\n        LDR      r1,[r0,#8]\n        TST      r1,#1\n        BEQ      |L1.212|\n|L1.204|\n        MOV      r0,#0\n        BX       lr\n|L1.212|\n        LDR      r1,[r0,#8]!\n        ORR      r1,r1,#1\n        STR      r1,[r0,#0]\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_ROWS 10\n#define MAX_COLS 6\n\ntypedef struct {\n    int row;\n    int col;\n    int booked : 1;\n} Seat;\n\ntypedef struct {\n    Seat seats[MAX_ROWS][MAX_COLS];\n    int numRows;\n    int numCols;\n} Flight;\n\n\nFlight* createFlight(int rows, int cols) {\n    Flight* flight = (Flight*)malloc(sizeof(Flight));\n    if (flight == NULL) return NULL;\n    flight->numRows = rows;\n    flight->numCols = cols;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            flight->seats[i][j].row = i;\n            flight->seats[i][j].col = j;\n            flight->seats[i][j].booked = 0;\n        }\n    }\n    return flight;\n}\n\n\nint bookSeat(Flight* flight, int row, int col) {\n    if (flight == NULL || row < 0 || row >= flight->numRows || col < 0 || col >= flight->numCols || flight->seats[row][col].booked) return 0;\n    flight->seats[row][col].booked = 1;\n    return 1;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbellmanFord__FPA100_iiT2Pi PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r12,#0\n        CMP      r1,#0\n        BLE      |L1.40|\n        MOV      lr,#0x240\n        ADD      lr,lr,#0xf4000\n|L1.24|\n        STR      lr,[r3,r12,LSL #2]\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        BLT      |L1.24|\n|L1.40|\n        MOV      r12,#0\n        STR      r12,[r3,r2,LSL #2]\n        MOV      r7,#1\n        CMP      r1,#1\n        BLE      |L1.176|\n|L1.60|\n        MOV      lr,#0\n        CMP      r1,#0\n        BLE      |L1.164|\n|L1.72|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.152|\n        ADD      r12,lr,lr,LSL #3\n        ADD      r12,r12,lr,LSL #4\n        ADD      r6,r0,r12,LSL #4\n|L1.96|\n        LDR      r5,[r6,r2,LSL #2]\n        CMP      r5,#0\n        LDRNE    r4,[r3,lr,LSL #2]\n        MOVNE    r12,#0x240\n        ADDNE    r12,r12,#0xf4000\n        CMPNE    r4,r12\n        ADDNE    r12,r5,r4\n        LDRNE    r4,[r3,r2,LSL #2]\n        CMPNE    r12,r4\n        BGE      |L1.140|\n        STR      r12,[r3,r2,LSL #2]\n|L1.140|\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.96|\n|L1.152|\n        ADD      lr,lr,#1\n        CMP      lr,r1\n        BLT      |L1.72|\n|L1.164|\n        ADD      r7,r7,#1\n        CMP      r7,r1\n        BLT      |L1.60|\n|L1.176|\n        MOV      lr,#0\n        CMP      r1,#0\n        BLE      |L1.284|\n|L1.188|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.272|\n        ADD      r12,lr,lr,LSL #3\n        ADD      r12,r12,lr,LSL #4\n        ADD      r6,r0,r12,LSL #4\n|L1.212|\n        LDR      r5,[r6,r2,LSL #2]\n        CMP      r5,#0\n        LDRNE    r4,[r3,lr,LSL #2]\n        MOVNE    r12,#0x240\n        ADDNE    r12,r12,#0xf4000\n        CMPNE    r4,r12\n        ADDNE    r12,r5,r4\n        LDRNE    r4,[r3,r2,LSL #2]\n        CMPNE    r12,r4\n        LDMLTFD  sp!,{r4-r7,lr}\n        MVNLT    r0,#0\n        BXLT     lr\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.212|\n|L1.272|\n        ADD      lr,lr,#1\n        CMP      lr,r1\n        BLT      |L1.188|\n|L1.284|\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define INF 1000000\n\nstruct Edge {\n    int to;\n    int weight;\n};\n\nint bellmanFord(int graph[][100], int numVertices, int source, int distances[]) {\n    for (int i = 0; i < numVertices; i++) {\n        distances[i] = INF;\n    }\n    distances[source] = 0;\n\n    for (int i = 1; i < numVertices; i++) {\n        for (int u = 0; u < numVertices; u++) {\n            for (int v = 0; v < numVertices; v++) {\n                if (graph[u][v] != 0 && distances[u] != INF && distances[u] + graph[u][v] < distances[v]) {\n                    distances[v] = distances[u] + graph[u][v];\n                }\n            }\n        }\n    }\n\n    for (int u = 0; u < numVertices; u++) {\n        for (int v = 0; v < numVertices; v++) {\n            if (graph[u][v] != 0 && distances[u] != INF && distances[u] + graph[u][v] < distances[v]) {\n                return -1; // Negative cycle detected\n            }\n        }\n    }\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmatrixMultiply__FPiT1iN23 PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        LDR      r5,[sp,#0x20]\n        MOV      r8,r2\n        MOV      r7,r1\n        MOV      r6,r0\n        MOV      r4,r3\n        CMP      r3,r2\n        LDMNEFD  sp!,{r3-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        MUL      r0,r5,r8\n        MOV      r0,r0,LSL #2\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        CMP      r8,#0\n        LDMLEFD  sp!,{r3-r9,lr}\n        MOV      r12,#0\n        BXLE     lr\n|L1.80|\n        MOV      r2,#0\n        CMP      r5,#0\n        BLE      |L1.160|\n|L1.92|\n        MOV      r3,#0\n        MOV      r1,#0\n        CMP      r4,#0\n        BLE      |L1.140|\n|L1.108|\n        MLA      lr,r4,r12,r1\n        MLA      r9,r5,r1,r2\n        LDR      lr,[r6,lr,LSL #2]\n        LDR      r9,[r7,r9,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        MLA      r3,r9,lr,r3\n        BLT      |L1.108|\n|L1.140|\n        MLA      r1,r5,r12,r2\n        ADD      r2,r2,#1\n        CMP      r2,r5\n        STR      r3,[r0,r1,LSL #2]\n        BLT      |L1.92|\n|L1.160|\n        ADD      r12,r12,#1\n        CMP      r12,r8\n        BLT      |L1.80|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* matrixMultiply(int* a, int* b, int aRows, int aCols, int bCols) {\n    if (aCols != aRows) return NULL;\n    int* c = (int*)malloc(aRows * bCols * sizeof(int));\n    if (c == NULL) return NULL;\n    for (int i = 0; i < aRows; i++) {\n        for (int j = 0; j < bCols; j++) {\n            int sum = 0;\n            for (int k = 0; k < aCols; k++) {\n                sum += a[i * aCols + k] * b[k * bCols + j];\n            }\n            c[i * bCols + j] = sum;\n        }\n    }\n    return c;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nshellSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        ADD      r2,r1,r1,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n|L1.24|\n        MOV      r12,r3\n        CMP      r3,r1\n        BGE      |L1.92|\n|L1.36|\n        LDR      lr,[r0,r12,LSL #2]\n        MOV      r2,r12\n        B        |L1.56|\n|L1.48|\n        STR      r5,[r0,r2,LSL #2]\n        MOV      r2,r4\n|L1.56|\n        CMP      r2,r3\n        SUBGE    r4,r2,r3\n        LDRGE    r5,[r0,r4,LSL #2]\n        CMPGE    r5,lr\n        BGT      |L1.48|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        STR      lr,[r0,r2,LSL #2]\n        BLT      |L1.36|\n|L1.92|\n        ADD      r2,r3,r3,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        BGT      |L1.24|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid shellSort(int arr[], int n) {\n    int gap, i, j, temp;\n    for (gap = n / 2; gap > 0; gap /= 2) {\n        for (i = gap; i < n; i++) {\n            temp = arr[i];\n            j = i;\n            while (j >= gap && arr[j - gap] > temp) {\n                arr[j] = arr[j - gap];\n                j -= gap;\n            }\n            arr[j] = temp;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisBSTUtil__FP4NodeiT2 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLT      |L1.84|\n        CMP      r0,r5\n        BLE      |L1.96|\n|L1.84|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.96|\n        SUB      r2,r0,#1\n        LDR      r0,[r4,#4]\n        BL       isBSTUtil__FP4NodeiT2\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r0,[r4,#0]\n        MOV      r2,r5\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#8]\n        BL       isBSTUtil__FP4NodeiT2\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.152|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nisBST__FP4Node PROC\n        MVN      r2,#0x80000000\n        MOV      r1,#0x80000000\n        B        isBSTUtil__FP4NodeiT2\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nint isBSTUtil(struct Node* node, int min, int max) {\n    if (node == NULL) return 1;\n    if (node->data < min || node->data > max) return 0;\n    return isBSTUtil(node->left, min, node->data - 1) && isBSTUtil(node->right, node->data + 1, max);\n}\n\nint isBST(struct Node* node) {\n    return isBSTUtil(node, -2147483648, 2147483647);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsolveQuadraticEquation__FdN21 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x38\n        ADD      r1,sp,#0x2c\n        MOV      r9,r3\n        ADR      r3,|L1.368|\n        LDMIA    r1,{r0,r1}\n        LDMIA    r11,{r8,r10,r11}\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r7,r1\n        MOV      r6,r0\n        MOV      r0,r9\n        MOV      r1,r8\n        EOR      r5,r8,#0x80000000\n        MOV      r4,r9\n        MOV      r3,r8\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r8,r0\n        ADR      r0,|L1.376|\n        MOV      r9,r1\n        ADD      r1,sp,#0x2c\n        LDMIA    r0,{r2,r3}\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _drsb\n        MOV      r8,r0\n        ADR      r0,|L1.384|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r9,r1\n        BL       _dcmpge\n        BLS      |L1.268|\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _drdiv\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _drdiv\n        MOV      r4,r0\n        MOV      r0,#2\n        MOV      r5,r1\n        B        |L1.336|\n|L1.268|\n        ADR      r0,|L1.384|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       _dcmpeq\n        MOVNE    r0,#0\n        BNE      |L1.336|\n        MOV      r2,r4\n        MOV      r3,r5\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _drdiv\n        MOV      r10,r0\n        MOV      r4,r0\n        MOV      r0,#1\n        MOV      r11,r1\n        MOV      r5,r1\n|L1.336|\n        LDR      r1,[sp,#0x28]\n        STMIA    r1,{r10,r11}\n        ADD      r2,r1,#8\n        STMIA    r2,{r4,r5}\n        STR      r0,[r1,#0x10]\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.368|\n        DCFD     0x4000000000000000\n|L1.376|\n        DCFD     0x4010000000000000\n|L1.384|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct Solution {\n    double x1;\n    double x2;\n    int numSolutions;\n};\n\n\nSolution solveQuadraticEquation(double a, double b, double c) {\n    Solution sol;\n    double discriminant = b * b - 4 * a * c;\n\n    if (discriminant > 0) {\n        sol.x1 = (-b + sqrt(discriminant)) / (2 * a);\n        sol.x2 = (-b - sqrt(discriminant)) / (2 * a);\n        sol.numSolutions = 2;\n    } else if (discriminant == 0) {\n        sol.x1 = -b / (2 * a);\n        sol.x2 = sol.x1;\n        sol.numSolutions = 1;\n    } else {\n        sol.numSolutions = 0;\n    }\n    return sol;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0x88\n        ADD      r0,r0,#0x13800\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADD      r0,r4,#0x13000\n        ADD      r2,r0,#0x880\n        MOV      r1,#0x3880\n        ADD      r1,r1,#0x10000\n        STMIA    r2,{r5,r6}\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfreeMatrix__FP6Matrix PROC\n        B        free\n        ENDP\n\nmatrixMultiply__FP6MatrixT1 PROC\n        STMFD    sp!,{r0,r1,r4-r11,lr}\n        SUB      sp,sp,#0xc\n        MOV      r9,r1\n        LDR      r1,[sp,#0xc]\n        ADD      r11,r9,#0x13000\n        ADD      r7,r1,#0x13000\n        LDR      r0,[r7,#0x884]\n        LDR      r1,[r11,#0x880]\n        CMP      r0,r1\n        ADDNE    sp,sp,#0x14\n        LDMNEFD  sp!,{r4-r11,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r11,#0x884]\n        LDR      r0,[r7,#0x880]\n        BL       createMatrix__FiT1\n        STR      r0,[sp,#4]\n        CMP      r0,#0\n        ADDEQ    sp,sp,#0x14\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        LDR      r0,[r7,#0x880]\n        MOV      r10,#0\n        CMP      r0,#0\n        BLE      |L1.340|\n|L1.180|\n        LDR      r0,[r11,#0x884]\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.324|\n        ADD      r0,r10,r10,LSL #3\n        LDR      r1,[sp,#0xc]\n        ADD      r0,r0,r10,LSL #4\n        ADD      r8,r1,r0,LSL #5\n        LDR      r1,[sp,#4]\n        ADD      r0,r1,r0,LSL #5\n        STR      r0,[sp,#8]\n|L1.224|\n        LDR      r0,[r7,#0x884]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.308|\n        LDR      r0,[sp,#8]\n        ADD      r6,r0,r5,LSL #3\n|L1.248|\n        ADD      r0,r4,r4,LSL #3\n        ADD      r0,r0,r4,LSL #4\n        ADD      r0,r9,r0,LSL #5\n        ADD      r1,r0,r5,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r8,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDMIA    r6,{r2,r3}\n        BL       _dadd\n        STMIA    r6,{r0,r1}\n        LDR      r0,[r7,#0x884]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.248|\n|L1.308|\n        LDR      r0,[r11,#0x884]\n        ADD      r5,r5,#1\n        CMP      r0,r5\n        BGT      |L1.224|\n|L1.324|\n        LDR      r0,[r7,#0x880]\n        ADD      r10,r10,#1\n        CMP      r0,r10\n        BGT      |L1.180|\n|L1.340|\n        LDR      r0,[sp,#4]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\nmatrixTranspose__FP6Matrix PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        ADD      r4,r0,#0x13000\n        LDR      r0,[r4,#0x884]\n        LDR      r1,[r4,#0x880]\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0x880]\n        MOV      r2,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.412|\n        LDR      r3,[r4,#0x884]\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.484|\n        ADD      r3,r2,r2,LSL #3\n        ADD      r3,r3,r2,LSL #4\n        ADD      r3,r5,r3,LSL #5\n|L1.440|\n        ADD      r12,r1,r1,LSL #3\n        ADD      r12,r12,r1,LSL #4\n        ADD      lr,r3,r1,LSL #3\n        ADD      r12,r0,r12,LSL #5\n        ADD      r12,r12,r2,LSL #3\n        LDMIA    lr,{r6,lr}\n        STMIA    r12,{r6,lr}\n        LDR      r12,[r4,#0x884]\n        ADD      r1,r1,#1\n        CMP      r12,r1\n        BGT      |L1.440|\n|L1.484|\n        LDR      r1,[r4,#0x880]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.412|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nperformPCA__FP6Matrixi PROC\n        STMFD    sp!,{r0,r1,r4-r11,lr}\n        SUB      sp,sp,#0x14\n        CMP      r0,#0\n        LDRNE    r1,[sp,#0x18]\n        MOV      r10,r0\n        CMPNE    r1,#0\n        BLE      |L1.556|\n        ADD      r0,r10,#0x13000\n        LDR      r7,[r0,#0x884]\n        LDR      r1,[sp,#0x18]\n        CMP      r7,r1\n        BGE      |L1.572|\n|L1.556|\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.572|\n        LDR      r4,[r0,#0x880]\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       createMatrix__FiT1\n        MOVS     r8,r0\n        ADDEQ    sp,sp,#0x1c\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r5,#0\n        CMP      r7,#0\n        BLE      |L1.816|\n        MOV      r0,r4\n        BL       _dflt\n        STR      r0,[sp,#0x10]\n        STR      r1,[sp,#0xc]\n|L1.632|\n        ADR      r0,|L1.1052|\n        LDR      r9,[r0,#4]\n        LDR      lr,[r0,#0]\n        MOV      r6,#0\n        CMP      r4,#0\n        BLE      |L1.708|\n|L1.656|\n        ADD      r0,r6,r6,LSL #3\n        ADD      r0,r0,r6,LSL #4\n        ADD      r0,r10,r0,LSL #5\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r2,r3}\n        MOV      r0,lr\n        MOV      r1,r9\n        BL       _dadd\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        MOV      lr,r0\n        MOV      r9,r1\n        BLT      |L1.656|\n|L1.708|\n        MOV      r3,r9\n        MOV      r2,lr\n        LDR      r0,[sp,#0x10]\n        LDR      r1,[sp,#0xc]\n        BL       _drdiv\n        MOV      r11,r1\n        MOV      r6,#0\n        CMP      r4,#0\n        STR      r0,[sp,#0]\n        BLE      |L1.804|\n|L1.748|\n        ADD      r1,r6,r6,LSL #3\n        ADD      r1,r1,r6,LSL #4\n        ADD      r0,r10,r1,LSL #5\n        ADD      r1,r8,r1,LSL #5\n        ADD      r9,r1,r5,LSL #3\n        ADD      r0,r0,r5,LSL #3\n        LDR      r2,[sp,#0]\n        LDMIA    r0,{r0,r1}\n        MOV      r3,r11\n        BL       _dsub\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        STMIA    r9,{r0,r1}\n        BLT      |L1.748|\n|L1.804|\n        ADD      r5,r5,#1\n        CMP      r5,r7\n        BLT      |L1.632|\n|L1.816|\n        MOV      r1,r7\n        MOV      r0,r7\n        BL       createMatrix__FiT1\n        STR      r0,[sp,#0]\n        CMP      r0,#0\n        ADDEQ    sp,sp,#0x1c\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r10,#0\n        CMP      r7,#0\n        BLE      |L1.1024|\n        SUB      r0,r4,#1\n        BL       _dflt\n        STR      r0,[sp,#8]\n        STR      r1,[sp,#4]\n|L1.876|\n        MOV      r6,#0\n        CMP      r7,#0\n        BLE      |L1.1012|\n        ADD      r0,r10,r10,LSL #3\n        LDR      r1,[sp,#0]\n        ADD      r0,r0,r10,LSL #4\n        ADD      r11,r1,r0,LSL #5\n|L1.904|\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.976|\n        ADD      r9,r11,r6,LSL #3\n|L1.920|\n        ADD      r0,r5,r5,LSL #3\n        ADD      r0,r0,r5,LSL #4\n        ADD      r0,r8,r0,LSL #5\n        ADD      r1,r0,r6,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r0,r10,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDMIA    r9,{r2,r3}\n        BL       _dadd\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        STMIA    r9,{r0,r1}\n        BLT      |L1.920|\n|L1.976|\n        ADD      r5,r11,r6,LSL #3\n        LDR      r0,[sp,#8]\n        LDR      r1,[sp,#4]\n        LDMIA    r5,{r2,r3}\n        BL       _drdiv\n        ADD      r6,r6,#1\n        CMP      r6,r7\n        STMIA    r5,{r0,r1}\n        BLT      |L1.904|\n|L1.1012|\n        ADD      r10,r10,#1\n        CMP      r10,r7\n        BLT      |L1.876|\n|L1.1024|\n        MOV      r0,r7\n        LDR      r1,[sp,#0x18]\n        BL       createMatrix__FiT1\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        CMP      r0,#0\n        BX       lr\n|L1.1052|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define MATRIX_SIZE 100\n\ntypedef struct {\n    double data[MATRIX_SIZE][MATRIX_SIZE];\n    int rows;\n    int cols;\n} Matrix;\n\n\nMatrix* createMatrix(int rows, int cols) {\n    Matrix* matrix = (Matrix*)malloc(sizeof(Matrix));\n    if (matrix == NULL) return NULL;\n    matrix->rows = rows;\n    matrix->cols = cols;\n    memset(matrix->data, 0, sizeof(matrix->data));\n    return matrix;\n}\n\n\nvoid freeMatrix(Matrix* matrix) {\n    free(matrix);\n}\n\n\nMatrix* matrixMultiply(Matrix* a, Matrix* b) {\n    if (a->cols != b->rows) return NULL;\n    Matrix* c = createMatrix(a->rows, b->cols);\n    if (c == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < b->cols; j++) {\n            for (int k = 0; k < a->cols; k++) {\n                c->data[i][j] += a->data[i][k] * b->data[k][j];\n            }\n        }\n    }\n    return c;\n}\n\n\nMatrix* matrixTranspose(Matrix* a) {\n    Matrix* b = createMatrix(a->cols, a->rows);\n    if (b == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < a->cols; j++) {\n            b->data[j][i] = a->data[i][j];\n        }\n    }\n    return b;\n}\n\n\nMatrix* performPCA(Matrix* data, int numComponents){\n    //This is a simplified PCA implementation, it lacks many features of a robust PCA implementation.\n    if(data == NULL || numComponents <=0 || numComponents > data->cols){\n        return NULL;\n    }\n\n    int n = data->rows;\n    int m = data->cols;\n    \n    // 1. Center the data\n    Matrix* centeredData = createMatrix(n,m);\n    if(centeredData == NULL) return NULL;\n    for(int j=0; j<m; ++j){\n        double colMean = 0;\n        for(int i=0; i<n; ++i){\n            colMean += data->data[i][j];\n        }\n        colMean /= n;\n        for(int i=0; i<n; ++i){\n            centeredData->data[i][j] = data->data[i][j] - colMean;\n        }\n    }\n    \n\n    // 2. Compute the covariance matrix\n    Matrix* covarianceMatrix = createMatrix(m, m);\n    if(covarianceMatrix == NULL) return NULL;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < n; k++) {\n                covarianceMatrix->data[i][j] += centeredData->data[k][i] * centeredData->data[k][j];\n            }\n            covarianceMatrix->data[i][j] /= (double)(n -1);\n        }\n    }\n\n    //3. Eigen decomposition (simplified - using only the top numComponents)\n    //This is a placeholder and would require a proper eigenvalue decomposition algorithm in a real implementation\n    Matrix* eigenVectors = createMatrix(m, numComponents);\n    if(eigenVectors == NULL) return NULL;\n\n    //In a real implementation this would be calculated properly\n\n    return eigenVectors;\n\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerate_password__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        SUB      sp,sp,#0x50\n        ADD      r8,sp,#4\n        MOV      r6,r0\n        MOV      r0,r8\n        MOV      r2,#0x49\n        LDR      r1,|L1.204|\n        BL       __rt_memcpy\n        MOV      r0,r8\n        BL       strlen\n        MOV      r7,r0\n        ADD      r0,r6,#1\n        BL       malloc\n        MOVS     r5,r0\n        ADDEQ    sp,sp,#0x50\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BXEQ     lr\n        BL       time\n        BL       srand\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.128|\n|L1.92|\n        BL       rand\n        MOV      r1,r0\n        MOV      r0,r7\n        BL       __rt_sdiv\n        LDRB     r0,[r8,r1]\n        STRB     r0,[r5,r4]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.92|\n|L1.128|\n        MOV      r0,#0\n        STRB     r0,[r5,r6]\n        ADD      sp,sp,#0x50\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* generate_password(int length) {\n    const char charset[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()\";\n    const int charset_length = strlen(charset);\n    char* password = (char*)malloc(length + 1);\n    if (password == NULL) return NULL;\n    srand(time(NULL));\n    for (int i = 0; i < length; i++) {\n        int random_index = rand() % charset_length;\n        password[i] = charset[random_index];\n    }\n    password[length] = '\\0';\n    return password;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsieve__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r0,#4\n        ADD      r6,r0,r4,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r5,#4]\n        STR      r2,[r5,#0]\n        MOV      r1,#2\n        CMP      r4,#4\n        BLT      |L1.136|\n|L1.80|\n        LDR      r0,[r5,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.120|\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BGT      |L1.120|\n|L1.104|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,r1\n        CMP      r0,r4\n        BLE      |L1.104|\n|L1.120|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BLE      |L1.80|\n|L1.136|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* sieve(int n) {\n    if (n <= 1) return 0;\n    int* primes = (int*)malloc((n + 1) * sizeof(int));\n    memset(primes, 1, (n + 1) * sizeof(int));\n    primes[0] = primes[1] = 0;\n    for (int p = 2; p * p <= n; p++) {\n        if (primes[p]) {\n            for (int i = p * p; i <= n; i += p)\n                primes[i] = 0;\n        }\n    }\n    return primes;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nobserverUpdate__FPv PROC\n        LDR      r1,[r0,#0]\n        ADR      r0,|L1.12|\n        B        _printf\n|L1.12|\n        DCB      \"%d\\0\\0\"\n        ENDP\n\nsubjectAttach__FPvP8Observer PROC\n        BX       lr\n        ENDP\n\nsubjectDetach__FPvP8Observer PROC\n        BX       lr\n        ENDP\n\nsubjectNotify__FPv PROC\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Observer {\n    void (*update)(void* data);\n    void* context;\n} Observer;\n\ntypedef struct Subject {\n    void (*attach)(void* subject, Observer* observer);\n    void (*detach)(void* subject, Observer* observer);\n    void (*notify)(void* subject);\n} Subject;\n\n\nvoid observerUpdate(void* data) {\n    int* num = (int*)data;\n    printf(\"%d\", *num);\n}\n\nvoid subjectAttach(void* subject, Observer* observer) {\n    //Implementation not needed for this example.\n}\n\n\nvoid subjectDetach(void* subject, Observer* observer) {\n    //Implementation not needed for this example.\n}\n\n\nvoid subjectNotify(void* subject) {\n    //Implementation not needed for this example.\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmaxSubArraySum__FPii PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        LDR      r12,[r0,#0]\n        MOV      r2,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.60|\n|L1.24|\n        LDR      lr,[r0,r3,LSL #2]\n        ADD      r3,r3,#1\n        ADD      r2,lr,r2\n        CMP      r12,r2\n        MOVLT    r12,r2\n        CMP      r2,#0\n        MOVLT    r2,#0\n        CMP      r3,r1\n        BLT      |L1.24|\n|L1.60|\n        LDR      lr,[sp],#4\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint maxSubArraySum(int arr[], int n) {\n    int max_so_far = arr[0];\n    int max_ending_here = 0;\n\n    for (int i = 0; i < n; i++) {\n        max_ending_here = max_ending_here + arr[i];\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n        if (max_ending_here < 0)\n            max_ending_here = 0;\n    }\n    return max_so_far;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nvectorAngle__FdN31 PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x38\n        LDMIA    r7,{r6,r7}\n        ADD      r5,sp,#0x40\n        MOV      r11,r3\n        MOV      r10,r2\n        MOV      r2,r6\n        MOV      r3,r7\n        LDMIA    r5,{r4,r5}\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _dadd\n        ADD      r12,sp,#0xc\n        STMIA    r12,{r0,r1}\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        BL       __softfp_sqrt\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        BL       __softfp_sqrt\n        ADR      r6,|L1.364|\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMIA    r6,{r2,r3}\n        BL       _dcmpeq\n        BEQ      |L1.280|\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMIA    r6,{r2,r3}\n        BL       _dcmpeq\n        BNE      |L1.296|\n|L1.280|\n        LDMIA    r6,{r0,r1}\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.296|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dmul\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        BL       __softfp_acos\n        ADR      r2,|L1.372|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.380|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        B        _ddiv\n|L1.364|\n        DCFD     0x0000000000000000\n|L1.372|\n        DCFD     0x4066800000000000\n|L1.380|\n        DCFD     0x400921fb54442eea\n        ENDP\n```",
        "output": "```cpp\n\ndouble vectorAngle(double x1, double y1, double x2, double y2) {\n    double dotProduct = x1 * x2 + y1 * y2;\n    double magnitude1 = sqrt(x1 * x1 + y1 * y1);\n    double magnitude2 = sqrt(x2 * x2 + y2 * y2);\n    if (magnitude1 == 0 || magnitude2 == 0) return 0;\n    double angleRad = acos(dotProduct / (magnitude1 * magnitude2));\n    return angleRad * 180 / 3.14159265359;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstartProfiling__FP11ProfileDataPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        STR      r1,[r0,#0]\n        MOV      r4,r0\n        BL       clock\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nendProfiling__FP11ProfileData PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       clock\n        STR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngenerateReport__FP11ProfileDatai PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        ADR      r8,|L1.152|\n|L1.84|\n        ADD      r6,r4,r4,LSL #1\n        ADD      r0,r5,r6,LSL #2\n        LDMIB    r0,{r0,r1}\n        SUB      r0,r1,r0\n        BL       _dfltu\n        LDMIA    r8,{r2,r3}\n        BL       _ddiv\n        MOV      r2,r0\n        MOV      r3,r1\n        LDR      r1,[r5,r6,LSL #2]\n        ADR      r0,|L1.160|\n        BL       printf\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.84|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.152|\n        DCFD     0x4059000000000000\n|L1.160|\n        DCB      \"%s: \"\n        DCB      \"%f s\"\n        DCB      \"econ\"\n        DCB      \"ds\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct ProfileData {\n    char* name;\n    clock_t start;\n    clock_t end;\n};\n\n\nvoid startProfiling(ProfileData* data, char* name){\n    data->name = name;\n    data->start = clock();\n}\n\nvoid endProfiling(ProfileData* data){\n    data->end = clock();\n}\n\nvoid generateReport(ProfileData* data, int count){\n    for (int i = 0; i < count; i++){\n        double duration = (double)(data[i].end - data[i].start) / CLOCKS_PER_SEC;\n        printf(\"%s: %f seconds\\n\", data[i].name, duration);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npreOrder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.48|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       preOrder__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        preOrder__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n\ninOrder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       inOrder__FP4Node\n        ADR      r0,|L1.48|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        inOrder__FP4Node\n        ENDP\n\npostOrder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       postOrder__FP4Node\n        LDR      r0,[r4,#8]\n        BL       postOrder__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.48|\n        B        _printf\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(0), right(0) {}\n};\n\n\nvoid preOrder(Node* node) {\n    if (node) {\n        printf(\"%d \", node->data);\n        preOrder(node->left);\n        preOrder(node->right);\n    }\n}\n\nvoid inOrder(Node* node) {\n    if (node) {\n        inOrder(node->left);\n        printf(\"%d \", node->data);\n        inOrder(node->right);\n    }\n}\n\nvoid postOrder(Node* node) {\n    if (node) {\n        postOrder(node->left);\n        postOrder(node->right);\n        printf(\"%d \", node->data);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nenqueue__Fi PROC\n|L1.0|\n        LDR      r2,|L1.448|\n        MOV      r1,r0\n        LDR      r0,[r2,#4]  ; tail\n        ADD      r3,r0,#1\n        STR      r3,[r2,#4]  ; tail\n        LDR      r2,|L1.452|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\ndequeue__Fv PROC\n        LDR      r1,|L1.448|\n        LDR      r0,[r1,#0]  ; head\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; head\n        LDR      r1,|L1.452|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\nisEmpty__Fv PROC\n        LDR      r0,|L1.448|\n        LDR      r1,[r0,#0]  ; head, tail\n        LDR      r0,[r0,#4]\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisBipartite__FPA1000_ii PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        ADD      r9,sp,#4\n        MOV      r10,r0\n        MOV      r6,r1\n        MVN      r1,#0\n        MOV      r0,r9\n        MOV      r2,#0xfa0\n        BL       __rt_memset\n        MOV      r7,#0\n        CMP      r6,#0\n        BLE      |L1.324|\n        MOV      r11,#0\n|L1.144|\n        LDR      r0,[r9,r7,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.312|\n        STR      r11,[r9,r7,LSL #2]\n        MOV      r0,r7\n        BL       enqueue__Fi\n        BL       isEmpty__Fv\n        CMP      r0,#0\n        BNE      |L1.312|\n|L1.180|\n        BL       dequeue__Fv\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.300|\n        ADD      r0,r5,r5,LSL #1\n        RSB      r0,r0,r5,LSL #7\n        ADD      r8,r10,r0,LSL #5\n|L1.212|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.288|\n        LDR      r0,[r9,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.260|\n        LDR      r0,[r9,r5,LSL #2]\n        RSB      r0,r0,#1\n        STR      r0,[r9,r4,LSL #2]\n        MOV      r0,r4\n        BL       enqueue__Fi\n        B        |L1.288|\n|L1.260|\n        LDR      r1,[r9,r5,LSL #2]\n        CMP      r0,r1\n        ADDEQ    sp,sp,#0xc00\n        ADDEQ    sp,sp,#0x3a4\n        LDMEQFD  sp!,{r4-r11,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n|L1.288|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.212|\n|L1.300|\n        BL       isEmpty__Fv\n        CMP      r0,#0\n        BEQ      |L1.180|\n|L1.312|\n        ADD      r7,r7,#1\n        CMP      r7,r6\n        BLT      |L1.144|\n|L1.324|\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 1000\n\nint queue[MAX_SIZE];\nint head = 0;\nint tail = 0;\n\nvoid enqueue(int x) {\n    queue[tail++] = x;\n}\n\nint dequeue() {\n    return queue[head++];\n}\n\nint isEmpty() {\n    return head == tail;\n}\n\nint isBipartite(int graph[MAX_SIZE][MAX_SIZE], int n) {\n    int color[MAX_SIZE];\n    memset(color, -1, sizeof(color));\n\n    for (int i = 0; i < n; i++) {\n        if (color[i] == -1) {\n            color[i] = 0;\n            enqueue(i);\n\n            while (!isEmpty()) {\n                int u = dequeue();\n                for (int v = 0; v < n; v++) {\n                    if (graph[u][v] && color[v] == -1) {\n                        color[v] = 1 - color[u];\n                        enqueue(v);\n                    } else if (graph[u][v] && color[v] == color[u]) {\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountingSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        MOV      r5,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        MOV      r0,#1\n        CMP      r7,#1\n        LDR      r6,[r5,#0]\n        BLE      |L1.64|\n|L1.40|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r1,r6\n        MOVGT    r6,r1\n        CMP      r0,r7\n        BLT      |L1.40|\n|L1.64|\n        MOV      r0,#4\n        ADD      r8,r0,r6,LSL #2\n        MOV      r0,r8\n        BL       malloc\n        MOV      r4,r0\n        MOV      r1,r8\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r7,#0\n        BLE      |L1.136|\n|L1.104|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r1,r4,r1,LSL #2\n        LDR      r2,[r1,#0]\n        CMP      r0,r7\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        BLT      |L1.104|\n|L1.136|\n        MOV      r3,#0\n        MOV      r0,#0\n        CMP      r6,#0\n        BLT      |L1.208|\n|L1.152|\n        LDR      r2,[r4,r0,LSL #2]\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.196|\n|L1.168|\n        MOV      r2,r3\n        STR      r0,[r5,r2,LSL #2]\n        LDR      r2,[r4,r0,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r2,r1\n        ADD      r3,r3,#1\n        BGT      |L1.168|\n|L1.196|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.152|\n|L1.208|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nvoid countingSort(int arr[], int n) {\n    if (n <= 0) return;\n\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n\n    int* count = (int*)malloc((max + 1) * sizeof(int));\n    memset(count, 0, (max + 1) * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    int k = 0;\n    for (int i = 0; i <= max; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            arr[k++] = i;\n        }\n    }\n    free(count);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompare_data__FPCvT1 PROC\n|L1.0|\n        LDR      r0,[r0,#0]\n        LDR      r1,[r1,#0]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n\nsort_data__FP4Datai PROC\n        LDR      r3,|L1.84|\n        MOV      r2,#0x38\n        B        qsort\n        ENDP\n```",
        "output": "```cpp\n\nstruct Data {\n    int id;\n    char name[50];\n};\n\nint compare_data(const void* a, const void* b) {\n    return ((Data*)a)->id - ((Data*)b)->id;\n}\n\nvoid sort_data(Data* data, int size) {\n    qsort(data, size, sizeof(Data), compare_data);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncaesar_cipher__FPciT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r7,r2\n        MOV      r5,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        BL       __rt_ctype_table\n        RSB      r2,r8,#0\n        CMP      r7,#0\n        MOVNE    r2,r8\n        LDR      r1,|L1.264|\n        MOV      r8,r2\n|L1.64|\n        LDRB     r3,[r5,r4]\n        LDR      r2,[r0,#0]\n        LDRB     r2,[r2,r3]\n        TST      r2,#0x18\n        BEQ      |L1.144|\n        TST      r2,#8\n        MOVEQ    r2,#0x41\n        MOVNE    r2,#0x61\n        SUB      r3,r3,r2\n        ADD      r3,r3,r8\n        ADD      r3,r3,#0x1a\n        SMULL    lr,r12,r1,r3\n        MOV      r12,r12,ASR #3\n        SUB      lr,r12,r12,ASR #31\n        SUB      r12,lr,lr,LSL #1\n        ADD      r12,r12,r12,LSL #4\n        ADD      r12,r12,lr,LSL #2\n        ADD      r3,r3,r12,LSL #1\n        ADD      r2,r3,r2\n        STRB     r2,[r5,r4]\n|L1.144|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.64|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid caesar_cipher(char *text, int shift, int encrypt) {\n    int len = strlen(text);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(text[i])) {\n            char base = islower(text[i]) ? 'a' : 'A';\n            text[i] = base + (text[i] - base + (encrypt ? shift : -shift) + 26) % 26;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncelsiusToFahrenheit__Ff PROC\n        STMFD    sp!,{r3,lr}\n        BL       _f2d\n        ADR      r2,|L1.52|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.60|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        ADR      r2,|L1.68|\n        LDMIA    r2,{r2,r3}\n        BL       _dadd\n        LDMFD    sp!,{r3,lr}\n        B        _d2f\n|L1.52|\n        DCFD     0x4022000000000000\n|L1.60|\n        DCFD     0x4014000000000000\n|L1.68|\n        DCFD     0x4040000000000000\n        ENDP\n\nfahrenheitToCelsius__Ff PROC\n        STMFD    sp!,{r3,lr}\n        BL       _f2d\n        ADR      r2,|L1.68|\n        LDMIA    r2,{r2,r3}\n        BL       _dsub\n        ADR      r2,|L1.60|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.52|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        LDMFD    sp!,{r3,lr}\n        B        _d2f\n        ENDP\n```",
        "output": "```cpp\n\nfloat celsiusToFahrenheit(float celsius) {\n    return (celsius * 9.0 / 5.0) + 32.0;\n}\n\nfloat fahrenheitToCelsius(float fahrenheit) {\n    return (fahrenheit - 32.0) * 5.0 / 9.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r4,#1\n        BL       fibonacci__Fi\n        MOV      r5,r0\n        SUB      r0,r4,#2\n        BL       fibonacci__Fi\n        ADD      r0,r5,r0\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npreorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        STR      r0,[sp,#0]\n        MOV      r4,#0\n|L1.68|\n        MOV      r0,r4\n        LDR      r5,[r6,r0,LSL #2]\n        ADR      r0,|L1.144|\n        SUB      r4,r4,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r0,[r5,#8]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        LDR      r0,[r5,#4]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        CMP      r4,#0\n        BGE      |L1.68|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.144|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid preorderIterative(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* stack[1000];\n    int top = -1;\n\n    stack[++top] = root;\n\n    while (top >= 0) {\n        struct Node* node = stack[top--];\n        printf(\"%d \", node->data);\n\n        if (node->right)\n            stack[++top] = node->right;\n        if (node->left)\n            stack[++top] = node->left;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbuildTree__FPiT1iT3T1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#8\n        LDR      r5,[sp,#0x28]\n        CMP      r2,r3\n        ADDGT    sp,sp,#8\n        MOV      r10,r1\n        MOV      r8,r0\n        MOV      r7,r2\n        MOV      r6,r3\n        LDMGTFD  sp!,{r4-r10,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r0,[r5,#0]\n        LDR      r4,[r10,r0,LSL #2]\n        MOV      r0,#0xc\n        BL       __nw__FUi\n        CMP      r0,#0\n        BEQ      |L1.88|\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n|L1.88|\n        MOV      r4,r0\n        LDR      r0,[r5,#0]\n        CMP      r7,r6\n        ADD      r0,r0,#1\n        STR      r0,[r5,#0]\n        ADDEQ    sp,sp,#8\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r9,#0\n        MOV      r0,r7\n|L1.136|\n        LDR      r2,[r8,r0,LSL #2]\n        CMP      r2,r1\n        MOVEQ    r9,r0\n        BEQ      |L1.164|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.136|\n|L1.164|\n        SUB      r3,r9,#1\n        MOV      r2,r7\n        MOV      r1,r10\n        MOV      r0,r8\n        STR      r5,[sp,#0]\n        BL       buildTree__FPiT1iT3T1\n        STR      r0,[r4,#4]\n        STR      r5,[sp,#0]\n        MOV      r0,r8\n        MOV      r3,r6\n        ADD      r2,r9,#1\n        MOV      r1,r10\n        BL       buildTree__FPiT1iT3T1\n        STR      r0,[r4,#8]\n        ADD      sp,sp,#8\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nNode* buildTree(int in[], int pre[], int inStrt, int inEnd, int* preIndex) {\n    if (inStrt > inEnd) return NULL;\n\n    Node* node = new Node(pre[*preIndex]);\n    (*preIndex)++;\n\n    if (inStrt == inEnd) return node;\n\n    int inIndex = 0;\n    for (int i = inStrt; i <= inEnd; i++) {\n        if (in[i] == node->data) {\n            inIndex = i;\n            break;\n        }\n    }\n\n    node->left = buildTree(in, pre, inStrt, inIndex - 1, preIndex);\n    node->right = buildTree(in, pre, inIndex + 1, inEnd, preIndex);\n\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndecimalToBinaryRecursive__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADD      r0,r4,r4,LSR #31\n        MOV      r5,r0,ASR #1\n        ADD      r1,r6,r6,LSL #2\n        MOV      r1,r1,LSL #1\n        MOV      r0,r5\n        BL       decimalToBinaryRecursive__FiT1\n        SUB      r1,r4,r5,LSL #1\n        MLA      r0,r6,r1,r0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndecimalToBinary__Fi PROC\n        CMP      r0,#0\n        MOVNE    r1,#1\n        BNE      decimalToBinaryRecursive__FiT1\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint decimalToBinaryRecursive(int n, int multiplier) {\n    if (n == 0) return 0;\n    return (n % 2) * multiplier + decimalToBinaryRecursive(n / 2, multiplier * 10);\n}\n\nint decimalToBinary(int n) {\n    if (n == 0) return 0;\n    return decimalToBinaryRecursive(n, 1);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngetHeight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrotateRight__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       getHeight__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       getHeight__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       getHeight__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       getHeight__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nrotateLeft__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       getHeight__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       getHeight__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       getHeight__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       getHeight__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       getHeight__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       getHeight__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       getHeight__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       getHeight__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rotateRight__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      rotateLeft__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       rotateLeft__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rotateRight__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rotateRight__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rotateLeft__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\navlHeight__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r0,#0xfa0\n        BL       malloc\n        MOV      r1,#0\n        MOV      r2,#1\n        STR      r5,[r0,#0]\n|L1.644|\n        MOV      r3,r1\n        LDR      r3,[r0,r3,LSL #2]\n        ADD      r1,r1,#1\n        LDR      r12,[r3,#4]\n        LDR      lr,[r3,#8]\n        CMP      r12,r4\n        MOVLE    r12,r4\n        MOV      r4,r12\n        CMP      lr,#0\n        MOVNE    r12,r2\n        STRNE    lr,[r0,r12,LSL #2]\n        LDR      r12,[r3,#0xc]\n        ADDNE    r2,r2,#1\n        CMP      r12,#0\n        MOVNE    r3,r2\n        STRNE    r12,[r0,r3,LSL #2]\n        ADDNE    r2,r2,#1\n        CMP      r1,r2\n        BLT      |L1.644|\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), height(1), left(NULL), right(NULL) {}\n};\n\nint getHeight(Node* node) {\n    if (node == NULL) return 0;\n    return node->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rotateRight(Node* y) {\n    Node* x = y->left;\n    Node* T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;\n    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;\n    return x;\n}\n\n\nNode* rotateLeft(Node* x) {\n    Node* y = x->right;\n    Node* T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;\n    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;\n    return y;\n}\n\n\nint getBalance(Node* N) {\n    if (N == NULL)\n        return 0;\n    return getHeight(N->left) - getHeight(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return (new Node(data));\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n    node->height = 1 + max(getHeight(node->left),\n                           getHeight(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rotateRight(node);\n    if (balance < -1 && data > node->right->data)\n        return rotateLeft(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = rotateLeft(node->left);\n        return rotateRight(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rotateRight(node->right);\n        return rotateLeft(node);\n    }\n    return node;\n}\n\nint avlHeight(Node* root){\n    if(root == NULL) return 0;\n    int height = 0;\n    Node* current;\n    \n    //Use a queue to implement level-order traversal\n    Node** queue = (Node**)malloc(sizeof(Node*) * 1000);\n    int head = 0;\n    int tail = 0;\n    queue[tail++] = root;\n\n    while(head < tail){\n        current = queue[head++];\n        height = current->height > height ? current->height : height;\n        if(current->left) queue[tail++] = current->left;\n        if(current->right) queue[tail++] = current->right;\n    }\n    free(queue);\n    return height;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nheight__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        CMP      r5,r0\n        MOVGT    r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r0,#1\n        BX       lr\n        ENDP\n\ndiameter__FP4Node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        MOV      r6,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r7,r0\n        LDR      r0,[r4,#4]\n        BL       diameter__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       diameter__FP4Node\n        ADD      r1,r6,r7\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        LDMGTFD  sp!,{r4-r7,lr}\n        MOVGT    r0,r1\n        BXGT     lr\n        CMP      r5,r0\n        MOVGT    r0,r5\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nint height(struct Node* node) {\n    if (node == NULL) return 0;\n    int lh = height(node->left);\n    int rh = height(node->right);\n    return (lh > rh ? lh : rh) + 1;\n}\n\nint diameter(struct Node* node) {\n    if (node == NULL) return 0;\n    int lh = height(node->left);\n    int rh = height(node->right);\n    int ld = diameter(node->left);\n    int rd = diameter(node->right);\n\n    return (lh + rh + 1 > ld ? (lh + rh + 1) : (ld > rd ? ld : rd));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_leap__Fi PROC\n        CMP      r0,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        LDR      r2,|L1.404|\n        SMULL    r3,r1,r2,r0\n        MOV      r1,r1,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADD      r3,r0,r1,LSL #2\n        SMULL    r12,r1,r2,r0\n        MOV      r1,r1,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r0,r1,LSL #2\n        CMP      r1,#2\n        SMULL    r12,r1,r2,r0\n        MOV      r1,r1,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r0,r1,LSL #2\n        BLE      |L1.140|\n        SMULL    r12,r1,r2,r1\n        MOV      r1,r1,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        MOV      r12,#0xd\n        ADD      r12,r12,r1,LSL #2\n        B        |L1.172|\n|L1.140|\n        SUB      r1,r1,#1\n        SMULL    r12,r1,r2,r1\n        MOV      r1,r1,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        MOV      r12,#0xc\n        ADD      r12,r12,r1,LSL #2\n|L1.172|\n        STMFD    sp!,{r4,lr}\n        SMULL    lr,r1,r2,r0\n        SMULL    lr,r0,r2,r0\n        MOV      lr,r12\n        ADD      r12,lr,lr,LSL #2\n        ADD      r12,r12,lr,LSL #3\n        ADD      lr,r12,#0xd\n        LDR      r12,|L1.408|\n        MOV      r1,r1,ASR #5\n        SMULL    r4,lr,r12,lr\n        MOV      r12,lr,ASR #1\n        SUB      r12,r12,r12,ASR #31\n        ADD      r3,r12,r3\n        SUB      r1,r1,r1,ASR #31\n        MOV      r12,r1,ASR #31\n        ADD      r12,r1,r12,LSR #30\n        ADD      r3,r3,r1\n        ADD      r3,r3,r12,ASR #2\n        SMULL    r12,r1,r2,r1\n        MOV      r1,r1,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r3,r1\n        MOV      r0,r0,ASR #7\n        SUB      r0,r0,r0,ASR #31\n        ADD      r1,r1,r0\n        LDR      r2,|L1.412|\n        MOV      r0,r1\n        MOV      r3,#0\n        SMLAL    r3,r0,r2,r1\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #3\n        ADDS     r0,r0,r1\n        LDMFD    sp!,{r4,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_leap(int year) {\n    if (year <= 0) return 0;\n    int q = year % 100;\n    int m = (year % 100 > 2) ? 13 + (year % 100) / 100 * 100 : 13 + (year % 100 -1) /100 *100 -1;\n    int K = year/ 100;\n    int J = year/400;\n    int h = (q + ((13*(m+1))/5) + K + (K/4) - (K/100) + J) %7;\n\n    if (h == 0) return 1;\n    return 0;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nbuildTree__FPiiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r2\n        MOV      r6,r0\n        MOV      r4,r1\n        CMP      r1,r2\n        LDMGEFD  sp!,{r3-r7,lr}\n        MOVGE    r0,#0\n        BXGE     lr\n        LDR      r0,[r6,r4,LSL #2]\n        BL       newNode__Fi\n        MOV      r5,r0\n        MOV      r0,#1\n        ADD      r1,r0,r4,LSL #1\n        MOV      r0,r6\n        MOV      r2,r7\n        BL       buildTree__FPiiT2\n        STR      r0,[r5,#4]\n        MOV      r0,#2\n        ADD      r1,r0,r4,LSL #1\n        MOV      r0,r6\n        MOV      r2,r7\n        BL       buildTree__FPiiT2\n        STR      r0,[r5,#8]\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nstruct node* buildTree(int arr[], int i, int n) {\n    if (i >= n) return NULL;\n\n    struct node* root = newNode(arr[i]);\n    root->left = buildTree(arr, 2 * i + 1, n);\n    root->right = buildTree(arr, 2 * i + 2, n);\n\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerate_password__FPci PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        SUB      sp,sp,#0x50\n        ADD      r8,sp,#4\n        MOV      r6,r0\n        MOV      r5,r1\n        LDR      r1,|L1.164|\n        MOV      r0,r8\n        MOV      r2,#0x49\n        BL       __rt_memcpy\n        MOV      r0,r8\n        BL       strlen\n        MOV      r7,r0\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.108|\n|L1.72|\n        BL       rand\n        MOV      r1,r0\n        MOV      r0,r7\n        BL       __rt_sdiv\n        LDRB     r0,[r8,r1]\n        STRB     r0,[r6,r4]\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.72|\n|L1.108|\n        MOV      r0,#0\n        STRB     r0,[r6,r5]\n        ADD      sp,sp,#0x50\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid generate_password(char* password, int length) {\n    const char charset[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()\";\n    int charset_length = strlen(charset);\n    srand(time(NULL));\n    for (int i = 0; i < length; i++) {\n        int random_index = rand() % charset_length;\n        password[i] = charset[random_index];\n    }\n    password[length] = '\\0';\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    return (N == NULL) ? 0 : N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int k) {\n    return new Node(k);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r1\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,r0\n        MOV      r0,r4\n        BL       __rt_sdiv\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        gcd__FiT1\n        ENDP\n\ngcd_multiple__FiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r5,#1\n        LDREQ    r0,[r6,#0]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r4,#1\n        LDR      r0,[r6,#0]\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.92|\n        LDR      r1,[r6,r4,LSL #2]\n        BL       gcd__FiT1\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.92|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nint gcd_multiple(int count, int* nums) {\n    if (count == 0) {\n        return 0;\n    }\n    if (count == 1) {\n        return nums[0];\n    }\n    int result = nums[0];\n    for (int i = 1; i < count; i++) {\n        result = gcd(result, nums[i]);\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateTensor__FiN21 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,#0x10\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       malloc\n        MOV      r4,r0\n        STMIA    r0,{r5-r7}\n        MOV      r0,r5,LSL #2\n        MUL      r0,r6,r0\n        MUL      r0,r7,r0\n        BL       malloc\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nfreeTensor__FP6Tensor PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0xc]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nconv2d__FP6TensorT1i PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#0x28\n        LDR      r0,[sp,#0x28]\n        MOV      r9,r2\n        LDR      r0,[r0,#0]\n        LDR      r1,[sp,#0x28]\n        LDR      r3,[r1,#4]\n        STR      r3,[sp,#0x1c]\n        LDR      r2,[r1,#8]\n        LDR      r1,[sp,#0x2c]\n        STR      r2,[sp,#0x18]\n        LDR      r1,[r1,#0]\n        STR      r1,[sp,#0x14]\n        LDR      r1,[sp,#0x2c]\n        LDR      r7,[r1,#4]\n        LDR      r1,[r1,#8]\n        STR      r1,[sp,#0x10]\n        CMP      r2,r1\n        ADDNE    sp,sp,#0x34\n        LDMNEFD  sp!,{r4-r11,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[sp,#0x14]\n        SUB      r1,r0,r1\n        MOV      r0,r9\n        BL       __rt_sdiv\n        ADD      r1,r0,#1\n        LDR      r3,[sp,#0x1c]\n        STR      r1,[sp,#0xc]\n        SUB      r1,r3,r7\n        MOV      r0,r9\n        BL       __rt_sdiv\n        ADD      r2,r0,#1\n        STR      r2,[sp,#8]\n        LDR      r1,[sp,#8]\n        MOV      r2,#1\n        LDR      r0,[sp,#0xc]\n        BL       createTensor__FiN21\n        STR      r0,[sp,#4]\n        LDR      r1,[sp,#0xc]\n        MOV      r0,#0\n        STR      r0,[sp,#0]\n        CMP      r1,#0\n        BLE      |L1.536|\n|L1.268|\n        LDR      r2,[sp,#8]\n        MOV      r10,#0\n        CMP      r2,#0\n        BLE      |L1.512|\n|L1.284|\n        LDR      r1,[sp,#0x10]\n        MOV      r8,#0\n        MOV      r6,#0\n        CMP      r1,#0\n        BLE      |L1.472|\n|L1.304|\n        LDR      r0,[sp,#0x14]\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.456|\n|L1.320|\n        MOV      r4,#0\n        CMP      r7,#0\n        BLE      |L1.440|\n        LDR      r0,[sp,#0]\n        MLA      r2,r9,r0,r5\n        LDR      r0,[sp,#0x28]\n        STR      r2,[sp,#0x24]\n        LDR      r0,[r0,#0xc]\n        STR      r0,[sp,#0x20]\n        LDR      r0,[sp,#0x2c]\n        LDR      r11,[r0,#0xc]\n|L1.364|\n        LDR      r1,[sp,#0x10]\n        MLA      r0,r7,r5,r4\n        MLA      r1,r0,r1,r6\n        LDR      r1,[r11,r1,LSL #2]\n        LDR      r2,[sp,#0x24]\n        LDR      r3,[sp,#0x1c]\n        MLA      r0,r9,r10,r4\n        MLA      r0,r3,r2,r0\n        LDR      r2,[sp,#0x18]\n        MLA      r2,r0,r2,r6\n        LDR      r0,[sp,#0x20]\n        LDR      r0,[r0,r2,LSL #2]\n        BL       _fmul\n        MOV      r1,r8\n        BL       _fadd\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        MOV      r8,r0\n        BLT      |L1.364|\n|L1.440|\n        LDR      r0,[sp,#0x14]\n        ADD      r5,r5,#1\n        CMP      r5,r0\n        BLT      |L1.320|\n|L1.456|\n        LDR      r1,[sp,#0x10]\n        ADD      r6,r6,#1\n        CMP      r6,r1\n        BLT      |L1.304|\n|L1.472|\n        LDR      r0,[sp,#4]\n        LDR      r0,[r0,#0xc]\n        LDR      r1,[sp,#0]\n        LDR      r2,[sp,#8]\n        MLA      r1,r2,r1,r10\n        STR      r8,[r0,r1,LSL #2]\n        LDR      r2,[sp,#8]\n        ADD      r10,r10,#1\n        CMP      r10,r2\n        BLT      |L1.284|\n|L1.512|\n        LDR      r0,[sp,#0]\n        LDR      r1,[sp,#0xc]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0]\n        CMP      r0,r1\n        BLT      |L1.268|\n|L1.536|\n        LDR      r0,[sp,#4]\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int height;\n    int width;\n    int channels;\n    float* data;\n} Tensor;\n\n\nTensor* createTensor(int h, int w, int c){\n    Tensor* t = (Tensor*)malloc(sizeof(Tensor));\n    t->height = h;\n    t->width = w;\n    t->channels = c;\n    t->data = (float*)malloc(sizeof(float) * h * w * c);\n    return t;\n}\n\nvoid freeTensor(Tensor* t){\n    free(t->data);\n    free(t);\n}\n\n\nTensor* conv2d(Tensor* input, Tensor* kernel, int stride){\n    int input_h = input->height;\n    int input_w = input->width;\n    int input_c = input->channels;\n    int kernel_h = kernel->height;\n    int kernel_w = kernel->width;\n    int kernel_c = kernel->channels;\n\n    if(input_c != kernel_c) return 0;\n\n    int output_h = (input_h - kernel_h) / stride + 1;\n    int output_w = (input_w - kernel_w) / stride + 1;\n    \n    Tensor* output = createTensor(output_h, output_w, 1);\n\n    for(int i = 0; i < output_h; ++i){\n        for(int j = 0; j < output_w; ++j){\n            float sum = 0;\n            for(int k = 0; k < kernel_c; ++k){\n                for(int l = 0; l < kernel_h; ++l){\n                    for(int m = 0; m < kernel_w; ++m){\n                        sum += input->data[(i * stride + l) * input_w * input_c + (j * stride + m) * input_c + k] * kernel->data[l * kernel_w * kernel_c + m * kernel_c + k];\n                    }\n                }\n            }\n            output->data[i * output_w + j] = sum;\n        }\n    }\n    return output;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npartition__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        SUB      r5,r2,#1\n        CMP      r1,r5\n        LDR      r4,[r0,r2,LSL #2]\n        SUB      r3,r1,#1\n        BGT      |L1.64|\n|L1.24|\n        LDR      lr,[r0,r1,LSL #2]\n        CMP      lr,r4\n        BGE      |L1.52|\n        ADD      r3,r3,#1\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r1,LSL #2]\n|L1.52|\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        BLE      |L1.24|\n|L1.64|\n        ADD      r12,r0,r3,LSL #2\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r1,[r12,#4]\n        STR      lr,[r12,#4]\n        STR      r1,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r3,#1\n        BX       lr\n        ENDP\n\nkthSmallest__FPiiN22 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,r2\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,r3\n        CMP      r3,#0\n        BLE      |L1.240|\n        SUB      r0,r7,r5\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.240|\n        MOV      r2,r7\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       partition__FPiiT2\n        SUB      r1,r0,r5\n        SUB      r2,r4,#1\n        CMP      r1,r2\n        LDREQ    r0,[r6,r0,LSL #2]\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        BLE      |L1.208|\n        SUB      r2,r0,#1\n        MOV      r0,r6\n        MOV      r3,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r4-r7,lr}\n        B        kthSmallest__FPiiN22\n|L1.208|\n        SUB      r1,r4,r0\n        ADD      r1,r1,r5\n        SUB      r3,r1,#1\n        ADD      r1,r0,#1\n        MOV      r0,r6\n        MOV      r2,r7\n        LDMFD    sp!,{r4-r7,lr}\n        B        kthSmallest__FPiiN22\n|L1.240|\n        LDMFD    sp!,{r4-r7,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nint kthSmallest(int arr[], int low, int high, int k) {\n    if (k > 0 && k <= high - low + 1) {\n        int pos = partition(arr, low, high);\n        if (pos - low == k - 1)\n            return arr[pos];\n        if (pos - low > k - 1)\n            return kthSmallest(arr, low, pos - 1, k);\n        return kthSmallest(arr, pos + 1, high, k - pos + low - 1);\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmeasure_performance__FPFv_di PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r5,r1\n        BL       clock\n        MOV      r7,r0\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.52|\n|L1.32|\n        MOV      lr,pc\n        BX       r6\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.32|\n|L1.52|\n        BL       clock\n        SUB      r0,r0,r7\n        BL       _dfltu\n        ADR      r2,|L1.112|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r6,r1\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        _drdiv\n|L1.112|\n        DCFD     0x4059000000000000\n        ENDP\n\nmy_function__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        ADR      r0,|L1.196|\n        LDMIA    r0,{r5,r6}\n        MOV      r4,#0\n|L1.136|\n        MOV      r0,r4\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r4,r4,#1\n        SUBS     r12,r4,#0xf4000\n        SUBGES   r12,r12,#0x240\n        MOV      r5,r0\n        MOV      r6,r1\n        BLT      |L1.136|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.196|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble measure_performance(double (*func)(), int iterations) {\n    clock_t start_time = clock();\n    for (int i = 0; i < iterations; i++) {\n        func();\n    }\n    clock_t end_time = clock();\n    double total_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;\n    return total_time / iterations;\n}\n\ndouble my_function() {\n    double sum = 0;\n    for (int i = 0; i < 1000000; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringToInt__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,#1\n        MOV      r6,#0\n        MOVS     r5,r0\n        MOV      r4,#0\n        BEQ      |L1.40|\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.52|\n|L1.40|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.52|\n        LDRB     r0,[r5,#0]\n        CMP      r0,#0x2d\n        MOVEQ    r4,#1\n        LDRB     r0,[r5,r4]\n        MVNEQ    r7,#0\n        CMP      r0,#0\n        BEQ      |L1.140|\n|L1.80|\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0x30\n        BCC      |L1.100|\n        CMP      r0,#0x39\n        BLS      |L1.112|\n|L1.100|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.112|\n        ADD      r1,r6,r6,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        SUB      r6,r0,#0x30\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.80|\n|L1.140|\n        MUL      r0,r6,r7\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint stringToInt(char *str) {\n    int sign = 1;\n    int res = 0;\n    int i = 0;\n\n    if (str == NULL || strlen(str) == 0) return 0;\n\n    if (str[0] == '-') {\n        sign = -1;\n        i++;\n    }\n\n    for (; str[i] != '\\0'; i++) {\n        if (str[i] < '0' || str[i] > '9') return 0;\n        res = res * 10 + (str[i] - '0');\n    }\n\n    return sign * res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindPrimeFactors__FiPiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        MOV      r0,#0\n        STR      r0,[r2,#0]\n        CMP      r4,#1\n        MOV      r7,r1\n        MOV      r6,r2\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        TST      r4,#1\n        BNE      |L1.80|\n        MOV      r1,#2\n|L1.48|\n        LDR      r0,[r6,#0]\n        ADD      r2,r0,#1\n        STR      r2,[r6,#0]\n        STR      r1,[r7,r0,LSL #2]\n        ADD      r0,r4,r4,LSR #31\n        MOV      r4,r0,ASR #1\n        TST      r4,#1\n        BEQ      |L1.48|\n|L1.80|\n        MOV      r5,#3\n        CMP      r4,#9\n        BLT      |L1.180|\n|L1.92|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.164|\n|L1.112|\n        LDR      r0,[r6,#0]\n        ADD      r1,r0,#1\n        STR      r1,[r6,#0]\n        STR      r5,[r7,r0,LSL #2]\n        MOV      r0,r5\n        MOV      r1,r4\n        BL       __rt_sdiv\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BEQ      |L1.112|\n|L1.164|\n        ADD      r5,r5,#2\n        MUL      r0,r5,r5\n        CMP      r0,r4\n        BLE      |L1.92|\n|L1.180|\n        CMP      r4,#2\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        LDR      r0,[r6,#0]\n        ADD      r1,r0,#1\n        STR      r1,[r6,#0]\n        STR      r4,[r7,r0,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid findPrimeFactors(int n, int* factors, int* count) {\n    *count = 0;\n    if (n <= 1) return;\n    while (n % 2 == 0) {\n        factors[(*count)++] = 2;\n        n /= 2;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors[(*count)++] = i;\n            n /= i;\n        }\n    }\n    if (n > 2)\n        factors[(*count)++] = n;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntriangle_area__FdT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        ADR      r8,|L1.108|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       _dcmple\n        BCC      |L1.56|\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMIA    r8,{r2,r3}\n        BL       _dcmple\n        BCS      |L1.72|\n|L1.56|\n        ADR      r1,|L1.116|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.72|\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        _dmul\n|L1.108|\n        DCFD     0x0000000000000000\n|L1.116|\n        DCFD     0xbff0000000000000\n|L1.124|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble triangle_area(double base, double height) {\n    if (base < 0 || height < 0) return -1.0; //Error handling for negative inputs.\n    return 0.5 * base * height;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerateSubsets__FPii PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r9,r0\n        MOV      r0,#1\n        MOV      r8,r0,LSL r1\n        MOV      r0,r8,LSL #2\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r7,r0\n        LDMEQFD  sp!,{r3-r11,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        CMP      r8,#0\n        BLE      |L1.248|\n        MOV      r10,#4\n        MVN      r11,#0\n|L1.60|\n        MOV      r5,#0\n        MOV      r0,#0\n        CMP      r6,#0\n        BLE      |L1.100|\n|L1.76|\n        MOV      r1,r4,ASR r0\n        TST      r1,#1\n        ADDNE    r5,r5,#1\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.76|\n|L1.100|\n        ADD      r0,r10,r5,LSL #2\n        BL       malloc\n        STR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.172|\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.152|\n|L1.132|\n        LDR      r0,[r7,r5,LSL #2]\n        BL       free\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        BLT      |L1.132|\n|L1.152|\n        MOV      r0,r7\n        BL       free\n        LDMFD    sp!,{r3-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.172|\n        STR      r11,[r0,r5,LSL #2]\n        MOV      r0,#0\n        MOV      r2,#0\n        CMP      r6,#0\n        BLE      |L1.236|\n|L1.192|\n        MOV      r1,r4,ASR r0\n        TST      r1,#1\n        BEQ      |L1.224|\n        LDR      r3,[r9,r0,LSL #2]\n        LDR      r12,[r7,r4,LSL #2]\n        MOV      r1,r2\n        STR      r3,[r12,r1,LSL #2]\n        ADD      r2,r2,#1\n|L1.224|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.192|\n|L1.236|\n        ADD      r4,r4,#1\n        CMP      r4,r8\n        BLT      |L1.60|\n|L1.248|\n        MOV      r0,r7\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint** generateSubsets(int* set, int n) {\n    int numSubsets = 1 << n;\n    int** subsets = (int**)malloc(numSubsets * sizeof(int*));\n    if (subsets == NULL) return NULL;\n\n    for (int i = 0; i < numSubsets; i++) {\n        int subsetSize = 0;\n        for (int j = 0; j < n; j++) {\n            if ((i >> j) & 1) {\n                subsetSize++;\n            }\n        }\n        subsets[i] = (int*)malloc((subsetSize + 1) * sizeof(int));\n        if (subsets[i] == NULL) {\n            for (int k = 0; k < i; k++) {\n                free(subsets[k]);\n            }\n            free(subsets);\n            return NULL;\n        }\n        subsets[i][subsetSize] = -1; \n        int k = 0;\n        for (int j = 0; j < n; j++) {\n            if ((i >> j) & 1) {\n                subsets[i][k++] = set[j];\n            }\n        }\n    }\n    return subsets;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsubsetSumRecursive__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r0\n        MOVS     r4,r2\n        LDMEQFD  sp!,{r4-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4-r7,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r7,r5,r1,LSL #2\n        LDR      r0,[r7,#-4]\n        SUB      r6,r1,#1\n        CMP      r0,r4\n        BLE      |L1.80|\n        MOV      r2,r4\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r7,lr}\n        B        subsetSumRecursive__FPiiT2\n|L1.80|\n        MOV      r2,r4\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       subsetSumRecursive__FPiiT2\n        CMP      r0,#0\n        BNE      |L1.136|\n        LDR      r0,[r7,#-4]\n        MOV      r1,r6\n        SUB      r2,r4,r0\n        MOV      r0,r5\n        BL       subsetSumRecursive__FPiiT2\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n|L1.136|\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint subsetSumRecursive(int arr[], int n, int sum) {\n    if (sum == 0) return 1;\n    if (n == 0 && sum != 0) return 0;\n    if (arr[n - 1] > sum) return subsetSumRecursive(arr, n - 1, sum);\n    return subsetSumRecursive(arr, n - 1, sum) || subsetSumRecursive(arr, n - 1, sum - arr[n - 1]);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r6,|L1.372|\n        LDR      r7,|L1.376|\n        MOV      r1,#1\n        STR      r1,[r6,r0,LSL #2]\n        LDR      r1,[r7,#0]  ; numVertices\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.380|\n        ADD      r5,r0,r1,LSL #4\n|L1.56|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.84|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        BLEQ     dfs__Fi\n|L1.84|\n        LDR      r0,[r7,#0]  ; numVertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.56|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nisTree__Fv PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.372|\n        MOV      r1,#0x190\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        BL       dfs__Fi\n        LDR      r0,|L1.376|\n        MOV      r1,#0\n        LDR      r0,[r0,#0]  ; numVertices\n        CMP      r0,#0\n        BLE      |L1.188|\n|L1.156|\n        LDR      r2,[r4,r1,LSL #2]\n        CMP      r2,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.156|\n|L1.188|\n        MOV      r2,#0\n        MOV      r3,#0\n        CMP      r0,#0\n        BLE      |L1.268|\n        LDR      lr,|L1.380|\n|L1.208|\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.256|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r12,lr,r12,LSL #4\n|L1.232|\n        LDR      r4,[r12,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r4,#0\n        ADDNE    r2,r2,#1\n        CMP      r1,r0\n        BLT      |L1.232|\n|L1.256|\n        ADD      r3,r3,#1\n        CMP      r3,r0\n        BLT      |L1.208|\n|L1.268|\n        SUB      r0,r0,#1\n        CMP      r0,r2\n        LDMFD    sp!,{r4,lr}\n        MOVEQ    r0,#1\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint graph[MAX_VERTICES][MAX_VERTICES];\nint visited[MAX_VERTICES];\nint numVertices;\n\nvoid dfs(int vertex) {\n    visited[vertex] = 1;\n    for (int i = 0; i < numVertices; i++) {\n        if (graph[vertex][i] && !visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\nint isTree() {\n    memset(visited, 0, sizeof(visited));\n    dfs(0);\n    for (int i = 0; i < numVertices; i++) {\n        if (!visited[i]) return 0; \n    }\n\n    int edges = 0;\n    for (int i = 0; i < numVertices; i++) {\n        for (int j = 0; j < numVertices; j++) {\n            if (graph[i][j]) edges++;\n        }\n    }\n\n    if (edges != numVertices -1) return 0;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfind__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r1\n        LDR      r1,[r0,r1,LSL #2]\n        MOV      r5,r0\n        CMP      r1,r4\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r0,r5\n        BL       find__FPii\n        STR      r0,[r5,r4,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nunite__FPiT1iT3 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r1\n        MOV      r1,r2\n        MOV      r7,r3\n        MOV      r5,r0\n        BL       find__FPii\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r1,r7\n        BL       find__FPii\n        CMP      r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r1,[r6,r4,LSL #2]\n        LDR      r2,[r6,r0,LSL #2]\n        CMP      r1,r2\n        STRLT    r0,[r5,r4,LSL #2]\n        LDMLTFD  sp!,{r4-r7,lr}\n        BXLT     lr\n        STRGT    r4,[r5,r0,LSL #2]\n        LDMGTFD  sp!,{r4-r7,lr}\n        BXGT     lr\n        STR      r4,[r5,r0,LSL #2]\n        LDR      r0,[r6,r4,LSL #2]\n        ADD      r0,r0,#1\n        STR      r0,[r6,r4,LSL #2]\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\ndetectCycle__FiPiT1 PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r6,r0,LSL #2\n        MOV      r4,r0\n        MOV      r0,r6\n        MOV      r11,r2\n        MOV      r9,r1\n        BL       malloc\n        MOV      r5,r0\n        MOV      r0,r6\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.244|\n        MOV      r1,#0\n|L1.224|\n        STR      r0,[r5,r0,LSL #2]\n        STR      r1,[r6,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.224|\n|L1.244|\n        MOV      r4,#0\n        CMP      r11,#0\n        BLE      |L1.364|\n|L1.256|\n        LDR      r7,[r9,r4,LSL #3]\n        ADD      r0,r9,r4,LSL #3\n        LDR      r8,[r0,#4]\n        MOV      r0,r5\n        MOV      r1,r7\n        BL       find__FPii\n        MOV      r10,r0\n        MOV      r0,r5\n        MOV      r1,r8\n        BL       find__FPii\n        CMP      r10,r0\n        BNE      |L1.332|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        BL       free\n        LDMFD    sp!,{r3-r11,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.332|\n        MOV      r3,r8\n        MOV      r2,r7\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       unite__FPiT1iT3\n        ADD      r4,r4,#1\n        CMP      r4,r11\n        BLT      |L1.256|\n|L1.364|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        BL       free\n        LDMFD    sp!,{r3-r11,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint find(int* parent, int i) {\n    if (parent[i] == i)\n        return i;\n    return parent[i] = find(parent, parent[i]);\n}\n\nvoid unite(int* parent, int* rank, int x, int y) {\n    x = find(parent, x);\n    y = find(parent, y);\n    if (x != y) {\n        if (rank[x] < rank[y])\n            parent[x] = y;\n        else if (rank[x] > rank[y])\n            parent[y] = x;\n        else {\n            parent[y] = x;\n            rank[x]++;\n        }\n    }\n}\n\nint detectCycle(int numVertices, int* edges, int numEdges) {\n    int* parent = (int*)malloc(numVertices * sizeof(int));\n    int* rank = (int*)malloc(numVertices * sizeof(int));\n    for (int i = 0; i < numVertices; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    for (int i = 0; i < numEdges; i++) {\n        int u = edges[2 * i];\n        int v = edges[2 * i + 1];\n        if (find(parent, u) == find(parent, v)) {\n            free(parent);\n            free(rank);\n            return 1;\n        }\n        unite(parent, rank, u, v);\n    }\n    free(parent);\n    free(rank);\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsquare_area__Fi PROC\n        CMP      r0,#0\n        MOVGE    r1,r0\n        MULGE    r0,r1,r0\n        MOVLT    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint square_area(int side) {\n    if (side < 0) return 0;\n    return side * side;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntopological_sort__FP5GraphPi PROC\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r12,[r0,#0]\n        SUB      sp,sp,#0x194\n        MOV      lr,#0\n        MOV      r4,#0\n        MOV      r3,#0\n        MOV      r2,#0\n        CMP      r12,#0\n        BLE      |L1.220|\n        ADD      r5,sp,#4\n|L1.40|\n        ADD      r12,r0,r2,LSL #2\n        ADD      r12,r12,#0x9000\n        LDR      r12,[r12,#0xc44]\n        CMP      r12,#0\n        MOVEQ    r12,r3\n        STREQ    r2,[r5,r12,LSL #2]\n        LDR      r12,[r0,#0]\n        ADD      r2,r2,#1\n        ADDEQ    r3,r3,#1\n        CMP      r12,r2\n        BGT      |L1.40|\n        CMP      lr,r3\n        BGE      |L1.220|\n|L1.92|\n        MOV      r2,lr\n        LDR      r12,[r5,r2,LSL #2]\n        MOV      r2,r4\n        STR      r12,[r1,r2,LSL #2]\n        LDR      r6,[r0,#0]\n        MOV      r2,#0\n        ADD      r4,r4,#1\n        ADD      lr,lr,#1\n        CMP      r6,#0\n        BLE      |L1.212|\n        MOV      r6,r12\n        ADD      r12,r6,r6,LSL #3\n        ADD      r12,r12,r6,LSL #4\n        ADD      r7,r0,r12,LSL #4\n|L1.148|\n        ADD      r12,r7,r2,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,#0\n        BEQ      |L1.196|\n        ADD      r12,r0,r2,LSL #2\n        ADD      r6,r12,#0x9000\n        LDR      r12,[r6,#0xc44]\n        SUBS     r12,r12,#1\n        STR      r12,[r6,#0xc44]\n        MOVEQ    r12,r3\n        STREQ    r2,[r5,r12,LSL #2]\n        ADDEQ    r3,r3,#1\n|L1.196|\n        LDR      r12,[r0,#0]\n        ADD      r2,r2,#1\n        CMP      r12,r2\n        BGT      |L1.148|\n|L1.212|\n        CMP      lr,r3\n        BLT      |L1.92|\n|L1.220|\n        LDR      r0,[r0,#0]\n        CMP      r0,r4\n        ADDEQ    sp,sp,#0x194\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        ADR      r0,|L1.268|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n        ADD      sp,sp,#0x194\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.268|\n        DCB      \"Cycl\"\n        DCB      \"e de\"\n        DCB      \"tect\"\n        DCB      \"ed!\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj[MAX_VERTICES][MAX_VERTICES];\n    int in_degree[MAX_VERTICES];\n} Graph;\n\nvoid topological_sort(Graph* graph, int* sorted) {\n    int i, j, k = 0;\n    int queue[MAX_VERTICES];\n    int head = 0, tail = 0;\n\n    for (i = 0; i < graph->vertices; i++) {\n        if (graph->in_degree[i] == 0) {\n            queue[tail++] = i;\n        }\n    }\n\n    while (head < tail) {\n        i = queue[head++];\n        sorted[k++] = i;\n\n        for (j = 0; j < graph->vertices; j++) {\n            if (graph->adj[i][j]) {\n                graph->in_degree[j]--;\n                if (graph->in_degree[j] == 0) {\n                    queue[tail++] = j;\n                }\n            }\n        }\n    }\n\n    if (k != graph->vertices) {\n        printf(\"Cycle detected!\\n\");\n        exit(1);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculatePageRank__FP5GraphPddi PROC\n        STMFD    sp!,{r0-r11,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        SUB      sp,sp,#0x32c\n        MOV      r10,r1\n        MOV      r6,#0\n        ADR      r4,|L1.404|\n        CMP      r0,#0\n        BLE      |L1.76|\n|L1.36|\n        LDR      r0,[r5,#0]\n        BL       _dflt\n        ADD      r7,r10,r6,LSL #3\n        LDMIA    r4,{r2,r3}\n        BL       _drdiv\n        STMIA    r7,{r0,r1}\n        LDR      r0,[r5,#0]\n        ADD      r6,r6,#1\n        CMP      r0,r6\n        BGT      |L1.36|\n|L1.76|\n        LDR      r0,[sp,#0x360]\n        MOV      r11,#0\n        CMP      r0,#0\n        ADDLE    sp,sp,#0x33c\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n        ADD      r1,sp,#0x334\n        LDMIA    r1,{r0,r1}\n        LDMIA    r4,{r2,r3}\n        BL       _drsb\n        STR      r0,[sp,#0x328]\n        STR      r1,[sp,#0x324]\n|L1.124|\n        LDR      r0,[r5,#0]\n        MOV      r6,#0\n        CMP      r0,#0\n        BLE      |L1.356|\n|L1.140|\n        ADR      r1,|L1.412|\n        LDMIA    r1,{r7,r8}\n        LDR      r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.256|\n|L1.164|\n        ADD      r0,r4,r4,LSL #3\n        ADD      r0,r0,r4,LSL #4\n        ADD      r9,r5,r0,LSL #5\n        ADR      r1,|L1.412|\n        ADD      r0,r9,r6,LSL #3\n        ADD      r0,r0,#4\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dcmpge\n        BLS      |L1.240|\n        ADD      r0,r10,r4,LSL #3\n        LDMIB    r9,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _ddiv\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n|L1.240|\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.164|\n|L1.256|\n        LDR      r4,[sp,#0x328]\n        LDR      r9,[sp,#0x324]\n        LDR      r0,[r5,#0]\n        BL       _dflt\n        MOV      r3,r9\n        MOV      r2,r4\n        BL       _drdiv\n        MOV      r9,r1\n        ADD      r1,sp,#0x334\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dmul\n        ADD      r2,sp,#4\n        ADD      r12,r2,r6,LSL #3\n        MOV      r2,r4\n        MOV      r4,r12\n        MOV      r3,r9\n        BL       _dadd\n        STMIA    r4,{r0,r1}\n        LDR      r0,[r5,#0]\n        ADD      r6,r6,#1\n        CMP      r0,r6\n        BGT      |L1.140|\n|L1.356|\n        LDR      r0,[r5,#0]\n        ADD      r1,sp,#4\n        MOV      r2,r0,LSL #3\n        MOV      r0,r10\n        BL       __rt_memcpy_w\n        LDR      r0,[sp,#0x360]\n        ADD      r11,r11,#1\n        CMP      r11,r0\n        BLT      |L1.124|\n        ADD      sp,sp,#0x33c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.404|\n        DCFD     0x3ff0000000000000\n|L1.412|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_NODES 100\n\nstruct Graph {\n    int numNodes;\n    double adjacencyMatrix[MAX_NODES][MAX_NODES];\n};\n\nvoid calculatePageRank(struct Graph* graph, double* pageRank, double dampingFactor, int maxIterations) {\n    int i, j, k;\n    double sum;\n\n    for (i = 0; i < graph->numNodes; i++) {\n        pageRank[i] = 1.0 / graph->numNodes;\n    }\n\n    for (k = 0; k < maxIterations; k++) {\n        double nextPageRank[MAX_NODES];\n        for (i = 0; i < graph->numNodes; i++) {\n            sum = 0.0;\n            for (j = 0; j < graph->numNodes; j++) {\n                if (graph->adjacencyMatrix[j][i] > 0.0) {\n                    sum += pageRank[j] / graph->adjacencyMatrix[j][0];\n                }\n            }\n            nextPageRank[i] = (1.0 - dampingFactor) / graph->numNodes + dampingFactor * sum;\n        }\n        memcpy(pageRank, nextPageRank, sizeof(double)* graph->numNodes);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nconcreteComponentOperation__Fv PROC\n|L1.0|\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nconcreteDecoratorOperation__FP9Decorator PROC\n        STMFD    sp!,{r3,lr}\n        LDR      r0,[r0,#0]\n        ADR      lr,|L1.28|\n        LDR      r0,[r0,#0]\n        BX       r0\n|L1.28|\n        LDMFD    sp!,{r3,lr}\n        MOV      r0,r0,LSL #1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Component {\n    int (*operation)(void);\n} Component;\n\ntypedef struct Decorator {\n    Component* component;\n    int (*operation)(Decorator*);\n} Decorator;\n\n\nint concreteComponentOperation(void) {\n    return 1;\n}\n\nint concreteDecoratorOperation(Decorator* decorator) {\n    return decorator->component->operation() * 2;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        CMP      r0,#0\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r2,#1\n        MOV      r1,#1\n        CMP      r0,#1\n        BLT      |L1.44|\n|L1.28|\n        MUL      r2,r1,r2\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLE      |L1.28|\n|L1.44|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint factorial(int n) {\n    if (n < 0) return 0;\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsieve__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r0,#2\n        MOVLT    r0,#4\n        LDMLTFD  sp!,{r4-r6,lr}\n        BLT      malloc\n        MOV      r6,r4,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r5,#0]\n        STR      r2,[r5,#4]\n        MOV      r1,#2\n        CMP      r4,#4\n        BLT      |L1.132|\n|L1.76|\n        LDR      r0,[r5,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BGT      |L1.116|\n|L1.100|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,r1\n        CMP      r0,r4\n        BLE      |L1.100|\n|L1.116|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BLE      |L1.76|\n|L1.132|\n        MOV      r1,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLT      |L1.172|\n|L1.148|\n        LDR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r1,r1,#1\n        CMP      r0,r4\n        BLE      |L1.148|\n|L1.172|\n        MOV      r0,r1,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        MOV      r2,#0\n        CMP      r4,#0\n        BLT      |L1.232|\n|L1.200|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        MOVNE    r1,r2\n        STRNE    r0,[r6,r1,LSL #2]\n        ADD      r0,r0,#1\n        ADDNE    r2,r2,#1\n        CMP      r0,r4\n        BLE      |L1.200|\n|L1.232|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* sieve(int limit) {\n    if (limit < 2) {\n        return (int*)malloc(sizeof(int) * 1);\n    }\n    int* primes = (int*)malloc(sizeof(int) * limit);\n    memset(primes, 1, sizeof(int) * limit);\n    primes[0] = 0;\n    primes[1] = 0;\n    for (int p = 2; p * p <= limit; p++) {\n        if (primes[p]) {\n            for (int i = p * p; i <= limit; i += p) {\n                primes[i] = 0;\n            }\n        }\n    }\n    int count = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) {\n            count++;\n        }\n    }\n    int* result = (int*)malloc(sizeof(int) * count);\n    int k = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) {\n            result[k++] = i;\n        }\n    }\n    free(primes);\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r4,#1\n        BL       fibonacci__Fi\n        MOV      r5,r0\n        SUB      r0,r4,#2\n        BL       fibonacci__Fi\n        ADD      r0,r5,r0\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nharmonic_number__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        CMP      r7,#0\n        ADR      r0,|L1.120|\n        MOVLE    r1,r0\n        LDRLE    r1,[r1,#4]\n        LDRLE    r0,[r0,#0]\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        MOV      r4,#1\n        CMP      r7,#1\n        LDMIA    r0,{r5,r6}\n        BLT      |L1.104|\n        ADR      r8,|L1.128|\n|L1.56|\n        MOV      r0,r4\n        BL       _dflt\n        LDMIA    r8,{r2,r3}\n        BL       _drdiv\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        MOV      r5,r0\n        MOV      r6,r1\n        BLE      |L1.56|\n|L1.104|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.120|\n        DCFD     0x0000000000000000\n|L1.128|\n        DCFD     0x3ff0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble harmonic_number(int n) {\n    if (n <= 0) {\n        return 0.0;\n    }\n    double result = 0.0;\n    for (int i = 1; i <= n; ++i) {\n        result += 1.0 / i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateEmployeeList__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        RSB      r0,r5,r5,LSL #3\n        MOV      r0,r0,LSL #4\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r0,#0\n        STMIB    r4,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEmployee__FP12EmployeeListPciT2f PROC\n        STMFD    sp!,{r3-r9,lr}\n        LDR      r6,[sp,#0x20]\n        MOV      r9,r3\n        MOV      r8,r1\n        MOV      r7,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        CMP      r1,r0\n        BNE      |L1.180|\n        MOV      r5,r0,LSL #1\n        RSB      r1,r5,r5,LSL #3\n        MOV      r1,r1,LSL #4\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r5,[r4,#8]\n|L1.180|\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        MOV      r1,r8\n        BL       strcpy\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        STR      r7,[r0,#0x34]\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        ADD      r0,r0,#0x38\n        MOV      r1,r9\n        BL       strcpy\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        STR      r6,[r0,#0x6c]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Employee {\n    char name[50];\n    int id;\n    char department[50];\n    float salary;\n};\n\nstruct EmployeeList {\n    Employee* employees;\n    int size;\n    int capacity;\n};\n\nEmployeeList* createEmployeeList(int initialCapacity) {\n    EmployeeList* list = (EmployeeList*)malloc(sizeof(EmployeeList));\n    if (list == NULL) return NULL;\n    list->employees = (Employee*)malloc(initialCapacity * sizeof(Employee));\n    if (list->employees == NULL) {\n        free(list);\n        return NULL;\n    }\n    list->size = 0;\n    list->capacity = initialCapacity;\n    return list;\n}\n\nint addEmployee(EmployeeList* list, char* name, int id, char* department, float salary) {\n    if (list == NULL) return 0;\n    if (list->size == list->capacity) {\n        int newCapacity = list->capacity * 2;\n        Employee* newEmployees = (Employee*)realloc(list->employees, newCapacity * sizeof(Employee));\n        if (newEmployees == NULL) return 0;\n        list->employees = newEmployees;\n        list->capacity = newCapacity;\n    }\n    strcpy(list->employees[list->size].name, name);\n    list->employees[list->size].id = id;\n    strcpy(list->employees[list->size].department, department);\n    list->employees[list->size].salary = salary;\n    list->size++;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetSum__FP4nodeiT2 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        CMP      r2,r5\n        LDREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        ADD      r2,r2,#1\n        MOV      r6,r2\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       getSum__FP4nodeiT2\n        MOV      r7,r0\n        LDR      r0,[r4,#8]\n        MOV      r2,r6\n        MOV      r1,r5\n        BL       getSum__FP4nodeiT2\n        ADD      r0,r7,r0\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nint getSum(struct node *root, int level, int currentLevel){\n    if(root == NULL) return 0;\n    if(currentLevel == level) return root->data;\n    return getSum(root->left, level, currentLevel + 1) + getSum(root->right, level, currentLevel + 1);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindMinMax__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#8\n        CMP      r2,#0\n        BGT      |L1.52|\n        MOV      r1,sp\n        MOV      r3,#0\n        MOV      r4,#0\n        STMIA    r1,{r3,r4}\n        LDMIA    sp,{r1,r2}\n        STMIA    r0,{r1,r2}\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.52|\n        LDR      lr,[r1,#0]\n        MOV      r3,#1\n        CMP      r2,#1\n        MOV      r4,lr\n        BLE      |L1.104|\n|L1.72|\n        LDR      r12,[r1,r3,LSL #2]\n        ADD      r3,r3,#1\n        CMP      r12,lr\n        MOVLT    lr,r12\n        CMP      r12,r4\n        MOVGT    r4,r12\n        CMP      r3,r2\n        BLT      |L1.72|\n|L1.104|\n        MOV      r1,sp\n        MOV      r2,#0\n        MOV      r3,#0\n        STMIA    r1,{r2,r3}\n        STR      r4,[sp,#4]\n        STR      lr,[sp,#0]\n        STR      r4,[r0,#4]\n        STR      lr,[r0,#0]\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Result {\n    int min;\n    int max;\n};\n\n\nResult findMinMax(int arr[], int size) {\n    if (size <= 0) {\n        Result res = {0,0};\n        return res;\n    }\n    int min = arr[0];\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    Result res = {min, max};\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindFirstOccurrence__FPiiT2 PROC\n|L1.0|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.40|\n|L1.12|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,r2\n        MOVEQ    r0,r3\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.12|\n|L1.40|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findFirstOccurrence(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbloomFilterCreate__FP11BloomFilteriT2 PROC\n        ADD      r3,r0,#0x3e8\n        STMIA    r3,{r1,r2}\n        B        __rt_memclr_w\n        ENDP\n\nbloomFilterAdd__FP11BloomFilteri PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0x3ec]\n        MOV      r6,r1\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        MOV      r7,#1\n|L1.48|\n        ADD      r0,r4,r4,LSL #4\n        ADD      r1,r0,r6\n        LDR      r0,[r5,#0x3e8]\n        BL       __rt_sdiv\n        STRB     r7,[r5,r1]\n        LDR      r0,[r5,#0x3ec]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.48|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nbloomFilterCheck__FP11BloomFilteri PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r6,[r0,#0x3ec]\n        MOV      r8,r1\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.168|\n        LDR      r7,[r5,#0x3e8]\n|L1.124|\n        ADD      r0,r4,r4,LSL #4\n        ADD      r1,r0,r8\n        MOV      r0,r7\n        BL       __rt_sdiv\n        LDRB     r0,[r5,r1]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        ADD      r4,r4,#1\n        CMP      r6,r4\n        BGT      |L1.124|\n|L1.168|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 1000\n#define HASH_FUNCTION(x, size) ((x) % (size))\n\nstruct BloomFilter {\n    unsigned char bits[MAX_SIZE];\n    int size;\n    int numHashes;\n};\n\nvoid bloomFilterCreate(struct BloomFilter *bf, int size, int numHashes) {\n    bf->size = size;\n    bf->numHashes = numHashes;\n    memset(bf->bits, 0, size);\n}\n\nvoid bloomFilterAdd(struct BloomFilter *bf, int value) {\n    for (int i = 0; i < bf->numHashes; i++) {\n        int hash = HASH_FUNCTION(value + i * 17, bf->size);\n        bf->bits[hash] = 1;\n    }\n}\n\nint bloomFilterCheck(struct BloomFilter *bf, int value) {\n    for (int i = 0; i < bf->numHashes; i++) {\n        int hash = HASH_FUNCTION(value + i * 17, bf->size);\n        if (!bf->bits[hash]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncatalan__Fi PROC\n        STMFD    sp!,{r3-r9,lr}\n        CMP      r0,#1\n        ADRLE    r1,|L1.116|\n        MOV      r7,r0\n        LDMLEIA  r1,{r0,r1}\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        MOV      r4,#0\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r5,r6}\n|L1.40|\n        MOV      r0,r4\n        BL       catalan__Fi\n        MOV      r8,r0\n        SUB      r0,r7,r4\n        SUB      r0,r0,#1\n        MOV      r9,r1\n        BL       catalan__Fi\n        UMULL    r2,r12,r0,r8\n        MLA      r12,r8,r1,r12\n        MLA      r3,r9,r0,r12\n        ADDS     r5,r5,r2\n        ADC      r6,r6,r3\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.40|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.116|\n        DCQ      0x0000000000000001\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long catalan(int n) {\n    if (n <= 1) return 1;\n    unsigned long long res = 0;\n    for (int i = 0; i < n; ++i)\n        res += catalan(i) * catalan(n - i - 1);\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindInorderSuccessor__FP4Nodei PROC\n        MOVS     r2,r0\n        MOV      r0,#0\n        BXEQ     lr\n|L1.12|\n        LDR      r3,[r2,#0]\n        CMP      r3,r1\n        MOVGT    r0,r2\n        LDRGT    r2,[r2,#4]\n        BGT      |L1.40|\n        BGE      |L1.52|\n        LDR      r2,[r2,#8]\n|L1.40|\n        CMP      r2,#0\n        BNE      |L1.12|\n        BX       lr\n|L1.52|\n        LDR      r1,[r2,#8]\n        CMP      r1,#0\n        MOVNE    r0,r1\n        LDRNE    r1,[r1,#4]\n        CMPNE    r1,#0\n        BXEQ     lr\n|L1.76|\n        LDR      r0,[r0,#4]\n        LDR      r1,[r0,#4]\n        CMP      r1,#0\n        BNE      |L1.76|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nNode* findInorderSuccessor(Node* root, int data) {\n    Node* current = root;\n    Node* successor = NULL;\n\n    while (current != NULL) {\n        if (data < current->data) {\n            successor = current;\n            current = current->left;\n        } else if (data > current->data) {\n            current = current->right;\n        } else {\n            if (current->right != NULL) {\n                Node* temp = current->right;\n                while (temp->left != NULL) {\n                    temp = temp->left;\n                }\n                successor = temp;\n            }\n            break;\n        }\n    }\n    return successor;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmerge__FPvUiT2PFPCvT1_iT1 PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0xc\n        LDR      r0,[sp,#0x10]\n        LDR      r8,[sp,#0x40]\n        MOV      r9,r0,LSR #1\n        SUB      r10,r0,r9\n        LDR      r0,[sp,#0xc]\n        MOV      r7,#0\n        MOV      r6,#0\n        MOV      r5,#0\n        MOV      r4,r2\n        STR      r0,[sp,#0]\n        MLA      r11,r2,r9,r0\n        B        |L1.136|\n|L1.56|\n        LDR      r0,[sp,#0]\n        MLA      r1,r4,r7,r11\n        LDR      r2,[sp,#0x18]\n        MLA      r0,r4,r6,r0\n        STR      r0,[sp,#4]\n        STR      r1,[sp,#8]\n        MOV      lr,pc\n        BX       r2\n        CMP      r0,#0\n        MLA      r0,r4,r5,r8\n        MOV      r2,r4\n        BGT      |L1.120|\n        LDR      r1,[sp,#4]\n        BL       __rt_memcpy\n        ADD      r6,r6,#1\n        B        |L1.132|\n|L1.120|\n        LDR      r1,[sp,#8]\n        BL       __rt_memcpy\n        ADD      r7,r7,#1\n|L1.132|\n        ADD      r5,r5,#1\n|L1.136|\n        CMP      r6,r9\n        CMPCC    r7,r10\n        BCC      |L1.56|\n        CMP      r6,r9\n        BCS      |L1.192|\n|L1.156|\n        LDR      r0,[sp,#0]\n        MOV      r2,r4\n        MLA      r1,r4,r6,r0\n        MLA      r0,r4,r5,r8\n        BL       __rt_memcpy\n        ADD      r6,r6,#1\n        CMP      r6,r9\n        ADD      r5,r5,#1\n        BCC      |L1.156|\n|L1.192|\n        CMP      r7,r10\n        BCS      |L1.232|\n|L1.200|\n        MLA      r1,r4,r7,r11\n        MLA      r0,r4,r5,r8\n        MOV      r2,r4\n        BL       __rt_memcpy\n        ADD      r7,r7,#1\n        CMP      r7,r10\n        ADD      r5,r5,#1\n        BCC      |L1.200|\n|L1.232|\n        LDR      r0,[sp,#0x10]\n        MOV      r1,r8\n        MUL      r2,r4,r0\n        LDR      r0,[sp,#0xc]\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        B        __rt_memcpy\n        ENDP\n\nmerge_sort__FPvUiT2PFPCvT1_i PROC\n        STMFD    sp!,{r4-r8,lr}\n        SUB      sp,sp,#8\n        CMP      r1,#1\n        ADDLS    sp,sp,#8\n        MOV      r8,r3\n        MOV      r7,r0\n        MOV      r5,r2\n        MOV      r4,r1\n        LDMLSFD  sp!,{r4-r8,lr}\n        BXLS     lr\n        MOV      r6,r4,LSR #1\n        MOV      r1,r6\n        MOV      r3,r8\n        MOV      r2,r5\n        MOV      r0,r7\n        BL       merge_sort__FPvUiT2PFPCvT1_i\n        SUB      r1,r4,r6\n        MLA      r0,r5,r6,r7\n        MOV      r3,r8\n        MOV      r2,r5\n        BL       merge_sort__FPvUiT2PFPCvT1_i\n        MUL      r0,r5,r4\n        BL       malloc\n        MOVS     r6,r0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r3,r8\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r7\n        STR      r6,[sp,#0]\n        BL       merge__FPvUiT2PFPCvT1_iT1\n        MOV      r0,r6\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r8,lr}\n        B        free\n        ENDP\n\nint_compar__FPCvT1 PROC\n        LDR      r0,[r0,#0]\n        LDR      r1,[r1,#0]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid merge(void *base, size_t nmemb, size_t size, int (*compar)(const void*, const void*), void *tmp) {\n    size_t left_size = nmemb / 2;\n    size_t right_size = nmemb - left_size;\n    char *left = (char*)base;\n    char *right = (char*)base + left_size * size;\n    char *tmp_ptr = (char*)tmp;\n    size_t i = 0, j = 0, k = 0;\n    while (i < left_size && j < right_size) {\n        if (compar(left + i * size, right + j * size) <= 0) {\n            memcpy(tmp_ptr + k * size, left + i * size, size);\n            i++;\n        } else {\n            memcpy(tmp_ptr + k * size, right + j * size, size);\n            j++;\n        }\n        k++;\n    }\n    while (i < left_size) {\n        memcpy(tmp_ptr + k * size, left + i * size, size);\n        i++;\n        k++;\n    }\n    while (j < right_size) {\n        memcpy(tmp_ptr + k * size, right + j * size, size);\n        j++;\n        k++;\n    }\n    memcpy(base, tmp, nmemb * size);\n}\n\n\nvoid merge_sort(void *base, size_t nmemb, size_t size, int (*compar)(const void*, const void*)) {\n    if (nmemb <= 1) return;\n    size_t mid = nmemb / 2;\n    merge_sort(base, mid, size, compar);\n    merge_sort((char*)base + mid * size, nmemb - mid, size, compar);\n    void *tmp = malloc(nmemb * size);\n    if(tmp == NULL) exit(1);\n    merge(base, nmemb, size, compar, tmp);\n    free(tmp);\n}\n\nint int_compar(const void *a, const void *b) {\n    return *(int*)a - *(int*)b;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.408|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0xa\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP9HashTableiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       hash__Fi\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        STMIA    r0,{r6,r7}\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #2]\n        STR      r1,[r0,#8]\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nsearch__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r4,r1\n        BL       hash__Fi\n        LDR      r1,[r5,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.220|\n|L1.188|\n        LDR      r1,[r0,#0]\n        CMP      r1,r4\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.188|\n|L1.220|\n        LDMFD    sp!,{r4,r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nfreeHashTable__FP9HashTable PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r4,#0\n|L1.244|\n        LDR      r0,[r6,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.276|\n|L1.260|\n        LDR      r5,[r0,#8]\n        BL       free\n        MOVS     r0,r5\n        BNE      |L1.260|\n|L1.276|\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        BLT      |L1.244|\n        LDR      r0,[r6,#0]\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct Node {\n    int key;\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct HashTable {\n    Node** table;\n} HashTable;\n\nunsigned int hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    ht->table = (Node**)calloc(TABLE_SIZE, sizeof(Node*));\n    return ht;\n}\n\nvoid insert(HashTable* ht, int key, int value) {\n    unsigned int index = hash(key);\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->value = value;\n    newNode->next = ht->table[index];\n    ht->table[index] = newNode;\n}\n\nint search(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    Node* current = ht->table[index];\n    while (current != NULL) {\n        if (current->key == key) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return -1; \n}\n\nvoid freeHashTable(HashTable* ht){\n    for(int i = 0; i < TABLE_SIZE; i++){\n        Node* current = ht->table[i];\n        while(current != NULL){\n            Node* next = current->next;\n            free(current);\n            current = next;\n        }\n    }\n    free(ht->table);\n    free(ht);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nenqueue__Fi PROC\n|L1.0|\n        LDR      r2,|L1.476|\n        MOV      r1,r0\n        LDR      r0,[r2,#4]  ; tail\n        ADD      r3,r0,#1\n        STR      r3,[r2,#4]  ; tail\n        LDR      r2,|L1.480|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\ndequeue__Fv PROC\n        LDR      r1,|L1.476|\n        LDR      r0,[r1,#0]  ; head\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; head\n        LDR      r1,|L1.480|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\nisEmpty__Fv PROC\n        LDR      r0,|L1.476|\n        LDR      r1,[r0,#0]  ; head, tail\n        LDR      r0,[r0,#4]\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nbfs__FiN21PiT4 PROC\n        STMFD    sp!,{r0-r11,lr}\n        LDR      r8,|L1.484|\n        SUB      sp,sp,#0x194\n        MOV      r9,r1\n        MOV      r5,r0\n        MOV      r0,r8\n        MOV      r1,#0x190\n        LDR      r7,[sp,#0x1c8]\n        MOV      r6,r2\n        BL       __rt_memclr_w\n        LDR      r0,|L1.476|\n        MOV      r1,#0\n        STR      r1,[r0,#4]  ; tail\n        STR      r1,[r0,#0]  ; head\n        MOV      r0,r5\n        BL       enqueue__Fi\n        MOV      r4,#1\n        ADD      r11,sp,#4\n        MOV      r0,r11\n        STR      r4,[r8,r5,LSL #2]\n        MOV      r2,#0x190\n        MVN      r1,#0\n        BL       __rt_memset\n        BL       isEmpty__Fv\n        CMP      r0,#0\n        BNE      |L1.308|\n        LDR      r10,|L1.484|\n|L1.196|\n        BL       dequeue__Fv\n        MOV      r5,r0\n        CMP      r0,r9\n        BEQ      |L1.308|\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.296|\n        ADD      r0,r5,r5,LSL #3\n        LDR      r1,|L1.488|\n        ADD      r0,r0,r5,LSL #4\n        ADD      r8,r1,r0,LSL #4\n|L1.240|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.284|\n        LDR      r0,[r10,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.284|\n        MOV      r0,#1\n        STR      r0,[r10,r4,LSL #2]\n        MOV      r0,r4\n        BL       enqueue__Fi\n        STR      r5,[r11,r4,LSL #2]\n|L1.284|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.240|\n|L1.296|\n        BL       isEmpty__Fv\n        CMP      r0,#0\n        BEQ      |L1.196|\n|L1.308|\n        MOV      r1,#0\n        STR      r1,[r7,#0]\n        CMN      r9,#1\n        ADDEQ    sp,sp,#0x1a4\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n|L1.332|\n        LDR      r0,[r7,#0]\n        ADD      r1,r0,#1\n        STR      r1,[r7,#0]\n        LDR      r1,[sp,#0x1a0]\n        STR      r9,[r1,r0,LSL #2]\n        LDR      r9,[r11,r9,LSL #2]\n        CMN      r9,#1\n        BNE      |L1.332|\n        ADD      sp,sp,#0x1a4\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_NODES 100\n#define QUEUE_SIZE 100\n\nint graph[MAX_NODES][MAX_NODES];\nint visited[MAX_NODES];\nint queue[QUEUE_SIZE];\nint head, tail;\n\nvoid enqueue(int node) {\n    queue[tail++] = node;\n}\n\nint dequeue() {\n    return queue[head++];\n}\n\nint isEmpty() {\n    return head == tail;\n}\n\nvoid bfs(int start, int end, int num_nodes, int* path, int* path_length) {\n    memset(visited, 0, sizeof(visited));\n    head = tail = 0;\n    enqueue(start);\n    visited[start] = 1;\n    int parent[MAX_NODES];\n    memset(parent, -1, sizeof(parent));\n\n    while (!isEmpty()) {\n        int curr = dequeue();\n        if (curr == end) break;\n        for (int i = 0; i < num_nodes; i++) {\n            if (graph[curr][i] && !visited[i]) {\n                visited[i] = 1;\n                enqueue(i);\n                parent[i] = curr;\n            }\n        }\n    }\n\n    int curr = end;\n    *path_length = 0;\n    while (curr != -1) {\n        path[(*path_length)++] = curr;\n        curr = parent[curr];\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPositive__Fc PROC\n|L1.0|\n        SUB      r0,r0,#0x61\n        CMP      r0,#0x19\n        MOVHI    r0,#0\n        MOVLS    r0,#1\n        BX       lr\n        ENDP\n\nisNegative__Fc PROC\n        SUB      r0,r0,#0x41\n        CMP      r0,#0x19\n        MOVHI    r0,#0\n        MOVLS    r0,#1\n        BX       lr\n        ENDP\n\nanalyzeSentiment__FPCc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,#0\n        MOV      r4,#0\n        BL       strlen\n        MOV      r3,r0\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.128|\n|L1.76|\n        LDRB     r2,[r6,r1]\n        MOV      r0,r2\n        BL       isPositive__Fc\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        BNE      |L1.116|\n        MOV      r0,r2\n        BL       isNegative__Fc\n        CMP      r0,#0\n        ADDNE    r5,r5,#1\n|L1.116|\n        ADD      r1,r1,#1\n        CMP      r1,r3\n        BLT      |L1.76|\n|L1.128|\n        SUB      r0,r4,r5\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isPositive(char c){\n    return c >= 'a' && c <= 'z';\n}\n\nint isNegative(char c){\n    return c >= 'A' && c <= 'Z';\n}\n\n\nint analyzeSentiment(const char* text) {\n    int positiveCount = 0;\n    int negativeCount = 0;\n    int len = strlen(text);\n    for (int i = 0; i < len; ++i) {\n        char c = text[i];\n        if (isPositive(c)) {\n            positiveCount++;\n        } else if (isNegative(c)) {\n            negativeCount++;\n        }\n    }\n    return positiveCount - negativeCount;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs1__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r8,|L1.480|\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r7,|L1.484|\n        STR      r0,[r8,r5,LSL #2]\n        LDR      r0,[r7,#0]  ; n\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.100|\n        ADD      r1,r5,r5,LSL #1\n        LDR      r0,|L1.488|\n        RSB      r1,r1,r5,LSL #7\n        ADD      r6,r0,r1,LSL #5\n|L1.56|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.84|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        BLEQ     dfs1__Fi\n|L1.84|\n        LDR      r0,[r7,#0]  ; n\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.56|\n|L1.100|\n        LDR      r0,[r7,#4]  ; count\n        ADD      r1,r0,#1\n        STR      r1,[r7,#4]  ; count\n        LDR      r1,|L1.492|\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\ndfs2__FiT1 PROC\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r7,|L1.496|\n        LDR      r8,|L1.484|\n        MOV      r5,r0\n        STR      r1,[r7,r0,LSL #2]\n        LDR      r0,[r8,#0]  ; n\n        MOV      r6,r1\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r9,lr}\n        BXLE     lr\n        LDR      r9,|L1.488|\n|L1.176|\n        ADD      r0,r4,r4,LSL #1\n        RSB      r0,r0,r4,LSL #7\n        ADD      r0,r9,r0,LSL #5\n        LDR      r0,[r0,r5,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.220|\n        LDR      r0,[r7,r4,LSL #2]\n        CMN      r0,#1\n        MOVEQ    r1,r6\n        MOVEQ    r0,r4\n        BLEQ     dfs2__FiT1\n|L1.220|\n        LDR      r0,[r8,#0]  ; n\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.176|\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n\nfindStronglyConnectedComponents__Fv PROC\n        STMFD    sp!,{r3-r7,lr}\n        LDR      r6,|L1.480|\n        MOV      r1,#0xfa0\n        MOV      r0,r6\n        BL       __rt_memclr_w\n        LDR      r5,|L1.484|\n        MOV      r4,#0\n        LDR      r0,[r5,#0]  ; n\n        CMP      r0,#0\n        BLE      |L1.316|\n|L1.284|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        BLEQ     dfs1__Fi\n        LDR      r0,[r5,#0]  ; n\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.284|\n|L1.316|\n        LDR      r1,[r5,#0]  ; n\n        MOV      r6,r5\n        LDR      r5,|L1.496|\n        MOV      r0,#0\n        CMP      r1,#0\n        BLE      |L1.360|\n        MVN      r2,#0\n|L1.344|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r1\n        BLT      |L1.344|\n|L1.360|\n        SUBS     r4,r1,#1\n        LDMMIFD  sp!,{r3-r7,lr}\n        BXMI     lr\n        LDR      r7,|L1.492|\n|L1.376|\n        LDR      r0,[r7,r4,LSL #2]\n        LDR      r1,[r5,r0,LSL #2]\n        CMN      r1,#1\n        BNE      |L1.408|\n        LDR      r1,[r6,#8]  ; componentCount\n        ADD      r2,r1,#1\n        STR      r2,[r6,#8]  ; componentCount\n        BL       dfs2__FiT1\n|L1.408|\n        SUBS     r4,r4,#1\n        BPL      |L1.376|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAXN 1000\n\nint n;\nint adj[MAXN][MAXN];\nint visited[MAXN];\nint order[MAXN];\nint count = 0;\nint component[MAXN];\nint componentCount = 0;\n\nvoid dfs1(int u) {\n    visited[u] = 1;\n    for (int v = 0; v < n; v++) {\n        if (adj[u][v] && !visited[v]) {\n            dfs1(v);\n        }\n    }\n    order[count++] = u;\n}\n\nvoid dfs2(int u, int c) {\n    component[u] = c;\n    for (int v = 0; v < n; v++) {\n        if (adj[v][u] && component[v] == -1) {\n            dfs2(v, c);\n        }\n    }\n}\n\nvoid findStronglyConnectedComponents() {\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        component[i] = -1;\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        int u = order[i];\n        if (component[u] == -1) {\n            dfs2(u, componentCount++);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STMIA    r4,{r5,r6}\n        MUL      r0,r6,r5\n        MOV      r5,r0,LSL #2\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.84|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r1,r5\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfreeMatrix__FP6Matrix PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\naddMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r4,#4]\n        LDREQ    r2,[r5,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDMIA    r4,{r2,r3}\n        MOV      r1,#0\n        MUL      r2,r3,r2\n        CMP      r2,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.228|\n        LDR      r2,[r4,#8]\n        LDR      r3,[r5,#8]\n        LDR      r2,[r2,r1,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        ADD      r2,r2,r3\n        LDR      r3,[r0,#8]\n        STR      r2,[r3,r1,LSL #2]\n        LDMIA    r4,{r2,r3}\n        ADD      r1,r1,#1\n        MUL      r2,r3,r2\n        CMP      r2,r1\n        BGT      |L1.228|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nmultiplyMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#0]\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r12,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n|L1.364|\n        LDR      r1,[r5,#4]\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.484|\n|L1.380|\n        LDR      r3,[r4,#4]\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.468|\n|L1.396|\n        LDR      lr,[r5,#4]\n        LDR      r7,[r4,#4]\n        LDR      r3,[r0,#8]\n        MLA      r6,lr,r12,r2\n        ADD      r3,r3,r6,LSL #2\n        LDR      r6,[r4,#8]\n        MLA      r8,r7,r12,r1\n        LDR      r6,[r6,r8,LSL #2]\n        LDR      r7,[r5,#8]\n        MLA      r8,lr,r1,r2\n        LDR      lr,[r7,r8,LSL #2]\n        LDR      r7,[r3,#0]\n        ADD      r1,r1,#1\n        MLA      r6,lr,r6,r7\n        STR      r6,[r3,#0]\n        LDR      r3,[r4,#4]\n        CMP      r3,r1\n        BGT      |L1.396|\n|L1.468|\n        LDR      r1,[r5,#4]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.380|\n|L1.484|\n        LDR      r1,[r4,#0]\n        ADD      r12,r12,#1\n        CMP      r1,r12\n        BGT      |L1.364|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\ntypedef struct {\n    int rows;\n    int cols;\n    int *data;\n} Matrix;\n\n\nMatrix* createMatrix(int rows, int cols) {\n    Matrix *matrix = (Matrix*)malloc(sizeof(Matrix));\n    if (matrix == NULL) return NULL;\n    matrix->rows = rows;\n    matrix->cols = cols;\n    matrix->data = (int*)malloc(rows * cols * sizeof(int));\n    if (matrix->data == NULL) {\n        free(matrix);\n        return NULL;\n    }\n    memset(matrix->data, 0, rows * cols * sizeof(int));\n    return matrix;\n}\n\n\nvoid freeMatrix(Matrix *matrix) {\n    if (matrix != NULL) {\n        free(matrix->data);\n        free(matrix);\n    }\n}\n\n\nMatrix* addMatrices(Matrix *a, Matrix *b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix *result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows * a->cols; i++) {\n        result->data[i] = a->data[i] + b->data[i];\n    }\n    return result;\n}\n\n\nMatrix* multiplyMatrices(Matrix *a, Matrix *b) {\n    if (a->cols != b->rows) return NULL;\n    Matrix *result = createMatrix(a->rows, b->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < b->cols; j++) {\n            for (int k = 0; k < a->cols; k++) {\n                result->data[i * b->cols + j] += a->data[i * a->cols + k] * b->data[k * b->cols + j];\n            }\n        }\n    }\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninverse__FPA10_dT1i PROC\n|L1.0|\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#0x330\n        CMP      r2,#0xa\n        ADDGT    sp,sp,#0x33c\n        MOV      r5,r2\n        LDMGTFD  sp!,{r4-r11,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        MOV      r1,r0\n        MOV      r0,sp\n        MOV      r2,#0x320\n        MOV      r4,sp\n        BL       __rt_memcpy_w\n        MOV      r1,#0\n        CMP      r5,#0\n        BLE      |L1.152|\n        ADR      r6,|L1.520|\n        ADR      r7,|L1.528|\n|L1.72|\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.140|\n        LDR      r3,[sp,#0x334]\n        ADD      r2,r1,r1,LSL #2\n        ADD      r3,r3,r2,LSL #4\n|L1.96|\n        CMP      r1,r0\n        ADD      r2,r3,r0,LSL #3\n        BNE      |L1.120|\n        LDMIA    r6,{r12,lr}\n        STMIA    r2,{r12,lr}\n        B        |L1.128|\n|L1.120|\n        LDMIA    r7,{r12,lr}\n        STMIA    r2,{r12,lr}\n|L1.128|\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.96|\n|L1.140|\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        BLT      |L1.72|\n|L1.152|\n        MOV      r10,#0\n        CMP      r5,#0\n        BLE      |L1.504|\n|L1.164|\n        ADD      r0,r10,r10,LSL #2\n        STR      r0,[sp,#0x32c]\n        ADD      r11,sp,r0,LSL #4\n        ADD      r0,r11,r10,LSL #3\n        LDMIA    r0,{r7,r8}\n        ADR      r2,|L1.536|\n        LDMIA    r2,{r2,r3}\n        MOV      r0,r7\n        BIC      r1,r8,#0x80000000\n        BL       _dcmple\n        ADDCC    sp,sp,#0x33c\n        LDMCCFD  sp!,{r4-r11,lr}\n        MOVCC    r0,#0\n        BXCC     lr\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.304|\n        LDR      r0,[sp,#0x32c]\n        LDR      r1,[sp,#0x334]\n        ADD      r9,r1,r0,LSL #4\n|L1.244|\n        ADD      r6,r11,r4,LSL #3\n        LDMIA    r6,{r0,r1}\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _ddiv\n        STMIA    r6,{r0,r1}\n        ADD      r6,r9,r4,LSL #3\n        LDMIA    r6,{r0,r1}\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _ddiv\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        STMIA    r6,{r0,r1}\n        BLT      |L1.244|\n|L1.304|\n        MOV      r7,#0\n        CMP      r5,#0\n        BLE      |L1.492|\n        LDR      r0,[sp,#0x32c]\n        LDR      r1,[sp,#0x334]\n        ADD      r0,r1,r0,LSL #4\n        STR      r0,[sp,#0x328]\n|L1.332|\n        CMP      r10,r7\n        BEQ      |L1.480|\n        ADD      r0,r7,r7,LSL #2\n        ADD      r1,sp,r0,LSL #4\n        STR      r1,[sp,#0x324]\n        ADD      r1,r1,r10,LSL #3\n        LDMIA    r1,{r8,r9}\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.480|\n        LDR      r1,[sp,#0x334]\n        ADD      r0,r1,r0,LSL #4\n        STR      r0,[sp,#0x320]\n|L1.384|\n        LDR      r0,[sp,#0x324]\n        MOV      r1,r9\n        ADD      r6,r0,r4,LSL #3\n        ADD      r0,r11,r4,LSL #3\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        BL       _dmul\n        LDMIA    r6,{r2,r3}\n        BL       _drsb\n        STMIA    r6,{r0,r1}\n        LDR      r0,[sp,#0x320]\n        MOV      r1,r9\n        ADD      r6,r0,r4,LSL #3\n        LDR      r0,[sp,#0x328]\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        BL       _dmul\n        LDMIA    r6,{r2,r3}\n        BL       _drsb\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        STMIA    r6,{r0,r1}\n        BLT      |L1.384|\n|L1.480|\n        ADD      r7,r7,#1\n        CMP      r7,r5\n        BLT      |L1.332|\n|L1.492|\n        ADD      r10,r10,#1\n        CMP      r10,r5\n        BLT      |L1.164|\n|L1.504|\n        ADD      sp,sp,#0x33c\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.520|\n        DCFD     0x3ff0000000000000\n|L1.528|\n        DCFD     0x0000000000000000\n|L1.536|\n        DCFD     0x3e112e0be826d695\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_SIZE 10\n\ntypedef double matrix[MAX_SIZE][MAX_SIZE];\n\nint inverse(matrix a, matrix inverse_a, int n) {\n    matrix b;\n    int i, j, k;\n    double det;\n\n\n    if (n > MAX_SIZE) return 0;\n\n    memcpy(b, a, sizeof(matrix));\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            if (i == j) inverse_a[i][j] = 1.0;\n            else inverse_a[i][j] = 0.0;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        double pivot = b[i][i];\n        if (fabs(pivot) < 1e-9) return 0;\n\n        for (j = 0; j < n; j++) {\n            b[i][j] /= pivot;\n            inverse_a[i][j] /= pivot;\n        }\n\n\n        for (j = 0; j < n; j++) {\n            if (i != j) {\n                double factor = b[j][i];\n                for (k = 0; k < n; k++) {\n                    b[j][k] -= factor * b[i][k];\n                    inverse_a[j][k] -= factor * inverse_a[i][k];\n                }\n            }\n        }\n    }\n\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.388|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.416|\n|L1.388|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.416|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.520|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.572|\n|L1.520|\n        CMP      r0,#1\n        BLE      |L1.564|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.608|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.564|\n        CMN      r0,#1\n        BGE      |L1.608|\n|L1.572|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.608|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.608|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisBalancedIterative__FP4Node PROC\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r4,sp\n        MVN      r1,#0\n|L1.648|\n        CMP      r0,#0\n        BEQ      |L1.676|\n|L1.656|\n        ADD      r1,r1,#1\n        STR      r0,[r4,r1,LSL #2]\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.656|\n|L1.676|\n        CMN      r1,#1\n        ADDEQ    sp,sp,#0xfa0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r2,[r4,r1,LSL #2]\n        SUB      r1,r1,#1\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        SUB      r0,r3,r0\n        ADD      r0,r0,#1\n        CMP      r0,#2\n        LDRLS    r0,[r2,#0xc]\n        BLS      |L1.648|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    return (N == NULL) ? 0 : N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int k) {\n    return new Node(k);\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\n\nNode* insert(Node* node, int key) {\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else \n        return node;\n\n    node->height = 1 + max(height(node->left),\n                           height(node->right));\n\n    int balance = getBalance(node);\n\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n\n    return node;\n}\n\n\nint isBalancedIterative(Node* root){\n    if(root == NULL) return 1;\n    int lh, rh;\n    Node* curr = root;\n    Node* stack[1000];\n    int top = -1;\n    while(1){\n        while(curr != NULL){\n            top++;\n            stack[top] = curr;\n            curr = curr->left;\n        }\n        if(top == -1) break;\n        curr = stack[top];\n        top--;\n        lh = height(curr->left);\n        rh = height(curr->right);\n        if(abs(lh - rh) > 1) return 0;\n        curr = curr->right;\n\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__FP5Stacki PROC\n        LDR      r2,[r0,#0]\n        CMP      r2,#0x63\n        BXEQ     lr\n        ADD      r2,r2,#1\n        STR      r2,[r0,#0]\n        ADD      r0,r0,r2,LSL #2\n        STR      r1,[r0,#4]\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        LDR      r1,[r0,#0]\n        CMN      r1,#1\n        MOVEQ    r0,#0\n        BXEQ     lr\n        SUB      r2,r1,#1\n        STR      r2,[r0,#0]\n        ADD      r0,r0,r1,LSL #2\n        LDR      r0,[r0,#4]\n        BX       lr\n        ENDP\n\npeek__FP5Stack PROC\n        LDR      r1,[r0,#0]\n        CMN      r1,#1\n        ADDNE    r0,r0,r1,LSL #2\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nisOperator__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        CMPNE    r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nprecedence__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVEQ    r0,#2\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\napplyOp__FiT1c PROC\n        MOV      r3,r0\n        MOV      r0,r1\n        CMP      r2,#0x2a\n        MULEQ    r0,r3,r0\n        BXEQ     lr\n        CMP      r2,#0x2b\n        ADDEQ    r0,r3,r0\n        BXEQ     lr\n        CMP      r2,#0x2d\n        SUBEQ    r0,r3,r0\n        BXEQ     lr\n        CMP      r2,#0x2f\n        MOVNE    r0,#0\n        BXNE     lr\n        CMP      r0,#0\n        MOVNE    r1,r3\n        BNE      __rt_sdiv\n        BX       lr\n        ENDP\n\nevaluate__FPc PROC\n        STMFD    sp!,{r4-r9,lr}\n        MOV      r5,r0\n        MVN      r0,#0\n        SUB      sp,sp,#0x32c\n        STR      r0,[sp,#0x198]\n        STR      r0,[sp,#4]\n        LDRB     r0,[r5,#0]\n        ADD      r6,sp,#0x198\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.600|\n        BL       __rt_ctype_table\n        MOV      r8,r0\n        ADD      r7,sp,#4\n|L1.288|\n        LDRB     r1,[r5,r4]\n        LDR      r2,[r8,#0]\n        LDRB     r0,[r2,r1]\n        TST      r0,#0x20\n        BEQ      |L1.360|\n        MOV      r1,#0\n|L1.312|\n        LDRB     r0,[r5,r4]\n        ADD      r1,r1,r1,LSL #2\n        ADD      r4,r4,#1\n        ADD      r0,r0,r1,LSL #1\n        SUB      r1,r0,#0x30\n        LDRB     r0,[r5,r4]\n        LDRB     r0,[r2,r0]\n        TST      r0,#0x20\n        BNE      |L1.312|\n        MOV      r0,r6\n        BL       push__FP5Stacki\n        B        |L1.504|\n|L1.360|\n        MOV      r0,r1\n        BL       isOperator__Fc\n        CMP      r0,#0\n        BEQ      |L1.500|\n        B        |L1.440|\n|L1.380|\n        MOV      r0,r6\n        BL       pop__FP5Stack\n        MOV      r3,r0\n        MOV      r0,r6\n        BL       pop__FP5Stack\n        MOV      r9,r0\n        MOV      r0,r7\n        BL       pop__FP5Stack\n        AND      r2,r0,#0xff\n        MOV      r0,r9\n        MOV      r1,r3\n        BL       applyOp__FiT1c\n        MOV      r1,r0\n        MOV      r0,r6\n        BL       push__FP5Stacki\n|L1.440|\n        LDR      r0,[sp,#4]\n        CMN      r0,#1\n        BEQ      |L1.488|\n        MOV      r0,r7\n        BL       peek__FP5Stack\n        AND      r0,r0,#0xff\n        BL       precedence__Fc\n        MOV      r1,r0\n        LDRB     r0,[r5,r4]\n        BL       precedence__Fc\n        CMP      r1,r0\n        BGE      |L1.380|\n|L1.488|\n        LDRB     r1,[r5,r4]\n        MOV      r0,r7\n        BL       push__FP5Stacki\n|L1.500|\n        ADD      r4,r4,#1\n|L1.504|\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.288|\n        LDR      r0,[sp,#4]\n        CMN      r0,#1\n        BEQ      |L1.600|\n|L1.528|\n        MOV      r0,r6\n        BL       pop__FP5Stack\n        MOV      r3,r0\n        MOV      r0,r6\n        BL       pop__FP5Stack\n        MOV      r4,r0\n        MOV      r0,r7\n        BL       pop__FP5Stack\n        AND      r2,r0,#0xff\n        MOV      r0,r4\n        MOV      r1,r3\n        BL       applyOp__FiT1c\n        MOV      r1,r0\n        MOV      r0,r6\n        BL       push__FP5Stacki\n        LDR      r0,[sp,#4]\n        CMN      r0,#1\n        BNE      |L1.528|\n|L1.600|\n        MOV      r0,r6\n        BL       pop__FP5Stack\n        ADD      sp,sp,#0x32c\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int top;\n    int arr[MAX_SIZE];\n} Stack;\n\nvoid push(Stack *s, int val) {\n    if (s->top == MAX_SIZE - 1) return;\n    s->arr[++(s->top)] = val;\n}\n\nint pop(Stack *s) {\n    if (s->top == -1) return 0; \n    return s->arr[(s->top)--];\n}\n\nint peek(Stack *s){\n    if(s->top == -1) return 0;\n    return s->arr[s->top];\n}\n\nint isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nint precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n\nint applyOp(int a, int b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return b ? a / b : 0; \n        default: return 0;\n    }\n}\n\nint evaluate(char *expression) {\n    Stack operandStack;\n    operandStack.top = -1;\n    Stack operatorStack;\n    operatorStack.top = -1;\n\n    int i = 0;\n    while (expression[i]) {\n        if (isdigit(expression[i])) {\n            int num = 0;\n            while (isdigit(expression[i])) {\n                num = num * 10 + (expression[i] - '0');\n                i++;\n            }\n            push(&operandStack, num);\n            continue;\n        }\n        if (isOperator(expression[i])) {\n            while (operatorStack.top != -1 && precedence(peek(&operatorStack)) >= precedence(expression[i])) {\n                int op2 = pop(&operandStack);\n                int op1 = pop(&operandStack);\n                push(&operandStack, applyOp(op1, op2, pop(&operatorStack)));\n            }\n            push(&operatorStack, expression[i]);\n        }\n        i++;\n    }\n    while (operatorStack.top != -1) {\n        int op2 = pop(&operandStack);\n        int op1 = pop(&operandStack);\n        push(&operandStack, applyOp(op1, op2, pop(&operatorStack)));\n    }\n    return pop(&operandStack);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndisplayDateTime__Fv PROC\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#8\n        ADD      r4,sp,#4\n        MOV      r0,r4\n        BL       time\n        MOV      r0,r4\n        BL       localtime\n        BL       asctime\n        MOV      r1,r0\n        ADR      r0,|L1.56|\n        BL       _printf\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.56|\n        DCB      \"%s\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid displayDateTime() {\n    time_t rawtime;\n    struct tm * timeinfo;\n\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n\n    printf(\"%s\", asctime(timeinfo));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FUxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        BEQ      |L1.108|\n|L1.44|\n        MOV      r8,r4\n        MOV      r9,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_udiv\n        MOV      r4,r2\n        MOV      r5,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r8\n        MOV      r7,r9\n        BNE      |L1.44|\n|L1.108|\n        MOV      r0,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n    while (b) {\n        unsigned long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        MVN      r4,#0\n|L1.64|\n        CMP      r0,#0\n        BEQ      |L1.92|\n|L1.72|\n        ADD      r4,r4,#1\n        STR      r0,[r6,r4,LSL #2]\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BNE      |L1.72|\n|L1.92|\n        MOV      r0,r4\n        LDR      r5,[r6,r0,LSL #2]\n        ADR      r0,|L1.144|\n        SUB      r4,r4,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r0,[r5,#8]\n        CMP      r0,#0\n        CMNEQ    r4,#1\n        BNE      |L1.64|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.144|\n        DCB      \"%d \\0\"\n        ENDP\n\npreorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        STR      r0,[sp,#0]\n        MOV      r4,#0\n|L1.176|\n        MOV      r0,r4\n        LDR      r5,[r6,r0,LSL #2]\n        ADR      r0,|L1.144|\n        SUB      r4,r4,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r0,[r5,#8]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        LDR      r0,[r5,#4]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        CMN      r4,#1\n        BNE      |L1.176|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\npostorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c00\n        SUB      sp,sp,#0x344\n        ADD      r3,sp,#0xc00\n        ADD      r3,r3,#0x3a4\n        STR      r0,[sp,#0xfa4]\n        ADD      lr,sp,#4\n        MVN      r4,#0\n        MOV      r1,#0\n|L1.296|\n        MOV      r0,r1\n        LDR      r0,[r3,r0,LSL #2]\n        ADD      r4,r4,#1\n        STR      r0,[lr,r4,LSL #2]\n        LDR      r2,[r0,#4]\n        SUB      r1,r1,#1\n        CMP      r2,#0\n        ADDNE    r1,r1,#1\n        STRNE    r2,[r3,r1,LSL #2]\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        ADDNE    r1,r1,#1\n        STRNE    r0,[r3,r1,LSL #2]\n        CMN      r1,#1\n        BNE      |L1.296|\n        CMN      r4,#1\n        ADDEQ    sp,sp,#0x1c00\n        ADDEQ    sp,sp,#0x344\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r5,lr\n|L1.380|\n        MOV      r0,r4\n        LDR      r0,[r5,r0,LSL #2]\n        SUB      r4,r4,#1\n        LDR      r1,[r0,#0]\n        ADR      r0,|L1.144|\n        BL       _printf\n        CMN      r4,#1\n        BNE      |L1.380|\n        ADD      sp,sp,#0x1c00\n        ADD      sp,sp,#0x344\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nvoid inorderIterative(struct Node* root) {\n    if (root == NULL) return;\n    struct Node* stack[1000];\n    int top = -1;\n    struct Node* curr = root;\n    while (curr != NULL || top != -1) {\n        while (curr != NULL) {\n            top++;\n            stack[top] = curr;\n            curr = curr->left;\n        }\n        curr = stack[top--];\n        printf(\"%d \", curr->data);\n        curr = curr->right;\n    }\n}\n\nvoid preorderIterative(struct Node* root) {\n    if (root == NULL) return;\n    struct Node* stack[1000];\n    int top = -1;\n    top++;\n    stack[top] = root;\n    while (top != -1) {\n        struct Node* curr = stack[top--];\n        printf(\"%d \", curr->data);\n        if (curr->right != NULL) {\n            top++;\n            stack[top] = curr->right;\n        }\n        if (curr->left != NULL) {\n            top++;\n            stack[top] = curr->left;\n        }\n    }\n}\n\nvoid postorderIterative(struct Node* root) {\n    if (root == NULL) return;\n    struct Node* stack1[1000], *stack2[1000];\n    int top1 = -1, top2 = -1;\n    top1++;\n    stack1[top1] = root;\n    while (top1 != -1) {\n        struct Node* curr = stack1[top1--];\n        top2++;\n        stack2[top2] = curr;\n        if (curr->left != NULL) {\n            top1++;\n            stack1[top1] = curr->left;\n        }\n        if (curr->right != NULL) {\n            top1++;\n            stack1[top1] = curr->right;\n        }\n    }\n    while (top2 != -1) {\n        printf(\"%d \", stack2[top2--]->data);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisEven__Fi PROC\n        AND      r0,r0,#1\n        RSB      r0,r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isEven(int n) {\n    return n % 2 == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MVN      r0,#0\n        STMIB    r4,{r0,r5}\n        MOV      r0,#0x240\n        ADD      r0,r0,#0xf4000\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#4]\n        CMN      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisFull__FP5Stack PROC\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#4]\n        SUB      r1,r1,#1\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       isFull__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        BXNE     lr\n        LDR      r0,[r2,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      r1,[r2,#0]\n        STR      r3,[r1,r0,LSL #2]\n        LDR      r0,[r2,#0xc]\n        CMP      r0,r3\n        STRGT    r3,[r2,#0xc]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r2,[r1,#4]\n        LDR      r4,[r1,#0]\n        SUB      lr,r2,#1\n        LDR      r0,[r4,r2,LSL #2]\n        MOV      r3,#0x240\n        ADD      r3,r3,#0xf4000\n        STR      lr,[r1,#4]\n        MOV      r2,#0\n        CMP      lr,#0\n        BLT      |L1.308|\n|L1.284|\n        LDR      r12,[r4,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r12,r3\n        MOVLT    r3,r12\n        CMP      lr,r2\n        BGE      |L1.284|\n|L1.308|\n        STR      r3,[r1,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetMin__FP5Stack PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDREQ    r0,[r1,#0xc]\n        LDR      lr,[sp],#4\n        MVNNE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* data;\n    int top;\n    int capacity;\n    int min;\n} Stack;\n\nStack* createStack(int capacity) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    if (!stack) return 0;\n    stack->data = (int*)malloc(sizeof(int) * capacity);\n    if (!stack->data) {\n        free(stack);\n        return 0;\n    }\n    stack->top = -1;\n    stack->capacity = capacity;\n    stack->min = 1000000; \n    return stack;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == -1;\n}\n\nint isFull(Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nvoid push(Stack* stack, int value) {\n    if (isFull(stack)) return;\n    stack->top++;\n    stack->data[stack->top] = value;\n    if (value < stack->min) stack->min = value;\n}\n\nint pop(Stack* stack) {\n    if (isEmpty(stack)) return -1;\n    int value = stack->data[stack->top];\n    stack->top--;\n    int newMin = 1000000;\n    for (int i = 0; i <= stack->top; i++) {\n        if (stack->data[i] < newMin) newMin = stack->data[i];\n    }\n    stack->min = newMin;\n    return value;\n}\n\n\nint getMin(Stack* stack){\n    if(isEmpty(stack)) return -1;\n    return stack->min;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsieveOfEratosthenes__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r0,#2\n        MOVLT    r0,#0\n        LDMLTFD  sp!,{r4-r6,lr}\n        BLT      malloc\n        MOV      r6,r4,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r5,#0]\n        STR      r2,[r5,#4]\n        MOV      r1,#2\n        CMP      r4,#4\n        BLT      |L1.132|\n|L1.76|\n        LDR      r0,[r5,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BGT      |L1.116|\n|L1.100|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,r1\n        CMP      r0,r4\n        BLE      |L1.100|\n|L1.116|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BLE      |L1.76|\n|L1.132|\n        MOV      r1,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLT      |L1.172|\n|L1.148|\n        LDR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r1,r1,#1\n        CMP      r0,r4\n        BLE      |L1.148|\n|L1.172|\n        MOV      r0,r1,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        MOV      r2,#0\n        CMP      r4,#0\n        BLT      |L1.232|\n|L1.200|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        MOVNE    r1,r2\n        STRNE    r0,[r6,r1,LSL #2]\n        ADD      r0,r0,#1\n        ADDNE    r2,r2,#1\n        CMP      r0,r4\n        BLE      |L1.200|\n|L1.232|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* sieveOfEratosthenes(int limit) {\n    if (limit < 2) {\n        return (int*)malloc(0);\n    }\n    int* primes = (int*)malloc(sizeof(int) * limit);\n    memset(primes, 1, sizeof(int) * limit);\n    primes[0] = 0;\n    primes[1] = 0;\n    for (int p = 2; p * p <= limit; p++) {\n        if (primes[p]) {\n            for (int i = p * p; i <= limit; i += p)\n                primes[i] = 0;\n        }\n    }\n    int count = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) {\n            count++;\n        }\n    }\n    int* result = (int*)malloc(sizeof(int) * count);\n    int k = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) {\n            result[k++] = i;\n        }\n    }\n    free(primes);\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        MOV      r2,r0\n        CMP      r0,#1\n        MOVLE    r0,r2\n        BXLE     lr\n        MOV      r3,#0\n        MOV      r0,#1\n        MOV      r1,#2\n        CMP      r2,#2\n        BXLT     lr\n|L1.36|\n        ADD      r12,r3,r0\n        MOV      r3,r0\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        MOV      r0,r12\n        BLE      |L1.36|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_disjoint_set__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r6,r5,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r6\n        BL       malloc\n        STMIB    r4,{r0,r5}\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.92|\n        MOV      r1,#0\n|L1.64|\n        LDR      r2,[r4,#0]\n        STR      r0,[r2,r0,LSL #2]\n        LDR      r2,[r4,#4]\n        STR      r1,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.64|\n|L1.92|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfind__FP12disjoint_seti PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        MOV      r4,r1\n        LDR      r1,[r0,r1,LSL #2]\n        CMP      r1,r4\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r0,r5\n        BL       find__FP12disjoint_seti\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nunite__FP12disjoint_setiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r4,r0\n        BL       find__FP12disjoint_seti\n        MOV      r5,r0\n        MOV      r0,r4\n        MOV      r1,r6\n        BL       find__FP12disjoint_seti\n        CMP      r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#4]\n        LDR      r2,[r1,r5,LSL #2]\n        LDR      r1,[r1,r0,LSL #2]\n        CMP      r2,r1\n        LDRLT    r1,[r4,#0]\n        STRLT    r0,[r1,r5,LSL #2]\n        LDMLTFD  sp!,{r4-r6,lr}\n        BXLT     lr\n        LDRGT    r1,[r4,#0]\n        STRGT    r5,[r1,r0,LSL #2]\n        LDMGTFD  sp!,{r4-r6,lr}\n        BXGT     lr\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,r5,LSL #2\n        LDR      r1,[r0,#0]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct disjoint_set {\n    int* parent;\n    int* rank;\n    int size;\n};\n\ndisjoint_set* create_disjoint_set(int n) {\n    disjoint_set* ds = (disjoint_set*)malloc(sizeof(disjoint_set));\n    ds->parent = (int*)malloc(n * sizeof(int));\n    ds->rank = (int*)malloc(n * sizeof(int));\n    ds->size = n;\n    for (int i = 0; i < n; i++) {\n        ds->parent[i] = i;\n        ds->rank[i] = 0;\n    }\n    return ds;\n}\n\nint find(disjoint_set* ds, int i) {\n    if (ds->parent[i] == i) return i;\n    return ds->parent[i] = find(ds, ds->parent[i]);\n}\n\nvoid unite(disjoint_set* ds, int i, int j) {\n    int root_i = find(ds, i);\n    int root_j = find(ds, j);\n    if (root_i != root_j) {\n        if (ds->rank[root_i] < ds->rank[root_j]) {\n            ds->parent[root_i] = root_j;\n        } else if (ds->rank[root_i] > ds->rank[root_j]) {\n            ds->parent[root_j] = root_i;\n        } else {\n            ds->parent[root_j] = root_i;\n            ds->rank[root_i]++;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nbuildTree__FPiiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r2\n        MOV      r6,r0\n        MOV      r4,r1\n        CMP      r1,r2\n        LDMGEFD  sp!,{r3-r7,lr}\n        MOVGE    r0,#0\n        BXGE     lr\n        LDR      r0,[r6,r4,LSL #2]\n        BL       newNode__Fi\n        MOV      r5,r0\n        MOV      r0,#1\n        ADD      r1,r0,r4,LSL #1\n        MOV      r0,r6\n        MOV      r2,r7\n        BL       buildTree__FPiiT2\n        STR      r0,[r5,#4]\n        MOV      r0,#2\n        ADD      r1,r0,r4,LSL #1\n        MOV      r0,r6\n        MOV      r2,r7\n        BL       buildTree__FPiiT2\n        STR      r0,[r5,#8]\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* buildTree(int arr[], int i, int n) {\n    if (i >= n) return NULL;\n\n    struct Node* root = newNode(arr[i]);\n\n    root->left = buildTree(arr, 2 * i + 1, n);\n    root->right = buildTree(arr, 2 * i + 2, n);\n\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_valid__FPci PROC\n|L1.0|\n        CMP      r1,#0\n        MOVEQ    r0,#1\n        BXEQ     lr\n        TST      r1,#1\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r2,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.100|\n|L1.40|\n        LDRB     r12,[r0,r3]\n        CMP      r12,#0x28\n        ADDEQ    r2,r2,#1\n        BEQ      |L1.64|\n        CMP      r12,#0x29\n        SUBEQ    r2,r2,#1\n|L1.64|\n        CMP      r2,#0\n        MOVLT    r0,#0\n        BXLT     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.40|\n        CMP      r2,#0\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.100|\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_valid(char *str, int len) {\n    if (len == 0) return 1;\n    if (len % 2 != 0) return 0;\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        if (count < 0) return 0;\n    }\n    return count == 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_safe__FiN21 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        LDR      r4,|L1.592|\n        ADD      r12,r0,r0,LSL #3\n        ADD      lr,r4,r12,LSL #2\n        MOV      r3,#0\n|L1.20|\n        LDR      r12,[lr,r3,LSL #2]\n        CMP      r12,r2\n        BEQ      |L1.52|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r4,r12,LSL #2\n        LDR      r12,[r12,r1,LSL #2]\n        CMP      r12,r2\n        BNE      |L1.64|\n|L1.52|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        ADD      r3,r3,#1\n        CMP      r3,#9\n        BLT      |L1.20|\n        LDR      r3,|L1.596|\n        SMULL    lr,r12,r3,r0\n        SUB      r12,r12,r12,ASR #31\n        SUB      r12,r12,r12,LSL #2\n        ADD      r12,r12,r0\n        SUB      lr,r0,r12\n        SMULL    r12,r0,r3,r1\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #2\n        ADD      r0,r0,r1\n        SUB      r12,r1,r0\n        MOV      r1,#0\n|L1.124|\n        ADD      r3,r1,lr\n        ADD      r3,r3,r3,LSL #3\n        ADD      r3,r4,r3,LSL #2\n        MOV      r0,#0\n|L1.140|\n        ADD      r5,r0,r12\n        LDR      r5,[r3,r5,LSL #2]\n        CMP      r5,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,#3\n        BLT      |L1.140|\n        ADD      r1,r1,#1\n        CMP      r1,#3\n        BLT      |L1.124|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nfill_grid__FiT1 PROC\n        STMFD    sp!,{r4-r9,lr}\n        MOV      r4,r1\n        CMP      r0,#8\n        CMPEQ    r4,#9\n        MOV      r6,r0\n        LDMEQFD  sp!,{r4-r9,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#9\n        ADDEQ    r6,r6,#1\n        ADD      r1,r6,r6,LSL #3\n        LDR      r0,|L1.592|\n        MOVEQ    r4,#0\n        ADD      r7,r0,r1,LSL #2\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        ADDGT    r1,r4,#1\n        MOVGT    r0,r6\n        LDMGTFD  sp!,{r4-r9,lr}\n        BGT      fill_grid__FiT1\n        MOV      r5,#1\n        ADD      r8,r4,r5\n        MOV      r9,#0\n|L1.292|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       is_safe__FiN21\n        CMP      r0,#0\n        BEQ      |L1.356|\n        STR      r5,[r7,r4,LSL #2]\n        MOV      r1,r8\n        MOV      r0,r6\n        BL       fill_grid__FiT1\n        CMP      r0,#0\n        STREQ    r9,[r7,r4,LSL #2]\n        BEQ      |L1.356|\n        LDMFD    sp!,{r4-r9,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.356|\n        ADD      r5,r5,#1\n        CMP      r5,#9\n        BLE      |L1.292|\n        LDMFD    sp!,{r4-r9,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nremove_numbers__Fi PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r6,r0\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        MOV      r4,#0\n        CMP      r6,#0\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        MOV      r9,#0\n        LDR      r8,|L1.592|\n        LDR      r7,|L1.600|\n|L1.428|\n        BL       rand\n        SMULL    r2,r1,r7,r0\n        MOV      r1,r1,ASR #1\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #3\n        ADD      r5,r1,r0\n        BL       rand\n        SMULL    r2,r1,r7,r0\n        MOV      r1,r1,ASR #1\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #3\n        ADD      r0,r1,r0\n        ADD      r1,r5,r5,LSL #3\n        ADD      r1,r8,r1,LSL #2\n        LDR      r2,[r1,r0,LSL #2]\n        CMP      r2,#0\n        STRNE    r9,[r1,r0,LSL #2]\n        ADDNE    r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.428|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n\ngenerate_sudoku__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,|L1.592|\n        MOV      r1,#0x144\n        BL       __rt_memclr_w\n        MOV      r1,#0\n        MOV      r0,#0\n        BL       fill_grid__FiT1\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        remove_numbers__Fi\n        ENDP\n```",
        "output": "```cpp\n\n#define GRID_SIZE 9\n\nint grid[GRID_SIZE][GRID_SIZE];\n\nint is_safe(int row, int col, int num) {\n    for (int x = 0; x < GRID_SIZE; x++)\n        if (grid[row][x] == num || grid[x][col] == num)\n            return 0;\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            if (grid[i + startRow][j + startCol] == num)\n                return 0;\n    return 1;\n}\n\nint fill_grid(int row, int col) {\n    if (row == GRID_SIZE - 1 && col == GRID_SIZE)\n        return 1;\n    if (col == GRID_SIZE) {\n        row++;\n        col = 0;\n    }\n    if (grid[row][col] > 0)\n        return fill_grid(row, col + 1);\n    for (int num = 1; num <= GRID_SIZE; num++) {\n        if (is_safe(row, col, num)) {\n            grid[row][col] = num;\n            if (fill_grid(row, col + 1))\n                return 1;\n            grid[row][col] = 0;\n        }\n    }\n    return 0;\n}\n\nvoid remove_numbers(int level) {\n    srand(time(0));\n    int count = 0;\n    while (count < level) {\n        int row = rand() % GRID_SIZE;\n        int col = rand() % GRID_SIZE;\n        if (grid[row][col] != 0) {\n            grid[row][col] = 0;\n            count++;\n        }\n    }\n}\n\n\nvoid generate_sudoku(int difficulty) {\n    memset(grid, 0, sizeof(grid));\n    fill_grid(0, 0);\n    remove_numbers(difficulty);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_string__FPci PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        CMP      r1,#0\n        MOVLE    r0,r4\n        MOV      r5,r1\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n        MOV      r0,r4\n        BL       strlen\n        CMP      r5,r0\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        SUB      r0,r0,#1\n        SUB      r0,r0,r5\n        LDRB     r2,[r4,r0]\n        LDRB     r1,[r4,r5]\n        STRB     r2,[r4,r5]\n        STRB     r1,[r4,r0]\n        ADD      r1,r5,#1\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        reverse_string__FPci\n        ENDP\n```",
        "output": "```cpp\n\nchar* reverse_string(char* str, int index) {\n    if (index <= 0) return str;\n    int len = strlen(str);\n    if (index >= len) return str;\n\n    char temp = str[index];\n    str[index] = str[len - 1 - index];\n    str[len - 1 - index] = temp;\n\n    return reverse_string(str, index + 1);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r6,|L1.344|\n        LDR      r7,|L1.348|\n        MOV      r1,#1\n        STR      r1,[r6,r0,LSL #2]\n        LDR      r1,[r7,#0]  ; numVertices\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.352|\n        ADD      r5,r0,r1,LSL #4\n|L1.56|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r6,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.84|\n        MOV      r0,r4\n        BL       dfs__Fi\n|L1.84|\n        LDR      r0,[r7,#0]  ; numVertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.56|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nisConnected__Fv PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.344|\n        MOV      r1,#0x190\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        BL       dfs__Fi\n        LDR      r1,|L1.348|\n        MOV      r0,#0\n        LDR      r1,[r1,#0]  ; numVertices\n        CMP      r1,#0\n        BLE      |L1.188|\n|L1.156|\n        LDR      r2,[r4,r0,LSL #2]\n        CMP      r2,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,r1\n        BLT      |L1.156|\n|L1.188|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint graph[MAX_VERTICES][MAX_VERTICES];\nint numVertices;\n\nvoid dfs(int vertex) {\n    visited[vertex] = 1;\n    for (int i = 0; i < numVertices; i++) {\n        if (graph[vertex][i] == 1 && !visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\n\nint isConnected() {\n    memset(visited, 0, sizeof(visited));\n    dfs(0);\n    for (int i = 0; i < numVertices; i++) {\n        if (!visited[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nisValidAVL__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        ADD      r0,r0,#1\n        CMP      r0,#2\n        LDMHIFD  sp!,{r4,lr}\n        MOVHI    r0,#0\n        BXHI     lr\n        LDR      r0,[r4,#8]\n        BL       isValidAVL__FP4Node\n        CMP      r0,#0\n        BEQ      |L1.408|\n        LDR      r0,[r4,#0xc]\n        BL       isValidAVL__FP4Node\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.408|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1; \n    return (node);\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\n\nint isValidAVL(Node* root) {\n    if (root == NULL) return 1;\n    int balance = getBalance(root);\n    if (abs(balance) > 1) return 0;\n    return isValidAVL(root->left) && isValidAVL(root->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateLinkedList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP10LinkedListiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r6,r1\n        MOV      r5,r2\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r6,[r0,#0]\n        CMP      r5,#0\n        LDREQ    r1,[r4,#0]\n        STREQ    r1,[r0,#4]\n        STREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r2,#0\n        SUB      r3,r5,#1\n        LDR      r1,[r4,#0]\n        B        |L1.112|\n|L1.104|\n        LDR      r1,[r1,#4]\n        ADD      r2,r2,#1\n|L1.112|\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r2,r3\n        BLT      |L1.104|\n        LDR      r2,[r1,#4]\n        STR      r2,[r0,#4]\n        STR      r0,[r1,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndeleteNode__FP10LinkedListi PROC\n        LDR      r2,[r0,#0]\n        CMP      r2,#0\n        BXEQ     lr\n        CMP      r1,#0\n        BNE      |L1.188|\n        LDR      r1,[r2,#4]\n        STR      r1,[r0,#0]\n        MOV      r0,r2\n        B        free\n|L1.188|\n        MOV      r0,#0\n        SUB      r1,r1,#1\n        B        |L1.216|\n|L1.200|\n        LDR      r2,[r2,#4]\n        ADD      r0,r0,#1\n        CMP      r2,#0\n        BXEQ     lr\n|L1.216|\n        CMP      r0,r1\n        BLT      |L1.200|\n        LDR      r0,[r2,#4]\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        STRNE    r1,[r2,#4]\n        BNE      free\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct LinkedList {\n    struct Node* head;\n};\n\nstruct LinkedList* createLinkedList() {\n    struct LinkedList* list = (struct LinkedList*)malloc(sizeof(struct LinkedList));\n    list->head = NULL;\n    return list;\n}\n\nvoid insert(struct LinkedList* list, int data, int index) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n\n    if (index == 0) {\n        newNode->next = list->head;\n        list->head = newNode;\n        return;\n    }\n\n    struct Node* current = list->head;\n    int currentIndex = 0;\n    while (current != NULL && currentIndex < index - 1) {\n        current = current->next;\n        currentIndex++;\n    }\n\n    if (current == NULL) return;\n\n    newNode->next = current->next;\n    current->next = newNode;\n}\n\nvoid deleteNode(struct LinkedList* list, int index) {\n    if (list->head == NULL) return;\n\n    if (index == 0) {\n        struct Node* temp = list->head;\n        list->head = list->head->next;\n        free(temp);\n        return;\n    }\n\n    struct Node* current = list->head;\n    int currentIndex = 0;\n    while (current != NULL && currentIndex < index - 1) {\n        current = current->next;\n        currentIndex++;\n    }\n\n    if (current == NULL || current->next == NULL) return;\n\n    struct Node* temp = current->next;\n    current->next = current->next->next;\n    free(temp);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npostorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       postorder__FP4Node\n        LDR      r0,[r4,#8]\n        BL       postorder__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.48|\n        B        _printf\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nvoid postorder(Node* node) {\n    if (node == NULL) return;\n    postorder(node->left);\n    postorder(node->right);\n    printf(\"%d \", node->data);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninit_model__Fv PROC\n        MOV      r0,#1\n        B        malloc\n        ENDP\n\nsuper_resolve__FPv5Image PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADD      r6,sp,#0x20\n        MOV      r9,r0\n        LDMIA    r6,{r0,r6}\n        MOV      r8,r0,LSL #1\n        MOV      r7,r3,LSL #1\n        MUL      r0,r8,r7\n        MUL      r4,r6,r0\n        MOV      r0,r4\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r4\n        MOV      r1,#0x80\n        BL       __rt_memset\n        STMIA    r9,{r5,r7,r8}\n        STR      r6,[r9,#0xc]\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n\ncleanup_model__FPv PROC\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n// Placeholder for image data structure.  Replace with actual image representation.\ntypedef struct {\n    unsigned char* data;\n    int width;\n    int height;\n    int channels;\n} Image;\n\n// Placeholder for deep learning model. Replace with actual model loading and inference.\ntypedef void* Model;\n\n// Placeholder for model initialization. Replace with actual model loading.\nModel init_model() {\n    return (void*)malloc(1); // Dummy allocation\n}\n\n// Placeholder for model inference. Replace with actual model inference code.\nImage super_resolve(Model model, Image input) {\n    Image output;\n    output.width = input.width * 2;\n    output.height = input.height * 2;\n    output.channels = input.channels;\n    output.data = (unsigned char*)malloc(output.width * output.height * output.channels);\n    memset(output.data, 128, output.width * output.height * output.channels); //Dummy output\n\n    return output;\n}\n\n// Placeholder for model cleanup. Replace with actual model cleanup.\nvoid cleanup_model(Model model) {\n    free(model);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__FiT1 PROC\n        MOV      r3,#1\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.32|\n|L1.16|\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        MUL      r3,r0,r3\n        BLT      |L1.16|\n|L1.32|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n\nisArmstrong__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r8,|L1.240|\n        MOV      r7,r0\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.88|\n|L1.64|\n        SMULL    r1,r0,r8,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        CMP      r0,#0\n        ADD      r5,r5,#1\n        BGT      |L1.64|\n|L1.88|\n        MOV      r4,r7\n        MOV      r6,#0\n        CMP      r7,#0\n        BLE      |L1.160|\n|L1.104|\n        SMULL    r1,r0,r8,r4\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r4,r0,LSL #1\n        MOV      r1,r5\n        BL       power__FiT1\n        ADD      r6,r0,r6\n        SMULL    r1,r0,r8,r4\n        MOV      r0,r0,ASR #2\n        SUB      r4,r0,r0,ASR #31\n        CMP      r4,#0\n        BGT      |L1.104|\n|L1.160|\n        CMP      r6,r7\n        LDMFD    sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint power(int base, int exp){\n    int res = 1;\n    for (int i = 0; i < exp; i++)\n        res *= base;\n    return res;\n}\n\nint isArmstrong(int num){\n    int num_digits = 0;\n    int temp = num;\n    while(temp > 0){\n        num_digits++;\n        temp /= 10;\n    }\n\n    temp = num;\n    int sum = 0;\n    while(temp > 0){\n        int digit = temp % 10;\n        sum += power(digit, num_digits);\n        temp /= 10;\n    }\n\n    return sum == num;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nenqueue__Fi PROC\n|L1.0|\n        LDR      r2,|L1.476|\n        MOV      r1,r0\n        LDR      r0,[r2,#4]  ; tail\n        ADD      r3,r0,#1\n        STR      r3,[r2,#4]  ; tail\n        LDR      r2,|L1.480|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\ndequeue__Fv PROC\n        LDR      r1,|L1.476|\n        LDR      r0,[r1,#0]  ; head\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; head\n        LDR      r1,|L1.480|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\nisEmpty__Fv PROC\n        LDR      r0,|L1.476|\n        LDR      r1,[r0,#0]  ; head, tail\n        LDR      r0,[r0,#4]\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nshortestPath__FPA1000_iiN22 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x2c00\n        SUB      sp,sp,#0x2e4\n        ADD      r11,sp,#0x1c00\n        ADD      r11,r11,#0x344\n        MOV      r8,r2\n        MOV      r4,r1\n        MVN      r1,#0\n        MOV      r2,#0xfa0\n        MOV      r0,r11\n        MOV      r6,r3\n        BL       __rt_memset\n        ADD      r10,sp,#0xc00\n        ADD      r10,r10,#0x3a4\n        MOV      r0,r10\n        MOV      r2,#0xfa0\n        MVN      r1,#0\n        BL       __rt_memset\n        ADD      r9,sp,#4\n        MOV      r0,r9\n        MOV      r1,#0xfa0\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        BL       enqueue__Fi\n        MOV      r0,#0\n        STR      r0,[r11,r4,LSL #2]\n        BL       isEmpty__Fv\n        CMP      r0,#0\n        BNE      |L1.348|\n|L1.204|\n        BL       dequeue__Fv\n        MOV      r5,r0\n        CMP      r0,r8\n        LDREQ    r0,[r11,r8,LSL #2]\n        ADDEQ    sp,sp,#0x2c00\n        ADDEQ    sp,sp,#0x2f4\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r0,#1\n        STR      r0,[r9,r5,LSL #2]\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.336|\n        ADD      r12,sp,#0x2000\n        LDR      r1,[r12,#0xee4]\n        ADD      r0,r5,r5,LSL #1\n        RSB      r0,r0,r5,LSL #7\n        ADD      r7,r1,r0,LSL #5\n|L1.276|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.324|\n        LDR      r0,[r9,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.324|\n        LDR      r0,[r11,r5,LSL #2]\n        ADD      r0,r0,#1\n        STR      r0,[r11,r4,LSL #2]\n        STR      r5,[r10,r4,LSL #2]\n        MOV      r0,r4\n        BL       enqueue__Fi\n|L1.324|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.276|\n|L1.336|\n        BL       isEmpty__Fv\n        CMP      r0,#0\n        BEQ      |L1.204|\n|L1.348|\n        ADD      sp,sp,#0x2c00\n        ADD      sp,sp,#0x2f4\n        LDMFD    sp!,{r4-r11,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_NODES 1000\n\nint queue[MAX_NODES];\nint head = 0;\nint tail = 0;\n\nvoid enqueue(int node) {\n    queue[tail++] = node;\n}\n\nint dequeue() {\n    return queue[head++];\n}\n\nint isEmpty() {\n    return head == tail;\n}\n\nint shortestPath(int graph[][MAX_NODES], int start, int end, int n) {\n    int dist[MAX_NODES];\n    int prev[MAX_NODES];\n    int visited[MAX_NODES];\n    memset(dist, -1, sizeof(dist));\n    memset(prev, -1, sizeof(prev));\n    memset(visited, 0, sizeof(visited));\n\n    enqueue(start);\n    dist[start] = 0;\n\n    while (!isEmpty()) {\n        int u = dequeue();\n        if (u == end) return dist[end];\n        visited[u] = 1;\n\n        for (int v = 0; v < n; v++) {\n            if (graph[u][v] && !visited[v]) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                enqueue(v);\n            }\n        }\n    }\n    return -1; \n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculate_something__FiT1 PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r2,r0\n        MOVS     r0,r1\n        LDMEQFD  sp!,{r3,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r1,r2\n        BL       __rt_sdiv\n        CMP      r0,#0x64\n        LDMFD    sp!,{r3,lr}\n        MOVGT    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define SUCCESS 0\n#define FAILURE 1\n\nint calculate_something(int a, int b) {\n    if (b == 0) return FAILURE;\n    if (a / b > 100) return FAILURE;\n    return a / b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfind_substring__FPCcT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       strlen\n        MOV      r8,r0\n        MOV      r0,r7\n        BL       strlen\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        CMP      r8,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        MVNEQ    r0,#0\n        BXEQ     lr\n        MOV      r4,#0\n        SUBS     r8,r8,r5\n        BMI      |L1.112|\n|L1.68|\n        ADD      r0,r6,r4\n        MOV      r2,r5\n        MOV      r1,r7\n        BL       strncmp\n        CMP      r0,#0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        ADD      r4,r4,#1\n        CMP      r8,r4\n        BGE      |L1.68|\n|L1.112|\n        LDMFD    sp!,{r4-r8,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint find_substring(const char *str, const char *substr) {\n    int str_len = strlen(str);\n    int substr_len = strlen(substr);\n    if (substr_len == 0) return 0;\n    if (str_len == 0) return -1;\n\n    for (int i = 0; i <= str_len - substr_len; ++i) {\n        if (strncmp(str + i, substr, substr_len) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintLeftViewUtil__FP4nodeiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        CMP      r0,r6\n        BGE      |L1.92|\n        ADR      r0,|L1.132|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        STR      r6,[r5,#0]\n|L1.92|\n        ADD      r1,r6,#1\n        MOV      r6,r1\n        MOV      r2,r5\n        LDR      r0,[r4,#4]\n        BL       printLeftViewUtil__FP4nodeiPi\n        MOV      r2,r5\n        MOV      r1,r6\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4-r6,lr}\n        B        printLeftViewUtil__FP4nodeiPi\n|L1.132|\n        DCB      \"%d \\0\"\n        ENDP\n\nprintLeftView__FP4node PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r1,#0\n        STR      r1,[sp,#0]\n        MOV      r1,#1\n        MOV      r2,sp\n        BL       printLeftViewUtil__FP4nodeiPi\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nvoid printLeftViewUtil(struct node *root, int level, int *max_level) {\n    if (root == NULL) return;\n\n    if (*max_level < level) {\n        printf(\"%d \", root->data);\n        *max_level = level;\n    }\n\n    printLeftViewUtil(root->left, level + 1, max_level);\n    printLeftViewUtil(root->right, level + 1, max_level);\n}\n\nvoid printLeftView(struct node *root) {\n    int max_level = 0;\n    printLeftViewUtil(root, 1, &max_level);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r1\n        LDMEQFD  sp!,{r4,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.88|\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.104|\n|L1.88|\n        BGE      |L1.104|\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.104|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        B        |L1.124|\n|L1.120|\n        MOV      r0,r1\n|L1.124|\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BNE      |L1.120|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.192|\n        LDR      r0,[r4,#4]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.308|\n|L1.192|\n        BGE      |L1.212|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.308|\n|L1.212|\n        LDR      r5,[r4,#4]\n        CMP      r5,#0\n        BNE      |L1.248|\n        LDR      r5,[r4,#8]\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.248|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.280|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.280|\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.308|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsearch__FP4Nodei PROC\n|L1.320|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#8]\n        LDRGT    r0,[r0,#4]\n        B        |L1.320|\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = 0;\n    return node;\n}\n\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == 0) return newNode(data);\n    if (data < node->data) node->left = insert(node->left, data);\n    else if (data > node->data) node->right = insert(node->right, data);\n    return node;\n}\n\n\nstruct Node* minValueNode(struct Node* node) {\n    struct Node* current = node;\n    while (current && current->left != 0) current = current->left;\n    return current;\n}\n\n\nstruct Node* deleteNode(struct Node* root, int data) {\n    if (root == 0) return root;\n    if (data < root->data) root->left = deleteNode(root->left, data);\n    else if (data > root->data) root->right = deleteNode(root->right, data);\n    else {\n        if (root->left == 0) {\n            struct Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == 0) {\n            struct Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\n\nstruct Node* search(struct Node* root, int data) {\n    if (root == 0 || root->data == data) return root;\n    if (data < root->data) return search(root->left, data);\n    return search(root->right, data);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndaysInMonth__FiT1 PROC\n        CMP      r0,#2\n        BNE      |L1.96|\n        TST      r1,#3\n        LDR      r0,|L1.388|\n        BNE      |L1.52|\n        SMULL    r3,r2,r0,r1\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r1,r2,LSL #2\n        BNE      |L1.88|\n|L1.52|\n        SMULL    r3,r2,r0,r1\n        MOV      r0,r2,ASR #7\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r0,r0,LSL #2\n        ADDS     r0,r1,r0,LSL #4\n        MOVNE    r0,#0x1c\n        BXNE     lr\n|L1.88|\n        MOV      r0,#0x1d\n        BX       lr\n|L1.96|\n        CMP      r0,#4\n        CMPNE    r0,#6\n        CMPNE    r0,#9\n        CMPNE    r0,#0xb\n        MOVNE    r0,#0x1f\n        BXNE     lr\n        MOV      r0,#0x1e\n        BX       lr\n        ENDP\n\nisLeap__Fi PROC\n        TST      r0,#3\n        LDR      r1,|L1.388|\n        BNE      |L1.172|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        BNE      |L1.208|\n|L1.172|\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.208|\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nnextDay__FP8Calendar PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        BL       daysInMonth__FiT1\n        LDR      r1,[r4,#8]\n        CMP      r1,r0\n        LDMLEFD  sp!,{r4,lr}\n        BXLE     lr\n        MOV      r1,#1\n        STR      r1,[r4,#8]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,r1\n        STR      r0,[r4,#4]\n        CMP      r0,#0xc\n        LDMLEFD  sp!,{r4,lr}\n        BXLE     lr\n        STR      r1,[r4,#4]\n        LDR      r0,[r4,#0]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Date {\n    int year;\n    int month;\n    int day;\n};\n\nstruct Calendar {\n    Date currentDate;\n};\n\n\nint daysInMonth(int month, int year) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) return 29;\n        else return 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) return 30;\n    else return 31;\n}\n\nint isLeap(int year){\n    return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);\n}\n\nvoid nextDay(Calendar *cal) {\n    cal->currentDate.day++;\n    int days = daysInMonth(cal->currentDate.month, cal->currentDate.year);\n    if (cal->currentDate.day > days) {\n        cal->currentDate.day = 1;\n        cal->currentDate.month++;\n        if (cal->currentDate.month > 12) {\n            cal->currentDate.month = 1;\n            cal->currentDate.year++;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npathSum__FP4Nodei PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        BNE      |L1.104|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        LDMFD    sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n|L1.104|\n        LDR      r1,[r4,#0]\n        SUB      r1,r5,r1\n        BL       pathSum__FP4Nodei\n        MOV      r6,r0\n        LDR      r0,[r4,#0]\n        SUB      r1,r5,r0\n        LDR      r0,[r4,#8]\n        BL       pathSum__FP4Nodei\n        ADD      r0,r6,r0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nint pathSum(struct Node* root, int sum) {\n    if (!root) return 0;\n    if (!root->left && !root->right) return (root->data == sum);\n    return pathSum(root->left, sum - root->data) + pathSum(root->right, sum - root->data);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbinomialCoeff__FUiT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOVS     r5,r1\n        MOV      r6,r0\n        CMPNE    r5,r6\n        ADR      r1,|L1.128|\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        ADRHI    r1,|L1.136|\n        LDMHIIA  r1,{r0,r1}\n        LDMHIFD  sp!,{r4-r8,lr}\n        BXHI     lr\n        CMP      r5,r6,LSR #1\n        SUBHI    r5,r6,r5\n        CMP      r5,#0\n        LDMIA    r1,{r0,r1}\n        MOV      r4,#0\n        LDMLSFD  sp!,{r4-r8,lr}\n        BXLS     lr\n|L1.76|\n        SUB      r2,r6,r4\n        UMULL    r7,r12,r2,r0\n        ADD      r0,r4,#1\n        MLA      r1,r2,r1,r12\n        MOV      r2,r0\n        MOV      r4,r0\n        MOV      r0,r7\n        MOV      r3,#0\n        BL       _ll_udiv\n        CMP      r4,r5\n        BCC      |L1.76|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.128|\n        DCQ      0x0000000000000001\n|L1.136|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long binomialCoeff(unsigned int n, unsigned int k) {\n    if (k == 0 || k == n) return 1;\n    if (k > n) return 0;\n    if (k > n / 2) k = n - k;\n    unsigned long long res = 1;\n    for (unsigned int i = 0; i < k; ++i) {\n        res = res * (n - i);\n        res = res / (i + 1);\n    }\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__FxN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r6,r2\n        ADR      r2,|L1.228|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.228|\n        LDMIA    r2,{r8,r9}\n        MOV      r7,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        ADR      r0,|L1.236|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BGE      |L1.212|\n|L1.72|\n        ADR      r0,|L1.244|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _ll_sdiv\n        MOV      r6,r0\n        MOV      r0,r2\n        MOV      r7,r1\n        MOV      r1,r3\n        ADR      r2,|L1.228|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.160|\n        UMULL    r0,r12,r8,r4\n        MLA      r12,r4,r9,r12\n        MLA      r1,r5,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.160|\n        UMULL    r0,r12,r4,r4\n        MLA      r12,r4,r5,r12\n        MLA      r1,r5,r4,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        ADR      r0,|L1.236|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BLT      |L1.72|\n|L1.212|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.228|\n        DCQ      0x0000000000000001\n|L1.236|\n        DCQ      0x0000000000000000\n|L1.244|\n        DCQ      0x0000000000000002\n        ENDP\n\nmillerRabin__Fxi PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        MOV      r2,#1\n        MOV      r7,r0\n        SUBS     r0,r0,r2\n        SUB      sp,sp,#0x20\n        ADR      r4,|L1.228|\n        ADR      r4,|L1.228|\n        STR      r0,[sp,#0x1c]\n        LDMIA    r4,{r2,r3}\n        SBC      r11,r1,#0\n        SUBS     r0,r2,r7\n        MOV      r8,r1\n        SBCS     r1,r3,r8\n        ADR      r6,|L1.236|\n        ADR      r5,|L1.244|\n        BGE      |L1.340|\n        ADR      r0,|L1.816|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r7\n        CMP      r8,r3\n        CMPEQ    r0,r2\n        BNE      |L1.356|\n|L1.340|\n        ADD      sp,sp,#0x2c\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.356|\n        ADR      r0,|L1.824|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r7\n        SBCS     r1,r3,r8\n        ADDGE    sp,sp,#0x2c\n        LDMGEFD  sp!,{r4-r11,lr}\n        MOVGE    r0,#1\n        BXGE     lr\n        LDR      r9,[sp,#0x1c]\n        LDMIA    r5,{r2,r3}\n        MOV      r10,r11\n        MOV      r4,#0\n        MOV      r1,r11\n        MOV      r0,r9\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r6,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.500|\n|L1.440|\n        MOV      r1,r10\n        MOV      r0,r9\n        LDMIA    r5,{r2,r3}\n        BL       _ll_sdiv\n        MOV      r9,r0\n        MOV      r10,r1\n        ADD      r4,r4,#1\n        LDMIA    r5,{r2,r3}\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r6,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BEQ      |L1.440|\n|L1.500|\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        LDR      r1,[sp,#0x28]\n        MOV      r0,#0\n        STR      r0,[sp,#0xc]\n        CMP      r1,#0\n        BLE      |L1.800|\n        MOV      r2,#2\n        SUBS     r0,r7,r2\n        STR      r0,[sp,#0x18]\n        SUB      r0,r4,#1\n        SBC      r1,r8,#0\n        ADD      r2,sp,#0x10\n        STMIA    r2,{r0,r1}\n|L1.560|\n        BL       rand\n        MOV      r3,r0,ASR #31\n        MOV      r2,r0\n        LDR      r0,[sp,#0x18]\n        LDR      r1,[sp,#0x14]\n        BL       _ll_srdv\n        MOV      r0,r2\n        MOV      r2,#2\n        ADDS     r0,r0,r2\n        ADC      r1,r3,#0\n        MOV      r3,r10\n        MOV      r2,r9\n        STMIA    sp,{r7,r8}\n        BL       power__FxN21\n        MOV      r4,r0\n        ADR      r0,|L1.228|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r5,r1\n        BEQ      |L1.776|\n        LDR      r0,[sp,#0x1c]\n        MOV      r2,r4\n        CMP      r11,r5\n        CMPEQ    r0,r2\n        BEQ      |L1.776|\n        LDR      r0,[sp,#0x10]\n        MOV      r6,#0\n        CMP      r0,#0\n        BLE      |L1.744|\n|L1.684|\n        UMULL    r0,r12,r4,r4\n        MLA      r12,r4,r5,r12\n        MLA      r1,r5,r4,r12\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _ll_sdiv\n        LDR      r0,[sp,#0x1c]\n        CMP      r11,r3\n        CMPEQ    r0,r2\n        LDRNE    r0,[sp,#0x10]\n        ADDNE    r6,r6,#1\n        CMPNE    r6,r0\n        MOV      r4,r2\n        MOV      r5,r3\n        BLT      |L1.684|\n|L1.744|\n        LDR      r0,[sp,#0x1c]\n        MOV      r2,r4\n        CMP      r11,r5\n        CMPEQ    r0,r2\n        ADDNE    sp,sp,#0x2c\n        LDMNEFD  sp!,{r4-r11,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.776|\n        LDR      r0,[sp,#0xc]\n        LDR      r1,[sp,#0x28]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0xc]\n        CMP      r0,r1\n        BLT      |L1.560|\n|L1.800|\n        ADD      sp,sp,#0x2c\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.816|\n        DCQ      0x0000000000000004\n|L1.824|\n        DCQ      0x0000000000000003\n        ENDP\n```",
        "output": "```cpp\n\nlong long power(long long base, long long exp, long long mod) {\n    long long res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\nint millerRabin(long long n, int k) {\n    if (n <= 1 || n == 4) return 0;\n    if (n <= 3) return 1;\n    long long d = n - 1;\n    int s = 0;\n    while (d % 2 == 0) {\n        d /= 2;\n        s++;\n    }\n    srand(time(0));\n    for (int i = 0; i < k; i++) {\n        long long a = rand() % (n - 2) + 2;\n        long long x = power(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        for (int j = 0; j < s - 1; j++) {\n            x = (x * x) % n;\n            if (x == n - 1) break;\n        }\n        if (x != n - 1) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculateProbability__FPcT1P9DataPointi PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r1\n        MOV      r9,r0\n        MOV      r8,r3\n        MOV      r7,r2\n        MOV      r6,#0\n        MOV      r5,#0\n        MOV      r4,#0\n        CMP      r3,#0\n        BLE      |L1.108|\n|L1.40|\n        ADD      r0,r7,r4,LSL #3\n        LDR      r0,[r0,#4]\n        MOV      r1,r10\n        BL       strcmp\n        CMP      r0,#0\n        BNE      |L1.88|\n        ADD      r5,r5,#1\n        LDR      r0,[r7,r4,LSL #3]\n        MOV      r1,r9\n        BL       strcmp\n        CMP      r0,#0\n        ADDEQ    r6,r6,#1\n|L1.88|\n        ADD      r4,r4,#1\n        CMP      r4,r8\n        BLT      |L1.40|\n        CMP      r5,#0\n        BNE      |L1.124|\n|L1.108|\n        ADR      r1,|L1.164|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        MOV      r0,r6\n        BL       _dflt\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r6,r1\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r10,lr}\n        B        _drdiv\n|L1.164|\n        DCFD     0x0000000000000000\n        ENDP\n\nclassify__FPcP9DataPointiPPcT3 PROC\n        STMFD    sp!,{r0-r11,lr}\n        ADR      r0,|L1.440|\n        LDMIA    r0,{r10,r11}\n        MOV      r0,#0\n        SUB      sp,sp,#0x14\n        STR      r0,[sp,#8]\n        LDR      r0,[sp,#0x48]\n        MOV      r9,r1\n        MOV      r8,r3\n        MOV      r7,r2\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.424|\n        MOV      r0,r7\n        BL       _dflt\n        STR      r0,[sp,#0x10]\n        STR      r1,[sp,#0xc]\n|L1.240|\n        LDR      r1,[r8,r5,LSL #2]\n        LDR      r0,[sp,#0x14]\n        MOV      r3,r7\n        MOV      r2,r9\n        BL       calculateProbability__FPcT1P9DataPointi\n        MOV      r6,#0\n        MOV      r4,#0\n        CMP      r7,#0\n        STMIA    sp,{r0,r1}\n        BLE      |L1.408|\n|L1.280|\n        LDR      r1,[r8,r5,LSL #2]\n        ADD      r0,r9,r4,LSL #3\n        LDR      r0,[r0,#4]\n        BL       strcmp\n        CMP      r0,#0\n        ADDEQ    r6,r6,#1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.280|\n        CMP      r6,#0\n        BEQ      |L1.408|\n        MOV      r0,r6\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        LDR      r1,[sp,#0xc]\n        LDR      r0,[sp,#0x10]\n        BL       _drdiv\n        MOV      r2,r0\n        MOV      r3,r1\n        LDMIA    sp,{r0,r1}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r6,r1\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dcmpge\n        BLS      |L1.408|\n        LDR      r0,[r8,r5,LSL #2]\n        MOV      r10,r4\n        MOV      r11,r6\n        STR      r0,[sp,#8]\n|L1.408|\n        LDR      r0,[sp,#0x48]\n        ADD      r5,r5,#1\n        CMP      r5,r0\n        BLT      |L1.240|\n|L1.424|\n        LDR      r0,[sp,#8]\n        ADD      sp,sp,#0x24\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.440|\n        DCFD     0xbff0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct DataPoint {\n    char* features;\n    char* label;\n};\n\n\ndouble calculateProbability(char* feature, char* label, struct DataPoint* dataset, int size) {\n    int countFeatureAndLabel = 0;\n    int countLabel = 0;\n    for (int i = 0; i < size; i++) {\n        if (strcmp(dataset[i].label, label) == 0) {\n            countLabel++;\n            if (strcmp(dataset[i].features, feature) == 0) {\n                countFeatureAndLabel++;\n            }\n        }\n    }\n    if (countLabel == 0) return 0.0;\n    return (double)countFeatureAndLabel / countLabel;\n}\n\nchar* classify(char* features, struct DataPoint* dataset, int size, char** labels, int numLabels) {\n    double maxProbability = -1.0;\n    char* bestLabel = 0;\n\n    for (int i = 0; i < numLabels; i++) {\n        double probability = calculateProbability(features, labels[i], dataset, size);\n        int countLabel = 0;\n        for (int j = 0; j < size; j++) {\n            if (strcmp(dataset[j].label, labels[i]) == 0) countLabel++;\n        }\n        if (countLabel == 0) continue;\n        double labelProbability = (double)countLabel / size;\n        double currentProbability = probability * labelProbability;\n\n        if (currentProbability > maxProbability) {\n            maxProbability = currentProbability;\n            bestLabel = labels[i];\n        }\n    }\n    return bestLabel;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nminDistance__FPiPbi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MVN      lr,#0x80000000\n        MOV      r3,#0\n        CMP      r2,#0\n        BLE      |L1.60|\n|L1.20|\n        LDR      r12,[r1,r3,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.48|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,lr\n        MOVLE    lr,r12\n        MOVLE    r4,r3\n|L1.48|\n        ADD      r3,r3,#1\n        CMP      r3,r2\n        BLT      |L1.20|\n|L1.60|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndijkstra__FPA100_iiN22 PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x324\n        MOV      r9,r0\n        MOV      r0,#0\n        ADD      r6,sp,#4\n        ADD      r7,sp,#0x194\n        MOV      r11,r2\n        MOV      r4,r3\n        MOV      r12,#0\n        CMP      r3,#0\n        BLE      |L1.144|\n        MVN      r2,#0x80000000\n        MOV      r3,r7\n|L1.124|\n        STR      r2,[r3,r0,LSL #2]\n        STR      r12,[r6,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.124|\n|L1.144|\n        SUB      r8,r4,#1\n        CMP      r8,#0\n        STR      r12,[r7,r1,LSL #2]\n        MOV      r5,#0\n        BLE      |L1.288|\n        MOV      r10,#1\n|L1.168|\n        MOV      r2,r4\n        MOV      r1,r6\n        MOV      r0,r7\n        BL       minDistance__FPiPbi\n        STR      r10,[r6,r0,LSL #2]\n        MOV      r1,#0\n        CMP      r4,#0\n        BLE      |L1.276|\n        ADD      r2,r0,r0,LSL #3\n        ADD      r2,r2,r0,LSL #4\n        ADD      r2,r9,r2,LSL #4\n|L1.212|\n        LDR      r3,[r6,r1,LSL #2]\n        CMP      r3,#0\n        BNE      |L1.264|\n        LDR      r12,[r2,r1,LSL #2]\n        CMP      r12,#0\n        LDRNE    r3,[r7,r0,LSL #2]\n        MOVNE    lr,r7\n        CMNNE    r3,#0x80000001\n        ADDNE    r3,r12,r3\n        LDRNE    r12,[lr,r1,LSL #2]\n        CMPNE    r3,r12\n        BGE      |L1.264|\n        STR      r3,[lr,r1,LSL #2]\n|L1.264|\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLT      |L1.212|\n|L1.276|\n        ADD      r5,r5,#1\n        CMP      r5,r8\n        BLT      |L1.168|\n|L1.288|\n        LDR      r1,[r7,r11,LSL #2]\n        ADR      r0,|L1.320|\n        CMN      r1,#0x80000001\n        MVNEQ    r1,#0\n        BL       _printf\n        ADD      sp,sp,#0x324\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.320|\n        DCB      \"%d\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define INF INT_MAX\n\nint minDistance(int dist[], bool sptSet[], int V) {\n    int min = INF, min_index;\n    for (int v = 0; v < V; v++)\n        if (sptSet[v] == 0 && dist[v] <= min)\n            min = dist[v], min_index = v;\n    return min_index;\n}\n\nvoid dijkstra(int graph[][100], int src, int dest, int V) {\n    int dist[100];\n    bool sptSet[100];\n    for (int i = 0; i < V; i++)\n        dist[i] = INF, sptSet[i] = 0;\n    dist[src] = 0;\n    for (int count = 0; count < V - 1; count++) {\n        int u = minDistance(dist, sptSet, V);\n        sptSet[u] = 1;\n        for (int v = 0; v < V; v++)\n            if (!sptSet[v] && graph[u][v] && dist[u] != INF && dist[u] + graph[u][v] < dist[v])\n                dist[v] = dist[u] + graph[u][v];\n    }\n    printf(\"%d\", dist[dest] == INF ? -1 : dist[dest]);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringLength__FPCc PROC\n|L1.0|\n        LDRB     r2,[r0,#0]\n        MOV      r1,#0\n        CMP      r2,#0\n        BEQ      |L1.32|\n|L1.16|\n        LDRB     r2,[r0,#1]!\n        ADD      r1,r1,#1\n        CMP      r2,#0\n        BNE      |L1.16|\n|L1.32|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint stringLength(const char* str) {\n    int length = 0;\n    while (*str != '\\0') {\n        length++;\n        str++;\n    }\n    return length;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__FP5Stackc PROC\n        LDR      r2,[r0,#0x64]\n        ADD      r2,r2,#1\n        STR      r2,[r0,#0x64]\n        STRB     r1,[r0,r2]\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        LDR      r2,[r0,#0x64]\n        MOV      r1,r0\n        LDRB     r0,[r0,r2]\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0x64]\n        BX       lr\n        ENDP\n\nprecedence__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVEQ    r0,#2\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\ninfixToPostfix__FPcT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MVN      r0,#0\n        SUB      sp,sp,#0x68\n        STR      r0,[sp,#0x64]\n        LDRB     r0,[r7,#0]\n        MOV      r6,r1\n        MOV      r5,#0\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.396|\n        BL       __rt_ctype_table\n        MOV      r8,r0\n        MOV      r3,sp\n|L1.136|\n        LDRB     r1,[r7,r5]\n        LDR      r0,[r8,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        MOVNE    r0,r4\n        STRNEB   r1,[r6,r0]\n        ADDNE    r4,r4,#1\n        BNE      |L1.336|\n        CMP      r1,#0x28\n        BNE      |L1.188|\n        MOV      r0,r3\n        BL       push__FP5Stackc\n        B        |L1.336|\n|L1.188|\n        CMP      r1,#0x29\n        BNE      |L1.280|\n        B        |L1.220|\n|L1.200|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        MOV      r1,r4\n        STRB     r0,[r6,r1]\n        ADD      r4,r4,#1\n|L1.220|\n        LDR      r0,[sp,#0x64]\n        CMN      r0,#1\n        BEQ      |L1.336|\n        LDR      r0,[sp,#0x64]\n        LDRB     r0,[r3,r0]\n        CMP      r0,#0x28\n        BNE      |L1.200|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        B        |L1.336|\n|L1.260|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        MOV      r1,r4\n        STRB     r0,[r6,r1]\n        ADD      r4,r4,#1\n|L1.280|\n        LDR      r0,[sp,#0x64]\n        CMN      r0,#1\n        BEQ      |L1.324|\n        LDRB     r0,[r7,r5]\n        BL       precedence__Fc\n        MOV      r1,r0\n        LDR      r0,[sp,#0x64]\n        LDRB     r0,[r3,r0]\n        BL       precedence__Fc\n        CMP      r1,r0\n        BLE      |L1.260|\n|L1.324|\n        LDRB     r1,[r7,r5]\n        MOV      r0,r3\n        BL       push__FP5Stackc\n|L1.336|\n        ADD      r5,r5,#1\n        LDRB     r0,[r7,r5]\n        CMP      r0,#0\n        BNE      |L1.136|\n        LDR      r0,[sp,#0x64]\n        CMN      r0,#1\n        BEQ      |L1.396|\n|L1.364|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        MOV      r1,r4\n        STRB     r0,[r6,r1]\n        LDR      r0,[sp,#0x64]\n        ADD      r4,r4,#1\n        CMN      r0,#1\n        BNE      |L1.364|\n|L1.396|\n        MOV      r0,#0\n        STRB     r0,[r6,r4]\n        ADD      sp,sp,#0x68\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    char data[MAX_SIZE];\n    int top;\n} Stack;\n\nvoid push(Stack *s, char x) {\n    s->top++;\n    s->data[s->top] = x;\n}\n\nchar pop(Stack *s) {\n    char x = s->data[s->top];\n    s->top--;\n    return x;\n}\n\nint precedence(char x) {\n    if (x == '+' || x == '-') return 1;\n    if (x == '*' || x == '/') return 2;\n    return 0;\n}\n\nvoid infixToPostfix(char infix[], char postfix[]) {\n    Stack s;\n    s.top = -1;\n    int i = 0, j = 0;\n    while (infix[i] != '\\0') {\n        if (isalnum(infix[i])) {\n            postfix[j++] = infix[i];\n        } else if (infix[i] == '(') {\n            push(&s, infix[i]);\n        } else if (infix[i] == ')') {\n            while (s.top != -1 && s.data[s.top] != '(') {\n                postfix[j++] = pop(&s);\n            }\n            if (s.top != -1) pop(&s);\n        } else {\n            while (s.top != -1 && precedence(infix[i]) <= precedence(s.data[s.top])) {\n                postfix[j++] = pop(&s);\n            }\n            push(&s, infix[i]);\n        }\n        i++;\n    }\n    while (s.top != -1) {\n        postfix[j++] = pop(&s);\n    }\n    postfix[j] = '\\0';\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsendMessage__FPvT1 PROC\n|L1.0|\n        LDR      r2,[r0,#0]\n        LDR      r2,[r2,#0]\n        BX       r2\n        ENDP\n\nconcreteColleague1SendMessage__FPvT1 PROC\n        ADR      r0,|L1.20|\n        B        _printf\n|L1.20|\n        DCB      \"Conc\"\n        DCB      \"rete\"\n        DCB      \"Coll\"\n        DCB      \"eagu\"\n        DCB      \"e1 s\"\n        DCB      \"ent \"\n        DCB      \"mess\"\n        DCB      \"age \"\n        DCB      \"to C\"\n        DCB      \"oncr\"\n        DCB      \"eteC\"\n        DCB      \"olle\"\n        DCB      \"ague\"\n        DCB      \"2\\n\\0\\0\"\n        ENDP\n\nconcreteColleague2SendMessage__FPvT1 PROC\n        ADR      r0,|L1.84|\n        B        _printf\n|L1.84|\n        DCB      \"Conc\"\n        DCB      \"rete\"\n        DCB      \"Coll\"\n        DCB      \"eagu\"\n        DCB      \"e2 s\"\n        DCB      \"ent \"\n        DCB      \"mess\"\n        DCB      \"age \"\n        DCB      \"to C\"\n        DCB      \"oncr\"\n        DCB      \"eteC\"\n        DCB      \"olle\"\n        DCB      \"ague\"\n        DCB      \"1\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    void (*sendMessage)(void*, void*);\n} Mediator;\n\ntypedef struct {\n    Mediator* mediator;\n    void* data;\n} Colleague;\n\nvoid sendMessage(void* sender, void* receiver) {\n    //Simulate sending a message.  In a real application, this would do something useful.\n    ((Colleague*)sender)->mediator->sendMessage(sender, receiver);\n}\n\n\nvoid concreteColleague1SendMessage(void* sender, void* receiver){\n    printf(\"ConcreteColleague1 sent message to ConcreteColleague2\\n\");\n}\n\nvoid concreteColleague2SendMessage(void* sender, void* receiver){\n    printf(\"ConcreteColleague2 sent message to ConcreteColleague1\\n\");\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_digits__Fi PROC\n        CMP      r0,#0xa\n        BXLT     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,|L1.108|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r4,r0,r2,LSL #1\n        SMULL    r2,r0,r1,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        BL       sum_digits__Fi\n        ADD      r0,r4,r0\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_digits(int n) {\n    if (n < 10) return n;\n    return (n % 10) + sum_digits(n / 10);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompare__FPCvT1 PROC\n|L1.0|\n        LDR      r0,[r0,#0]\n        LDR      r1,[r1,#0]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n\nfindKthSmallest__FPiiT2 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r4,r2\n        CMP      r2,#0\n        BLE      |L1.44|\n        CMP      r4,r1\n        BLE      |L1.56|\n|L1.44|\n        LDMFD    sp!,{r3-r5,lr}\n        MVN      r0,#0\n        BX       lr\n|L1.56|\n        LDR      r3,|L1.152|\n        MOV      r2,#4\n        MOV      r0,r5\n        BL       qsort\n        ADD      r0,r5,r4,LSL #2\n        LDR      r0,[r0,#-4]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint compare(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}\n\nint findKthSmallest(int arr[], int n, int k) {\n    if (k <= 0 || k > n) return -1; \n\n    qsort(arr, n, sizeof(int), compare);\n    return arr[k - 1];\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateDisjointSet__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r6,r5,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r6\n        BL       malloc\n        STMIB    r4,{r0,r5}\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        CMPNE    r0,#0\n        BNE      |L1.108|\n        MOV      r0,r1\n        BL       free\n        LDR      r0,[r4,#4]\n        BL       free\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.108|\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.152|\n        MOV      r1,#0\n|L1.124|\n        LDR      r2,[r4,#0]\n        STR      r0,[r2,r0,LSL #2]\n        LDR      r2,[r4,#4]\n        STR      r1,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.124|\n|L1.152|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfind__FP11DisjointSeti PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        MOV      r4,r1\n        LDR      r1,[r0,r1,LSL #2]\n        CMP      r1,r4\n        BEQ      |L1.208|\n        MOV      r0,r5\n        BL       find__FP11DisjointSeti\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n|L1.208|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nunite__FP11DisjointSetiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r4,r0\n        BL       find__FP11DisjointSeti\n        MOV      r5,r0\n        MOV      r0,r4\n        MOV      r1,r6\n        BL       find__FP11DisjointSeti\n        CMP      r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#4]\n        LDR      r2,[r1,r5,LSL #2]\n        LDR      r1,[r1,r0,LSL #2]\n        CMP      r2,r1\n        LDRLT    r1,[r4,#0]\n        STRLT    r0,[r1,r5,LSL #2]\n        LDMLTFD  sp!,{r4-r6,lr}\n        BXLT     lr\n        LDRGT    r1,[r4,#0]\n        STRGT    r5,[r1,r0,LSL #2]\n        LDMGTFD  sp!,{r4-r6,lr}\n        BXGT     lr\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,r5,LSL #2\n        LDR      r1,[r0,#0]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct DisjointSet {\n    int *parent;\n    int *rank;\n    int size;\n};\n\nstruct DisjointSet* createDisjointSet(int n) {\n    struct DisjointSet* set = (struct DisjointSet*)malloc(sizeof(struct DisjointSet));\n    if (set == NULL) return NULL;\n    set->parent = (int*)malloc(n * sizeof(int));\n    set->rank = (int*)malloc(n * sizeof(int));\n    set->size = n;\n    if (set->parent == NULL || set->rank == NULL) {\n        free(set->parent);\n        free(set->rank);\n        free(set);\n        return NULL;\n    }\n\n    for (int i = 0; i < n; i++) {\n        set->parent[i] = i;\n        set->rank[i] = 0;\n    }\n    return set;\n}\n\nint find(struct DisjointSet* set, int i) {\n    if (set->parent[i] != i) {\n        set->parent[i] = find(set, set->parent[i]);\n    }\n    return set->parent[i];\n}\n\nvoid unite(struct DisjointSet* set, int i, int j) {\n    int root_i = find(set, i);\n    int root_j = find(set, j);\n    if (root_i != root_j) {\n        if (set->rank[root_i] < set->rank[root_j]) {\n            set->parent[root_i] = root_j;\n        } else if (set->rank[root_i] > set->rank[root_j]) {\n            set->parent[root_j] = root_i;\n        } else {\n            set->parent[root_j] = root_i;\n            set->rank[root_i]++;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntrapezoidal_rule__FPFd_ddT2i PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r10,r3\n        SUB      sp,sp,#0xc\n        LDR      r9,[sp,#0x30]\n        MOV      r3,r2\n        MOV      r7,r2\n        MOV      r2,r1\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r0,r10\n        MOV      r1,r9\n        LDR      r4,[sp,#0x34]\n        BL       _dsub\n        MOV      r8,r0\n        MOV      r0,r4\n        MOV      r11,r1\n        BL       _dflt\n        MOV      r3,r11\n        MOV      r2,r8\n        BL       _drdiv\n        MOV      r8,r0\n        STR      r1,[sp,#8]\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      lr,pc\n        BX       r5\n        MOV      r11,r0\n        STR      r1,[sp,#4]\n        MOV      r1,r9\n        MOV      r0,r10\n        MOV      lr,pc\n        BX       r5\n        MOV      r2,r11\n        LDR      r3,[sp,#4]\n        BL       _dadd\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r9,#1\n        CMP      r4,#1\n        BLE      |L1.244|\n|L1.160|\n        MOV      r0,r9\n        BL       _dflt\n        MOV      r2,r8\n        LDR      r3,[sp,#8]\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      lr,pc\n        BX       r5\n        ADR      r2,|L1.284|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        ADD      r9,r9,#1\n        CMP      r9,r4\n        MOV      r10,r0\n        MOV      r11,r1\n        BLT      |L1.160|\n|L1.244|\n        MOV      r2,r8\n        MOV      r1,r11\n        MOV      r0,r10\n        LDR      r3,[sp,#8]\n        BL       _dmul\n        ADR      r2,|L1.292|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dmul\n|L1.284|\n        DCFD     0x4000000000000000\n|L1.292|\n        DCFD     0x3fe0000000000000\n        ENDP\n\nmy_function__Fd PROC\n        MOV      r3,r1\n        MOV      r2,r0\n        B        _dmul\n        ENDP\n```",
        "output": "```cpp\n\ndouble trapezoidal_rule(double (*f)(double), double a, double b, int n) {\n    double h = (b - a) / n;\n    double sum = f(a) + f(b);\n    for (int i = 1; i < n; i++) {\n        sum += 2 * f(a + i * h);\n    }\n    return sum * h / 2.0;\n}\n\ndouble my_function(double x) {\n    return x * x;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbfs__FP4NodeiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r1,#0x190\n        SUB      sp,sp,#0x320\n        ADD      r5,sp,r1\n        MOV      r4,r0\n        MOV      r0,r5\n        BL       __rt_memclr_w\n        MOV      r6,#1\n        STR      r8,[sp,#0]\n        STR      r6,[r5,r8,LSL #2]\n        MOV      lr,#0\n        MOV      r2,#1\n        MOV      r7,sp\n|L1.56|\n        MOV      r0,lr\n        LDR      r1,[r7,r0,LSL #2]\n        MOV      r0,#0\n        ADD      r1,r1,r1,LSL #4\n        ADD      r1,r1,r1,LSL #1\n        ADD      r3,r4,r1,LSL #3\n        LDR      r1,[r3,#0x194]\n        ADD      lr,lr,#1\n        CMP      r1,#0\n        BLE      |L1.148|\n|L1.96|\n        ADD      r1,r3,r0,LSL #2\n        LDR      r1,[r1,#4]\n        LDR      r12,[r5,r1,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.132|\n        MOV      r12,r2\n        STR      r6,[r5,r1,LSL #2]\n        STR      r1,[r7,r12,LSL #2]\n        ADD      r2,r2,#1\n|L1.132|\n        LDR      r1,[r3,#0x194]\n        ADD      r0,r0,#1\n        CMP      r1,r0\n        BGT      |L1.96|\n|L1.148|\n        CMP      lr,r2\n        BLT      |L1.56|\n        ADD      sp,sp,#0x320\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_NODES 100\n\ntypedef struct {\n    int data;\n    int adj[MAX_NODES];\n    int adj_count;\n} Node;\n\nvoid bfs(Node* graph, int start_node, int num_nodes) {\n    int visited[MAX_NODES];\n    memset(visited, 0, sizeof(visited));\n    int queue[MAX_NODES];\n    int head = 0, tail = 0;\n    queue[tail++] = start_node;\n    visited[start_node] = 1;\n\n    while (head < tail) {\n        int current_node = queue[head++];\n        for (int i = 0; i < graph[current_node].adj_count; ++i) {\n            int neighbor = graph[current_node].adj[i];\n            if (!visited[neighbor]) {\n                visited[neighbor] = 1;\n                queue[tail++] = neighbor;\n            }\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\naddBook__FPcT1i PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        LDR      r4,|L1.432|\n        MOV      r7,r1\n        LDR      r1,[r4,#0]  ; bookCount\n        MOV      r6,r2\n        CMP      r1,#0x64\n        LDMGEFD  sp!,{r3-r7,lr}\n        MOVGE    r0,#0\n        BXGE     lr\n        ADD      r12,r1,r1,LSL #2\n        ADD      r1,r12,r1,LSL #3\n        LDR      r5,|L1.436|\n        ADD      r2,r5,r1,LSL #4\n        MOV      r1,r0\n        MOV      r0,r2\n        BL       strcpy\n        LDR      r0,[r4,#0]  ; bookCount\n        MOV      r1,r7\n        ADD      r12,r0,r0,LSL #2\n        ADD      r0,r12,r0,LSL #3\n        ADD      r0,r5,r0,LSL #4\n        ADD      r0,r0,#0x64\n        BL       strcpy\n        LDR      r0,[r4,#0]  ; bookCount\n        MOV      r2,#1\n        ADD      r1,r0,r0,LSL #2\n        ADD      r1,r1,r0,LSL #3\n        ADD      r1,r5,r1,LSL #4\n        STR      r6,[r1,#0xc8]!\n        STR      r2,[r1,#4]\n        ADD      r0,r0,r2\n        STR      r0,[r4,#0]  ; bookCount\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nborrowBook__Fi PROC\n        LDR      r2,|L1.432|\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r2,#0]  ; bookCount\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.244|\n        LDR      r3,|L1.436|\n|L1.168|\n        ADD      r12,r1,r1,LSL #2\n        ADD      r12,r12,r1,LSL #3\n        ADD      r12,r3,r12,LSL #4\n        LDR      lr,[r12,#0xc8]\n        CMP      lr,r0\n        LDREQ    r12,[r12,#0xcc]\n        CMPEQ    r12,#1\n        BNE      |L1.232|\n        ADD      r12,r1,r1,LSL #2\n        ADD      r1,r12,r1,LSL #3\n        ADD      r1,r3,r1,LSL #4\n        MOV      r0,#0\n        STR      r0,[r1,#0xcc]\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n|L1.232|\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLT      |L1.168|\n|L1.244|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nreturnBook__Fi PROC\n        LDR      r2,|L1.432|\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r2,#0]  ; bookCount\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.356|\n        LDR      r3,|L1.436|\n|L1.284|\n        ADD      r12,r1,r1,LSL #2\n        ADD      r12,r12,r1,LSL #3\n        ADD      r12,r3,r12,LSL #4\n        LDR      lr,[r12,#0xc8]\n        CMP      lr,r0\n        LDREQ    r12,[r12,#0xcc]\n        CMPEQ    r12,#0\n        BNE      |L1.344|\n        ADD      r12,r1,r1,LSL #2\n        ADD      r1,r12,r1,LSL #3\n        ADD      r1,r3,r1,LSL #4\n        MOV      r0,#1\n        STR      r0,[r1,#0xcc]\n        LDR      lr,[sp],#4\n        BX       lr\n|L1.344|\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLT      |L1.284|\n|L1.356|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_BOOKS 100\n#define MAX_TITLE_LEN 100\n\nstruct Book {\n    char title[MAX_TITLE_LEN];\n    char author[MAX_TITLE_LEN];\n    int id;\n    int available;\n};\n\nstruct Book library[MAX_BOOKS];\nint bookCount = 0;\n\nint addBook(char *title, char *author, int id) {\n    if (bookCount >= MAX_BOOKS) return 0;\n    strcpy(library[bookCount].title, title);\n    strcpy(library[bookCount].author, author);\n    library[bookCount].id = id;\n    library[bookCount].available = 1;\n    bookCount++;\n    return 1;\n}\n\nint borrowBook(int id) {\n    for (int i = 0; i < bookCount; i++) {\n        if (library[i].id == id && library[i].available == 1) {\n            library[i].available = 0;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint returnBook(int id) {\n    for (int i = 0; i < bookCount; i++) {\n        if (library[i].id == id && library[i].available == 0) {\n            library[i].available = 1;\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisSymmetric__FPA100_ii PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.100|\n|L1.16|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.88|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r4,r0,r12,LSL #4\n|L1.40|\n        ADD      r12,r2,r2,LSL #3\n        ADD      r12,r12,r2,LSL #4\n        ADD      r12,r0,r12,LSL #4\n        LDR      lr,[r4,r2,LSL #2]\n        LDR      r12,[r12,r3,LSL #2]\n        CMP      lr,r12\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.40|\n|L1.88|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.16|\n|L1.100|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isSymmetric(int matrix[][100], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] != matrix[j][i])\n                return 0;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngaussianElimination__FPPdPdi PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        MOV      r10,r1\n        MOV      r7,r2\n        MOV      r5,#0\n        MOV      r4,r0\n        CMP      r2,#0\n        BLE      |L1.416|\n|L1.32|\n        ADD      r8,r5,#1\n        STR      r8,[sp,#8]\n        CMP      r8,r7\n        MOV      r6,r5\n        BGE      |L1.108|\n|L1.52|\n        LDR      r0,[r4,r8,LSL #2]\n        ADD      r0,r0,r5,LSL #3\n        LDR      r1,[r0,#4]\n        LDR      r2,[r0,#0]\n        LDR      r0,[r4,r6,LSL #2]\n        BIC      r3,r1,#0x80000000\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmple\n        MOVCC    r6,r8\n        ADD      r8,r8,#1\n        CMP      r8,r7\n        BLT      |L1.52|\n|L1.108|\n        LDR      r0,[r4,r6,LSL #2]\n        ADR      r2,|L1.544|\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        LDMIA    r2,{r2,r3}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmple\n        BCC      |L1.404|\n        MOV      r0,#0\n        CMP      r7,#0\n        BLE      |L1.212|\n|L1.152|\n        LDR      r2,[r4,r6,LSL #2]\n        LDR      r1,[r4,r5,LSL #2]\n        ADD      r2,r2,r0,LSL #3\n        LDR      lr,[r2,#0]\n        ADD      r1,r1,r0,LSL #3\n        LDR      r2,[r2,#4]\n        LDMIA    r1,{r3,r12}\n        STR      r2,[r1,#4]\n        STR      lr,[r1,#0]\n        LDR      r1,[r4,r6,LSL #2]\n        ADD      r1,r1,r0,LSL #3\n        ADD      r0,r0,#1\n        CMP      r0,r7\n        STMIA    r1,{r3,r12}\n        BLT      |L1.152|\n|L1.212|\n        ADD      r2,r10,r5,LSL #3\n        STR      r2,[sp,#4]\n        ADD      r3,r10,r6,LSL #3\n        LDMIA    r3,{r12,lr}\n        LDMIA    r2,{r0,r1}\n        STMIA    r2,{r12,lr}\n        STMIA    r3,{r0,r1}\n        LDR      r8,[sp,#8]\n        CMP      r8,r7\n        BGE      |L1.404|\n|L1.252|\n        LDR      r0,[r4,r5,LSL #2]\n        ADD      r1,r0,r5,LSL #3\n        LDR      r0,[r4,r8,LSL #2]\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _ddiv\n        MOV      r11,r0\n        MOV      r6,r5\n        CMP      r5,r7\n        STR      r1,[sp,#0]\n        BGE      |L1.356|\n|L1.300|\n        LDR      r0,[r4,r8,LSL #2]\n        ADD      r9,r0,r6,LSL #3\n        LDR      r0,[r4,r5,LSL #2]\n        ADD      r0,r0,r6,LSL #3\n        LDMIA    r0,{r2,r3}\n        LDR      r1,[sp,#0]\n        MOV      r0,r11\n        BL       _dmul\n        LDMIA    r9,{r2,r3}\n        BL       _drsb\n        ADD      r6,r6,#1\n        CMP      r6,r7\n        STMIA    r9,{r0,r1}\n        BLT      |L1.300|\n|L1.356|\n        LDR      r2,[sp,#4]\n        MOV      r0,r11\n        LDMIA    r2,{r2,r3}\n        LDR      r1,[sp,#0]\n        BL       _dmul\n        ADD      r6,r10,r8,LSL #3\n        LDMIA    r6,{r2,r3}\n        BL       _drsb\n        ADD      r8,r8,#1\n        CMP      r8,r7\n        STMIA    r6,{r0,r1}\n        BLT      |L1.252|\n|L1.404|\n        LDR      r5,[sp,#8]\n        CMP      r5,r7\n        BLT      |L1.32|\n|L1.416|\n        SUBS     r6,r7,#1\n        ADDMI    sp,sp,#0xc\n        LDMMIFD  sp!,{r4-r11,lr}\n        BXMI     lr\n|L1.432|\n        ADD      r5,r6,#1\n        CMP      r5,r7\n        BGE      |L1.496|\n        ADD      r8,r10,r6,LSL #3\n|L1.448|\n        LDR      r0,[r4,r6,LSL #2]\n        ADD      r1,r10,r5,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDMIA    r8,{r2,r3}\n        BL       _drsb\n        ADD      r5,r5,#1\n        CMP      r5,r7\n        STMIA    r8,{r0,r1}\n        BLT      |L1.448|\n|L1.496|\n        LDR      r0,[r4,r6,LSL #2]\n        ADD      r5,r10,r6,LSL #3\n        ADD      r0,r0,r6,LSL #3\n        LDMIA    r0,{r2,r3}\n        LDMIA    r5,{r0,r1}\n        BL       _ddiv\n        SUBS     r6,r6,#1\n        STMIA    r5,{r0,r1}\n        BPL      |L1.432|\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.544|\n        DCFD     0x3ddb7cdfd9d7bdbb\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid gaussianElimination(double **A, double *b, int n) {\n    for (int i = 0; i < n; i++) {\n        int maxRow = i;\n        for (int k = i + 1; k < n; k++) {\n            if (fabs(A[k][i]) > fabs(A[maxRow][i])) {\n                maxRow = k;\n            }\n        }\n        if(fabs(A[maxRow][i]) < 1e-10){\n            continue;\n        }\n        for (int k = 0; k < n; k++) {\n            double temp = A[i][k];\n            A[i][k] = A[maxRow][k];\n            A[maxRow][k] = temp;\n        }\n        double temp = b[i];\n        b[i] = b[maxRow];\n        b[maxRow] = temp;\n        for (int k = i + 1; k < n; k++) {\n            double factor = A[k][i] / A[i][i];\n            for (int j = i; j < n; j++) {\n                A[k][j] -= factor * A[i][j];\n            }\n            b[k] -= factor * b[i];\n        }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j < n; j++) {\n            b[i] -= A[i][j] * b[j];\n        }\n        b[i] /= A[i][i];\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisAlphabet__Fc PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       __rt_ctype_table\n        LDR      r0,[r0,#0]\n        LDRB     r0,[r0,r4]\n        LDMFD    sp!,{r4,lr}\n        AND      r0,r0,#0x18\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isAlphabet(char c) {\n    return isalpha(c);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nquicksort__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r2\n        MOV      r4,r0\n        CMP      r1,r2\n        LDMGEFD  sp!,{r4-r6,lr}\n        BXGE     lr\n        SUB      r6,r5,#1\n        CMP      r1,r6\n        LDR      lr,[r4,r5,LSL #2]\n        SUB      r2,r1,#1\n        MOV      r0,r1\n        BGT      |L1.88|\n|L1.48|\n        LDR      r12,[r4,r0,LSL #2]\n        CMP      r12,lr\n        BGE      |L1.76|\n        ADD      r2,r2,#1\n        LDR      r3,[r4,r2,LSL #2]\n        STR      r12,[r4,r2,LSL #2]\n        STR      r3,[r4,r0,LSL #2]\n|L1.76|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.48|\n|L1.88|\n        ADD      r3,r4,r2,LSL #2\n        LDR      r12,[r4,r5,LSL #2]\n        LDR      r0,[r3,#4]\n        STR      r12,[r3,#4]\n        STR      r0,[r4,r5,LSL #2]\n        ADD      r6,r2,#1\n        SUB      r2,r6,#1\n        MOV      r0,r4\n        BL       quicksort__FPiiT2\n        MOV      r2,r5\n        ADD      r1,r6,#1\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        B        quicksort__FPiiT2\n        ENDP\n```",
        "output": "```cpp\n\nvoid quicksort(int *arr, int left, int right) {\n    if (left < right) {\n        int pivot = arr[right];\n        int i = left - 1;\n        for (int j = left; j <= right - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[right];\n        arr[right] = temp;\n        int partition = i + 1;\n        quicksort(arr, left, partition - 1);\n        quicksort(arr, partition + 1, right);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        CMP      r5,r0\n        ADDLE    r0,r0,#1\n        ADDGT    r0,r5,#1\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nint height(Node* node) {\n    if (node == NULL)\n        return 0;\n    else {\n        int lheight = height(node->left);\n        int rheight = height(node->right);\n\n        return (lheight > rheight) ? (lheight + 1) : (rheight + 1);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nasync_operation_callback__FPvi PROC\n        STR      r1,[r0,#0]\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nperform_async_operation__FP14AsyncOperation PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r2,r0\n        LDR      r0,[r0,#8]\n        ADR      lr,|L1.44|\n        MOV      r1,r0,LSL #1\n        LDR      r0,[r2,#4]\n        LDR      r2,[r2,#0]\n        BX       r2\n|L1.44|\n        LDMFD    sp!,{r3,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n//Structure to represent an asynchronous operation\ntypedef struct {\n    int (*callback)(void* ,int); //Callback function pointer\n    void* callback_data; //Data to be passed to the callback\n    int data; //Data for the operation\n} AsyncOperation;\n\n\nint async_operation_callback(void* data, int result){\n    //Perform post-operation actions\n    int* result_ptr = (int*)data;\n    *result_ptr = result;\n    return 0;\n}\n\n\nint perform_async_operation(AsyncOperation* op){\n    //Simulate asynchronous operation\n    int result = op->data * 2;  //Example operation\n    op->callback(op->callback_data, result);\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        CMP      r0,#0\n        MOVNE    r1,#0\n        STRNE    r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#0]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#0]\n        LDR      r2,[r0,#4]\n        LDR      r4,[r0,#0]\n        STR      r2,[r1,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npeek__FP5Stack PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDREQ    r0,[r1,#0]\n        LDREQ    r0,[r0,#0]\n        LDR      lr,[sp],#4\n        MVNNE    r0,#0\n        BX       lr\n        ENDP\n\ndeleteStack__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        BNE      |L1.248|\n|L1.224|\n        MOV      r0,r4\n        BL       pop__FP5Stack\n        MOV      r0,r4\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.224|\n|L1.248|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\ntypedef struct Stack {\n    Node* top;\n} Stack;\n\nStack* createStack() {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    if (stack == NULL) return NULL;\n    stack->top = NULL;\n    return stack;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == NULL;\n}\n\nvoid push(Stack* stack, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) return;\n    newNode->data = data;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nint pop(Stack* stack) {\n    if (isEmpty(stack)) return -1; \n    Node* temp = stack->top;\n    int data = temp->data;\n    stack->top = stack->top->next;\n    free(temp);\n    return data;\n}\n\nint peek(Stack* stack){\n    if (isEmpty(stack)) return -1;\n    return stack->top->data;\n}\n\nvoid deleteStack(Stack* stack){\n    while(!isEmpty(stack)){\n        pop(stack);\n    }\n    free(stack);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npostorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       postorder__FP4Node\n        LDR      r0,[r4,#8]\n        BL       postorder__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.48|\n        B        _printf\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(0), right(0) {}\n};\n\nvoid postorder(Node *root) {\n    if (root == 0) return;\n    postorder(root->left);\n    postorder(root->right);\n    printf(\"%d \", root->data);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nquicksort__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r2\n        MOV      r4,r0\n        CMP      r1,r2\n        LDMGEFD  sp!,{r4-r6,lr}\n        BXGE     lr\n        SUB      r6,r5,#1\n        CMP      r1,r6\n        LDR      lr,[r4,r5,LSL #2]\n        SUB      r2,r1,#1\n        MOV      r0,r1\n        BGT      |L1.88|\n|L1.48|\n        LDR      r12,[r4,r0,LSL #2]\n        CMP      r12,lr\n        BGE      |L1.76|\n        ADD      r2,r2,#1\n        LDR      r3,[r4,r2,LSL #2]\n        STR      r12,[r4,r2,LSL #2]\n        STR      r3,[r4,r0,LSL #2]\n|L1.76|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.48|\n|L1.88|\n        ADD      r3,r4,r2,LSL #2\n        LDR      r12,[r4,r5,LSL #2]\n        LDR      r0,[r3,#4]\n        STR      r12,[r3,#4]\n        STR      r0,[r4,r5,LSL #2]\n        ADD      r6,r2,#1\n        SUB      r2,r6,#1\n        MOV      r0,r4\n        BL       quicksort__FPiiT2\n        MOV      r2,r5\n        ADD      r1,r6,#1\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        B        quicksort__FPiiT2\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid quicksort(int* arr, int low, int high) {\n    if (low < high) {\n        int pivot = arr[high];\n        int i = low -1;\n        for (int j = low; j <= high - 1; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        int pi = i + 1;\n        quicksort(arr, low, pi - 1);\n        quicksort(arr, pi + 1, high);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateAccount__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        CMP      r0,#0\n        MOVNE    r1,#0\n        STRNE    r1,[r0,#4]\n        STRNE    r4,[r0,#0]\n        LDMFD    sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\ndeposit__FP7Accountf PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        CMP      r0,#0\n        MOV      r4,r0\n        MOVNE    r0,r5\n        MOVNE    r1,#0\n        BLNE     _fcmple\n        LDMLSFD  sp!,{r3-r5,lr}\n        MOVLS    r0,#0\n        BXLS     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       _fadd\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nwithdraw__FP7Accountf PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        CMP      r0,#0\n        MOV      r4,r0\n        MOVNE    r0,r5\n        MOVNE    r1,#0\n        BLNE     _fcmple\n        BLS      |L1.160|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       _fcmple\n        BCS      |L1.172|\n|L1.160|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.172|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       _fsub\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Account {\n    int accountNumber;\n    float balance;\n};\n\nAccount* createAccount(int accountNumber) {\n    Account* acc = (Account*)malloc(sizeof(Account));\n    if (acc == NULL) return NULL;\n    acc->accountNumber = accountNumber;\n    acc->balance = 0.0;\n    return acc;\n}\n\nint deposit(Account* acc, float amount) {\n    if (acc == NULL || amount <= 0) return 0;\n    acc->balance += amount;\n    return 1;\n}\n\nint withdraw(Account* acc, float amount) {\n    if (acc == NULL || amount <= 0 || acc->balance < amount) return 0;\n    acc->balance -= amount;\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nshell_sort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        ADD      r2,r1,r1,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n|L1.24|\n        MOV      r12,r3\n        CMP      r3,r1\n        BGE      |L1.92|\n|L1.36|\n        LDR      lr,[r0,r12,LSL #2]\n        MOV      r2,r12\n        B        |L1.56|\n|L1.48|\n        STR      r5,[r0,r2,LSL #2]\n        MOV      r2,r4\n|L1.56|\n        CMP      r2,r3\n        SUBGE    r4,r2,r3\n        LDRGE    r5,[r0,r4,LSL #2]\n        CMPGE    r5,lr\n        BGT      |L1.48|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        STR      lr,[r0,r2,LSL #2]\n        BLT      |L1.36|\n|L1.92|\n        ADD      r2,r3,r3,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        BGT      |L1.24|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid shell_sort(int arr[], int n) {\n    int gap, i, j, temp;\n    for (gap = n / 2; gap > 0; gap /= 2) {\n        for (i = gap; i < n; i++) {\n            temp = arr[i];\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            arr[j] = temp;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringLength__FPCc PROC\n|L1.0|\n        B        strlen\n        ENDP\n```",
        "output": "```cpp\n\nint stringLength(const char* str) {\n    return strlen(str);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__FP5Graphi PROC\n        MOV      r3,#0\n        STR      r1,[r0,#0]\n        CMP      r1,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        MOV      lr,#0\n|L1.24|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.68|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r12,r0,r12,LSL #4\n|L1.48|\n        ADD      r4,r12,r2,LSL #2\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        STR      lr,[r4,#4]\n        BLT      |L1.48|\n|L1.68|\n        ADD      r2,r0,r3,LSL #2\n        ADD      r2,r2,#0x9000\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        STR      lr,[r2,#0xc44]\n        BLT      |L1.24|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        CMP      r1,#0\n        LDRGE    r3,[r0,#0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        ADD      r0,r0,r1,LSL #4\n        ADD      r0,r0,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r0,#4]\n        BX       lr\n        ENDP\n\ndepthFirstSearch__FP5Graphi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        LDRGE    r0,[r5,#0]\n        CMPGE    r0,r1\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        ADD      r0,r5,r1,LSL #2\n        ADD      r0,r0,#0x9000\n        LDR      r2,[r0,#0xc44]\n        CMP      r2,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        BXNE     lr\n        MOV      r2,#1\n        STR      r2,[r0,#0xc44]\n        LDR      r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        ADD      r0,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        ADD      r6,r5,r0,LSL #4\n|L1.248|\n        ADD      r0,r6,r4,LSL #2\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        MOVNE    r1,r4\n        MOVNE    r0,r5\n        BLNE     depthFirstSearch__FP5Graphi\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.248|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int matrix[MAX_VERTICES][MAX_VERTICES];\n    int visited[MAX_VERTICES];\n} Graph;\n\n\nvoid createGraph(Graph *graph, int vertices) {\n    graph->vertices = vertices;\n    for (int i = 0; i < vertices; i++) {\n        for (int j = 0; j < vertices; j++) {\n            graph->matrix[i][j] = 0;\n        }\n        graph->visited[i] = 0;\n    }\n}\n\nvoid addEdge(Graph *graph, int source, int destination) {\n    if (source >= 0 && source < graph->vertices && destination >=0 && destination < graph->vertices)\n        graph->matrix[source][destination] = 1;\n\n}\n\n\nvoid depthFirstSearch(Graph *graph, int vertex) {\n    if (vertex < 0 || vertex >= graph->vertices || graph->visited[vertex]) return;\n\n    graph->visited[vertex] = 1;\n    for (int i = 0; i < graph->vertices; i++) {\n        if (graph->matrix[vertex][i]) {\n            depthFirstSearch(graph, i);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_leap__Fi PROC\n        TST      r0,#3\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,|L1.120|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        MOVNE    r0,#1\n        BXNE     lr\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint is_leap(int year){\n    if (year % 4 != 0) return 0;\n    if (year % 100 == 0) {\n        if (year % 400 == 0) return 1;\n        return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nroll_dice__FiT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        CMP      r0,#0\n        CMPGT    r7,#0\n        MOV      r6,r0\n        LDMLEFD  sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BXLE     lr\n        BL       time\n        BL       srand\n        MOV      r5,#0\n        MOV      r4,#0\n|L1.48|\n        BL       rand\n        MOV      r1,r0\n        MOV      r0,r7\n        BL       __rt_sdiv\n        ADD      r0,r1,r5\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        ADD      r5,r0,#1\n        BLT      |L1.48|\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint roll_dice(int num_dice, int num_sides) {\n    if (num_dice <= 0 || num_sides <= 0) return 0;\n    srand(time(0));\n    int total = 0;\n    for (int i = 0; i < num_dice; i++) {\n        total += (rand() % num_sides) + 1;\n    }\n    return total;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n        MOV      r2,r0\n        MOVS     r0,r1\n        STMFD    sp!,{r4,lr}\n        BEQ      |L1.40|\n|L1.16|\n        MOV      r4,r0\n        MOV      r1,r2\n        BL       __rt_sdiv\n        MOVS     r0,r1\n        MOV      r2,r4\n        BNE      |L1.16|\n|L1.40|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndecimalToBinary__FUi PROC\n        MOV      r2,#0\n        MOV      r1,#1\n        CMP      r0,#0\n        BEQ      |L1.40|\n|L1.16|\n        AND      r3,r0,#1\n        MLA      r2,r1,r3,r2\n        ADD      r1,r1,r1,LSL #2\n        MOV      r1,r1,LSL #1\n        MOVS     r0,r0,LSR #1\n        BNE      |L1.16|\n|L1.40|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int decimalToBinary(unsigned int decimal) {\n    unsigned int binary = 0;\n    unsigned int power = 1;\n    while (decimal > 0) {\n        binary += (decimal % 2) * power;\n        power *= 10;\n        decimal /= 2;\n    }\n    return binary;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfcn_segmentation__F5image PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x9d00\n        MOV      r5,#0x1c40\n        ADD      r5,r5,#0x8000\n        ADD      r4,sp,#0xc0\n        MOV      r6,r0\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       __rt_memclr_w\n        ADD      r1,sp,#0x9c00\n        ADD      r1,r1,#0x114\n        MOV      r0,#0\n|L1.52|\n        LDR      r2,[r1,r0,LSL #2]\n        CMP      r2,#0x7f\n        MOVLE    r2,#0\n        MOVGT    r2,#0xff\n        STR      r2,[r4,r0,LSL #2]\n        ADD      r0,r0,#1\n        SUBS     r12,r0,#0x2000\n        SUBGES   r12,r12,#0x710\n        BLT      |L1.52|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       __rt_memcpy_w\n        ADD      sp,sp,#0x9d00\n        LDMFD    sp!,{r4-r6}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n// Replace with actual FCN implementation.  This is a placeholder.\ntypedef struct {\n    int data[100*100]; //Example. Replace with actual image data structure.\n} image;\n\nimage fcn_segmentation(image input){\n    image output;\n    memset(output.data, 0, sizeof(output.data)); // Placeholder: set output to zero.\n    for(int i = 0; i < 100 * 100; i++){\n        output.data[i] = input.data[i] > 127 ? 255 : 0; //Simple thresholding\n    }\n    return output;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfractionalKnapsack__FP4ItemiT2 PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        MOVS     r0,r1\n        MOV      r4,r2\n        CMPNE    r4,#0\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        SUB      r1,r0,#1\n        ADD      r0,r5,#8\n        MOV      r8,r0\n        MOV      r7,r1\n        MOV      r2,r4\n        BL       fractionalKnapsack__FP4ItemiT2\n        LDR      r9,[r5,#4]\n        MOV      r6,r0\n        LDR      r0,[r5,#0]\n        CMP      r9,r4\n        BGT      |L1.116|\n        BL       _fflt\n        MOV      r5,r0\n        MOV      r0,r8\n        SUB      r2,r4,r9\n        MOV      r1,r7\n        BL       fractionalKnapsack__FP4ItemiT2\n        MOV      r1,r5\n        BL       _fadd\n        MOV      r4,r0\n        B        |L1.192|\n|L1.116|\n        BL       _fflt\n        MOV      r5,r0\n        MOV      r0,r4\n        BL       _fflt\n        MOV      r4,r0\n        MOV      r0,r9\n        BL       _fflt\n        MOV      r1,r4\n        BL       _frdiv\n        MOV      r1,r5\n        BL       _fmul\n        MOV      r4,r0\n        MOV      r0,r8\n        MOV      r2,#0\n        MOV      r1,r7\n        BL       fractionalKnapsack__FP4ItemiT2\n        MOV      r1,r4\n        BL       _fadd\n        MOV      r4,r0\n|L1.192|\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       _fcmpge\n        MOVLS    r0,r6\n        MOVHI    r0,r4\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Item {\n    int value;\n    int weight;\n};\n\nfloat fractionalKnapsack(struct Item items[], int n, int capacity) {\n    if (n == 0 || capacity == 0) {\n        return 0;\n    }\n\n    float value_per_weight = (float)items[0].value / items[0].weight;\n    float value_without_first = fractionalKnapsack(items + 1, n - 1, capacity);\n\n    float value_with_first = 0;\n    if (items[0].weight <= capacity) {\n        value_with_first = items[0].value + fractionalKnapsack(items + 1, n - 1, capacity - items[0].weight);\n    } else {\n        value_with_first = (float)items[0].value * ((float)capacity / items[0].weight) + fractionalKnapsack(items+1, n-1, 0);\n    }\n\n\n    return value_with_first > value_without_first ? value_with_first : value_without_first;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitializeDeck__FP4Deck PROC\n|L1.0|\n        MOV      r2,#0\n        MOV      r3,#0\n|L1.8|\n        MOV      r1,#0\n|L1.12|\n        STR      r3,[r0,r2,LSL #3]\n        ADD      r12,r0,r2,LSL #3\n        STR      r1,[r12,#4]\n        ADD      r1,r1,#1\n        CMP      r1,#0xd\n        ADD      r2,r2,#1\n        BLT      |L1.12|\n        ADD      r3,r3,#1\n        CMP      r3,#4\n        BLT      |L1.8|\n        MOV      r1,#0\n        STR      r1,[r0,#0x1a0]\n        BX       lr\n        ENDP\n\nshuffleDeck__FP4Deck PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        MOV      r4,#0x33\n|L1.88|\n        BL       rand\n        MOV      r1,r0\n        ADD      r0,r4,#1\n        BL       __rt_sdiv\n        ADD      r0,r5,r4,LSL #3\n        ADD      r1,r5,r1,LSL #3\n        LDMIA    r1,{r12,lr}\n        LDMIA    r0,{r2,r3}\n        STMIA    r0,{r12,lr}\n        SUB      r4,r4,#1\n        CMP      r4,#0\n        STMIA    r1,{r2,r3}\n        BGT      |L1.88|\n        MOV      r0,#0\n        STR      r0,[r5,#0x1a0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ndealCard__FP4Deck PROC\n        LDR      r2,[r1,#0x1a0]\n        CMP      r2,#0x34\n        BLT      |L1.184|\n        LDR      r2,|L1.284|\n        LDMIA    r2,{r1,r2}  ; <Anon4_line_46>, <Anon4_line_46>\n        STMIA    r0,{r1,r2}\n        BX       lr\n|L1.184|\n        ADD      r3,r2,#1\n        STR      r3,[r1,#0x1a0]\n        ADD      r1,r1,r2,LSL #3\n        LDR      r2,[r1,#0]\n        LDR      r1,[r1,#4]\n        STR      r1,[r0,#4]\n        STR      r2,[r0,#0]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define SUITS 4\n#define RANKS 13\n\ntypedef struct {\n    int suit;\n    int rank;\n} Card;\n\ntypedef struct {\n    Card cards[SUITS * RANKS];\n    int top;\n} Deck;\n\nvoid initializeDeck(Deck *deck) {\n    int i = 0;\n    for (int suit = 0; suit < SUITS; suit++) {\n        for (int rank = 0; rank < RANKS; rank++) {\n            deck->cards[i].suit = suit;\n            deck->cards[i].rank = rank;\n            i++;\n        }\n    }\n    deck->top = 0;\n}\n\n\nvoid shuffleDeck(Deck *deck) {\n    srand(time(NULL));\n    for (int i = SUITS * RANKS - 1; i > 0; i--) {\n        int j = rand() % (i + 1);\n        Card temp = deck->cards[i];\n        deck->cards[i] = deck->cards[j];\n        deck->cards[j] = temp;\n    }\n    deck->top = 0;\n}\n\nCard dealCard(Deck *deck) {\n    if (deck->top >= SUITS * RANKS) {\n        // Handle empty deck case (replace with appropriate error handling)\n        Card emptyCard = {-1, -1};\n        return emptyCard;\n    }\n    return deck->cards[deck->top++];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMarkovChain__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        STR      r6,[r4,#0]\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        STR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r5,#0\n        CMP      r6,#0\n        BLE      |L1.188|\n        MOV      r7,r6,LSL #3\n|L1.88|\n        MOV      r0,r7\n        BL       malloc\n        LDR      r1,[r4,#4]\n        CMP      r0,#0\n        STR      r0,[r1,r5,LSL #2]\n        BNE      |L1.176|\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.148|\n|L1.124|\n        LDR      r0,[r4,#4]\n        LDR      r0,[r0,r6,LSL #2]\n        BL       free\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        BLT      |L1.124|\n|L1.148|\n        LDR      r0,[r4,#4]\n        BL       free\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.176|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.88|\n|L1.188|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nfreeMarkovChain__FP11MarkovChain PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.260|\n|L1.232|\n        LDR      r0,[r5,#4]\n        LDR      r0,[r0,r4,LSL #2]\n        BL       free\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.232|\n|L1.260|\n        LDR      r0,[r5,#4]\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n\nsimulateMarkovChain__FP11MarkovChainiT2 PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        MOVS     r6,r0\n        BEQ      |L1.320|\n        CMP      r1,#0\n        LDRGE    r0,[r6,#0]\n        CMPGE    r0,r1\n        BLE      |L1.320|\n        LDR      r0,[sp,#8]\n        CMP      r0,#0\n        BGE      |L1.336|\n|L1.320|\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        MVN      r0,#0\n        BX       lr\n|L1.336|\n        MOV      r8,r1\n        MOV      r9,#0\n        BLE      |L1.496|\n|L1.348|\n        BL       rand\n        BL       _dflt\n        ADR      r2,|L1.512|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        MOV      r10,r0\n        ADR      r0,|L1.520|\n        LDMIA    r0,{r5,r7}\n        LDR      r0,[r6,#0]\n        MOV      r11,r1\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.480|\n|L1.400|\n        LDR      r0,[r6,#4]\n        MOV      r1,r7\n        LDR      r0,[r0,r8,LSL #2]\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r5\n        BL       _dadd\n        MOV      r5,r0\n        MOV      r7,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        MOV      r0,r10\n        MOV      r1,r11\n        BL       _dcmple\n        MOVLS    r8,r4\n        BLS      |L1.480|\n        LDR      r0,[r6,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.400|\n|L1.480|\n        LDR      r0,[sp,#8]\n        ADD      r9,r9,#1\n        CMP      r9,r0\n        BLT      |L1.348|\n|L1.496|\n        MOV      r0,r8\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.512|\n        DCFD     0x41dfffffffc00000\n|L1.520|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct MarkovChain {\n    int numStates;\n    double** transitionMatrix;\n};\n\nstruct MarkovChain* createMarkovChain(int numStates) {\n    struct MarkovChain* chain = (struct MarkovChain*)malloc(sizeof(struct MarkovChain));\n    if (chain == NULL) return NULL;\n    chain->numStates = numStates;\n    chain->transitionMatrix = (double**)malloc(numStates * sizeof(double*));\n    if (chain->transitionMatrix == NULL) {\n        free(chain);\n        return NULL;\n    }\n    for (int i = 0; i < numStates; i++) {\n        chain->transitionMatrix[i] = (double*)malloc(numStates * sizeof(double));\n        if (chain->transitionMatrix[i] == NULL) {\n            for (int j = 0; j < i; j++) free(chain->transitionMatrix[j]);\n            free(chain->transitionMatrix);\n            free(chain);\n            return NULL;\n        }\n    }\n    return chain;\n}\n\n\nvoid freeMarkovChain(struct MarkovChain* chain) {\n    if (chain == NULL) return;\n    for (int i = 0; i < chain->numStates; i++) {\n        free(chain->transitionMatrix[i]);\n    }\n    free(chain->transitionMatrix);\n    free(chain);\n}\n\n\nint simulateMarkovChain(struct MarkovChain* chain, int initialState, int steps) {\n    if (chain == NULL || initialState < 0 || initialState >= chain->numStates || steps < 0) return -1;\n    int currentState = initialState;\n    for (int i = 0; i < steps; i++) {\n        double randomNumber = (double)rand() / RAND_MAX;\n        double cumulativeProbability = 0.0;\n        for (int j = 0; j < chain->numStates; j++) {\n            cumulativeProbability += chain->transitionMatrix[currentState][j];\n            if (randomNumber <= cumulativeProbability) {\n                currentState = j;\n                break;\n            }\n        }\n    }\n    return currentState;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nclassifyVideo__FPC10VideoFramei8CNNModel PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r7,lr}\n        MOV      lr,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.112|\n        LDR      r5,|L1.296|\n        ADD      r4,sp,#0x1c\n|L1.32|\n        ADD      r12,lr,lr,LSL #1\n        RSB      r12,r12,lr,LSL #7\n        ADD      r6,r0,r12,LSL #5\n        MOV      r2,#0\n|L1.48|\n        SMULL    r7,r12,r5,r2\n        MOV      r12,r12,ASR #5\n        SUB      r12,r12,r12,ASR #31\n        SUB      r12,r12,r12,LSL #1\n        ADD      r12,r12,r12,LSL #2\n        ADD      r12,r12,r12,LSL #2\n        ADD      r12,r2,r12,LSL #2\n        LDR      r12,[r4,r12,LSL #2]\n        LDR      r7,[r6,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r2,#0x3e8\n        MLA      r3,r12,r7,r3\n        BLT      |L1.48|\n        ADD      lr,lr,#1\n        CMP      lr,r1\n        BLT      |L1.32|\n|L1.112|\n        LDR      r0,|L1.300|\n        LDMFD    sp!,{r4-r7}\n        SMULL    r2,r1,r0,r3\n        MOV      r0,r1,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        LDR      lr,[sp],#0x14\n        ADD      r0,r3,r0,LSL #1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\n// Dummy 3D CNN implementation.  Replace with actual implementation using a suitable library.\nstruct VideoFrame {\n    int data[1000];\n};\n\nstruct CNNModel {\n    int weights[100];\n};\n\nint classifyVideo(const VideoFrame* video, int numFrames, CNNModel model) {\n    // Simulate classification. Replace with actual 3D CNN inference.\n    int sum = 0;\n    for (int i = 0; i < numFrames; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n            sum += video[i].data[j] * model.weights[j % 100];\n        }\n    }\n    return sum % 10; // Simulate a class label\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        SUB      r6,r1,#1\n        CMP      r6,#0\n        MOV      lr,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.24|\n        SUB      r3,r1,lr\n        SUB      r5,r3,#1\n        CMP      r5,#0\n        MOV      r2,#0\n        BLE      |L1.80|\n|L1.44|\n        LDR      r3,[r0,r2,LSL #2]\n        ADD      r4,r0,r2,LSL #2\n        LDR      r12,[r4,#4]\n        CMP      r3,r12\n        STRGT    r12,[r0,r2,LSL #2]\n        STRGT    r3,[r4,#4]\n        ADD      r2,r2,#1\n        CMP      r5,r2\n        BGT      |L1.44|\n|L1.80|\n        ADD      lr,lr,#1\n        CMP      lr,r6\n        BLT      |L1.24|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ncalculateMeanMedianMode__FPii PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r9,r0\n        MOV      r5,r1\n        MOV      r1,#0\n        MOV      r0,#0\n        MOV      r4,r2\n        CMP      r2,#0\n        BLE      |L1.152|\n|L1.132|\n        LDR      r2,[r5,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        ADD      r0,r2,r0\n        BLT      |L1.132|\n|L1.152|\n        BL       _fflt\n        MOV      r6,r0\n        MOV      r0,r4\n        BL       _fflt\n        MOV      r1,r6\n        BL       _frdiv\n        MOV      r8,r0\n        MOV      r7,r4,LSL #2\n        MOV      r0,r7\n        BL       malloc\n        MOV      r6,r0\n        MOV      r2,r7\n        MOV      r1,r5\n        BL       __rt_memcpy_w\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       sort__FPii\n        ADD      r0,r4,r4,LSR #31\n        MOV      r0,r0,ASR #1\n        TST      r4,#1\n        BNE      |L1.272|\n        ADD      r1,r6,r0,LSL #2\n        LDR      r1,[r1,#-4]\n        LDR      r0,[r6,r0,LSL #2]\n        ADD      r0,r1,r0\n        BL       _fflt\n        MOV      r1,#0x3f000000\n        BL       _fmul\n        MOV      r7,r0\n        B        |L1.284|\n|L1.272|\n        LDR      r0,[r6,r0,LSL #2]\n        BL       _fflt\n        MOV      r7,r0\n|L1.284|\n        MOV      r0,r6\n        BL       free\n        MOV      r2,#0\n        MOV      r0,#1\n        MOV      r1,#1\n        CMP      r4,#1\n        LDR      r12,[r5,#0]\n        BLE      |L1.376|\n|L1.316|\n        LDR      lr,[r5,r1,LSL #2]\n        ADD      r3,r5,r1,LSL #2\n        LDR      r3,[r3,#-4]\n        CMP      lr,r3\n        ADDEQ    r0,r0,#1\n        BEQ      |L1.356|\n        CMP      r0,r2\n        MOVGT    r2,r0\n        MOV      r0,#1\n        MOVGT    r12,r3\n|L1.356|\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLT      |L1.316|\n        CMP      r0,r2\n        BLE      |L1.384|\n|L1.376|\n        ADD      r0,r5,r4,LSL #2\n        LDR      r12,[r0,#-4]\n|L1.384|\n        STR      r8,[r9],#4\n        STMIA    r9,{r7,r12}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid sort(int *arr, int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\n\nstruct Results {\n    float mean;\n    float median;\n    int mode;\n};\n\n\nstruct Results calculateMeanMedianMode(int *arr, int n) {\n    struct Results results;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    results.mean = (float)sum / n;\n\n    int *sortedArr = (int *)malloc(n * sizeof(int));\n    memcpy(sortedArr, arr, n * sizeof(int));\n    sort(sortedArr, n);\n    if (n % 2 == 0) {\n        results.median = (float)(sortedArr[n / 2 - 1] + sortedArr[n / 2]) / 2;\n    } else {\n        results.median = (float)sortedArr[n / 2];\n    }\n    free(sortedArr);\n\n    int maxCount = 0;\n    results.mode = arr[0];\n    int count = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] == arr[i - 1]) {\n            count++;\n        } else {\n            if (count > maxCount) {\n                maxCount = count;\n                results.mode = arr[i - 1];\n            }\n            count = 1;\n        }\n    }\n    if (count > maxCount) {\n        results.mode = arr[n-1];\n    }\n\n    return results;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        CMP      r0,#0\n        MOVLT    r0,#0\n        MOV      r2,#1\n        BXLT     lr\n        MOV      r1,#1\n        CMP      r0,#1\n        BLT      |L1.44|\n|L1.28|\n        MUL      r2,r1,r2\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLE      |L1.28|\n|L1.44|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\nint factorial(int n) {\n    int result = 1;\n    if (n < 0) return 0;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlongest_increasing_subsequence__FPii PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOVS     r7,r1\n        MOV      r5,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r6,r7,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,#1\n        MOV      r0,r4\n        BL       __rt_memset\n        MOV      r6,#1\n        MOV      r0,#1\n        CMP      r7,#1\n        BLE      |L1.164|\n|L1.80|\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.140|\n|L1.92|\n        LDR      r2,[r5,r0,LSL #2]\n        LDR      r3,[r5,r1,LSL #2]\n        CMP      r2,r3\n        BLE      |L1.128|\n        LDR      r3,[r4,r0,LSL #2]\n        LDR      r2,[r4,r1,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        STRLT    r2,[r4,r0,LSL #2]\n|L1.128|\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.92|\n|L1.140|\n        LDR      r1,[r4,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r1,r6\n        MOVGT    r6,r1\n        CMP      r0,r7\n        BLT      |L1.80|\n|L1.164|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint longest_increasing_subsequence(int arr[], int n) {\n    if (n == 0) return 0;\n    int *dp = (int *)malloc(n * sizeof(int));\n    if (dp == NULL) return 0;\n    memset(dp, 1, n * sizeof(int));\n    int max_length = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1;\n            }\n        }\n        if (dp[i] > max_length) {\n            max_length = dp[i];\n        }\n    }\n    free(dp);\n    return max_length;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__FdT1 PROC\n        B        _dadd\n        ENDP\n\nsubtract__FdT1 PROC\n        B        _dsub\n        ENDP\n\nmultiply__FdT1 PROC\n        B        _dmul\n        ENDP\n\ndivide__FdT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r3\n        MOV      r4,r2\n        ADR      r6,|L1.88|\n        MOV      r8,r1\n        MOV      r7,r0\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMIA    r6,{r2,r3}\n        BL       _dcmpeq\n        LDMEQIA  r6,{r0,r1}\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r8\n        MOV      r0,r7\n        LDMFD    sp!,{r4-r8,lr}\n        B        _ddiv\n|L1.88|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble add(double a, double b) { return a + b; }\ndouble subtract(double a, double b) { return a - b; }\ndouble multiply(double a, double b) { return a * b; }\ndouble divide(double a, double b) { \n    if (b == 0) return 0; //Handle division by zero. Could throw an exception in a more robust implementation.\n    return a / b; }\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npostorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x324\n        MOV      r1,r0\n        STR      r1,[sp,#0x194]\n        MOV      r0,#0\n        ADD      r3,sp,#0x194\n        ADD      r5,sp,#4\n        MVN      r4,#0\n|L1.80|\n        MOV      r1,r0\n        LDR      r1,[r3,r1,LSL #2]\n        ADD      r4,r4,#1\n        STR      r1,[r5,r4,LSL #2]\n        LDR      r2,[r1,#4]\n        SUB      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r0,r0,#1\n        STRNE    r2,[r3,r0,LSL #2]\n        LDR      r1,[r1,#8]\n        CMP      r1,#0\n        ADDNE    r0,r0,#1\n        STRNE    r1,[r3,r0,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.80|\n        CMN      r4,#1\n        ADDEQ    sp,sp,#0x324\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n|L1.156|\n        MOV      r0,r4\n        LDR      r0,[r5,r0,LSL #2]\n        SUB      r4,r4,#1\n        LDR      r1,[r0,#0]\n        ADR      r0,|L1.200|\n        BL       _printf\n        CMN      r4,#1\n        BNE      |L1.156|\n        ADD      sp,sp,#0x324\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.200|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid postorderIterative(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* stack1[100];\n    struct Node* stack2[100];\n    int top1 = -1;\n    int top2 = -1;\n\n    stack1[++top1] = root;\n\n    while (top1 != -1) {\n        struct Node* node = stack1[top1--];\n        stack2[++top2] = node;\n\n        if (node->left)\n            stack1[++top1] = node->left;\n        if (node->right)\n            stack1[++top1] = node->right;\n    }\n\n    while (top2 != -1) {\n        printf(\"%d \", stack2[top2--]->data);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintBottomView__FP4Node PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r11,lr}\n        BXEQ     lr\n        MOV      r6,#0\n        MOV      r0,#4\n        BL       malloc\n        MOV      r5,r0\n        STR      r6,[r0,#0]\n        MOV      r0,#4\n        BL       malloc\n        MOV      r6,r0\n        LDR      r0,[r4,#0]\n        STR      r0,[r6,#0]\n        MOV      r0,#0xfa0\n        BL       malloc\n        STR      r4,[r0,#0]\n        MOV      r4,#1\n        MOV      r8,r0\n        MOV      r9,#0\n|L1.120|\n        MOV      r0,r9\n        LDR      r7,[r8,r0,LSL #2]\n        ADD      r9,r9,#1\n        ADD      r0,r5,r9,LSL #2\n        LDR      r11,[r0,#-4]\n        LDR      r1,[r7,#4]\n        CMP      r1,#0\n        BEQ      |L1.228|\n        MOV      r0,r4\n        STR      r1,[r8,r0,LSL #2]\n        ADD      r4,r4,#1\n        MOV      r10,r4,LSL #2\n        MOV      r1,r10\n        MOV      r0,r5\n        BL       realloc\n        MOV      r5,r0\n        ADD      r1,r5,r4,LSL #2\n        SUB      r0,r11,#1\n        STR      r0,[r1,#-4]\n        MOV      r1,r10\n        MOV      r0,r6\n        BL       realloc\n        MOV      r6,r0\n        LDR      r0,[r7,#4]\n        ADD      r1,r6,r4,LSL #2\n        LDR      r0,[r0,#0]\n        STR      r0,[r1,#-4]\n|L1.228|\n        LDR      r1,[r7,#8]\n        CMP      r1,#0\n        BEQ      |L1.316|\n        MOV      r0,r4\n        STR      r1,[r8,r0,LSL #2]\n        ADD      r4,r4,#1\n        MOV      r10,r4,LSL #2\n        MOV      r1,r10\n        MOV      r0,r5\n        BL       realloc\n        MOV      r5,r0\n        ADD      r1,r5,r4,LSL #2\n        ADD      r0,r11,#1\n        STR      r0,[r1,#-4]\n        MOV      r1,r10\n        MOV      r0,r6\n        BL       realloc\n        MOV      r6,r0\n        LDR      r0,[r7,#8]\n        ADD      r1,r6,r4,LSL #2\n        LDR      r0,[r0,#0]\n        STR      r0,[r1,#-4]\n|L1.316|\n        CMP      r9,r4\n        BLT      |L1.120|\n        MOV      r7,#0\n        CMP      r4,#0\n        BLE      |L1.360|\n|L1.336|\n        LDR      r1,[r6,r7,LSL #2]\n        ADR      r0,|L1.388|\n        BL       _printf\n        ADD      r7,r7,#1\n        CMP      r7,r4\n        BLT      |L1.336|\n|L1.360|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        BL       free\n        MOV      r0,r8\n        LDMFD    sp!,{r3-r11,lr}\n        B        free\n|L1.388|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid printBottomView(Node* root) {\n    if (!root) return;\n\n    int hd = 0;\n    int minhd = 0, maxhd = 0;\n\n    Node* curr = root;\n    \n    int* hdarr = (int*)malloc(sizeof(int));\n    hdarr[0] = hd;\n    \n    int* arr = (int*)malloc(sizeof(int));\n    arr[0] = root->data;\n    \n    int count = 1;\n    \n    Node** q = (Node**)malloc(sizeof(Node*) * 1000);\n    q[0] = root;\n    int head = 0;\n    int tail = 1;\n\n\n    while(head < tail){\n        curr = q[head++];\n        hd = hdarr[head -1];\n        \n        if (curr->left){\n            q[tail++] = curr->left;\n            hdarr = (int*)realloc(hdarr, sizeof(int) * tail);\n            hdarr[tail - 1] = hd - 1;\n\n            arr = (int*)realloc(arr, sizeof(int) * tail);\n            arr[tail - 1] = curr->left->data;\n\n            \n        }\n\n        if(curr->right){\n            q[tail++] = curr->right;\n            hdarr = (int*)realloc(hdarr, sizeof(int) * tail);\n            hdarr[tail - 1] = hd + 1;\n\n            arr = (int*)realloc(arr, sizeof(int) * tail);\n            arr[tail - 1] = curr->right->data;\n\n        }\n\n    }\n    \n    \n    for (int i = 0; i < tail; i++){\n        printf(\"%d \",arr[i]);\n    }\n\n\n    free(hdarr);\n    free(arr);\n    free(q);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreatePriorityQueue__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0x190\n        BL       malloc\n        MOV      r1,#0\n        STMIA    r4,{r0,r1}\n        MOV      r1,#0x64\n        STR      r1,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nheapifyUp__FP13PriorityQueuei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r1,#1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r4,r0,ASR #1\n        LDR      r0,[r5,#0]\n        LDR      r2,[r0,r1,LSL #2]\n        LDR      r3,[r0,r4,LSL #2]\n        CMP      r2,r3\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyUp__FP13PriorityQueuei\n        ENDP\n\ninsert__FP13PriorityQueuei PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP13PriorityQueuei\n        ENDP\n\nheapifyDown__FP13PriorityQueuei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#4]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.260|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVGT    r4,r0\n|L1.260|\n        CMP      r3,r2\n        BLE      |L1.288|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVGT    r4,r2\n|L1.288|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP13PriorityQueuei\n        ENDP\n\nextractMax__FP13PriorityQueue PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        BL       heapifyDown__FP13PriorityQueuei\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nfindMax__FP13PriorityQueue PROC\n        LDR      r1,[r0,#4]\n        CMP      r1,#0\n        LDRGT    r0,[r0,#0]\n        LDRGT    r0,[r0,#0]\n        MOVLE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int *heap;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nPriorityQueue* createPriorityQueue() {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    pq->heap = (int*)malloc(sizeof(int) * MAX_SIZE);\n    pq->size = 0;\n    pq->capacity = MAX_SIZE;\n    return pq;\n}\n\nvoid swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid heapifyUp(PriorityQueue* pq, int index) {\n    if (index <= 0) return;\n    int parent = (index - 1) / 2;\n    if (pq->heap[index] > pq->heap[parent]) {\n        swap(&pq->heap[index], &pq->heap[parent]);\n        heapifyUp(pq, parent);\n    }\n}\n\nvoid insert(PriorityQueue* pq, int value) {\n    if (pq->size == pq->capacity) return;\n    pq->heap[pq->size] = value;\n    pq->size++;\n    heapifyUp(pq, pq->size - 1);\n}\n\nvoid heapifyDown(PriorityQueue* pq, int index) {\n    int largest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < pq->size && pq->heap[left] > pq->heap[largest])\n        largest = left;\n    if (right < pq->size && pq->heap[right] > pq->heap[largest])\n        largest = right;\n\n    if (largest != index) {\n        swap(&pq->heap[index], &pq->heap[largest]);\n        heapifyDown(pq, largest);\n    }\n}\n\n\nint extractMax(PriorityQueue* pq) {\n    if (pq->size <= 0) return 0; \n    int max = pq->heap[0];\n    pq->heap[0] = pq->heap[pq->size - 1];\n    pq->size--;\n    heapifyDown(pq, 0);\n    return max;\n}\n\n\nint findMax(PriorityQueue* pq){\n    if(pq->size <=0) return 0;\n    return pq->heap[0];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateBag__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STMIB    r4,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nadd__FP3Bagi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        CMP      r1,r0\n        BNE      |L1.160|\n        MOV      r5,r0,LSL #1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r5,[r4,#8]\n|L1.160|\n        LDMIA    r4,{r0,r1}\n        STR      r6,[r0,r1,LSL #2]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Bag {\n    int* data;\n    int size;\n    int capacity;\n};\n\nstruct Bag* createBag(int capacity) {\n    struct Bag* bag = (struct Bag*)malloc(sizeof(struct Bag));\n    if (bag == NULL) return NULL;\n    bag->data = (int*)malloc(capacity * sizeof(int));\n    if (bag->data == NULL) {\n        free(bag);\n        return NULL;\n    }\n    bag->size = 0;\n    bag->capacity = capacity;\n    return bag;\n}\n\nvoid add(struct Bag* bag, int value) {\n    if (bag == NULL) return;\n    if (bag->size == bag->capacity) {\n        int newCapacity = bag->capacity * 2;\n        int* newData = (int*)realloc(bag->data, newCapacity * sizeof(int));\n        if (newData == NULL) return;\n        bag->data = newData;\n        bag->capacity = newCapacity;\n    }\n    bag->data[bag->size] = value;\n    bag->size++;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsortedMerge__FP4NodeT1 PROC\n        STMFD    sp!,{r4,lr}\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,r1\n        BXEQ     lr\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        BGT      |L1.104|\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        BL       sortedMerge__FP4NodeT1\n        STR      r0,[r4,#4]\n        B        |L1.120|\n|L1.104|\n        MOV      r4,r1\n        LDR      r1,[r1,#4]\n        BL       sortedMerge__FP4NodeT1\n        STR      r0,[r4,#4]\n|L1.120|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetMiddle__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BXEQ     lr\n|L1.148|\n        LDR      r1,[r1,#4]\n        CMP      r1,#0\n        BXEQ     lr\n        LDR      r0,[r0,#4]\n        LDR      r1,[r1,#4]\n        CMP      r1,#0\n        BNE      |L1.148|\n        BX       lr\n        ENDP\n\nmergeSort__FPP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        BL       getMiddle__FP4Node\n        LDR      r1,[r0,#4]\n        STR      r1,[sp,#0]\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        MOV      r0,r4\n        BL       mergeSort__FPP4Node\n        MOV      r5,r0\n        MOV      r0,sp\n        BL       mergeSort__FPP4Node\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       sortedMerge__FP4NodeT1\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n\nstruct Node* sortedMerge(struct Node* a, struct Node* b) {\n    struct Node* result = NULL;\n    if (a == NULL)\n        return b;\n    if (b == NULL)\n        return a;\n    if (a->data <= b->data) {\n        result = a;\n        result->next = sortedMerge(a->next, b);\n    } else {\n        result = b;\n        result->next = sortedMerge(a, b->next);\n    }\n    return result;\n}\n\nstruct Node* getMiddle(struct Node* head) {\n    if (head == NULL || head->next == NULL)\n        return head;\n    struct Node* slow = head;\n    struct Node* fast = head->next;\n    while (fast != NULL) {\n        fast = fast->next;\n        if (fast != NULL) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n    }\n    return slow;\n}\n\nstruct Node* mergeSort(struct Node** headRef) {\n    struct Node* head = *headRef;\n    if (head == NULL || head->next == NULL)\n        return head;\n    struct Node* middle = getMiddle(head);\n    struct Node* nextOfMiddle = middle->next;\n    middle->next = NULL;\n    struct Node* left = mergeSort(headRef);\n    struct Node* right = mergeSort(&nextOfMiddle);\n    *headRef = sortedMerge(left, right);\n    return *headRef;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmy_malloc__Fi PROC\n|L1.0|\n        ADD      r0,r0,#0xf\n        MOV      r1,r0,ASR #31\n        ADD      r0,r0,r1,LSR #28\n        STR      lr,[sp,#-4]!\n        LDR      lr,|L1.284|\n        MOV      r2,r0,ASR #4\n        MOV      r0,#0\n|L1.28|\n        ADD      r12,r0,r0,LSL #1\n        ADD      r1,lr,r12,LSL #2\n        LDR      r3,[r1,#8]\n        CMP      r3,#0\n        BEQ      |L1.92|\n        LDR      r3,[r1,#4]\n        CMP      r3,r2\n        BLT      |L1.92|\n        ADD      r0,r0,r0,LSL #1\n        ADD      r0,lr,r0,LSL #2\n        MOV      r3,#0\n        STR      r3,[r0,#8]\n        STR      r2,[r1,#4]\n        LDR      r0,[lr,r12,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n|L1.92|\n        ADD      r0,r0,#1\n        CMP      r0,#0x40\n        BLT      |L1.28|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nmy_free__FPv PROC\n        CMP      r0,#0\n        BXEQ     lr\n        LDR      r2,|L1.284|\n        SUB      r0,r0,r2\n        MOV      r1,r0,ASR #31\n        ADD      r0,r0,r1,LSR #28\n        MOV      r0,r0,ASR #4\n        CMP      r0,#0x40\n        BXCS     lr\n        ADD      r0,r0,r0,LSL #1\n        ADD      r0,r2,r0,LSL #2\n        MOV      r1,#1\n        STR      r1,[r0,#8]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MEMORY_SIZE 1024\n#define BLOCK_SIZE 16\n\ntypedef struct {\n    char* ptr;\n    int size;\n    int free;\n} Block;\n\nBlock memory[MEMORY_SIZE / BLOCK_SIZE];\nint next_free = 0;\n\n\nvoid* my_malloc(int size) {\n    int blocks_needed = (size + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int i;\n    for (i = 0; i < MEMORY_SIZE / BLOCK_SIZE; ++i) {\n        if (memory[i].free && memory[i].size >= blocks_needed) {\n            memory[i].free = 0;\n            memory[i].size = blocks_needed;\n            return memory[i].ptr;\n        }\n    }\n    return NULL;\n}\n\nvoid my_free(void* ptr) {\n    if(ptr == NULL) return;\n    int index = ( (char*)ptr - (char*)memory ) / BLOCK_SIZE;\n    if (index >= 0 && index < MEMORY_SIZE / BLOCK_SIZE) {\n        memory[index].free = 1;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r1\n        LDMEQFD  sp!,{r4,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.88|\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.104|\n|L1.88|\n        BGE      |L1.104|\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.104|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        B        |L1.124|\n|L1.120|\n        MOV      r0,r1\n|L1.124|\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BNE      |L1.120|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.192|\n        LDR      r0,[r4,#4]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.308|\n|L1.192|\n        BGE      |L1.212|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.308|\n|L1.212|\n        LDR      r5,[r4,#4]\n        CMP      r5,#0\n        BNE      |L1.248|\n        LDR      r5,[r4,#8]\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.248|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.280|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.280|\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.308|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsearch__FP4Nodei PROC\n|L1.320|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#8]\n        LDRGT    r0,[r0,#4]\n        B        |L1.320|\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) return newNode(data);\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    return node;\n}\n\n\nstruct Node* minValueNode(struct Node* node) {\n    struct Node* current = node;\n    while (current && current->left != NULL)\n        current = current->left;\n    return current;\n}\n\nstruct Node* deleteNode(struct Node* root, int data) {\n    if (root == NULL) return root;\n    if (data < root->data)\n        root->left = deleteNode(root->left, data);\n    else if (data > root->data)\n        root->right = deleteNode(root->right, data);\n    else {\n        if (root->left == NULL) {\n            struct Node *temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node *temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\nstruct Node* search(struct Node* root, int data) {\n    if (root == NULL || root->data == data) return root;\n    if (data < root->data) return search(root->left, data);\n    return search(root->right, data);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_bits__FUi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r3,r0\n        MOV      r2,#0x20\n        SUB      r12,r2,#1\n        MOV      r0,#0\n        MOV      lr,#1\n        MOV      r1,#0\n|L1.28|\n        MOV      r4,r3,LSR r1\n        TST      r4,#1\n        SUBNE    r4,r12,r1\n        ORRNE    r0,r0,lr,LSL r4\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLT      |L1.28|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int reverse_bits(unsigned int n) {\n    unsigned int reversed = 0;\n    int bit_count = sizeof(n) * 8;\n\n    for (int i = 0; i < bit_count; i++) {\n        if ((n >> i) & 1) {\n            reversed |= (1 << (bit_count - 1 - i));\n        }\n    }\n    return reversed;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nheight__FP4node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4node\n        CMP      r5,r0\n        ADDLE    r0,r0,#1\n        ADDGT    r0,r5,#1\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\ndiameter__FP4node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4node\n        MOV      r6,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4node\n        MOV      r7,r0\n        LDR      r0,[r4,#4]\n        BL       diameter__FP4node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       diameter__FP4node\n        ADD      r1,r6,r7\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        CMPGT    r1,r0\n        LDMGTFD  sp!,{r4-r7,lr}\n        MOVGT    r0,r1\n        BXGT     lr\n        CMP      r5,r0\n        MOVGT    r0,r5\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nint height(struct node* node) {\n    if (node == NULL)\n        return 0;\n    else {\n        int lheight = height(node->left);\n        int rheight = height(node->right);\n\n        return (lheight > rheight) ? (lheight + 1) : (rheight + 1);\n    }\n}\n\nint diameter(struct node* tree) {\n    if (tree == NULL)\n        return 0;\n\n    int lheight = height(tree->left);\n    int rheight = height(tree->right);\n\n    int ldiameter = diameter(tree->left);\n    int rdiameter = diameter(tree->right);\n\n\n    return  ((lheight + rheight + 1) > ldiameter && (lheight + rheight + 1) > rdiameter ) ? (lheight + rheight + 1) : (ldiameter > rdiameter ? ldiameter : rdiameter);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__FPCci PROC\n        LDRB     r3,[r0,#0]\n        MOV      r2,r1\n        MOV      r1,#0\n        CMP      r3,#0\n        BEQ      |L1.48|\n|L1.20|\n        LDRB     r3,[r0,r1]\n        RSB      r2,r2,r2,LSL #5\n        ADD      r1,r1,#1\n        ADD      r2,r2,r3\n        LDRB     r3,[r0,r1]\n        CMP      r3,#0\n        BNE      |L1.20|\n|L1.48|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nbloom_add__FPcPCc PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,#1\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r4,#0\n|L1.76|\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       hash__FPCci\n        MOV      r1,r4,ASR #31\n        ADD      r1,r4,r1,LSR #29\n        MOV      r0,r0,LSL #22\n        MOV      r0,r0,LSR #22\n        MOV      r1,r1,ASR #3\n        SUB      r1,r4,r1,LSL #3\n        LDRB     r2,[r5,r0]\n        ADD      r4,r4,#1\n        CMP      r4,#3\n        ORR      r1,r2,r7,LSL r1\n        STRB     r1,[r5,r0]\n        BLT      |L1.76|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nbloom_check__FPcPCc PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,#1\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r4,#0\n|L1.164|\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       hash__FPCci\n        MOV      r0,r0,LSL #22\n        MOV      r0,r0,LSR #22\n        MOV      r1,r4,ASR #31\n        ADD      r1,r4,r1,LSR #29\n        LDRB     r0,[r5,r0]\n        MOV      r1,r1,ASR #3\n        SUB      r1,r4,r1,LSL #3\n        TST      r0,r7,LSL r1\n        LDMEQFD  sp!,{r4-r7,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r4,r4,#1\n        CMP      r4,#3\n        BLT      |L1.164|\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define BLOOM_SIZE 1024\n#define NUM_HASHES 3\n\nunsigned int hash(const char* str, int num) {\n    unsigned int hash = num;\n    for (int i = 0; str[i]; i++) {\n        hash = hash * 31 + str[i];\n    }\n    return hash;\n}\n\nvoid bloom_add(char bloom[], const char* str) {\n    for (int i = 0; i < NUM_HASHES; i++) {\n        unsigned int index = hash(str, i) % BLOOM_SIZE;\n        bloom[index] |= (1 << (i % 8));\n    }\n}\n\nint bloom_check(char bloom[], const char* str) {\n    for (int i = 0; i < NUM_HASHES; i++) {\n        unsigned int index = hash(str, i) % BLOOM_SIZE;\n        if (!(bloom[index] & (1 << (i % 8))))\n            return 0;\n    }\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nremoveDuplicateChars__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       strlen\n        CMP      r0,#1\n        LDMLEFD  sp!,{r4,lr}\n        BXLE     lr\n        LDRB     r0,[r4,#1]\n        MOV      r1,r4\n        ADD      r2,r4,#1\n        CMP      r0,#0\n        BEQ      |L1.128|\n|L1.56|\n        MOV      r0,r4\n        MOV      lr,#0\n        CMP      r4,r1\n        BCS      |L1.108|\n        LDRB     r3,[r2,#0]\n|L1.76|\n        LDRB     r12,[r0,#0]\n        CMP      r12,r3\n        BEQ      |L1.116|\n        ADD      r0,r0,#1\n        CMP      r0,r1\n        BCC      |L1.76|\n        CMP      lr,#0\n        BNE      |L1.116|\n|L1.108|\n        LDRB     r0,[r2,#0]\n        STRB     r0,[r1,#1]!\n|L1.116|\n        LDRB     r0,[r2,#1]!\n        CMP      r0,#0\n        BNE      |L1.56|\n|L1.128|\n        ADD      r0,r1,#1\n        MOV      r1,#0\n        STRB     r1,[r0,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        strlen\n        ENDP\n```",
        "output": "```cpp\n\nint removeDuplicateChars(char *str) {\n    if (str == 0) return 0;\n    int len = strlen(str);\n    if (len <= 1) return len;\n    char *p = str;\n    char *q = str + 1;\n    while (*q) {\n        char *r = str;\n        int found = 0;\n        while (r < p) {\n            if (*r == *q) {\n                found = 1;\n                break;\n            }\n            r++;\n        }\n        if (!found) {\n            p++;\n            *p = *q;\n        }\n        q++;\n    }\n    p++;\n    *p = 0;\n    return strlen(str);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhandleNetworkError__Fi PROC\n        CMP      r0,#1\n        ADREQ    r0,|L1.28|\n        BEQ      _printf\n        CMP      r0,#2\n        ADRNE    r0,|L1.48|\n        ADREQ    r0,|L1.72|\n        B        _printf\n|L1.28|\n        DCB      \"Netw\"\n        DCB      \"ork \"\n        DCB      \"erro\"\n        DCB      \"r 1\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.48|\n        DCB      \"Unkn\"\n        DCB      \"own \"\n        DCB      \"Netw\"\n        DCB      \"ork \"\n        DCB      \"erro\"\n        DCB      \"r\\n\\0\\0\"\n|L1.72|\n        DCB      \"Netw\"\n        DCB      \"ork \"\n        DCB      \"erro\"\n        DCB      \"r 2\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid handleNetworkError(int errorCode) {\n    if (errorCode == 1) {\n        printf(\"Network error 1\\n\");\n        //Perform actions for error 1.\n    } else if (errorCode == 2) {\n        printf(\"Network error 2\\n\");\n        //Perform actions for error 2.\n    } else {\n        printf(\"Unknown Network error\\n\");\n        //Perform actions for unknown error.\n\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlinearSearch__FPiiT2 PROC\n|L1.0|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.40|\n|L1.12|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,r2\n        MOVEQ    r0,r3\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.12|\n|L1.40|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntoLower__Fc PROC\n        STMFD    sp!,{r3,lr}\n        BL       tolower\n        LDMFD    sp!,{r3,lr}\n        AND      r0,r0,#0xff\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar toLower(char c) {\n    return tolower(c);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nremoveDuplicates__FPii PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        CMP      r1,#0\n        LDRLE    lr,[sp],#4\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r3,#1\n        MOV      r2,#1\n        CMP      r1,#1\n        BLE      |L1.72|\n|L1.36|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      lr,r0,r2,LSL #2\n        LDR      lr,[lr,#-4]\n        ADD      r2,r2,#1\n        CMP      r12,lr\n        STRNE    r12,[r0,r3,LSL #2]\n        ADDNE    r3,r3,#1\n        CMP      r2,r1\n        BLT      |L1.36|\n|L1.72|\n        LDR      lr,[sp],#4\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint removeDuplicates(int* arr, int size) {\n    if (size <= 0) return 0;\n    int uniqueSize = 1;\n    for (int i = 1; i < size; i++) {\n        if (arr[i] != arr[i - 1]) {\n            arr[uniqueSize] = arr[i];\n            uniqueSize++;\n        }\n    }\n    return uniqueSize;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncentral_difference__FPFd_ddT2 PROC\n        STMFD    sp!,{r4-r10,lr}\n        LDR      r4,[sp,#0x20]\n        MOV      r7,r2\n        MOV      r6,r1\n        MOV      r5,r3\n        MOV      r8,r0\n        MOV      r0,r6\n        MOV      r2,r5\n        MOV      r3,r4\n        MOV      r1,r7\n        BL       _dadd\n        MOV      lr,pc\n        BX       r8\n        MOV      r9,r0\n        MOV      r10,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r4\n        MOV      r2,r5\n        BL       _dsub\n        MOV      lr,pc\n        BX       r8\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _drsb\n        MOV      r6,r0\n        ADR      r0,|L1.144|\n        LDMIA    r0,{r2,r3}\n        MOV      r7,r1\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        LDMFD    sp!,{r4-r10,lr}\n        B        _drdiv\n|L1.144|\n        DCFD     0x4000000000000000\n        ENDP\n\nmy_function__Fd PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dmul\n        ENDP\n```",
        "output": "```cpp\n\ndouble central_difference(double (*f)(double), double x, double h) {\n    return (f(x + h) - f(x - h)) / (2 * h);\n}\n\ndouble my_function(double x) {\n    return x * x * x;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninorder__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r5,#0\n|L1.60|\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.96|\n        ADR      r0,|L1.160|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r4,[r4,#8]\n        B        |L1.144|\n|L1.92|\n        MOV      r0,r1\n|L1.96|\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        STREQ    r4,[r0,#8]\n        LDREQ    r4,[r4,#4]\n        BEQ      |L1.144|\n        CMP      r1,r4\n        BNE      |L1.92|\n        STR      r5,[r0,#8]\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.160|\n        BL       _printf\n        LDR      r4,[r4,#8]\n|L1.144|\n        CMP      r4,#0\n        BNE      |L1.60|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.160|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node *root) {\n    struct Node *curr = root;\n    struct Node *pre = NULL;\n    while (curr != NULL) {\n        if (curr->left == NULL) {\n            printf(\"%d \", curr->data);\n            curr = curr->right;\n        } else {\n            pre = curr->left;\n            while (pre->right != NULL && pre->right != curr) {\n                pre = pre->right;\n            }\n            if (pre->right == NULL) {\n                pre->right = curr;\n                curr = curr->left;\n            } else {\n                pre->right = NULL;\n                printf(\"%d \", curr->data);\n                curr = curr->right;\n            }\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMemento__FP15OriginatorState PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#4\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,#4\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        LDRNE    r1,[r5,#0]\n        STRNE    r1,[r0,#0]\n        MOVNE    r0,r4\n        LDMNEFD  sp!,{r3-r5,lr}\n        BXNE     lr\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nsetMemento__FP15OriginatorStateP7Memento PROC\n        LDR      r1,[r1,#0]\n        LDR      r1,[r1,#0]\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n\nfreeMemento__FP7Memento PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int value;\n} OriginatorState;\n\n\ntypedef struct {\n    OriginatorState* state;\n} Memento;\n\n\nMemento* createMemento(OriginatorState* state) {\n    Memento* memento = (Memento*)malloc(sizeof(Memento));\n    if (memento == NULL) {\n        return NULL;\n    }\n    memento->state = (OriginatorState*)malloc(sizeof(OriginatorState));\n    if (memento->state == NULL) {\n        free(memento);\n        return NULL;\n    }\n    memcpy(memento->state, state, sizeof(OriginatorState));\n    return memento;\n}\n\n\nvoid setMemento(OriginatorState* state, Memento* memento) {\n    memcpy(state, memento->state, sizeof(OriginatorState));\n}\n\n\nvoid freeMemento(Memento* memento) {\n    free(memento->state);\n    free(memento);\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_leap__Fi PROC\n        TST      r0,#3\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,|L1.200|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        MOVNE    r0,#1\n        BXNE     lr\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_leap(int year) {\n    if (year % 4 != 0) return 0;\n    if (year % 100 == 0) {\n        if (year % 400 == 0) return 1;\n        return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMinHeap__Fi PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        STR      r5,[r0,#4]!\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nminHeapify__FP7MinHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#8]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.136|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVLT    r4,r0\n|L1.136|\n        CMP      r3,r2\n        BLE      |L1.164|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVLT    r4,r2\n|L1.164|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r1,r0,r1,LSL #2\n        ADD      r0,r0,r4,LSL #2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        minHeapify__FP7MinHeapi\n        ENDP\n\nextractMin__FP7MinHeap PROC\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        MVNLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#8]\n        MOV      r1,#0\n        BL       minHeapify__FP7MinHeapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsertMinHeap__FP7MinHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        LDR      r2,[r4,#4]\n        CMP      r0,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDR      r2,[r4,#0]\n        SUB      r0,r0,#1\n        STR      r1,[r2,r0,LSL #2]\n        B        |L1.348|\n|L1.332|\n        ADD      r1,r2,r5,LSL #2\n        ADD      r0,r2,r0,LSL #2\n        BL       swap__FPiT1\n        MOV      r0,r5\n|L1.348|\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        SUB      r1,r0,#1\n        ADD      r1,r1,r1,LSR #31\n        LDR      r2,[r4,#0]\n        MOV      r5,r1,ASR #1\n        LDR      r1,[r2,r5,LSL #2]\n        LDR      r3,[r2,r0,LSL #2]\n        CMP      r1,r3\n        BGT      |L1.332|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nfindKthLargest__FPiiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r0\n        MOV      r0,r2\n        MOV      r8,r1\n        MOV      r7,r2\n        BL       createMinHeap__Fi\n        MOV      r4,r0\n        MOV      r5,#0\n        CMP      r7,#0\n        BLE      |L1.464|\n|L1.440|\n        LDR      r1,[r6,r5,LSL #2]\n        MOV      r0,r4\n        BL       insertMinHeap__FP7MinHeapi\n        ADD      r5,r5,#1\n        CMP      r5,r7\n        BLT      |L1.440|\n|L1.464|\n        CMP      r7,r8\n        BGE      |L1.524|\n|L1.472|\n        LDR      r1,[r4,#0]\n        LDR      r0,[r6,r7,LSL #2]\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        BLE      |L1.512|\n        MOV      r0,r4\n        BL       extractMin__FP7MinHeap\n        LDR      r1,[r6,r7,LSL #2]\n        MOV      r0,r4\n        BL       insertMinHeap__FP7MinHeapi\n|L1.512|\n        ADD      r7,r7,#1\n        CMP      r7,r8\n        BLT      |L1.472|\n|L1.524|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        extractMin__FP7MinHeap\n        ENDP\n```",
        "output": "```cpp\n\nstruct MinHeap {\n    int* arr;\n    int capacity;\n    int size;\n};\n\nstruct MinHeap* createMinHeap(int capacity) {\n    struct MinHeap* minHeap = (struct MinHeap*)malloc(sizeof(struct MinHeap));\n    minHeap->capacity = capacity;\n    minHeap->size = 0;\n    minHeap->arr = (int*)malloc(minHeap->capacity * sizeof(int));\n    return minHeap;\n}\n\nvoid swap(int* x, int* y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid minHeapify(struct MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n\n    if (left < minHeap->size && minHeap->arr[left] < minHeap->arr[smallest])\n        smallest = left;\n\n    if (right < minHeap->size && minHeap->arr[right] < minHeap->arr[smallest])\n        smallest = right;\n\n    if (smallest != idx) {\n        swap(&minHeap->arr[smallest], &minHeap->arr[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n\n\nint extractMin(struct MinHeap* minHeap) {\n    if (minHeap->size <= 0) return -1;\n    int root = minHeap->arr[0];\n    minHeap->arr[0] = minHeap->arr[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return root;\n}\n\nvoid insertMinHeap(struct MinHeap* minHeap, int newNum) {\n    if (minHeap->size == minHeap->capacity) return;\n    minHeap->size++;\n    int i = minHeap->size - 1;\n    minHeap->arr[i] = newNum;\n    while (i != 0 && minHeap->arr[i] < minHeap->arr[(i - 1) / 2]) {\n        swap(&minHeap->arr[i], &minHeap->arr[(i - 1) / 2]);\n        i = (i - 1) / 2;\n    }\n}\n\n\nint findKthLargest(int* nums, int numsSize, int k) {\n    struct MinHeap* minHeap = createMinHeap(k);\n    for (int i = 0; i < k; i++) {\n        insertMinHeap(minHeap, nums[i]);\n    }\n    for (int i = k; i < numsSize; i++) {\n        if (nums[i] > minHeap->arr[0]) {\n            extractMin(minHeap);\n            insertMinHeap(minHeap, nums[i]);\n        }\n    }\n    return extractMin(minHeap);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.540|\n        LDR      r1,[r2,#0]  ; top\n        ADD      r1,r1,#1\n        STR      r1,[r2,#0]  ; top\n        LDR      r2,|L1.544|\n        STR      r0,[r2,r1,LSL #2]\n        LDR      r2,|L1.548|\n        MOV      r1,#1\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.540|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.544|\n        LDR      r2,|L1.548|\n        LDR      r0,[r1,r0,LSL #2]\n        MOV      r1,#0\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\ntarjan__Fi PROC\n        STMFD    sp!,{r4-r10,lr}\n        LDR      r7,|L1.552|\n        MOV      r5,r0\n        LDR      r0,[r7,#8]  ; id@tarjan__Fi_0\n        LDR      r8,|L1.556|\n        ADD      r1,r0,#1\n        STR      r1,[r7,#8]  ; id@tarjan__Fi_0\n        LDR      r9,|L1.560|\n        STR      r0,[r8,r5,LSL #2]\n        STR      r0,[r9,r5,LSL #2]\n        MOV      r0,r5\n        BL       push__Fi\n        LDR      r0,[r7,#0]  ; num_nodes\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.264|\n        ADD      r1,r5,r5,LSL #1\n        LDR      r0,|L1.564|\n        RSB      r1,r1,r5,LSL #7\n        LDR      r10,|L1.548|\n        ADD      r6,r0,r1,LSL #5\n|L1.164|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.248|\n        LDR      r0,[r9,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.220|\n        MOV      r0,r4\n        BL       tarjan__Fi\n        LDR      r0,[r8,r5,LSL #2]\n        LDR      r1,[r8,r4,LSL #2]\n        CMP      r0,r1\n        MOVGE    r0,r1\n        STR      r0,[r8,r5,LSL #2]\n        B        |L1.248|\n|L1.220|\n        LDR      r1,[r10,r4,LSL #2]\n        CMP      r1,#0\n        BEQ      |L1.248|\n        LDR      r1,[r8,r5,LSL #2]\n        CMP      r1,r0\n        MOVLT    r0,r1\n        STR      r0,[r8,r5,LSL #2]\n|L1.248|\n        LDR      r0,[r7,#0]  ; num_nodes\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.164|\n|L1.264|\n        LDR      r0,[r8,r5,LSL #2]\n        LDR      r1,[r9,r5,LSL #2]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r10,lr}\n        BXNE     lr\n        LDR      r3,|L1.568|\n|L1.288|\n        BL       pop__Fv\n        LDR      r1,[r7,#4]  ; scc_count\n        CMP      r0,r5\n        STR      r1,[r3,r0,LSL #2]\n        BNE      |L1.288|\n        LDR      r0,[r7,#4]  ; scc_count\n        ADD      r0,r0,#1\n        STR      r0,[r7,#4]  ; scc_count\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\nstrongly_connected_components__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r5,|L1.560|\n        MOV      r2,#0xfa0\n        MVN      r1,#0\n        MOV      r0,r5\n        BL       __rt_memset\n        MOV      r1,#0xfa0\n        LDR      r0,|L1.548|\n        BL       __rt_memclr_w\n        MOV      r2,#0xfa0\n        MVN      r1,#0\n        LDR      r0,|L1.568|\n        BL       __rt_memset\n        LDR      r6,|L1.552|\n        MOV      r4,#0\n        LDR      r0,[r6,#0]  ; num_nodes\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.404|\n        LDR      r0,[r5,r4,LSL #2]\n        CMN      r0,#1\n        MOVEQ    r0,r4\n        BLEQ     tarjan__Fi\n        LDR      r0,[r6,#0]  ; num_nodes\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.404|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_NODES 1000\n\nint num_nodes;\nint stack[MAX_NODES];\nint top = -1;\nint index[MAX_NODES];\nint lowlink[MAX_NODES];\nint onstack[MAX_NODES];\nint scc[MAX_NODES];\nint scc_count = 0;\nint adj[MAX_NODES][MAX_NODES];\n\nvoid push(int v) {\n    stack[++top] = v;\n    onstack[v] = 1;\n}\n\nint pop() {\n    int v = stack[top--];\n    onstack[v] = 0;\n    return v;\n}\n\nvoid tarjan(int v) {\n    static int id = 0;\n    index[v] = lowlink[v] = id++;\n    push(v);\n    for (int u = 0; u < num_nodes; u++) {\n        if (adj[v][u]) {\n            if (index[u] == -1) {\n                tarjan(u);\n                lowlink[v] = (lowlink[v] < lowlink[u]) ? lowlink[v] : lowlink[u];\n            } else if (onstack[u]) {\n                lowlink[v] = (lowlink[v] < index[u]) ? lowlink[v] : index[u];\n            }\n        }\n    }\n    if (lowlink[v] == index[v]) {\n        int u;\n        do {\n            u = pop();\n            scc[u] = scc_count;\n        } while (u != v);\n        scc_count++;\n    }\n}\n\nvoid strongly_connected_components() {\n    memset(index, -1, sizeof(index));\n    memset(onstack, 0, sizeof(onstack));\n    memset(scc, -1, sizeof(scc));\n    for (int v = 0; v < num_nodes; v++) {\n        if (index[v] == -1)\n            tarjan(v);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisBalanced__FPCc PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        TST      r0,#1\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r1,#0\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.112|\n|L1.44|\n        LDRB     r3,[r4,r2]\n        CMP      r3,#0x7b\n        ADDEQ    r1,r1,#1\n        BEQ      |L1.68|\n        CMP      r3,#0x7d\n        SUBEQ    r1,r1,#1\n|L1.68|\n        CMP      r1,#0\n        LDMLTFD  sp!,{r4,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.44|\n        CMP      r1,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.112|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isBalanced(const char* seq) {\n    int len = strlen(seq);\n    if (len % 2 != 0) return 0;\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (seq[i] == '{') count++;\n        else if (seq[i] == '}') count--;\n        if (count < 0) return 0;\n    }\n    return count == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nminKey__FPiPb PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MVN      r12,#0x80000000\n        MOV      r2,#0\n|L1.12|\n        LDR      r3,[r1,r2,LSL #2]\n        CMP      r3,#0\n        BNE      |L1.40|\n        LDR      r3,[r0,r2,LSL #2]\n        CMP      r3,r12\n        MOVLT    r12,r3\n        MOVLT    lr,r2\n|L1.40|\n        ADD      r2,r2,#1\n        CMP      r2,#5\n        BLT      |L1.12|\n        MOV      r0,lr\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nprimMST__FPA5_i PROC\n        STMFD    sp!,{r4-r9,lr}\n        SUB      sp,sp,#0x3c\n        MOV      r7,r0\n        MOV      r0,#0\n        MOV      r5,sp\n        ADD      r6,sp,#0x14\n        MVN      r2,#0x80000000\n        MOV      r1,#0\n|L1.96|\n        STR      r2,[r6,r0,LSL #2]\n        STR      r1,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,#5\n        BLT      |L1.96|\n        MVN      r0,#0\n        STR      r0,[sp,#0x28]\n        MOV      r4,#0\n        MOV      r8,#1\n        STR      r1,[sp,#0x14]\n        ADD      r9,sp,#0x28\n|L1.140|\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       minKey__FPiPb\n        ADD      r2,r0,r0,LSL #2\n        ADD      r2,r7,r2,LSL #2\n        STR      r8,[r5,r0,LSL #2]\n        MOV      r1,#0\n|L1.168|\n        LDR      r3,[r2,r1,LSL #2]\n        CMP      r3,#0\n        BEQ      |L1.212|\n        LDR      r12,[r5,r1,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.212|\n        LDR      r12,[r6,r1,LSL #2]\n        CMP      r3,r12\n        STRLT    r0,[r9,r1,LSL #2]\n        LDRLT    r3,[r2,r1,LSL #2]\n        STRLT    r3,[r6,r1,LSL #2]\n|L1.212|\n        ADD      r1,r1,#1\n        CMP      r1,#5\n        BLT      |L1.168|\n        ADD      r4,r4,#1\n        CMP      r4,#4\n        BLT      |L1.140|\n        ADD      sp,sp,#0x3c\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define V 5\n\nint minKey(int key[], bool mstSet[]) {\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < V; v++)\n        if (mstSet[v] == 0 && key[v] < min)\n            min = key[v], min_index = v;\n    return min_index;\n}\n\nvoid primMST(int graph[V][V]) {\n    int parent[V];\n    int key[V];\n    bool mstSet[V];\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = 0;\n    key[0] = 0;\n    parent[0] = -1;\n    for (int count = 0; count < V - 1; count++) {\n        int u = minKey(key, mstSet);\n        mstSet[u] = 1;\n        for (int v = 0; v < V; v++)\n            if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbitwise_operations__FUiT1c PROC\n        CMP      r2,#0x21\n        MVNEQ    r0,r0\n        BXEQ     lr\n        CMP      r2,#0x26\n        ANDEQ    r0,r0,r1\n        BXEQ     lr\n        CMP      r2,#0x5e\n        EOREQ    r0,r0,r1\n        BXEQ     lr\n        CMP      r2,#0x7c\n        ORREQ    r0,r0,r1\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int bitwise_operations(unsigned int a, unsigned int b, char op) {\n    switch (op) {\n    case '&': return a & b;\n    case '|': return a | b;\n    case '^': return a ^ b;\n    case '!': return ~a;\n    default: return 0; \n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbitwiseAnd__FUiT1 PROC\n        AND      r0,r0,r1\n        BX       lr\n        ENDP\n\nbitwiseOr__FUiT1 PROC\n        ORR      r0,r0,r1\n        BX       lr\n        ENDP\n\nbitwiseXor__FUiT1 PROC\n        EOR      r0,r0,r1\n        BX       lr\n        ENDP\n\nbitwiseNot__FUi PROC\n        MVN      r0,r0\n        BX       lr\n        ENDP\n\nleftShift__FUii PROC\n        MOV      r0,r0,LSL r1\n        BX       lr\n        ENDP\n\nrightShift__FUii PROC\n        MOV      r0,r0,LSR r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int bitwiseAnd(unsigned int a, unsigned int b) {\n    return a & b;\n}\n\nunsigned int bitwiseOr(unsigned int a, unsigned int b) {\n    return a | b;\n}\n\nunsigned int bitwiseXor(unsigned int a, unsigned int b) {\n    return a ^ b;\n}\n\nunsigned int bitwiseNot(unsigned int a) {\n    return ~a;\n}\n\nunsigned int leftShift(unsigned int a, int b) {\n    return a << b;\n}\n\nunsigned int rightShift(unsigned int a, int b) {\n    return a >> b;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nconvert__Fi PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x3c\n        ADD      lr,sp,#0x18\n        MOV      r4,#0\n        MOV      r5,#0\n        MOV      r7,#0\n        MOV      r6,#0\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r12,#0\n        STMIA    lr!,{r1-r7,r12}\n        STR      r1,[lr,#0]\n        ADD      r1,sp,#0xc\n        MOV      r4,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        STMIA    r1,{r2-r4}\n        MOV      r3,#0\n        MOV      r4,sp\n        MOV      r2,#0\n        MOV      r5,#0\n        STMIA    r4,{r2,r3,r5}\n        MOV      r3,#0\n        SUB      lr,lr,#0x20\n        MOV      r12,r0\n        CMP      r0,#0\n        BLE      |L1.152|\n|L1.112|\n        MOV      r2,r12\n        ADD      r12,r12,r12,LSR #31\n        MOV      r12,r12,ASR #1\n        SUB      r2,r2,r12,LSL #1\n        ADD      r5,r2,#0x30\n        MOV      r2,r3\n        STRB     r5,[lr,r2]\n        ADD      r3,r3,#1\n        CMP      r12,#0\n        BGT      |L1.112|\n|L1.152|\n        ADD      r12,r3,r3,LSR #31\n        MOV      r7,r12,ASR #1\n        CMP      r7,#0\n        MOV      r2,#0\n        BLE      |L1.208|\n|L1.172|\n        SUB      r5,r3,r2\n        ADD      r5,r5,lr\n        LDRB     r6,[r5,#-1]\n        LDRB     r12,[lr,r2]\n        STRB     r6,[lr,r2]\n        ADD      r2,r2,#1\n        CMP      r7,r2\n        STRB     r12,[r5,#-1]\n        BGT      |L1.172|\n|L1.208|\n        MOV      r12,r0\n        MOV      r3,#0\n        CMP      r0,#0\n        BLE      |L1.268|\n|L1.224|\n        MOV      r2,r12\n        MOV      r12,r12,ASR #31\n        ADD      r12,r2,r12,LSR #29\n        MOV      r12,r12,ASR #3\n        SUB      r2,r2,r12,LSL #3\n        ADD      r5,r2,#0x30\n        MOV      r2,r3\n        STRB     r5,[r1,r2]\n        ADD      r3,r3,#1\n        CMP      r12,#0\n        BGT      |L1.224|\n|L1.268|\n        ADD      r12,r3,r3,LSR #31\n        MOV      r7,r12,ASR #1\n        CMP      r7,#0\n        MOV      r2,#0\n        BLE      |L1.324|\n|L1.288|\n        SUB      r5,r3,r2\n        ADD      r5,r5,r1\n        LDRB     r6,[r5,#-1]\n        LDRB     r12,[r1,r2]\n        STRB     r6,[r1,r2]\n        ADD      r2,r2,#1\n        CMP      r7,r2\n        STRB     r12,[r5,#-1]\n        BGT      |L1.288|\n|L1.324|\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.408|\n|L1.336|\n        MOV      r3,r0,ASR #31\n        ADD      r3,r0,r3,LSR #28\n        MOV      r3,r3,ASR #4\n        SUB      r0,r0,r3,LSL #4\n        CMP      r0,#0xa\n        BGE      |L1.380|\n        ADD      r12,r0,#0x30\n        MOV      r0,r2\n        STRB     r12,[r4,r0]\n        ADD      r2,r2,#1\n        B        |L1.396|\n|L1.380|\n        ADD      r12,r0,#0x37\n        MOV      r0,r2\n        STRB     r12,[r4,r0]\n        ADD      r2,r2,#1\n|L1.396|\n        MOV      r0,r3\n        CMP      r3,#0\n        BGT      |L1.336|\n|L1.408|\n        ADD      r3,r2,r2,LSR #31\n        MOV      r6,r3,ASR #1\n        CMP      r6,#0\n        MOV      r0,#0\n        BLE      |L1.464|\n|L1.428|\n        SUB      r12,r2,r0\n        ADD      r12,r12,r4\n        LDRB     r5,[r12,#-1]\n        LDRB     r3,[r4,r0]\n        STRB     r5,[r4,r0]\n        ADD      r0,r0,#1\n        CMP      r6,r0\n        STRB     r3,[r12,#-1]\n        BGT      |L1.428|\n|L1.464|\n        MOV      r2,r1\n        MOV      r1,lr\n        MOV      r3,r4\n        ADR      r0,|L1.496|\n        BL       _printf\n        ADD      sp,sp,#0x3c\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.496|\n        DCB      \"%s %\"\n        DCB      \"s %s\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid convert(int num) {\n    char binary[33] = {0};\n    char octal[12] = {0};\n    char hex[9] = {0};\n\n    int temp = num;\n    int i = 0;\n    while (temp > 0) {\n        binary[i++] = (temp % 2) + '0';\n        temp /= 2;\n    }\n    \n    for(int j=0; j<i/2; j++){\n        char t = binary[j];\n        binary[j] = binary[i-j-1];\n        binary[i-j-1] = t;\n    }\n\n    temp = num;\n    i = 0;\n    while (temp > 0) {\n        octal[i++] = (temp % 8) + '0';\n        temp /= 8;\n    }\n    for(int j=0; j<i/2; j++){\n        char t = octal[j];\n        octal[j] = octal[i-j-1];\n        octal[i-j-1] = t;\n    }\n\n    temp = num;\n    i = 0;\n    while (temp > 0) {\n        int rem = temp % 16;\n        if (rem < 10) {\n            hex[i++] = rem + '0';\n        } else {\n            hex[i++] = rem - 10 + 'A';\n        }\n        temp /= 16;\n    }\n    for(int j=0; j<i/2; j++){\n        char t = hex[j];\n        hex[j] = hex[i-j-1];\n        hex[i-j-1] = t;\n    }\n\n    printf(\"%s %s %s\\n\", binary, octal, hex);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncelsiusToFahrenheit__Ff PROC\n        STMFD    sp!,{r3,lr}\n        BL       _f2d\n        ADR      r2,|L1.52|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.60|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        ADR      r2,|L1.68|\n        LDMIA    r2,{r2,r3}\n        BL       _dadd\n        LDMFD    sp!,{r3,lr}\n        B        _d2f\n|L1.52|\n        DCFD     0x4022000000000000\n|L1.60|\n        DCFD     0x4014000000000000\n|L1.68|\n        DCFD     0x4040000000000000\n        ENDP\n```",
        "output": "```cpp\n\nfloat celsiusToFahrenheit(float celsius) {\n    return (celsius * 9.0 / 5.0) + 32.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbuildTree__FPPdPiiN33 PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x44\n        MOV      r8,r1\n        MOVS     r4,r2\n        ADDNE    r1,sp,#0x78\n        LDMNEIA  r1,{r0,r1}\n        CMPNE    r0,r1\n        BNE      |L1.124|\n        MOV      r0,#0x18\n        BL       malloc\n        MOV      r3,#0\n        STR      r3,[r0,#0x14]\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r4,#0\n        BLE      |L1.88|\n|L1.64|\n        LDR      r12,[r8,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r12,#0\n        ADDEQ    r2,r2,#1\n        CMP      r1,r4\n        BLT      |L1.64|\n|L1.88|\n        CMP      r4,r2,LSL #1\n        MOVGE    r1,#1\n        STRGE    r1,[r0,#0x14]\n        STRLT    r3,[r0,#0x14]\n        STR      r3,[r0,#0xc]\n        STR      r3,[r0,#0x10]\n        ADD      sp,sp,#0x54\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.124|\n        MVN      r1,#0\n        STR      r1,[sp,#0x2c]\n        ADR      r0,|L1.1056|\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r1,[sp,#0x24]\n        STR      r0,[sp,#0x28]\n        ADR      r0,|L1.1064|\n        LDMIA    r0,{r5,r6}\n        ADD      r1,sp,#0x1c\n        STMIA    r1,{r5,r6}\n        LDR      r1,[sp,#0x50]\n        MOV      r7,#0\n        SUB      r1,r1,#1\n        STR      r1,[sp,#0x40]\n        CMP      r1,#0\n        BLE      |L1.840|\n        MOV      r0,r4\n        BL       _dflt\n        STR      r0,[sp,#0x3c]\n        STR      r1,[sp,#0x38]\n|L1.208|\n        MOV      r1,#0\n        STR      r1,[sp,#0x18]\n        CMP      r4,#0\n        BLE      |L1.824|\n|L1.224|\n        LDR      r0,[sp,#0x44]\n        LDR      r1,[sp,#0x18]\n        MOV      r9,#0\n        LDR      r0,[r0,r1,LSL #2]\n        MOV      r10,#0\n        ADD      r0,r0,r7,LSL #3\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r1,[sp,#0x10]\n        MOV      r5,#0\n        MOV      r6,#0\n        MOV      r11,#0\n        CMP      r4,#0\n        STR      r0,[sp,#0x14]\n        BLE      |L1.360|\n|L1.284|\n        LDR      r0,[sp,#0x44]\n        ADD      r3,sp,#0x10\n        LDR      r0,[r0,r11,LSL #2]\n        LDMIA    r3,{r2,r3}\n        ADD      r0,r0,r7,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dcmple\n        LDR      r0,[r8,r11,LSL #2]\n        BCS      |L1.336|\n        CMP      r0,#0\n        ADDNE    r10,r10,#1\n        ADDEQ    r9,r9,#1\n        B        |L1.348|\n|L1.336|\n        CMP      r0,#0\n        ADDNE    r6,r6,#1\n        ADDEQ    r5,r5,#1\n|L1.348|\n        ADD      r11,r11,#1\n        CMP      r11,r4\n        BLT      |L1.284|\n|L1.360|\n        ADR      r1,|L1.1064|\n        LDMIA    r1,{r0,r1}\n        ADD      r2,sp,#8\n        STMIA    r2,{r0,r1}\n        ADD      r0,r9,r10\n        STR      r0,[sp,#0x34]\n        CMP      r0,#0\n        BLE      |L1.508|\n        MOV      r0,r9\n        BL       _dflt\n        MOV      r9,r0\n        LDR      r0,[sp,#0x34]\n        MOV      r10,r1\n        BL       _dflt\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _drdiv\n        MOV      r9,r0\n        MOV      r11,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        ADR      r10,|L1.1064|\n        LDMIA    r10,{r2,r3}\n        BL       _drsb\n        STMIA    sp,{r0,r1}\n        LDMIA    r10,{r2,r3}\n        MOV      r1,r11\n        MOV      r0,r9\n        BL       _drsb\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       _dmul\n        LDMIA    sp,{r2,r3}\n        BL       _drsb\n        ADD      r2,sp,#8\n        STMIA    r2,{r0,r1}\n|L1.508|\n        ADR      r9,|L1.1064|\n        ADD      r0,r5,r6\n        LDMIA    r9,{r10,r11}\n        STR      r0,[sp,#0x30]\n        CMP      r0,#0\n        BLE      |L1.652|\n        MOV      r0,r5\n        BL       _dflt\n        MOV      r5,r0\n        LDR      r0,[sp,#0x30]\n        MOV      r6,r1\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _drdiv\n        MOV      r5,r0\n        MOV      r6,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        LDMIA    r9,{r2,r3}\n        BL       _drsb\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMIA    r9,{r2,r3}\n        BL       _drsb\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        MOV      r10,r0\n        MOV      r11,r1\n|L1.652|\n        LDR      r0,[sp,#0x34]\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        LDR      r1,[sp,#0x38]\n        LDR      r0,[sp,#0x3c]\n        BL       _drdiv\n        ADD      r3,sp,#8\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r5,r0\n        LDR      r0,[sp,#0x30]\n        MOV      r6,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        LDR      r1,[sp,#0x38]\n        LDR      r0,[sp,#0x3c]\n        BL       _drdiv\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r3,sp,#0x1c\n        LDMIA    r3,{r2,r3}\n        MOV      r5,r0\n        MOV      r6,r1\n        BL       _dcmple\n        BCS      |L1.804|\n        ADD      r1,sp,#0x1c\n        STMIA    r1,{r5,r6}\n        LDR      r0,[sp,#0x14]\n        LDR      r1,[sp,#0x10]\n        STR      r7,[sp,#0x2c]\n        STR      r0,[sp,#0x28]\n        STR      r1,[sp,#0x24]\n|L1.804|\n        LDR      r1,[sp,#0x18]\n        ADD      r1,r1,#1\n        STR      r1,[sp,#0x18]\n        CMP      r1,r4\n        BLT      |L1.224|\n|L1.824|\n        LDR      r0,[sp,#0x40]\n        ADD      r7,r7,#1\n        CMP      r7,r0\n        BLT      |L1.208|\n|L1.840|\n        MOV      r0,#0x18\n        BL       malloc\n        LDR      r1,[sp,#0x2c]\n        ADD      r2,sp,#0x24\n        STR      r1,[r0,#0]\n        LDMIA    r2,{r1,r2}\n        STMIB    r0,{r1,r2}\n        MOV      r11,r0\n        MOV      r9,#0\n        MOV      r10,#0\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.944|\n|L1.892|\n        LDR      r0,[sp,#0x44]\n        ADD      r3,sp,#0x24\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[sp,#0x2c]\n        LDMIA    r3,{r2,r3}\n        ADD      r0,r0,r1,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dcmple\n        ADDCS    r10,r10,#1\n        ADDCC    r9,r9,#1\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        BLT      |L1.892|\n|L1.944|\n        MOV      r6,r9,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r10,LSL #2\n        STR      r0,[sp,#0x18]\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[sp,#0x14]\n        MOV      r0,r6\n        BL       malloc\n        STR      r0,[sp,#0x10]\n        MOV      r0,r5\n        BL       malloc\n        MOV      r6,#0\n        MOV      r7,#0\n        MOV      r5,#0\n        CMP      r4,#0\n        STR      r0,[sp,#0xc]\n        BLE      |L1.1148|\n|L1.1020|\n        LDR      r0,[sp,#0x44]\n        ADD      r3,sp,#0x24\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[sp,#0x2c]\n        LDMIA    r3,{r2,r3}\n        ADD      r0,r0,r1,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dcmple\n        B        |L1.1072|\n|L1.1056|\n        DCFD     0xbff0000000000000\n|L1.1064|\n        DCFD     0x3ff0000000000000\n|L1.1072|\n        LDR      r0,[sp,#0x44]\n        LDR      r0,[r0,r5,LSL #2]\n        BCS      |L1.1112|\n        LDR      r1,[sp,#0x18]\n        STR      r0,[r1,r6,LSL #2]\n        LDR      r0,[r8,r5,LSL #2]\n        LDR      r1,[sp,#0x10]\n        STR      r0,[r1,r6,LSL #2]\n        ADD      r6,r6,#1\n        B        |L1.1136|\n|L1.1112|\n        LDR      r1,[sp,#0x14]\n        STR      r0,[r1,r7,LSL #2]\n        LDR      r0,[r8,r5,LSL #2]\n        LDR      r1,[sp,#0xc]\n        STR      r0,[r1,r7,LSL #2]\n        ADD      r7,r7,#1\n|L1.1136|\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        BLT      |L1.1020|\n|L1.1148|\n        ADD      r3,sp,#0x78\n        LDMIA    r3,{r0,r3}\n        ADD      r2,r0,#1\n        STMIA    sp,{r2,r3}\n        MOV      r4,r2\n        MOV      r2,r9\n        LDR      r0,[sp,#0x18]\n        LDR      r1,[sp,#0x10]\n        LDR      r3,[sp,#0x50]\n        BL       buildTree__FPPdPiiN33\n        STR      r0,[r11,#0xc]\n        LDR      r3,[sp,#0x7c]\n        STR      r4,[sp,#0]\n        STR      r3,[sp,#4]\n        LDR      r3,[sp,#0x50]\n        LDR      r0,[sp,#0x14]\n        LDR      r1,[sp,#0xc]\n        MOV      r2,r10\n        BL       buildTree__FPPdPiiN33\n        STR      r0,[r11,#0x10]\n        ADD      sp,sp,#0x54\n        MOV      r0,r11\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\nclassify__FP4NodePd PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0xc]\n        MOV      r5,r1\n        CMP      r0,#0\n        LDREQ    r0,[r4,#0x14]\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDMIB    r4,{r2,r3}\n        ADD      r0,r5,r0,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dcmple\n        MOVCC    r1,r5\n        LDRCC    r0,[r4,#0xc]\n        LDMCCFD  sp!,{r3-r5,lr}\n        BCC      classify__FP4NodePd\n        MOV      r1,r5\n        LDR      r0,[r4,#0x10]\n        LDMFD    sp!,{r3-r5,lr}\n        B        classify__FP4NodePd\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int feature;\n    double threshold;\n    struct Node *left;\n    struct Node *right;\n    int prediction;\n};\n\n\nstruct Node* buildTree(double** data, int* labels, int rows, int cols, int depth, int maxDepth) {\n    if (rows == 0 || depth == maxDepth) {\n        struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n        node->prediction = 0;\n        int count0 = 0;\n        for (int i = 0; i < rows; i++) {\n            if (labels[i] == 0) count0++;\n        }\n        if (count0 * 2 > rows) node->prediction = 0;\n        else node->prediction = 1;\n        node->left = NULL;\n        node->right = NULL;\n        return node;\n\n    }\n    int bestFeature = -1;\n    double bestThreshold = -1.0;\n    double bestGini = 1.0;\n    for (int f = 0; f < cols - 1; f++) {\n        for (int i = 0; i < rows; i++) {\n            double threshold = data[i][f];\n            int leftCount0 = 0, leftCount1 = 0, rightCount0 = 0, rightCount1 = 0;\n            for (int j = 0; j < rows; j++) {\n                if (data[j][f] < threshold) {\n                    if (labels[j] == 0) leftCount0++;\n                    else leftCount1++;\n                } else {\n                    if (labels[j] == 0) rightCount0++;\n                    else rightCount1++;\n                }\n            }\n            double giniLeft = 1.0;\n            if (leftCount0 + leftCount1 > 0) {\n                double p0 = (double)leftCount0 / (leftCount0 + leftCount1);\n                giniLeft = 1.0 - p0 * p0 - (1.0 - p0) * (1.0 - p0);\n            }\n            double giniRight = 1.0;\n            if (rightCount0 + rightCount1 > 0) {\n                double p0 = (double)rightCount0 / (rightCount0 + rightCount1);\n                giniRight = 1.0 - p0 * p0 - (1.0 - p0) * (1.0 - p0);\n            }\n            double weightedGini = ((double)(leftCount0 + leftCount1) / rows) * giniLeft + ((double)(rightCount0 + rightCount1) / rows) * giniRight;\n\n            if (weightedGini < bestGini) {\n                bestGini = weightedGini;\n                bestFeature = f;\n                bestThreshold = threshold;\n            }\n        }\n    }\n\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->feature = bestFeature;\n    node->threshold = bestThreshold;\n    int leftRows = 0;\n    int rightRows =0;\n    for (int i =0; i < rows; i++) {\n        if (data[i][bestFeature] < bestThreshold) leftRows++;\n        else rightRows++;\n    }\n    double** leftData = (double**)malloc(leftRows * sizeof(double*));\n    double** rightData = (double**)malloc(rightRows * sizeof(double*));\n    int* leftLabels = (int*)malloc(leftRows * sizeof(int));\n    int* rightLabels = (int*)malloc(rightRows * sizeof(int));\n    int leftIndex = 0;\n    int rightIndex = 0;\n    for (int i = 0; i < rows; i++) {\n        if (data[i][bestFeature] < bestThreshold) {\n            leftData[leftIndex] = data[i];\n            leftLabels[leftIndex] = labels[i];\n            leftIndex++;\n        } else {\n            rightData[rightIndex] = data[i];\n            rightLabels[rightIndex] = labels[i];\n            rightIndex++;\n        }\n    }\n    node->left = buildTree(leftData, leftLabels, leftRows, cols, depth + 1, maxDepth);\n    node->right = buildTree(rightData, rightLabels, rightRows, cols, depth + 1, maxDepth);\n\n    return node;\n}\n\n\n\nint classify(struct Node* node, double* data) {\n    if (node->left == NULL) return node->prediction;\n    if (data[node->feature] < node->threshold) return classify(node->left, data);\n    else return classify(node->right, data);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FUxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        BEQ      |L1.108|\n|L1.44|\n        MOV      r8,r4\n        MOV      r9,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_udiv\n        MOV      r4,r2\n        MOV      r5,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r8\n        MOV      r7,r9\n        BNE      |L1.44|\n|L1.108|\n        MOV      r0,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n\npow_mod__FUxN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r4,r2\n        ADR      r2,|L1.372|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.372|\n        LDMIA    r2,{r8,r9}\n        MOV      r5,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r6,r2\n        MOV      r7,r3\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BLS      |L1.356|\n|L1.208|\n        ADR      r0,|L1.380|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _ll_udiv\n        MOV      r0,r2\n        ADR      r2,|L1.372|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.288|\n        UMULL    r0,r12,r8,r6\n        MLA      r12,r6,r9,r12\n        MLA      r1,r7,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.288|\n        UMULL    r0,r12,r6,r6\n        MLA      r12,r6,r7,r12\n        MLA      r1,r7,r6,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r0,r4,LSR #1\n        ORR      r4,r0,r5,LSL #31\n        ADR      r0,|L1.124|\n        MOV      r6,r2\n        MOV      r7,r3\n        LDMIA    r0,{r2,r3}\n        MOV      r5,r5,LSR #1\n        CMP      r5,r3\n        MOV      r0,r4\n        CMPEQ    r0,r2\n        BHI      |L1.208|\n|L1.356|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.372|\n        DCQ      0x0000000000000001\n|L1.380|\n        DCQ      0x0000000000000002\n        ENDP\n\nextended_gcd__FUxT1PUxT3 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#0x18\n        ADD      r7,sp,#0x38\n        LDMIA    r7,{r6,r7}\n        ADR      r10,|L1.124|\n        MOV      r9,r3\n        MOV      r8,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r5,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r4,r0\n        BNE      |L1.488|\n        LDMIA    r10,{r0,r1}\n        STMIA    r6,{r0,r1}\n        ADR      r0,|L1.372|\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[r7,#4]\n        STR      r1,[r7,#0]\n        ADD      sp,sp,#0x18\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.488|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _ll_udiv\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r0,r2\n        MOV      r1,r3\n        ADD      r3,sp,#8\n        ADD      r2,sp,#0x10\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       extended_gcd__FUxT1PUxT3\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        MOV      r4,r0\n        UMULL    r0,r12,r8,r2\n        MLA      r12,r2,r9,r12\n        MOV      r5,r1\n        ADD      r1,sp,#8\n        MOV      r2,r0\n        LDMIA    r1,{r0,r1}\n        SUBS     r0,r0,r2\n        MLA      r3,r8,r3,r12\n        SBC      r1,r1,r3\n        STMIA    r6,{r0,r1}\n        ADD      r1,sp,#0x10\n        LDMIA    r1,{r0,r1}\n        STMIA    r7,{r0,r1}\n        ADD      sp,sp,#0x18\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\nmodInverse__FUxT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c\n        MOV      r5,r3\n        MOV      r4,r2\n        ADD      r2,sp,#0x14\n        ADD      r3,sp,#0xc\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       extended_gcd__FUxT1PUxT3\n        ADR      r2,|L1.372|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        ADRNE    r1,|L1.124|\n        LDMNEIA  r1,{r0,r1}\n        ADDNE    sp,sp,#0x1c\n        LDMNEFD  sp!,{r4,r5,lr}\n        BXNE     lr\n        ADD      r1,sp,#0x14\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_udiv\n        ADDS     r0,r2,r4\n        ADC      r1,r3,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_udiv\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r2\n        MOV      r1,r3\n        BX       lr\n        ENDP\n\nrsa_encrypt__FUxN21 PROC\n        STR      lr,[sp,#-4]!\n        SUB      sp,sp,#0xc\n        ADD      lr,sp,#0x10\n        LDMIA    lr,{r12,lr}\n        STMIA    sp,{r12,lr}\n        BL       pow_mod__FUxN21\n        ADD      sp,sp,#0xc\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nrsa_decrypt__FUxN21 PROC\n        STR      lr,[sp,#-4]!\n        SUB      sp,sp,#0xc\n        ADD      lr,sp,#0x10\n        LDMIA    lr,{r12,lr}\n        STMIA    sp,{r12,lr}\n        BL       pow_mod__FUxN21\n        ADD      sp,sp,#0xc\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned long long ull;\n\null gcd(ull a, ull b) {\n    while (b) {\n        ull t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\null pow_mod(ull base, ull exp, ull mod) {\n    ull res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\null extended_gcd(ull a, ull b, ull *x, ull *y) {\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    ull x1, y1;\n    ull d = extended_gcd(b % a, a, &x1, &y1);\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return d;\n}\n\null modInverse(ull n, ull mod) {\n    ull x, y;\n    ull g = extended_gcd(n, mod, &x, &y);\n    if (g != 1) return 0;\n    return (x % mod + mod) % mod;\n}\n\n\null rsa_encrypt(ull message, ull e, ull n) {\n    return pow_mod(message, e, n);\n}\n\null rsa_decrypt(ull ciphertext, ull d, ull n) {\n    return pow_mod(ciphertext, d, n);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmaxPathSum__FP8TreeNodePi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,r6\n        LDR      r0,[r4,#4]\n        BL       maxPathSum__FP8TreeNodePi\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        MOV      r1,r6\n        BL       maxPathSum__FP8TreeNodePi\n        CMP      r5,r0\n        LDR      r2,[r4,#0]\n        MOVLE    r1,r0\n        MOVGT    r1,r5\n        ADD      r1,r2,r1\n        LDR      r2,[r6,#0]\n        CMP      r2,r1\n        STRLT    r1,[r6,#0]\n        CMP      r5,#0\n        MOVLE    r5,#0\n        LDR      r1,[r4,#0]\n        CMP      r0,#0\n        ADD      r1,r1,r5\n        LDMFD    sp!,{r4-r6,lr}\n        MOVLE    r0,#0\n        ADD      r0,r1,r0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint maxPathSum(TreeNode* root, int* max_sum) {\n    if (root == NULL) {\n        return 0;\n    }\n\n    int leftSum = maxPathSum(root->left, max_sum);\n    int rightSum = maxPathSum(root->right, max_sum);\n\n    int currentSum = root->val + (leftSum > rightSum ? leftSum : rightSum);\n    \n    if (currentSum > *max_sum) {\n        *max_sum = currentSum;\n    }\n    \n    return root->val + (leftSum > 0 ? leftSum : 0) + (rightSum > 0 ? rightSum : 0);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintBoundaryLeft__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BEQ      |L1.92|\n        ADR      r0,|L1.132|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#4]\n        LDMFD    sp!,{r4,lr}\n        B        printBoundaryLeft__FP4Node\n|L1.92|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.132|\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        printBoundaryLeft__FP4Node\n|L1.132|\n        DCB      \"%d \\0\"\n        ENDP\n\nprintBoundaryRight__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BEQ      |L1.184|\n        BL       printBoundaryRight__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.132|\n        B        _printf\n|L1.184|\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        BL       printBoundaryRight__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.132|\n        B        _printf\n        ENDP\n\nprintLeaves__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r0,[r4,#8]\n        CMPEQ    r0,#0\n        BNE      |L1.268|\n        ADR      r0,|L1.132|\n        LDR      r1,[r4,#0]\n        BL       _printf\n|L1.268|\n        LDR      r0,[r4,#4]\n        BL       printLeaves__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        printLeaves__FP4Node\n        ENDP\n\nprintBoundary__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.132|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       printBoundaryLeft__FP4Node\n        LDR      r0,[r4,#4]\n        BL       printLeaves__FP4Node\n        LDR      r0,[r4,#8]\n        BL       printLeaves__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        printBoundaryRight__FP4Node\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nvoid printBoundaryLeft(struct Node* root) {\n    if (root == NULL) return;\n    if (root->left) {\n        printf(\"%d \", root->data);\n        printBoundaryLeft(root->left);\n    } else if (root->right) {\n        printf(\"%d \", root->data);\n        printBoundaryLeft(root->right);\n    }\n}\n\nvoid printBoundaryRight(struct Node* root) {\n    if (root == NULL) return;\n    if (root->right) {\n        printBoundaryRight(root->right);\n        printf(\"%d \", root->data);\n    } else if (root->left) {\n        printBoundaryRight(root->left);\n        printf(\"%d \", root->data);\n    }\n}\n\n\nvoid printLeaves(struct Node* root) {\n    if(root == NULL) return;\n    if(root->left == NULL && root->right == NULL){\n        printf(\"%d \", root->data);\n    }\n    printLeaves(root->left);\n    printLeaves(root->right);\n}\n\nvoid printBoundary(struct Node* root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    printBoundaryLeft(root->left);\n    printLeaves(root->left);\n    printLeaves(root->right);\n    printBoundaryRight(root->right);\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        ADD      r2,r0,r0,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        MOV      r1,#0\n        BLE      |L1.76|\n        SUB      r0,r0,#1\n|L1.36|\n        LDRB     r2,[r4,r1]\n        SUB      r12,r0,r1\n        LDRB     r12,[r4,r12]\n        CMP      r2,r12\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r1,r1,#1\n        CMP      r3,r1\n        BGT      |L1.36|\n|L1.76|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isPalindrome(char* str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfloydWarshall__FPA100_ii PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x9c00\n        SUB      sp,sp,#0x44\n        ADD      r11,sp,#4\n        MOV      r6,r1\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.92|\n|L1.32|\n        MOV      r1,#0\n        CMP      r6,#0\n        BLE      |L1.80|\n        ADD      lr,r2,r2,LSL #3\n        ADD      lr,lr,r2,LSL #4\n        ADD      r3,r11,lr,LSL #4\n        ADD      r4,r0,lr,LSL #4\n|L1.60|\n        LDR      lr,[r4,r1,LSL #2]\n        STR      lr,[r3,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,r6\n        BLT      |L1.60|\n|L1.80|\n        ADD      r2,r2,#1\n        CMP      r2,r6\n        BLT      |L1.32|\n|L1.92|\n        CMP      r6,#0\n        ADDLE    sp,sp,#0x9c00\n        ADDLE    sp,sp,#0x44\n        MOV      r7,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n        ADR      r10,|L1.284|\n|L1.120|\n        MOV      r8,#0\n        CMP      r6,#0\n        BLE      |L1.256|\n        ADD      r0,r7,r7,LSL #3\n        ADD      r0,r0,r7,LSL #4\n        ADD      r9,r11,r0,LSL #4\n|L1.144|\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.244|\n        ADD      r0,r8,r8,LSL #3\n        ADD      r0,r0,r8,LSL #4\n        ADD      r5,r11,r0,LSL #4\n|L1.168|\n        LDR      r0,[r5,r7,LSL #2]\n        BL       _dflt\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpeq\n        BEQ      |L1.232|\n        LDR      r0,[r9,r4,LSL #2]\n        BL       _dflt\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpeq\n        BEQ      |L1.232|\n        LDR      r0,[r5,r7,LSL #2]\n        LDR      r1,[r9,r4,LSL #2]\n        ADD      r0,r0,r1\n        LDR      r1,[r5,r4,LSL #2]\n        CMP      r0,r1\n        STRLT    r0,[r5,r4,LSL #2]\n|L1.232|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.168|\n|L1.244|\n        ADD      r8,r8,#1\n        CMP      r8,r6\n        BLT      |L1.144|\n|L1.256|\n        ADD      r7,r7,#1\n        CMP      r7,r6\n        BLT      |L1.120|\n        ADD      sp,sp,#0x9c00\n        ADD      sp,sp,#0x44\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.284|\n        DCFD     0x41cdcd6500000000\n        ENDP\n```",
        "output": "```cpp\n\n#define INF 1e9\n\nvoid floydWarshall(int graph[][100], int n) {\n    int dist[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = graph[i][j];\n        }\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    \n    //The resulting shortest paths are stored in dist[][]\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nunique_elements__FPiiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        MOV      lr,#0\n        MOV      r5,#0\n        MOV      r12,#0\n        CMP      r1,#0\n        BLE      |L1.108|\n|L1.24|\n        MOV      r6,#1\n        MOV      r3,#0\n        CMP      r12,#0\n        BLE      |L1.76|\n        LDR      r4,[r0,lr,LSL #2]\n|L1.44|\n        LDR      r7,[r2,r3,LSL #2]\n        CMP      r4,r7\n        BEQ      |L1.96|\n        ADD      r3,r3,#1\n        CMP      r3,r12\n        BLT      |L1.44|\n        CMP      r6,#0\n        BEQ      |L1.96|\n|L1.76|\n        LDR      r4,[r0,lr,LSL #2]\n        MOV      r3,r5\n        STR      r4,[r2,r3,LSL #2]\n        ADD      r5,r5,#1\n        ADD      r12,r12,#1\n|L1.96|\n        ADD      lr,lr,#1\n        CMP      lr,r1\n        BLT      |L1.24|\n|L1.108|\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\nint unique_elements(int arr[], int size, int unique[]) {\n    int count = 0;\n    int unique_index = 0;\n    for (int i = 0; i < size; i++) {\n        int is_unique = 1;\n        for (int j = 0; j < count; j++) {\n            if (arr[i] == unique[j]) {\n                is_unique = 0;\n                break;\n            }\n        }\n        if (is_unique) {\n            unique[unique_index++] = arr[i];\n            count++;\n        }\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndayOfWeek__F4Date PROC\n|L1.0|\n        CMP      r1,#1\n        CMPNE    r1,#2\n        LDR      r3,|L1.216|\n        SUBEQ    r0,r0,#1\n        STR      lr,[sp,#-4]!\n        SMULL    lr,r12,r3,r0\n        MOV      r12,r12,ASR #5\n        SUB      r12,r12,r12,ASR #31\n        SUB      r12,r12,r12,LSL #1\n        ADD      r12,r12,r12,LSL #2\n        ADD      r12,r12,r12,LSL #2\n        ADD      lr,r0,r12,LSL #2\n        SMULL    r12,r0,r3,r0\n        ADDEQ    r1,r1,#0xc\n        ADD      r12,r1,r1,LSL #2\n        ADD      r1,r12,r1,LSL #3\n        ADD      r3,r1,#0xd\n        LDR      r1,|L1.220|\n        MOV      r0,r0,ASR #5\n        SMULL    r12,r3,r1,r3\n        MOV      r1,r3,ASR #1\n        SUB      r1,r1,r1,ASR #31\n        ADD      r1,r1,r2\n        MOV      r2,lr,ASR #31\n        ADD      r2,lr,r2,LSR #30\n        ADD      r1,r1,lr\n        ADD      r1,r1,r2,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        MOV      r2,r0,ASR #31\n        ADD      r2,r0,r2,LSR #30\n        ADD      r1,r1,r2,ASR #2\n        SUB      r1,r1,r0,LSL #1\n        LDR      r2,|L1.224|\n        MOV      r0,r1\n        MOV      r3,#0\n        SMLAL    r3,r0,r2,r1\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #3\n        ADD      r0,r0,r1\n        CMP      r0,#0\n        LDR      lr,[sp],#4\n        ADDLT    r0,r0,#7\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Date {\n    int year;\n    int month;\n    int day;\n};\n\nint dayOfWeek(Date date) {\n    if (date.month == 1 || date.month == 2) {\n        date.year--;\n        date.month += 12;\n    }\n    int q = date.day;\n    int m = date.month;\n    int K = date.year % 100;\n    int J = date.year / 100;\n    int h = q + ((13 * (m + 1)) / 5) + K + (K / 4) + (J / 4) - (2 * J);\n    h %= 7;\n    return (h < 0) ? (h + 7) : h;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndecimalToBinary__FUi PROC\n        MOV      r2,#0\n        MOV      r1,#1\n        CMP      r0,#0\n        BEQ      |L1.40|\n|L1.16|\n        AND      r3,r0,#1\n        MLA      r2,r1,r3,r2\n        ADD      r1,r1,r1,LSL #2\n        MOV      r1,r1,LSL #1\n        MOVS     r0,r0,LSR #1\n        BNE      |L1.16|\n|L1.40|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int decimalToBinary(unsigned int decimal) {\n    unsigned int binary = 0;\n    unsigned int power = 1;\n    while (decimal > 0) {\n        binary += (decimal % 2) * power;\n        power *= 10;\n        decimal /= 2;\n    }\n    return binary;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountOccurrences__FPCcc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r4,#0\n        BL       strlen\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.56|\n|L1.32|\n        LDRB     r2,[r5,r1]\n        ADD      r1,r1,#1\n        CMP      r2,r6\n        ADDEQ    r4,r4,#1\n        CMP      r1,r0\n        BLT      |L1.32|\n|L1.56|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countOccurrences(const char* str, char ch) {\n    int count = 0;\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateCNN__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xfa0\n        BL       malloc\n        MOV      r4,r0\n        MOV      r1,#0xfa0\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nfreeCNN__FP3CNN PROC\n        B        free\n        ENDP\n\nstyleTransfer__FP3CNNPcN22 PROC\n        CMP      r0,#0\n        ADRNE    r0,|L1.56|\n        BNE      _printf\n        BX       lr\n|L1.56|\n        DCB      \"%s %\"\n        DCB      \"s %s\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n// Placeholder for CNN implementation.  Replace with actual CNN library.\ntypedef struct {\n    int data[1000]; //replace with actual data structure\n} CNN;\n\nCNN* createCNN() {\n    CNN* cnn = (CNN*)malloc(sizeof(CNN));\n    memset(cnn->data, 0, sizeof(cnn->data));\n    return cnn;\n}\n\n\nvoid freeCNN(CNN* cnn) {\n    free(cnn);\n}\n\n\n// Placeholder for style transfer function. Replace with actual implementation using CNN.\nvoid styleTransfer(CNN* cnn, char* inputImage, char* styleImage, char* outputImage) {\n    // Replace this with actual style transfer logic using the CNN\n    if(cnn == 0) return;\n    printf(\"%s %s %s\\n\", inputImage, styleImage, outputImage);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsearch__FPiiN22 PROC\n        CMP      r1,r2\n        BGT      |L1.76|\n|L1.48|\n        LDR      r12,[r0,r1,LSL #2]\n        CMP      r12,r3\n        MOVEQ    r0,r1\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLE      |L1.48|\n|L1.76|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nbuildTree__FPiT1iT3 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r8,r0\n        MOV      r7,r1\n        MOV      r6,r3\n        MOV      r5,r2\n        CMP      r2,r3\n        LDMGTFD  sp!,{r3-r9,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r1,|L1.348|\n        LDR      r0,[r1,#0]  ; preIndex@buildTree__FPiT1iT3_0\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; preIndex@buildTree__FPiT1iT3_0\n        LDR      r0,[r7,r0,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        CMP      r5,r6\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r8\n        LDR      r3,[r4,#0]\n        BL       search__FPiiN22\n        MOV      r9,r0\n        SUB      r3,r0,#1\n        MOV      r0,r8\n        MOV      r2,r5\n        MOV      r1,r7\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#4]\n        MOV      r0,r8\n        MOV      r3,r6\n        ADD      r2,r9,#1\n        MOV      r1,r7\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nint search(int arr[], int strt, int end, int value) {\n    for (int i = strt; i <= end; i++) {\n        if (arr[i] == value)\n            return i;\n    }\n    return -1;\n}\n\n\nstruct Node* buildTree(int in[], int pre[], int inStrt, int inEnd) {\n    static int preIndex = 0;\n    if (inStrt > inEnd)\n        return NULL;\n\n    struct Node* tNode = newNode(pre[preIndex++]);\n\n    if (inStrt == inEnd)\n        return tNode;\n\n    int inIndex = search(in, inStrt, inEnd, tNode->data);\n\n    tNode->left = buildTree(in, pre, inStrt, inIndex - 1);\n    tNode->right = buildTree(in, pre, inIndex + 1, inEnd);\n\n    return tNode;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninit_graph__FP5Graph PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        ADD      r0,r0,#0x10000\n        ADD      r0,r0,#0x3880\n        MOV      r2,#0x190\n        MVN      r1,#0\n        BL       __rt_memset\n        MOV      r1,#0xa10\n        ADD      r1,r1,#0x13000\n        MOV      r0,#0\n        STR      r0,[r1,r4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP5GraphiT2 PROC\n        MOV      r3,r2\n        ADD      r2,r0,#0x13000\n        LDR      r12,[r2,#0xa10]\n        ADD      r1,r0,r1,LSL #2\n        STR      r3,[r0,r12,LSL #3]\n        LDR      r12,[r2,#0xa10]\n        ADD      r1,r1,#0x13000\n        LDR      r3,[r1,#0x880]\n        ADD      r0,r0,r12,LSL #3\n        STR      r3,[r0,#4]\n        LDR      r0,[r2,#0xa10]\n        STR      r0,[r1,#0x880]\n        LDR      r0,[r2,#0xa10]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xa10]\n        BX       lr\n        ENDP\n\nbfs__FP5GraphiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x190\n        STR      r1,[sp,#0]\n        MOV      r4,#1\n        STR      r4,[r2,r1,LSL #2]\n        MOV      r5,sp\n        MOV      lr,#0\n        MOV      r12,#1\n|L1.148|\n        MOV      r1,lr\n        LDR      r1,[r5,r1,LSL #2]\n        ADD      lr,lr,#1\n        ADD      r1,r0,r1,LSL #2\n        ADD      r1,r1,#0x13000\n        LDR      r1,[r1,#0x880]\n        CMN      r1,#1\n        BEQ      |L1.232|\n|L1.180|\n        LDR      r3,[r0,r1,LSL #3]\n        LDR      r6,[r2,r3,LSL #2]\n        CMP      r6,#0\n        BNE      |L1.216|\n        STR      r4,[r2,r3,LSL #2]\n        LDR      r6,[r0,r1,LSL #3]\n        MOV      r3,r12\n        STR      r6,[r5,r3,LSL #2]\n        ADD      r12,r12,#1\n|L1.216|\n        ADD      r1,r0,r1,LSL #3\n        LDR      r1,[r1,#4]\n        CMN      r1,#1\n        BNE      |L1.180|\n|L1.232|\n        CMP      lr,r12\n        BLT      |L1.148|\n        ADD      sp,sp,#0x190\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertex;\n    int next;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_VERTICES * MAX_VERTICES];\n    int head[MAX_VERTICES];\n    int num_edges;\n} Graph;\n\nvoid init_graph(Graph *g) {\n    memset(g->head, -1, sizeof(g->head));\n    g->num_edges = 0;\n}\n\nvoid add_edge(Graph *g, int u, int v) {\n    g->edges[g->num_edges].vertex = v;\n    g->edges[g->num_edges].next = g->head[u];\n    g->head[u] = g->num_edges;\n    g->num_edges++;\n}\n\nvoid bfs(Graph *g, int start_node, int* visited) {\n    int queue[MAX_VERTICES];\n    int head = 0;\n    int tail = 0;\n\n    queue[tail++] = start_node;\n    visited[start_node] = 1;\n\n    while (head < tail) {\n        int u = queue[head++];\n        int v = g->head[u];\n        while (v != -1) {\n            if (!visited[g->edges[v].vertex]) {\n                visited[g->edges[v].vertex] = 1;\n                queue[tail++] = g->edges[v].vertex;\n            }\n            v = g->edges[v].next;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_digits__Fi PROC\n        CMP      r0,#0\n        RSBLT    r0,r0,#0\n        CMP      r0,#0\n        MOV      r1,#0\n        BLE      |L1.72|\n        LDR      r3,|L1.120|\n|L1.24|\n        SMULL    r12,r2,r3,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r0,r2,LSL #1\n        ADD      r1,r2,r1\n        SMULL    r2,r0,r3,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        CMP      r0,#0\n        BGT      |L1.24|\n|L1.72|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_digits(int n) {\n    int sum = 0;\n    if (n < 0) n = -n;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nrangeSearch__FP4NodeiT2Pi PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLT      |L1.664|\n        CMP      r0,r6\n        LDRLE    r0,[r7,#0]\n        ADDLE    r0,r0,#1\n        STRLE    r0,[r7,#0]\n|L1.664|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.696|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       rangeSearch__FP4NodeiT2Pi\n|L1.696|\n        LDR      r0,[r4,#0]\n        CMP      r0,r6\n        LDMGEFD  sp!,{r4-r7,lr}\n        BXGE     lr\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4-r7,lr}\n        B        rangeSearch__FP4NodeiT2Pi\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    Node *left, *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return (node);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\nvoid rangeSearch(Node* root, int min, int max, int* count) {\n    if (root == NULL) return;\n    if (root->key >= min && root->key <= max) (*count)++;\n    if (root->key > min) rangeSearch(root->left, min, max, count);\n    if (root->key < max) rangeSearch(root->right, min, max, count);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npostOrderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x324\n        MOV      r1,r0\n        STR      r1,[sp,#0x194]\n        MOV      r0,#0\n        ADD      r3,sp,#0x194\n        ADD      r5,sp,#4\n        MVN      r4,#0\n|L1.80|\n        MOV      r1,r0\n        LDR      r1,[r3,r1,LSL #2]\n        ADD      r4,r4,#1\n        STR      r1,[r5,r4,LSL #2]\n        LDR      r2,[r1,#4]\n        SUB      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r0,r0,#1\n        STRNE    r2,[r3,r0,LSL #2]\n        LDR      r1,[r1,#8]\n        CMP      r1,#0\n        ADDNE    r0,r0,#1\n        STRNE    r1,[r3,r0,LSL #2]\n        CMP      r0,#0\n        BGE      |L1.80|\n        CMP      r4,#0\n        ADDLT    sp,sp,#0x324\n        LDMLTFD  sp!,{r4,r5,lr}\n        BXLT     lr\n|L1.156|\n        MOV      r0,r4\n        LDR      r0,[r5,r0,LSL #2]\n        SUB      r4,r4,#1\n        LDR      r1,[r0,#0]\n        ADR      r0,|L1.200|\n        BL       _printf\n        CMP      r4,#0\n        BGE      |L1.156|\n        ADD      sp,sp,#0x324\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.200|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\ntypedef struct Node Node;\n\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nvoid postOrderIterative(Node* root) {\n    if (root == NULL)\n        return;\n\n    struct Node* stack1[100];\n    struct Node* stack2[100];\n    int top1 = -1;\n    int top2 = -1;\n\n    stack1[++top1] = root;\n    while (top1 >= 0) {\n        Node* node = stack1[top1--];\n        stack2[++top2] = node;\n\n        if (node->left)\n            stack1[++top1] = node->left;\n        if (node->right)\n            stack1[++top1] = node->right;\n    }\n    while (top2 >= 0) {\n        printf(\"%d \", stack2[top2--]->data);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntoLower__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        LDMLSFD  sp!,{r3-r5,lr}\n        BXLS     lr\n|L1.40|\n        LDRB     r0,[r5,r4]\n        BL       tolower\n        STRB     r0,[r5,r4]\n        ADD      r4,r4,#1\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,r4\n        BHI      |L1.40|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid toLower(char* str) {\n    if (str == 0) return;\n    for (int i = 0; i < strlen(str); i++) {\n        str[i] = tolower(str[i]);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nlevelOrder__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        ADD      r7,sp,#4\n        STR      r0,[sp,#4]\n        MOV      r6,#0\n        MOV      r4,#1\n|L1.76|\n        MOV      r0,r6\n        LDR      r5,[r7,r0,LSL #2]\n        ADR      r0,|L1.164|\n        ADD      r6,r6,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r1,[r5,#4]\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        LDR      r1,[r5,#8]\n        ADDNE    r4,r4,#1\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        ADDNE    r4,r4,#1\n        CMP      r6,r4\n        BNE      |L1.76|\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.164|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid levelOrder(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* queue[1000];\n    int front = 0, rear = 0;\n\n    queue[rear++] = root;\n\n    while (front != rear) {\n        struct Node* node = queue[front++];\n        printf(\"%d \", node->data);\n\n        if (node->left != NULL)\n            queue[rear++] = node->left;\n\n        if (node->right != NULL)\n            queue[rear++] = node->right;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheuristic__FiN31 PROC\n|L1.0|\n        SUB      r0,r0,r2\n        CMP      r0,#0\n        RSBLT    r0,r0,#0\n        SUB      r1,r1,r3\n        CMP      r1,#0\n        RSBLT    r1,r1,#0\n        ADD      r0,r0,r1\n        BX       lr\n        ENDP\n\ncreateNode__FiN31P4Node PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r0,#0x18\n        LDR      r6,[sp,#0x18]\n        MOV      r8,r1\n        MOV      r5,r3\n        MOV      r4,r2\n        BL       malloc\n        ADD      r1,r0,#0xc\n        STMIA    r1,{r4,r5}\n        ADD      r1,r4,r5\n        STR      r1,[r0,#8]\n        STR      r6,[r0,#0x14]\n        STMIA    r0,{r7,r8}\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\naStar__FiN51PPi PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x2c\n        ADD      r3,sp,#0x34\n        LDMIA    r3,{r2,r3}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       heuristic__FiN31\n        MOV      r3,#0\n        STR      r3,[sp,#0]\n        MOV      r3,r0\n        MOV      r0,r4\n        MOV      r2,#0\n        MOV      r1,r5\n        BL       createNode__FiN31P4Node\n        MOV      r3,#0\n        STR      r3,[sp,#0]\n        MOV      r5,r0\n        ADD      r1,sp,#0x34\n        LDMIA    r1,{r0,r1}\n        MOV      r2,#0\n        BL       createNode__FiN31P4Node\n        ADD      r1,sp,#0x60\n        LDMIA    r1,{r0,r1}\n        MUL      r0,r1,r0\n        MOV      r4,r0,LSL #2\n        MOV      r0,r4\n        BL       malloc\n        MOV      r7,r0\n        STR      r5,[r0,#0]\n        MOV      r0,r4\n        MOV      r6,#1\n        BL       malloc\n        MOV      r11,#0\n        STR      r0,[sp,#0x28]\n|L1.232|\n        LDR      r0,[r7,#0]\n        MOV      r1,#1\n        LDR      r3,[r0,#8]\n        MOV      r0,#0\n        CMP      r6,#1\n        BLE      |L1.288|\n|L1.256|\n        LDR      r2,[r7,r1,LSL #2]\n        LDR      r2,[r2,#8]\n        CMP      r2,r3\n        MOVLT    r0,r1\n        ADD      r1,r1,#1\n        MOVLT    r3,r2\n        CMP      r1,r6\n        BLT      |L1.256|\n|L1.288|\n        ADD      r1,r7,r6,LSL #2\n        LDR      r1,[r1,#-4]\n        LDR      r8,[r7,r0,LSL #2]\n        STR      r1,[r7,r0,LSL #2]\n        LDR      r0,[r8,#0]\n        LDR      r1,[sp,#0x34]\n        SUB      r6,r6,#1\n        CMP      r0,r1\n        LDREQ    r0,[r8,#4]\n        LDREQ    r1,[sp,#0x38]\n        CMPEQ    r0,r1\n        BNE      |L1.368|\n        MOV      r0,r7\n        BL       free\n        LDR      r0,[sp,#0x28]\n        BL       free\n        MOV      r0,r8\n        ADD      sp,sp,#0x3c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.368|\n        LDR      r2,[sp,#0x28]\n        MOV      r0,r11\n        STR      r8,[r2,r0,LSL #2]\n        LDR      r1,|L1.956|\n        ADD      r0,sp,#0x18\n        LDMIA    r1,{r2-r5}\n        STMIA    r0,{r2-r5}\n        LDR      r1,|L1.960|\n        ADD      lr,sp,#8\n        LDMIA    r1,{r2-r5}\n        STMIA    lr,{r2-r5}\n        ADD      r11,r11,#1\n        MOV      r9,#0\n|L1.420|\n        ADD      r1,sp,#0x18\n        LDR      r1,[r1,r9,LSL #2]\n        LDR      r0,[r8,#0]\n        ADD      lr,sp,#8\n        ADD      r4,r0,r1\n        LDR      r0,[r8,#4]\n        LDR      r1,[lr,r9,LSL #2]\n        CMP      r4,#0\n        ADD      r5,r0,r1\n        BLT      |L1.732|\n        LDR      r0,[sp,#0x60]\n        CMP      r4,r0\n        BGE      |L1.732|\n        CMP      r5,#0\n        BLT      |L1.732|\n        LDR      r0,[sp,#0x64]\n        CMP      r5,r0\n        BGE      |L1.732|\n        LDR      r0,[sp,#0x68]\n        LDR      r0,[r0,r4,LSL #2]\n        LDR      r0,[r0,r5,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.732|\n        LDR      r0,[r8,#0xc]\n        ADD      r3,sp,#0x34\n        ADD      r1,r0,#1\n        STR      r1,[sp,#4]\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       heuristic__FiN31\n        LDR      r1,[sp,#4]\n        MOV      r3,r0\n        ADD      r10,r1,r0\n        MOV      r2,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        STR      r8,[sp,#0]\n        BL       createNode__FiN31P4Node\n        MOV      r12,#0\n        MOV      r1,#0\n        CMP      r6,#0\n        BLE      |L1.644|\n|L1.592|\n        LDR      r2,[r7,r1,LSL #2]\n        LDR      r3,[r2,#0]\n        CMP      r3,r4\n        LDREQ    r3,[r2,#4]\n        CMPEQ    r3,r5\n        BNE      |L1.632|\n        LDR      r2,[r2,#8]\n        CMP      r2,r10\n        MOVLE    r12,#1\n        BLE      |L1.644|\n|L1.632|\n        ADD      r1,r1,#1\n        CMP      r1,r6\n        BLT      |L1.592|\n|L1.644|\n        MOV      lr,#0\n        MOV      r1,#0\n        CMP      r11,#0\n        BLE      |L1.716|\n|L1.660|\n        LDR      r2,[sp,#0x28]\n        LDR      r2,[r2,r1,LSL #2]\n        LDR      r3,[r2,#0]\n        CMP      r3,r4\n        LDREQ    r3,[r2,#4]\n        CMPEQ    r3,r5\n        BNE      |L1.704|\n        LDR      r2,[r2,#8]\n        CMP      r2,r10\n        MOVLE    lr,#1\n        BLE      |L1.716|\n|L1.704|\n        ADD      r1,r1,#1\n        CMP      r1,r11\n        BLT      |L1.660|\n|L1.716|\n        ORRS     r1,r12,lr\n        MOVEQ    r1,r6\n        STREQ    r0,[r7,r1,LSL #2]\n        ADDEQ    r6,r6,#1\n|L1.732|\n        ADD      r9,r9,#1\n        CMP      r9,#4\n        BLT      |L1.420|\n        CMP      r6,#0\n        BGT      |L1.232|\n        MOV      r0,r7\n        BL       free\n        LDR      r0,[sp,#0x28]\n        BL       free\n        ADD      sp,sp,#0x3c\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int x, y;\n    int f, g, h;\n    struct Node* parent;\n};\n\nint heuristic(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nstruct Node* createNode(int x, int y, int g, int h, struct Node* parent) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->x = x;\n    node->y = y;\n    node->g = g;\n    node->h = h;\n    node->f = g + h;\n    node->parent = parent;\n    return node;\n}\n\n\nstruct Node* aStar(int startX, int startY, int endX, int endY, int width, int height, int** grid) {\n    struct Node* startNode = createNode(startX, startY, 0, heuristic(startX, startY, endX, endY), 0);\n    struct Node* endNode = createNode(endX, endY, 0, 0, 0);\n\n    struct Node** openList = (struct Node**)malloc(sizeof(struct Node*) * (width * height));\n    int openListCount = 0;\n    openList[openListCount++] = startNode;\n\n    struct Node** closedList = (struct Node**)malloc(sizeof(struct Node*) * (width * height));\n    int closedListCount = 0;\n\n\n    while (openListCount > 0) {\n        int lowestF = openList[0]->f;\n        int lowestIndex = 0;\n        for (int i = 1; i < openListCount; i++) {\n            if (openList[i]->f < lowestF) {\n                lowestF = openList[i]->f;\n                lowestIndex = i;\n            }\n        }\n        struct Node* currentNode = openList[lowestIndex];\n        openList[lowestIndex] = openList[openListCount - 1];\n        openListCount--;\n\n        if (currentNode->x == endX && currentNode->y == endY) {\n            free(openList);\n            free(closedList);\n            return currentNode;\n        }\n\n        closedList[closedListCount++] = currentNode;\n\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; i++) {\n            int newX = currentNode->x + dx[i];\n            int newY = currentNode->y + dy[i];\n\n            if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newX][newY] == 0) {\n                int g = currentNode->g + 1;\n                int h = heuristic(newX, newY, endX, endY);\n                int f = g + h;\n\n                struct Node* newNode = createNode(newX, newY, g, h, currentNode);\n                int inOpenList = 0;\n                for (int j = 0; j < openListCount; j++) {\n                    if (openList[j]->x == newX && openList[j]->y == newY && openList[j]->f <= f) {\n                        inOpenList = 1;\n                        break;\n                    }\n                }\n                int inClosedList = 0;\n                for (int j = 0; j < closedListCount; j++) {\n                    if (closedList[j]->x == newX && closedList[j]->y == newY && closedList[j]->f <= f) {\n                        inClosedList = 1;\n                        break;\n                    }\n                }\n                if (!inOpenList && !inClosedList) {\n                    openList[openListCount++] = newNode;\n                }\n            }\n        }\n    }\n    free(openList);\n    free(closedList);\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_graph__Fi PROC\n        MUL      r1,r0,r0\n        MOV      r0,r1,LSL #2\n        B        malloc\n        ENDP\n\nadd_edge__FPiiN22 PROC\n        STR      lr,[sp,#-4]!\n        MLA      lr,r3,r1,r2\n        MOV      r12,#1\n        STR      r12,[r0,lr,LSL #2]\n        MLA      r1,r3,r2,r1\n        STR      r12,[r0,r1,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ndfs__FPiiT2T1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r0,#1\n        STR      r0,[r3,r2,LSL #2]\n        MOV      r8,r2\n        MOV      r6,r3\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n|L1.88|\n        MLA      r0,r5,r8,r4\n        LDR      r0,[r7,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.136|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.136|\n        MOV      r3,r6\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r7\n        BL       dfs__FPiiT2T1\n|L1.136|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.88|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nis_connected__FPii PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        MOV      r6,r1,LSL #2\n        MOV      r0,r6\n        MOV      r5,r1\n        BL       malloc\n        MOV      r4,r0\n        MOV      r1,r6\n        BL       __rt_memclr_w\n        MOV      r3,r4\n        MOV      r2,#0\n        MOV      r1,r5\n        MOV      r0,r7\n        BL       dfs__FPiiT2T1\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.268|\n|L1.224|\n        LDR      r1,[r4,r0,LSL #2]\n        CMP      r1,#0\n        BNE      |L1.256|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.256|\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.224|\n|L1.268|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint* create_graph(int num_vertices) {\n    return (int*)malloc(num_vertices * num_vertices * sizeof(int));\n}\n\nvoid add_edge(int* graph, int from, int to, int num_vertices) {\n    graph[from * num_vertices + to] = 1;\n    graph[to * num_vertices + from] = 1;\n}\n\nvoid dfs(int* graph, int num_vertices, int vertex, int* visited) {\n    visited[vertex] = 1;\n    for (int i = 0; i < num_vertices; i++) {\n        if (graph[vertex * num_vertices + i] && !visited[i]) {\n            dfs(graph, num_vertices, i, visited);\n        }\n    }\n}\n\nint is_connected(int* graph, int num_vertices) {\n    int* visited = (int*)malloc(num_vertices * sizeof(int));\n    memset(visited, 0, num_vertices * sizeof(int));\n    dfs(graph, num_vertices, 0, visited);\n    for (int i = 0; i < num_vertices; i++) {\n        if (!visited[i]) {\n            free(visited);\n            return 0;\n        }\n    }\n    free(visited);\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlinePlaneIntersection__F4Line5Plane PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x34\n        ADD      r8,sp,#0x68\n        LDMIA    r8,{r4-r8}\n        ADD      r11,sp,#0x84\n        LDMIA    r11,{r0,r1,r9-r11}\n        MOV      r2,r5\n        MOV      r3,r6\n        BL       _dsub\n        STR      r1,[sp,#0x2c]\n        ADD      r1,sp,#0x7c\n        STR      r0,[sp,#0x30]\n        LDMIA    r1,{r0,r1}\n        LDR      r2,[sp,#0x64]\n        MOV      r3,r4\n        BL       _dsub\n        STR      r0,[sp,#0x28]\n        STR      r1,[sp,#0x24]\n        ADD      r3,sp,#0x5c\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r8\n        MOV      r0,r7\n        BL       _dsub\n        MOV      r3,r10\n        MOV      r2,r9\n        STR      r0,[sp,#0x20]\n        STR      r1,[sp,#0x1c]\n        BL       _dmul\n        MOV      r7,r0\n        MOV      r8,r1\n        LDR      r1,[sp,#0x24]\n        LDR      r0,[sp,#0x28]\n        MOV      r2,r11\n        LDR      r3,[sp,#0x98]\n        BL       _dmul\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n        LDR      r1,[sp,#0x2c]\n        LDR      r0,[sp,#0x30]\n        ADD      r3,sp,#0x9c\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dadd\n        ADR      r2,|L1.556|\n        MOV      r8,r1\n        BIC      r1,r1,#0x80000000\n        LDMIA    r2,{r2,r3}\n        MOV      r7,r0\n        BL       _dcmple\n        BCS      |L1.256|\n        LDR      lr,|L1.564|\n        LDMIA    lr,{r0-r3,r12,lr}\n        LDR      r4,[sp,#0x58]\n        STMIA    r4,{r0-r3,r12,lr}\n|L1.240|\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.256|\n        ADD      r3,sp,#0x5c\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r10\n        MOV      r0,r9\n        BL       _dmul\n        MOV      r9,r0\n        MOV      r10,r1\n        LDR      r1,[sp,#0x98]\n        MOV      r0,r11\n        MOV      r3,r4\n        LDR      r2,[sp,#0x64]\n        BL       _dmul\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dadd\n        MOV      r10,r1\n        ADD      r1,sp,#0x9c\n        MOV      r9,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dmul\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dadd\n        ADD      r3,sp,#0xa4\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        EOR      r1,r1,#0x80000000\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _ddiv\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,#0\n        MOV      r0,#0\n        ADD      r9,sp,#4\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r10,#0\n        MOV      r11,#0\n        STMIA    r9,{r0-r3,r10,r11}\n        LDR      r0,[sp,#0x20]\n        LDR      r1,[sp,#0x1c]\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dmul\n        ADD      r3,sp,#0x5c\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        STMIB    sp,{r0,r1}\n        LDR      r0,[sp,#0x28]\n        LDR      r1,[sp,#0x24]\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dmul\n        MOV      r3,r4\n        LDR      r2,[sp,#0x64]\n        BL       _dadd\n        ADD      r2,sp,#0xc\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x30]\n        LDR      r1,[sp,#0x2c]\n        MOV      r2,r7\n        MOV      r3,r8\n        BL       _dmul\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        LDR      r4,[sp,#0x58]\n        LDMIA    r9,{r0-r3,r5,r6}\n        STMIA    r4,{r0-r3,r5,r6}\n        B        |L1.240|\n|L1.556|\n        DCFD     0x3eb0c6f7a0b5ed8d\n|L1.564|\n        DCD      ||.constdata$1||\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point {\n    double x, y, z;\n};\n\nstruct Plane {\n    double a, b, c, d;\n};\n\nstruct Line {\n    Point p1, p2;\n};\n\n\nPoint linePlaneIntersection(Line l, Plane p) {\n    double denominator = p.a * (l.p2.x - l.p1.x) + p.b * (l.p2.y - l.p1.y) + p.c * (l.p2.z - l.p1.z);\n    if (fabs(denominator) < 1e-6) {\n        Point invalid = {NAN, NAN, NAN};\n        return invalid;\n    }\n\n    double t = -(p.a * l.p1.x + p.b * l.p1.y + p.c * l.p1.z + p.d) / denominator;\n    Point intersection = {l.p1.x + t * (l.p2.x - l.p1.x),\n                          l.p1.y + t * (l.p2.y - l.p1.y),\n                          l.p1.z + t * (l.p2.z - l.p1.z)};\n    return intersection;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        LDR      r1,[r0,#0]\n        CMP      r1,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r2,[r1,#4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r0,#0]\n        MOV      r0,r1\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npeek__FP5Stack PROC\n        LDR      r0,[r0,#0]\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0]\n        MVNEQ    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Stack {\n    struct Node* top;\n};\n\nvoid push(Stack* s, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) return;\n    newNode->data = data;\n    newNode->next = s->top;\n    s->top = newNode;\n}\n\nint pop(Stack* s) {\n    if (s->top == NULL) return -1; \n    int data = s->top->data;\n    Node* temp = s->top;\n    s->top = s->top->next;\n    free(temp);\n    return data;\n}\n\nint peek(Stack* s) {\n    if (s->top == NULL) return -1;\n    return s->top->data;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        CMP      r12,r1\n        MOV      r3,r2\n        BGE      |L1.48|\n        LDR      r4,[r0,r12,LSL #2]\n        LDR      r5,[r0,r2,LSL #2]\n        CMP      r4,r5\n        MOVGT    r2,r12\n|L1.48|\n        CMP      lr,r1\n        BGE      |L1.72|\n        LDR      r12,[r0,lr,LSL #2]\n        LDR      r4,[r0,r2,LSL #2]\n        CMP      r12,r4\n        MOVGT    r2,lr\n|L1.72|\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nbuildHeap__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r4,r0,#1\n        MOV      r5,r1\n        LDMMIFD  sp!,{r4-r6,lr}\n        BXMI     lr\n|L1.140|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       heapify__FPiiT2\n        SUBS     r4,r4,#1\n        BPL      |L1.140|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid buildHeap(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncosine_similarity__FPdT1i PROC\n|L1.0|\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        ADR      r0,|L1.336|\n        LDR      r1,[r0,#4]\n        LDR      r2,[r0,#0]\n        SUB      sp,sp,#0x10\n        STR      r1,[sp,#8]\n        STR      r2,[sp,#4]\n        LDMIA    r0,{r7,r8}\n        LDR      r0,[sp,#0x18]\n        MOV      r5,r7\n        MOV      r4,#0\n        MOV      r6,r8\n        CMP      r0,#0\n        BLE      |L1.216|\n|L1.56|\n        LDR      r0,[sp,#0x14]\n        ADD      r1,r0,r4,LSL #3\n        LDR      r0,[sp,#0x10]\n        LDR      r3,[r1,#4]\n        ADD      r0,r0,r4,LSL #3\n        STR      r3,[sp,#0xc]\n        LDR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        LDR      r0,[r0,#0]\n        MOV      r9,r2\n        MOV      r10,r1\n        MOV      r11,r0\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _dadd\n        STMIB    sp,{r0,r1}\n        MOV      r1,r10\n        MOV      r0,r11\n        MOV      r3,r10\n        MOV      r2,r11\n        BL       _dmul\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _dadd\n        LDR      r3,[sp,#0xc]\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r3\n        MOV      r0,r9\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        MOV      r5,r0\n        LDR      r0,[sp,#0x18]\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        MOV      r6,r1\n        BLT      |L1.56|\n|L1.216|\n        ADR      r4,|L1.336|\n        LDMIA    r4,{r2,r3}\n        MOV      r1,r8\n        MOV      r0,r7\n        BL       _dcmpeq\n        BEQ      |L1.260|\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMIA    r4,{r2,r3}\n        BL       _dcmpeq\n        BNE      |L1.276|\n|L1.260|\n        LDMIA    r4,{r0,r1}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.276|\n        MOV      r1,r8\n        MOV      r0,r7\n        BL       __softfp_sqrt\n        MOV      r4,r0\n        MOV      r7,r1\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       __softfp_sqrt\n        MOV      r3,r7\n        MOV      r2,r4\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        B        _drdiv\n|L1.336|\n        DCFD     0x0000000000000000\n        ENDP\n\nrecommend__FP4ItemiPcT2 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x400\n        SUB      sp,sp,#0xb4\n        CMP      r1,#0\n        ADDLE    sp,sp,#0x400\n        ADDLE    sp,sp,#0xc4\n        MOV      r11,r2\n        MVN      r9,#0\n        MOV      r7,r0\n        MOV      r6,r1\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n|L1.396|\n        ADD      r0,r4,r4,LSL #5\n        ADD      r0,r7,r0,LSL #2\n        MOV      r1,r11\n        BL       strcmp\n        CMP      r0,#0\n        MOVEQ    r9,r4\n        BEQ      |L1.436|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.396|\n|L1.436|\n        CMN      r9,#1\n        ADDEQ    sp,sp,#0x400\n        ADDEQ    sp,sp,#0xc4\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r5,#0\n        ADD      r4,sp,#0x190\n        CMP      r6,#0\n        BLE      |L1.528|\n        ADD      r0,r9,r9,LSL #5\n        ADD      r0,r7,r0,LSL #2\n        ADD      r10,r0,#0x34\n|L1.484|\n        ADD      r0,r5,r5,LSL #5\n        ADD      r0,r7,r0,LSL #2\n        ADD      r1,r0,#0x34\n        MOV      r0,r10\n        ADD      r8,r4,r5,LSL #3\n        MOV      r2,#0xa\n        BL       cosine_similarity__FPdT1i\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        STMIA    r8,{r0,r1}\n        BLT      |L1.484|\n|L1.528|\n        MOV      r0,#0\n        MOV      r8,sp\n        CMP      r6,#0\n        BLE      |L1.560|\n|L1.544|\n        STR      r0,[r8,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.544|\n|L1.560|\n        SUB      r0,r6,#1\n        STR      r0,[sp,#0x4b0]\n        CMP      r0,#0\n        MOV      r5,#0\n        BLE      |L1.676|\n|L1.580|\n        ADD      r4,r5,#1\n        MOV      r10,r4\n        CMP      r4,r6\n        BGE      |L1.660|\n|L1.596|\n        LDR      r0,[r8,r4,LSL #2]\n        ADD      r2,sp,#0x190\n        ADD      r1,r2,r0,LSL #3\n        LDR      r0,[r8,r5,LSL #2]\n        ADD      r0,r2,r0,LSL #3\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dcmple\n        BCS      |L1.648|\n        LDR      r1,[r8,r4,LSL #2]\n        LDR      r0,[r8,r5,LSL #2]\n        STR      r1,[r8,r5,LSL #2]\n        STR      r0,[r8,r4,LSL #2]\n|L1.648|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.596|\n|L1.660|\n        LDR      r0,[sp,#0x4b0]\n        MOV      r5,r10\n        CMP      r10,r0\n        BLT      |L1.580|\n|L1.676|\n        MOV      r1,r11\n        ADR      r0,|L1.760|\n        BL       _printf\n        MOV      r4,#1\n        B        |L1.728|\n|L1.696|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,r9\n        BEQ      |L1.724|\n        ADD      r0,r0,r0,LSL #5\n        ADD      r1,r7,r0,LSL #2\n        ADR      r0,|L1.788|\n        BL       _printf\n|L1.724|\n        ADD      r4,r4,#1\n|L1.728|\n        LDR      r0,[sp,#0x4c0]\n        CMP      r4,r0\n        CMPLE    r4,r6\n        BLT      |L1.696|\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#0xc4\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.760|\n        DCB      \"Reco\"\n        DCB      \"mmen\"\n        DCB      \"dati\"\n        DCB      \"ons \"\n        DCB      \"for \"\n        DCB      \"%s:\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.788|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_ITEMS 100\n#define MAX_FEATURES 10\n\nstruct Item {\n    char name[50];\n    double features[MAX_FEATURES];\n};\n\ndouble cosine_similarity(double *a, double *b, int n) {\n    double dot_product = 0.0;\n    double magnitude_a = 0.0;\n    double magnitude_b = 0.0;\n    for (int i = 0; i < n; i++) {\n        dot_product += a[i] * b[i];\n        magnitude_a += a[i] * a[i];\n        magnitude_b += b[i] * b[i];\n    }\n    if (magnitude_a == 0.0 || magnitude_b == 0.0) return 0.0;\n    return dot_product / (sqrt(magnitude_a) * sqrt(magnitude_b));\n}\n\n\nvoid recommend(Item *items, int num_items, char *target_item_name, int top_n) {\n    int target_index = -1;\n    for (int i = 0; i < num_items; i++) {\n        if (strcmp(items[i].name, target_item_name) == 0) {\n            target_index = i;\n            break;\n        }\n    }\n    if (target_index == -1) return;\n\n    double similarities[MAX_ITEMS];\n    for (int i = 0; i < num_items; i++) {\n        similarities[i] = cosine_similarity(items[target_index].features, items[i].features, MAX_FEATURES);\n    }\n\n    int indices[MAX_ITEMS];\n    for (int i = 0; i < num_items; i++) indices[i] = i;\n\n    for (int i = 0; i < num_items -1; i++) {\n        for (int j = i + 1; j < num_items; j++) {\n            if (similarities[indices[i]] < similarities[indices[j]]) {\n                int temp = indices[i];\n                indices[i] = indices[j];\n                indices[j] = temp;\n            }\n        }\n    }\n\n\n    printf(\"Recommendations for %s:\\n\", target_item_name);\n    for (int i = 1; i <= top_n && i < num_items; i++) {\n        if (indices[i] != target_index)\n            printf(\"%s\\n\", items[indices[i]].name);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninsertionSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        CMP      r1,#1\n        LDMLEFD  sp!,{r4,lr}\n        MOV      r3,#1\n        BXLE     lr\n|L1.20|\n        LDR      r12,[r0,r3,LSL #2]\n        SUB      r2,r3,#1\n        B        |L1.44|\n|L1.32|\n        ADD      r4,r0,r2,LSL #2\n        STR      lr,[r4,#4]\n        SUB      r2,r2,#1\n|L1.44|\n        CMP      r2,#0\n        LDRGE    lr,[r0,r2,LSL #2]\n        CMPGE    lr,r12\n        BGT      |L1.32|\n        ADD      r2,r0,r2,LSL #2\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        STR      r12,[r2,#4]\n        BLT      |L1.20|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncomplex_add__F7complexT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_sub__F7complexT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dsub\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dsub\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_mul__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x4c\n        LDMIA    r7,{r4-r7}\n        MOV      r10,r2\n        MOV      r9,r1\n        MOV      r11,r3\n        MOV      r3,r5\n        MOV      r0,r9\n        MOV      r1,r10\n        MOV      r2,r4\n        LDR      r8,[sp,#0x48]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r2,r6\n        ADD      r6,sp,#0xc\n        STMIA    r6,{r0,r1}\n        MOV      r1,r10\n        MOV      r0,r9\n        MOV      r3,r7\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x38]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDR      r1,[sp,#0x10]\n        STR      r1,[r2,#4]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r2,#0]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\ncomplex_div__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r7,sp,#0x3c\n        LDMIA    r7,{r4-r7}\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r4\n        ADR      r10,|L1.668|\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        MOV      r8,r0\n        MOV      r9,r1\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpeq\n        BNE      |L1.488|\n        MOV      r1,r10\n        LDR      r10,[r10,#0]\n        LDMIA    r1,{r0,r11}\n        MOV      r1,r11\n        B        |L1.640|\n|L1.488|\n        ADD      r1,sp,#0x2c\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r11,r1\n        ADD      r1,sp,#0x34\n        MOV      r10,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n        MOV      r11,r1\n        ADD      r1,sp,#0x34\n        MOV      r10,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r5,r1\n        ADD      r1,sp,#0x2c\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n|L1.640|\n        LDR      r2,[sp,#0x28]\n        STMIA    r2,{r10,r11}\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.668|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    double real;\n    double imag;\n} complex;\n\ncomplex complex_add(complex a, complex b) {\n    complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\ncomplex complex_sub(complex a, complex b) {\n    complex result;\n    result.real = a.real - b.real;\n    result.imag = a.imag - b.imag;\n    return result;\n}\n\ncomplex complex_mul(complex a, complex b) {\n    complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\ncomplex complex_div(complex a, complex b) {\n    complex result;\n    double denominator = b.real * b.real + b.imag * b.imag;\n    if (denominator == 0) {\n        result.real = 0;\n        result.imag = 0;\n    } else {\n        result.real = (a.real * b.real + a.imag * b.imag) / denominator;\n        result.imag = (a.imag * b.real - a.real * b.imag) / denominator;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidIP__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0x18\n        ADD      r3,sp,#8\n        ADD      r2,sp,#0xc\n        STMIA    sp,{r2,r3}\n        ADD      r3,sp,#0x10\n        ADD      r2,sp,#0x14\n        MOV      r4,r0\n        ADR      r1,|L1.232|\n        BL       _sscanf\n        CMP      r0,#4\n        ADDNE    sp,sp,#0x18\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[sp,#0x14]\n        CMP      r0,#0\n        BLT      |L1.140|\n        CMP      r0,#0xff\n        BGT      |L1.140|\n        LDR      r0,[sp,#0x10]\n        CMP      r0,#0\n        BLT      |L1.140|\n        CMP      r0,#0xff\n        BGT      |L1.140|\n        LDR      r0,[sp,#0xc]\n        CMP      r0,#0\n        BLT      |L1.140|\n        CMP      r0,#0xff\n        BGT      |L1.140|\n        LDR      r0,[sp,#8]\n        CMP      r0,#0\n        BLT      |L1.140|\n        CMP      r0,#0xff\n        BLE      |L1.156|\n|L1.140|\n        ADD      sp,sp,#0x18\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.156|\n        LDRB     r1,[r4,#0]\n        MOV      r0,#0\n        CMP      r1,#0\n        BEQ      |L1.216|\n|L1.172|\n        LDRB     r1,[r4,#0]\n        CMP      r1,#0x2e\n        LDRB     r1,[r4,#1]!\n        ADDEQ    r0,r0,#1\n        CMP      r1,#0\n        BNE      |L1.172|\n        CMP      r0,#3\n        ADDEQ    sp,sp,#0x18\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.216|\n        ADD      sp,sp,#0x18\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.232|\n        DCB      \"%d.%\"\n        DCB      \"d.%d\"\n        DCB      \".%d\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint isValidIP(char *ip) {\n    int a, b, c, d;\n    int numScanned;\n\n    numScanned = sscanf(ip, \"%d.%d.%d.%d\", &a, &b, &c, &d);\n    if (numScanned != 4) return 0;\n\n    if (a < 0 || a > 255 || b < 0 || b > 255 || c < 0 || c > 255 || d < 0 || d > 255) return 0;\n    \n    char *ptr = ip;\n    int count = 0;\n    while(*ptr != '\\0'){\n        if(*ptr == '.') count++;\n        ptr++;\n    }\n    if(count != 3) return 0;\n\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FPPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r8,|L1.384|\n        MOV      r5,r1\n        LDR      r1,[r8,#0]  ; visited\n        MOV      r6,r0\n        MOV      r0,#1\n        STR      r0,[r1,r2,LSL #2]\n        CMP      r5,#0\n        MOV      r7,r2\n        MOV      r4,#0\n        BLE      |L1.112|\n|L1.44|\n        LDR      r0,[r6,r7,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r8,#0]  ; visited\n        LDREQ    r0,[r0,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.100|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       dfs__FPPiiT2\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n|L1.100|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.44|\n|L1.112|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nis_connected__FPPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r4,r1,LSL #2\n        MOV      r0,r4\n        MOV      r5,r1\n        BL       malloc\n        LDR      r1,|L1.384|\n        STR      r0,[r1,#0]  ; visited\n        MOV      r1,r4\n        BL       __rt_memclr_w\n        MOV      r1,r5\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r2,#0\n        B        dfs__FPPiiT2\n        ENDP\n```",
        "output": "```cpp\n\n\nint* visited;\n\nint dfs(int** graph, int n, int node) {\n    visited[node] = 1;\n    for (int i = 0; i < n; i++) {\n        if (graph[node][i] == 1 && visited[i] == 0) {\n            if (!dfs(graph, n, i)) return 0;\n        }\n    }\n    return 1;\n}\n\nint is_connected(int** graph, int n) {\n    visited = (int*)malloc(n * sizeof(int));\n    memset(visited, 0, n * sizeof(int));\n    return dfs(graph, n, 0);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisBalanced__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        SUB      r0,r1,r0\n        ADD      r0,r0,#1\n        CMP      r0,#2\n        BHI      |L1.704|\n        LDR      r0,[r4,#4]\n        BL       isBalanced__FP4Node\n        CMP      r0,#0\n        BEQ      |L1.704|\n        LDR      r0,[r4,#8]\n        BL       isBalanced__FP4Node\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.704|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    Node *left;\n    Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1; \n    return node;\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else \n        return node;\n    node->height = 1 + max(height(node->left),height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nint isBalanced(Node *root) {\n    if (root == NULL) return 1;\n    int lh = height(root->left);\n    int rh = height(root->right);\n    if (abs(lh - rh) <= 1 && isBalanced(root->left) && isBalanced(root->right))\n        return 1;\n\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nparseFactor__Fv PROC\n|L1.0|\n        LDR      r12,|L1.392|\n        SUB      sp,sp,#8\n        LDMIA    r12,{r1,r2}  ; input, pos\n        LDRB     r2,[r2,r1]\n        SUB      r2,r2,#0x30\n        CMP      r2,#9\n        BHI      |L1.48|\n        MOV      r3,#3\n        STRB     r3,[sp,#0]\n        STR      r2,[sp,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r12,#0]  ; pos\n|L1.48|\n        LDMIA    sp,{r1,r2}\n        STMIA    r0,{r1,r2}\n        ADD      sp,sp,#8\n        BX       lr\n        ENDP\n\nparseTerm__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x10\n        MOV      r6,r0\n        ADD      r0,sp,#8\n        BL       parseFactor__Fv\n        LDR      r4,|L1.392|\n        LDR      r0,[r4,#4]  ; input, pos\n        LDR      r1,[r4,#0]\n        LDRB     r0,[r0,r1]\n        CMP      r0,#0x2a\n        BNE      |L1.168|\n        MOV      r5,sp\n|L1.112|\n        LDR      r0,[r4,#0]  ; pos\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0]  ; pos\n        MOV      r0,r5\n        BL       parseFactor__Fv\n        LDR      r0,[sp,#0xc]\n        LDR      r1,[sp,#4]\n        MUL      r0,r1,r0\n        STR      r0,[sp,#0xc]\n        LDR      r0,[r4,#4]  ; input, pos\n        LDR      r1,[r4,#0]\n        LDRB     r0,[r0,r1]\n        CMP      r0,#0x2a\n        BEQ      |L1.112|\n|L1.168|\n        ADD      r1,sp,#8\n        LDMIA    r1,{r0,r1}\n        STMIA    r6,{r0,r1}\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nparseExpression__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x10\n        MOV      r6,r0\n        ADD      r0,sp,#8\n        BL       parseTerm__Fv\n        LDR      r4,|L1.392|\n        LDR      r0,[r4,#4]  ; input, pos\n        LDR      r1,[r4,#0]\n        LDRB     r0,[r0,r1]\n        CMP      r0,#0x2b\n        BNE      |L1.296|\n        MOV      r5,sp\n|L1.240|\n        LDR      r0,[r4,#0]  ; pos\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0]  ; pos\n        MOV      r0,r5\n        BL       parseTerm__Fv\n        LDR      r0,[sp,#0xc]\n        LDR      r1,[sp,#4]\n        ADD      r0,r0,r1\n        STR      r0,[sp,#0xc]\n        LDR      r0,[r4,#4]  ; input, pos\n        LDR      r1,[r4,#0]\n        LDRB     r0,[r0,r1]\n        CMP      r0,#0x2b\n        BEQ      |L1.240|\n|L1.296|\n        ADD      r1,sp,#8\n        LDMIA    r1,{r0,r1}\n        STMIA    r6,{r0,r1}\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef enum {\n    EXPR, TERM, FACTOR, NUMBER\n} ExpressionType;\n\ntypedef struct {\n    ExpressionType type;\n    int value;\n} Expression;\n\nint pos = 0;\nchar *input;\n\nExpression parseFactor() {\n    Expression expr;\n    if (input[pos] >= '0' && input[pos] <= '9') {\n        expr.type = NUMBER;\n        expr.value = input[pos] - '0';\n        pos++;\n    }\n    return expr;\n}\n\nExpression parseTerm() {\n    Expression expr = parseFactor();\n    while (input[pos] == '*') {\n        pos++;\n        Expression next = parseFactor();\n        expr.value *= next.value;\n    }\n    return expr;\n}\n\n\nExpression parseExpression() {\n    Expression expr = parseTerm();\n    while (input[pos] == '+') {\n        pos++;\n        Expression next = parseTerm();\n        expr.value += next.value;\n    }\n    return expr;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfind__FP6subseti PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r1\n        LDR      r1,[r0,r1,LSL #3]\n        MOV      r5,r0\n        CMP      r1,r4\n        BEQ      |L1.36|\n        MOV      r0,r5\n        BL       find__FP6subseti\n        STR      r0,[r5,r4,LSL #3]\n|L1.36|\n        LDR      r0,[r5,r4,LSL #3]\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nUnion__FP6subsetiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r4,r0\n        BL       find__FP6subseti\n        MOV      r5,r0\n        MOV      r0,r4\n        MOV      r1,r6\n        BL       find__FP6subseti\n        ADD      r1,r4,r5,LSL #3\n        LDR      r2,[r1,#4]\n        ADD      r3,r4,r0,LSL #3\n        LDR      r3,[r3,#4]\n        CMP      r2,r3\n        STRLT    r0,[r4,r5,LSL #3]\n        LDMLTFD  sp!,{r4-r6,lr}\n        BXLT     lr\n        STR      r5,[r4,r0,LSL #3]\n        LDRLE    r0,[r1,#4]\n        ADDLE    r0,r0,#1\n        STRLE    r0,[r1,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ncompare__FPCvT1 PROC\n        LDR      r0,[r0,#4]\n        LDR      r1,[r1,#4]\n        CMP      r0,r1\n        MOVLE    r0,#0\n        MOVGT    r0,#1\n        BX       lr\n        ENDP\n\nkruskal__FP5Graph PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r0,r0,LSL #3\n        BL       malloc\n        MOV      r10,r0\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        MOV      r6,#0\n        MOV      r7,#0\n        LDR      r3,|L1.616|\n        MOV      r2,#8\n        BL       qsort\n        LDR      r0,[r4,#0]\n        MOV      r0,r0,LSL #3\n        BL       malloc\n        LDR      r1,[r4,#0]\n        MOV      r5,r0\n        MOV      r0,#0\n        CMP      r1,#0\n        BLE      |L1.368|\n        MOV      r1,#0\n|L1.248|\n        STR      r0,[r5,r0,LSL #3]\n        ADD      r2,r5,r0,LSL #3\n        STR      r1,[r2,#4]\n        LDR      r2,[r4,#0]\n        ADD      r0,r0,#1\n        CMP      r2,r0\n        BGT      |L1.248|\n        B        |L1.368|\n|L1.280|\n        MOV      r0,r7\n        LDR      r1,[r4,#8]\n        ADD      r7,r7,#1\n        ADD      r0,r1,r0,LSL #3\n        LDMIA    r0,{r1,r11}\n        MOV      r8,r1\n        MOV      r0,r5\n        BL       find__FP6subseti\n        MOV      r9,r0\n        MOV      r0,r5\n        MOV      r1,r8\n        BL       find__FP6subseti\n        CMP      r9,r0\n        BEQ      |L1.368|\n        MOV      r1,r6\n        ADD      r1,r10,r1,LSL #3\n        STMIA    r1,{r8,r11}\n        MOV      r2,r0\n        MOV      r0,r5\n        MOV      r1,r9\n        ADD      r6,r6,#1\n        BL       Union__FP6subsetiT2\n|L1.368|\n        LDR      r0,[r4,#0]\n        SUB      r0,r0,#1\n        CMP      r0,r6\n        LDRGT    r0,[r4,#4]\n        CMPGT    r0,r7\n        BGT      |L1.280|\n        MOV      r0,#0xc\n        BL       malloc\n        STR      r6,[r0,#4]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#0]\n        STR      r10,[r0,#8]\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define INF INT_MAX\n\ntypedef struct Edge {\n    int to;\n    int weight;\n} Edge;\n\ntypedef struct Graph {\n    int V;\n    int E;\n    Edge* edge;\n} Graph;\n\ntypedef struct subset {\n    int parent;\n    int rank;\n} subset;\n\n\nint find(subset *subsets, int i) {\n    if (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n    return subsets[i].parent;\n}\n\nvoid Union(subset *subsets, int x, int y) {\n    int xroot = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    if (subsets[xroot].rank < subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    else if (subsets[xroot].rank > subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n    else {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\nint compare(const void* a, const void* b) {\n    Edge* a1 = (Edge*)a;\n    Edge* b1 = (Edge*)b;\n    return a1->weight > b1->weight;\n}\n\nGraph* kruskal(Graph* graph) {\n    Edge *result = (Edge*)malloc(graph->V * sizeof(Edge));\n    int e = 0;\n    int i = 0;\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), compare);\n\n    subset *subsets = (subset*)malloc(graph->V * sizeof(subset));\n\n    for (int v = 0; v < graph->V; ++v) {\n        subsets[v].parent = v;\n        subsets[v].rank = 0;\n    }\n\n    while (e < graph->V - 1 && i < graph->E) {\n        Edge next_edge = graph->edge[i++];\n        int x = find(subsets, next_edge.to);\n        int y = find(subsets, next_edge.to);\n\n\n        if (x != y) {\n            result[e++] = next_edge;\n            Union(subsets, x, y);\n        }\n    }\n    Graph* mst = (Graph*)malloc(sizeof(Graph));\n    mst->E = e;\n    mst->V = graph->V;\n    mst->edge = result;\n    return mst;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nchatbot__FPCc PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        ADR      r1,|L1.120|\n        BL       strcmp\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        ADREQ    r0,|L1.128|\n        BXEQ     lr\n        MOV      r0,r4\n        ADR      r1,|L1.144|\n        BL       strcmp\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        ADREQ    r0,|L1.156|\n        BXEQ     lr\n        MOV      r0,r4\n        ADR      r1,|L1.184|\n        BL       strcmp\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        ADREQ    r0,|L1.192|\n        BXEQ     lr\n        MOV      r0,#0x32\n        BL       malloc\n        MOV      r4,r0\n        ADR      r1,|L1.204|\n        BL       _sprintf\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.120|\n        DCB      \"hell\"\n        DCB      \"o\\0\\0\\0\"\n|L1.128|\n        DCB      \"Hell\"\n        DCB      \"o th\"\n        DCB      \"ere!\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.144|\n        DCB      \"how \"\n        DCB      \"are \"\n        DCB      \"you\\0\"\n|L1.156|\n        DCB      \"I\\'m \"\n        DCB      \"doin\"\n        DCB      \"g we\"\n        DCB      \"ll, \"\n        DCB      \"than\"\n        DCB      \"k yo\"\n        DCB      \"u!\\0\\0\"\n|L1.184|\n        DCB      \"good\"\n        DCB      \"bye\\0\"\n|L1.192|\n        DCB      \"Good\"\n        DCB      \"bye!\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.204|\n        DCB      \"I\\'m \"\n        DCB      \"not \"\n        DCB      \"sure\"\n        DCB      \" I u\"\n        DCB      \"nder\"\n        DCB      \"stan\"\n        DCB      \"d.\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n//Simplified chatbot -  No actual NLP or machine learning involved.\nchar* chatbot(const char* input) {\n    if (strcmp(input, \"hello\") == 0) {\n        return \"Hello there!\";\n    } else if (strcmp(input, \"how are you\") == 0) {\n        return \"I'm doing well, thank you!\";\n    } else if (strcmp(input, \"goodbye\") == 0) {\n        return \"Goodbye!\";\n    } else {\n        char* response = (char*)malloc(50 * sizeof(char)); // Potential memory leak if not freed.\n        sprintf(response, \"I'm not sure I understand.\");\n        return response;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisInteger__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        BEQ      |L1.28|\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.40|\n|L1.28|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.40|\n        LDRB     r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0x2d\n        MOVEQ    r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        BL       __rt_ctype_table\n        LDR      r1,[r0,#0]\n|L1.76|\n        LDRB     r0,[r5,r4]\n        LDRB     r0,[r1,r0]\n        TST      r0,#0x20\n        LDMEQFD  sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.76|\n|L1.116|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isInteger(const char* str) {\n    if (str == 0 || strlen(str) == 0) return 0;\n    int i = 0;\n    if (str[0] == '-') i++;\n    for (; str[i] != '\\0'; i++) {\n        if (!isdigit(str[i])) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndeterminant__FiPA10_i PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r6,r1\n        MOV      r4,r0\n        CMP      r0,#1\n        LDREQ    r0,[r6,#0]\n        SUB      sp,sp,#0x190\n        ADDEQ    sp,sp,#0x190\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        CMP      r4,#2\n        BNE      |L1.84|\n        LDR      r0,[r6,#0]\n        LDR      r1,[r6,#0x2c]\n        MUL      r0,r1,r0\n        LDR      r1,[r6,#4]!\n        LDR      r2,[r6,#0x24]\n        ADD      sp,sp,#0x190\n        LDMFD    sp!,{r4-r10,lr}\n        MUL      r1,r2,r1\n        SUB      r0,r0,r1\n        BX       lr\n|L1.84|\n        MOV      r7,#0\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.248|\n        SUB      r8,r4,#1\n        MOV      r9,sp\n|L1.108|\n        MOV      lr,#0\n        MOV      r2,#1\n        CMP      r4,#1\n        BLE      |L1.200|\n|L1.124|\n        MOV      r1,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.184|\n        ADD      r3,lr,lr,LSL #2\n        ADD      r12,r2,r2,LSL #2\n        ADD      r10,r6,r12,LSL #3\n        ADD      r3,r9,r3,LSL #3\n|L1.156|\n        CMP      r0,r5\n        LDRNE    r12,[r10,r0,LSL #2]\n        ADD      r0,r0,#1\n        STRNE    r12,[r3,r1,LSL #2]\n        ADDNE    r1,r1,#1\n        CMP      r0,r4\n        BLT      |L1.156|\n|L1.184|\n        ADD      r2,r2,#1\n        CMP      r2,r4\n        ADD      lr,lr,#1\n        BLT      |L1.124|\n|L1.200|\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       determinant__FiPA10_i\n        TST      r5,#1\n        LDR      r2,[r6,r5,LSL #2]\n        MVNNE    r1,#0\n        MOVEQ    r1,#1\n        MUL      r1,r2,r1\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        MLA      r7,r0,r1,r7\n        BLT      |L1.108|\n|L1.248|\n        MOV      r0,r7\n        ADD      sp,sp,#0x190\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint determinant(int n, int matrix[10][10]) {\n    if (n == 1) return matrix[0][0];\n    if (n == 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n    int det = 0;\n    int submatrix[10][10];\n    for (int i = 0; i < n; i++) {\n        int subi = 0;\n        for (int j = 1; j < n; j++) {\n            int subj = 0;\n            for (int k = 0; k < n; k++) {\n                if (k == i) continue;\n                submatrix[subi][subj] = matrix[j][k];\n                subj++;\n            }\n            subi++;\n        }\n        det += (i % 2 == 0 ? 1 : -1) * matrix[0][i] * determinant(n - 1, submatrix);\n    }\n    return det;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitializeSystem__FP17ReservationSystemi PROC\n        MOV      r2,#0\n        STR      r1,[r0,#0x320]\n        CMP      r1,#0\n        BXLE     lr\n        MOV      r12,#0\n|L1.20|\n        ADD      r3,r2,#1\n        STR      r3,[r0,r2,LSL #3]\n        ADD      r2,r0,r2,LSL #3\n        STR      r12,[r2,#4]\n        MOV      r2,r3\n        CMP      r3,r1\n        BLT      |L1.20|\n        BX       lr\n        ENDP\n\nreserveSeat__FP17ReservationSystemi PROC\n        CMP      r1,#1\n        LDRGE    r2,[r0,#0x320]\n        CMPGE    r2,r1\n        MOVLT    r0,#0\n        BXLT     lr\n        ADD      r0,r0,r1,LSL #3\n        LDR      r1,[r0,#-4]\n        CMP      r1,#0\n        MOVEQ    r1,#1\n        STREQ    r1,[r0,#-4]\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SEATS 100\n\nstruct Seat {\n    int seatNumber;\n    int isReserved;\n};\n\nstruct ReservationSystem {\n    Seat seats[MAX_SEATS];\n    int totalSeats;\n};\n\nvoid initializeSystem(ReservationSystem* system, int totalSeats) {\n    system->totalSeats = totalSeats;\n    for (int i = 0; i < totalSeats; i++) {\n        system->seats[i].seatNumber = i + 1;\n        system->seats[i].isReserved = 0;\n    }\n}\n\nint reserveSeat(ReservationSystem* system, int seatNumber) {\n    if (seatNumber < 1 || seatNumber > system->totalSeats) return 0;\n    if (system->seats[seatNumber - 1].isReserved) return 0;\n    system->seats[seatNumber - 1].isReserved = 1;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FUxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        BEQ      |L1.108|\n|L1.44|\n        MOV      r8,r4\n        MOV      r9,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_udiv\n        MOV      r4,r2\n        MOV      r5,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r8\n        MOV      r7,r9\n        BNE      |L1.44|\n|L1.108|\n        MOV      r0,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n\npow_mod__FUxN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r4,r2\n        ADR      r2,|L1.372|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.372|\n        LDMIA    r2,{r8,r9}\n        MOV      r5,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r6,r2\n        MOV      r7,r3\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BLS      |L1.356|\n|L1.208|\n        ADR      r0,|L1.380|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _ll_udiv\n        MOV      r0,r2\n        ADR      r2,|L1.372|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.288|\n        UMULL    r0,r12,r8,r6\n        MLA      r12,r6,r9,r12\n        MLA      r1,r7,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.288|\n        UMULL    r0,r12,r6,r6\n        MLA      r12,r6,r7,r12\n        MLA      r1,r7,r6,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r0,r4,LSR #1\n        ORR      r4,r0,r5,LSL #31\n        ADR      r0,|L1.124|\n        MOV      r6,r2\n        MOV      r7,r3\n        LDMIA    r0,{r2,r3}\n        MOV      r5,r5,LSR #1\n        CMP      r5,r3\n        MOV      r0,r4\n        CMPEQ    r0,r2\n        BHI      |L1.208|\n|L1.356|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.372|\n        DCQ      0x0000000000000001\n|L1.380|\n        DCQ      0x0000000000000002\n        ENDP\n\nextended_gcd__FUxT1PUxT3 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#0x18\n        ADD      r7,sp,#0x38\n        LDMIA    r7,{r6,r7}\n        ADR      r10,|L1.124|\n        MOV      r9,r3\n        MOV      r8,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r5,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r4,r0\n        BNE      |L1.488|\n        LDMIA    r10,{r0,r1}\n        STMIA    r6,{r0,r1}\n        ADR      r0,|L1.372|\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[r7,#4]\n        STR      r1,[r7,#0]\n        ADD      sp,sp,#0x18\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.488|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _ll_udiv\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r0,r2\n        MOV      r1,r3\n        ADD      r3,sp,#8\n        ADD      r2,sp,#0x10\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       extended_gcd__FUxT1PUxT3\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        MOV      r4,r0\n        UMULL    r0,r12,r8,r2\n        MLA      r12,r2,r9,r12\n        MOV      r5,r1\n        ADD      r1,sp,#8\n        MOV      r2,r0\n        LDMIA    r1,{r0,r1}\n        SUBS     r0,r0,r2\n        MLA      r3,r8,r3,r12\n        SBC      r1,r1,r3\n        STMIA    r6,{r0,r1}\n        ADD      r1,sp,#0x10\n        LDMIA    r1,{r0,r1}\n        STMIA    r7,{r0,r1}\n        ADD      sp,sp,#0x18\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\nmodInverse__FUxT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c\n        MOV      r5,r3\n        MOV      r4,r2\n        ADD      r2,sp,#0x14\n        ADD      r3,sp,#0xc\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       extended_gcd__FUxT1PUxT3\n        ADR      r2,|L1.372|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        ADRNE    r1,|L1.124|\n        LDMNEIA  r1,{r0,r1}\n        ADDNE    sp,sp,#0x1c\n        LDMNEFD  sp!,{r4,r5,lr}\n        BXNE     lr\n        ADD      r1,sp,#0x14\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_udiv\n        ADDS     r0,r2,r4\n        ADC      r1,r3,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_udiv\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r2\n        MOV      r1,r3\n        BX       lr\n        ENDP\n\nrsa__FUxN31 PROC\n        STMFD    sp!,{r4-r11,lr}\n        UMULL    r4,r12,r0,r2\n        MLA      r12,r2,r1,r12\n        MOV      r8,r2\n        MOV      r2,#1\n        SUBS     r8,r8,r2\n        MLA      r5,r3,r0,r12\n        SBC      r3,r3,#0\n        MOV      r10,r0\n        SUBS     r0,r10,r2\n        MOV      r11,r1\n        SBC      r1,r11,#0\n        UMULL    r2,r12,r0,r8\n        MLA      r12,r8,r1,r12\n        SUB      sp,sp,#0xc\n        ADD      r7,sp,#0x30\n        LDMIA    r7,{r6,r7}\n        MLA      r3,r0,r3,r12\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       modInverse__FUxT1\n        MOV      r8,r0\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOVEQ    r0,#1\n        MOV      r9,r1\n        BLEQ     exit\n        STMIA    sp,{r4,r5}\n        ADD      r1,sp,#0x38\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       pow_mod__FUxN21\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r3,r9\n        MOV      r2,r8\n        STMIA    sp,{r4,r5}\n        BL       pow_mod__FUxN21\n        MOV      r3,r0\n        STR      r1,[sp,#0]\n        MOV      r1,r6\n        ADR      r0,|L1.972|\n        MOV      r2,r7\n        BL       _printf\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.972|\n        DCB      \"%llu\"\n        DCB      \" %ll\"\n        DCB      \"u\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n    while (b) {\n        unsigned long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nunsigned long long pow_mod(unsigned long long base, unsigned long long exp, unsigned long long mod) {\n    unsigned long long res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\nunsigned long long extended_gcd(unsigned long long a, unsigned long long b, unsigned long long *x, unsigned long long *y) {\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    unsigned long long x1, y1;\n    unsigned long long d = extended_gcd(b % a, a, &x1, &y1);\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return d;\n}\n\n\nunsigned long long modInverse(unsigned long long n, unsigned long long mod) {\n    unsigned long long x, y;\n    unsigned long long g = extended_gcd(n, mod, &x, &y);\n    if (g != 1) return 0; \n    return (x % mod + mod) % mod;\n}\n\n\nvoid rsa(unsigned long long p, unsigned long long q, unsigned long long e, unsigned long long m){\n    unsigned long long n = p * q;\n    unsigned long long phi = (p - 1) * (q - 1);\n    unsigned long long d = modInverse(e, phi);\n\n    if(d == 0) exit(1);\n\n    unsigned long long c = pow_mod(m, e, n);\n    unsigned long long m2 = pow_mod(c, d, n);\n\n    printf(\"%llu %llu\",c,m2);\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash1__Fi PROC\n|L1.0|\n        LDR      r1,|L1.320|\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\nhash2__Fi PROC\n        LDR      r2,|L1.324|\n        MOV      r1,r0\n        MOV      r3,#0\n        SMLAL    r3,r0,r2,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #3\n        ADD      r0,r0,r1\n        RSB      r0,r0,#7\n        BX       lr\n        ENDP\n\ndoubleHashing__FiPi PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       hash1__Fi\n        MOV      r4,r0\n        MOV      r5,#0\n        LDR      r8,|L1.320|\n        B        |L1.144|\n|L1.104|\n        MOV      r0,r6\n        BL       hash2__Fi\n        ADD      r0,r0,r4\n        SMULL    r2,r1,r8,r0\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r4,r0,r1,LSL #1\n        ADD      r5,r5,#1\n|L1.144|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        CMPNE    r5,#0xa\n        BLT      |L1.104|\n        CMP      r5,#0xa\n        MOVNE    r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        MVNEQ    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\nint hash1(int key) {\n    return key % TABLE_SIZE;\n}\n\nint hash2(int key) {\n    return 7 - (key % 7);\n}\n\nint doubleHashing(int key, int arr[]) {\n    int index = hash1(key);\n    int i = 0;\n    while (arr[index] != 0 && i < TABLE_SIZE) {\n        index = (index + hash2(key)) % TABLE_SIZE;\n        i++;\n    }\n    if (i == TABLE_SIZE)\n        return -1;\n    return index;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.380|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0xa\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP9HashTableiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       hash__Fi\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        STMIA    r0,{r6,r7}\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #2]\n        STR      r1,[r0,#8]\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nsearch__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r4,r1\n        BL       hash__Fi\n        LDR      r1,[r5,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.220|\n|L1.188|\n        LDR      r1,[r0,#0]\n        CMP      r1,r4\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.188|\n|L1.220|\n        LDMFD    sp!,{r4,r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nfreeHashTable__FP9HashTable PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r4,#0\n|L1.244|\n        LDR      r0,[r6,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.276|\n|L1.260|\n        LDR      r5,[r0,#8]\n        BL       free\n        MOVS     r0,r5\n        BNE      |L1.260|\n|L1.276|\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        BCC      |L1.244|\n        LDR      r0,[r6,#0]\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct Node {\n    int key;\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct HashTable {\n    Node** table;\n} HashTable;\n\nunsigned int hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    ht->table = (Node**)calloc(TABLE_SIZE, sizeof(Node*));\n    return ht;\n}\n\nvoid insert(HashTable* ht, int key, int value) {\n    unsigned int index = hash(key);\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->value = value;\n    newNode->next = ht->table[index];\n    ht->table[index] = newNode;\n}\n\nint search(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    Node* current = ht->table[index];\n    while (current != NULL) {\n        if (current->key == key) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return -1; \n}\n\nvoid freeHashTable(HashTable* ht) {\n    for (unsigned int i = 0; i < TABLE_SIZE; i++) {\n        Node* current = ht->table[i];\n        while (current != NULL) {\n            Node* next = current->next;\n            free(current);\n            current = next;\n        }\n    }\n    free(ht->table);\n    free(ht);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncheckBalanced__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        MOV      r1,#0\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.96|\n|L1.28|\n        LDRB     r3,[r4,r2]\n        CMP      r3,#0x7b\n        ADDEQ    r1,r1,#1\n        BEQ      |L1.52|\n        CMP      r3,#0x7d\n        SUBEQ    r1,r1,#1\n|L1.52|\n        CMP      r1,#0\n        LDMLTFD  sp!,{r4,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.28|\n        CMP      r1,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.96|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint checkBalanced(char* expression) {\n    int len = strlen(expression);\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (expression[i] == '{') {\n            count++;\n        } else if (expression[i] == '}') {\n            count--;\n        }\n        if (count < 0) return 0;\n    }\n    return count == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindLastOccurrence__FPiiT2 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MVN      r12,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.44|\n|L1.20|\n        LDR      lr,[r0,r3,LSL #2]\n        CMP      lr,r2\n        MOVEQ    r12,r3\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.20|\n|L1.44|\n        LDR      lr,[sp],#4\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findLastOccurrence(int arr[], int size, int element) {\n    int lastIndex = -1;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            lastIndex = i;\n        }\n    }\n    return lastIndex;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncatalan__Fi PROC\n        STMFD    sp!,{r3-r9,lr}\n        CMP      r0,#1\n        ADRLE    r1,|L1.116|\n        MOV      r7,r0\n        LDMLEIA  r1,{r0,r1}\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        MOV      r4,#0\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r5,r6}\n|L1.40|\n        MOV      r0,r4\n        BL       catalan__Fi\n        MOV      r8,r0\n        SUB      r0,r7,r4\n        SUB      r0,r0,#1\n        MOV      r9,r1\n        BL       catalan__Fi\n        UMULL    r2,r12,r0,r8\n        MLA      r12,r8,r1,r12\n        MLA      r3,r9,r0,r12\n        ADDS     r5,r5,r2\n        ADC      r6,r6,r3\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.40|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.116|\n        DCQ      0x0000000000000001\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long catalan(int n) {\n    if (n <= 1) return 1;\n    unsigned long long res = 0;\n    for (int i = 0; i < n; i++)\n        res += catalan(i) * catalan(n - i - 1);\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreatePriorityQueue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#8]\n        STR      r5,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nheapifyUp__FP13PriorityQueuei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r1,#1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r4,r0,ASR #1\n        LDR      r0,[r5,#0]\n        LDR      r2,[r0,r1,LSL #2]\n        LDR      r3,[r0,r4,LSL #2]\n        CMP      r2,r3\n        LDMGEFD  sp!,{r4,r5,lr}\n        BXGE     lr\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyUp__FP13PriorityQueuei\n        ENDP\n\nenqueue__FP13PriorityQueuei PROC\n        LDR      r2,[r0,#8]\n        LDR      r3,[r0,#4]\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#8]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP13PriorityQueuei\n        ENDP\n\nheapifyDown__FP13PriorityQueuei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#8]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.304|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVLT    r4,r0\n|L1.304|\n        CMP      r3,r2\n        BLE      |L1.332|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVLT    r4,r2\n|L1.332|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP13PriorityQueuei\n        ENDP\n\ndequeue__FP13PriorityQueue PROC\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#8]\n        MOV      r1,#0\n        BL       heapifyDown__FP13PriorityQueuei\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int *heap;\n    int capacity;\n    int size;\n} PriorityQueue;\n\nPriorityQueue* createPriorityQueue(int capacity) {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    if (pq == NULL) return NULL;\n    pq->heap = (int*)malloc(sizeof(int) * capacity);\n    if (pq->heap == NULL) {\n        free(pq);\n        return NULL;\n    }\n    pq->capacity = capacity;\n    pq->size = 0;\n    return pq;\n}\n\nvoid swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid heapifyUp(PriorityQueue* pq, int index) {\n    if (index <= 0) return;\n    int parent = (index - 1) / 2;\n    if (pq->heap[index] < pq->heap[parent]) {\n        swap(&pq->heap[index], &pq->heap[parent]);\n        heapifyUp(pq, parent);\n    }\n}\n\nvoid enqueue(PriorityQueue* pq, int value) {\n    if (pq->size == pq->capacity) return;\n    pq->heap[pq->size] = value;\n    pq->size++;\n    heapifyUp(pq, pq->size - 1);\n}\n\nvoid heapifyDown(PriorityQueue* pq, int index) {\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n    int smallest = index;\n    if (left < pq->size && pq->heap[left] < pq->heap[smallest])\n        smallest = left;\n    if (right < pq->size && pq->heap[right] < pq->heap[smallest])\n        smallest = right;\n    if (smallest != index) {\n        swap(&pq->heap[index], &pq->heap[smallest]);\n        heapifyDown(pq, smallest);\n    }\n}\n\nint dequeue(PriorityQueue* pq) {\n    if (pq->size == 0) return -1; \n    int result = pq->heap[0];\n    pq->heap[0] = pq->heap[pq->size - 1];\n    pq->size--;\n    heapifyDown(pq, 0);\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        B        |L1.48|\n|L1.44|\n        MOV      r0,r1\n|L1.48|\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BNE      |L1.44|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.116|\n        LDR      r0,[r4,#4]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.232|\n|L1.116|\n        BGE      |L1.136|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.232|\n|L1.136|\n        LDR      r5,[r4,#4]\n        CMP      r5,#0\n        BNE      |L1.172|\n        LDR      r5,[r4,#8]\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.172|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.204|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.204|\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.232|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n};\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nNode* minValueNode(Node* node) {\n    Node* current = node;\n    while (current && current->left != NULL)\n        current = current->left;\n    return current;\n}\n\nNode* deleteNode(Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->data)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->data)\n        root->right = deleteNode(root->right, key);\n    else {\n        if (root->left == NULL) {\n            Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisComplete__FP4node PROC\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r3,r0\n        STR      r3,[sp,#0]\n        MOV      r0,#1\n        MOV      lr,sp\n        MOV      r1,#0\n        MOV      r2,#0\n|L1.84|\n        MOV      r3,r2\n        LDR      r3,[lr,r3,LSL #2]\n        ADD      r2,r2,#1\n        LDR      r4,[r3,#4]\n        CMP      r4,#0\n        MOVEQ    r1,#1\n        BEQ      |L1.148|\n        CMP      r1,#1\n        MOVNE    r12,r0\n        STRNE    r4,[lr,r12,LSL #2]\n        ADDNE    r0,r0,#1\n        BNE      |L1.148|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.148|\n        LDR      r12,[r3,#8]\n        CMP      r12,#0\n        MOVEQ    r1,#1\n        BEQ      |L1.200|\n        CMP      r1,#1\n        MOVNE    r3,r0\n        STRNE    r12,[lr,r3,LSL #2]\n        ADDNE    r0,r0,#1\n        BNE      |L1.200|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.200|\n        CMP      r2,r0\n        BLT      |L1.84|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nint isComplete(struct node* root) {\n    if (root == NULL)\n        return 1;\n    int flag = 0;\n    struct node* q[1000];\n    int head = 0, tail = 0;\n    q[tail++] = root;\n    while (head < tail) {\n        struct node* temp = q[head++];\n        if (temp->left) {\n            if (flag == 1) return 0;\n            q[tail++] = temp->left;\n        } else {\n            flag = 1;\n        }\n        if (temp->right) {\n            if (flag == 1) return 0;\n            q[tail++] = temp->right;\n        } else {\n            flag = 1;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmandelbrot__FdT1i PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#4\n        LDR      r11,[sp,#0x38]\n        ADR      r0,|L1.276|\n        LDMIA    r0,{r6,r7}\n        MOV      r4,r6\n        MOV      r8,#0\n        MOV      r5,r7\n        B        |L1.176|\n|L1.36|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dmul\n        MOV      r9,r0\n        MOV      r10,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _drsb\n        LDMIB    sp,{r2,r3}\n        BL       _dadd\n        MOV      r9,r0\n        ADR      r0,|L1.284|\n        LDMIA    r0,{r2,r3}\n        MOV      r10,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r6,r9\n        MOV      r7,r10\n        ADD      r8,r8,#1\n|L1.176|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dmul\n        MOV      r9,r0\n        MOV      r10,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dadd\n        ADR      r2,|L1.292|\n        LDMIA    r2,{r2,r3}\n        BL       _dcmple\n        BCS      |L1.260|\n        CMP      r8,r11\n        BLT      |L1.36|\n|L1.260|\n        MOV      r0,r8\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.276|\n        DCFD     0x0000000000000000\n|L1.284|\n        DCFD     0x4000000000000000\n|L1.292|\n        DCFD     0x4010000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define WIDTH 80\n#define HEIGHT 20\n\nint mandelbrot(double cr, double ci, int maxiter) {\n    double zr = 0.0, zi = 0.0;\n    int i = 0;\n    while (zr * zr + zi * zi < 4.0 && i < maxiter) {\n        double temp = zr * zr - zi * zi + cr;\n        zi = 2.0 * zr * zi + ci;\n        zr = temp;\n        i++;\n    }\n    return i;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidPassword__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        BL       strlen\n        MOV      r7,r0\n        CMP      r0,#8\n        LDMLTFD  sp!,{r4-r8,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r5,#0\n        MOV      r6,#0\n        MOV      r4,#0\n        BL       __rt_ctype_table\n        LDR      r2,[r0,#0]\n|L1.52|\n        LDRB     r0,[r8,r4]\n        LDRB     r0,[r2,r0]\n        TST      r0,#0x20\n        ADDNE    r5,r5,#1\n        BNE      |L1.80|\n        TST      r0,#0x38\n        ADDEQ    r6,r6,#1\n|L1.80|\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.52|\n        CMP      r5,#0\n        CMPGT    r6,#0\n        LDMFD    sp!,{r4-r8,lr}\n        MOVLE    r0,#0\n        MOVGT    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isValidPassword(char* password) {\n    int length = strlen(password);\n    if (length < 8) return 0;\n    int digitCount = 0;\n    int specialCharCount = 0;\n    for (int i = 0; i < length; i++) {\n        if (isdigit(password[i])) digitCount++;\n        else if (!isalnum(password[i])) specialCharCount++;\n    }\n    return digitCount > 0 && specialCharCount > 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverseList__FP4Node PROC\n        MOVS     r1,r0\n        MOV      r0,#0\n        BXEQ     lr\n|L1.12|\n        LDR      r2,[r1,#4]\n        STR      r0,[r1,#4]\n        MOV      r0,r1\n        MOVS     r1,r2\n        BNE      |L1.12|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nNode* reverseList(Node* head) {\n    Node* prev = NULL;\n    Node* current = head;\n    Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_graph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x44\n        ADD      r0,r0,#0x9c00\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#0x1c40\n        ADD      r1,r1,#0x8000\n        STR      r5,[r4,#0]\n        ADD      r0,r4,#4\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP5GraphiT2 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r3,[r0,#0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r12,r1,r1,LSL #3\n        ADD      r12,r12,r1,LSL #4\n        ADD      r12,r0,r12,LSL #4\n        ADD      r12,r12,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r12,#4]\n        ADD      r12,r2,r2,LSL #3\n        ADD      r2,r12,r2,LSL #4\n        ADD      r0,r0,r2,LSL #4\n        ADD      r0,r0,r1,LSL #2\n        STR      r3,[r0,#4]\n        BX       lr\n        ENDP\n\nbfs__FP5Graphi PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x320\n        MOVS     r4,r0\n        ADDEQ    sp,sp,#0x320\n        MOV      r6,r1\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r6,#0\n        LDRGE    r0,[r4,#0]\n        CMPGE    r0,r6\n        ADDLE    sp,sp,#0x320\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        MOV      r1,#0x190\n        ADD      r5,sp,r1\n        MOV      r0,r5\n        BL       __rt_memclr_w\n        MOV      r3,#1\n        STR      r6,[sp,#0]\n        STR      r3,[r5,r6,LSL #2]\n        MOV      r2,#0\n        MOV      r1,#1\n        MOV      lr,sp\n|L1.240|\n        MOV      r0,r2\n        LDR      r6,[lr,r0,LSL #2]\n        LDR      r12,[r4,#0]\n        MOV      r0,#0\n        ADD      r2,r2,#1\n        CMP      r12,#0\n        BLE      |L1.336|\n        ADD      r12,r6,r6,LSL #3\n        ADD      r12,r12,r6,LSL #4\n        ADD      r6,r4,r12,LSL #4\n|L1.280|\n        ADD      r12,r6,r0,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,#1\n        LDREQ    r12,[r5,r0,LSL #2]\n        CMPEQ    r12,#0\n        BNE      |L1.320|\n        MOV      r12,r1\n        STR      r3,[r5,r0,LSL #2]\n        STR      r0,[lr,r12,LSL #2]\n        ADD      r1,r1,#1\n|L1.320|\n        LDR      r12,[r4,#0]\n        ADD      r0,r0,#1\n        CMP      r12,r0\n        BGT      |L1.280|\n|L1.336|\n        CMP      r2,r1\n        BLT      |L1.240|\n        ADD      sp,sp,#0x320\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj_matrix[MAX_VERTICES][MAX_VERTICES];\n} Graph;\n\n\nGraph* create_graph(int vertices) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == NULL) return NULL;\n    graph->vertices = vertices;\n    memset(graph->adj_matrix, 0, sizeof(graph->adj_matrix));\n    return graph;\n}\n\n\nvoid add_edge(Graph* graph, int src, int dest) {\n    if (graph == NULL || src < 0 || src >= graph->vertices || dest < 0 || dest >= graph->vertices) return;\n    graph->adj_matrix[src][dest] = 1;\n    graph->adj_matrix[dest][src] = 1; \n}\n\n\nvoid bfs(Graph* graph, int start_vertex) {\n    if(graph == NULL || start_vertex < 0 || start_vertex >= graph->vertices) return;\n\n    int visited[MAX_VERTICES] = {0};\n    int queue[MAX_VERTICES];\n    int head = 0;\n    int tail = 0;\n\n    queue[tail++] = start_vertex;\n    visited[start_vertex] = 1;\n\n    while (head < tail) {\n        int vertex = queue[head++];\n        \n        for (int i = 0; i < graph->vertices; ++i) {\n            if (graph->adj_matrix[vertex][i] == 1 && !visited[i]) {\n                visited[i] = 1;\n                queue[tail++] = i;\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_safe__FiT1 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.72|\n        LDR      r12,|L1.252|\n|L1.20|\n        LDR      r3,[r12,r2,LSL #2]\n        SUB      r3,r3,r1\n        CMP      r3,#0\n        RSBLT    r3,r3,#0\n        CMP      r3,#0\n        SUBNE    lr,r0,r2\n        CMPNE    lr,r3\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.20|\n|L1.72|\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nsolve_nqueens__FiT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        CMP      r0,r1\n        BNE      |L1.128|\n        LDR      r0,|L1.256|\n        LDR      r1,[r0,#0]  ; count\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]  ; count\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.128|\n        MOV      r4,#0\n        CMP      r6,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        ADD      r7,r5,#1\n        LDR      r8,|L1.252|\n|L1.152|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       is_safe__FiT1\n        CMP      r0,#0\n        BEQ      |L1.188|\n        STR      r4,[r8,r5,LSL #2]\n        MOV      r1,r6\n        MOV      r0,r7\n        BL       solve_nqueens__FiT1\n|L1.188|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.152|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAXN 100\n\nint board[MAXN];\nint count;\n\nint is_safe(int row, int col) {\n    for (int prev_row = 0; prev_row < row; ++prev_row) {\n        int diff = abs(board[prev_row] - col);\n        if (diff == 0 || diff == row - prev_row) return 0;\n    }\n    return 1;\n}\n\nvoid solve_nqueens(int row, int n) {\n    if (row == n) {\n        count++;\n        return;\n    }\n    for (int col = 0; col < n; ++col) {\n        if (is_safe(row, col)) {\n            board[row] = col;\n            solve_nqueens(row + 1, n);\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Listi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Listi PROC\n        MOV      r3,#0\n        LDR      r2,[r0,#0]\n        B        |L1.92|\n|L1.84|\n        MOV      r3,r2\n        LDR      r2,[r2,#4]\n|L1.92|\n        CMP      r2,#0\n        BXEQ     lr\n        LDR      r12,[r2,#0]\n        CMP      r12,r1\n        BNE      |L1.84|\n        CMP      r3,#0\n        LDRNE    r0,[r2,#4]\n        LDREQ    r1,[r2,#4]\n        STRNE    r0,[r3,#4]\n        STREQ    r1,[r0,#0]\n        MOV      r0,r2\n        B        free\n        ENDP\n\nsearch__FP4Listi PROC\n        LDR      r0,[r0,#0]\n        CMP      r0,#0\n        BEQ      |L1.180|\n|L1.152|\n        LDR      r2,[r0,#0]\n        CMP      r2,r1\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BNE      |L1.152|\n|L1.180|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct List {\n    Node* head;\n};\n\nList* createList() {\n    List* list = (List*)malloc(sizeof(List));\n    list->head = NULL;\n    return list;\n}\n\nvoid insert(List* list, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = list->head;\n    list->head = newNode;\n}\n\nvoid deleteNode(List* list, int data) {\n    Node* current = list->head;\n    Node* prev = NULL;\n    while (current != NULL && current->data != data) {\n        prev = current;\n        current = current->next;\n    }\n    if (current == NULL) return;\n    if (prev == NULL) {\n        list->head = current->next;\n    } else {\n        prev->next = current->next;\n    }\n    free(current);\n}\n\nint search(List* list, int data) {\n    Node* current = list->head;\n    while (current != NULL) {\n        if (current->data == data) return 1;\n        current = current->next;\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntarjan__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r4,r0\n        LDR      r0,|L1.508|\n        MOV      r7,r1\n        LDR      r1,[r0,#0xc]  ; timer\n        LDR      r9,|L1.512|\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0xc]  ; timer\n        LDR      r8,|L1.516|\n        STR      r1,[r9,r4,LSL #2]\n        STR      r1,[r8,r4,LSL #2]\n        LDR      r1,[r0,#8]  ; top\n        LDR      r2,|L1.520|\n        ADD      r1,r1,#1\n        STR      r1,[r0,#8]  ; top\n        STR      r4,[r2,r1,LSL #2]\n        LDR      r10,|L1.524|\n        MOV      r1,#1\n        STR      r1,[r10,r4,LSL #2]\n        LDR      r0,[r0,#0]  ; n\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.212|\n        ADD      r1,r4,r4,LSL #1\n        LDR      r0,|L1.528|\n        RSB      r1,r1,r4,LSL #7\n        LDR      r11,|L1.508|\n        ADD      r6,r0,r1,LSL #5\n|L1.112|\n        LDR      r0,[r6,r5,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.196|\n        LDR      r0,[r9,r5,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.172|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       tarjan__FiT1\n        LDR      r0,[r8,r4,LSL #2]\n        LDR      r1,[r8,r5,LSL #2]\n        CMP      r0,r1\n        MOVGE    r0,r1\n        STR      r0,[r8,r4,LSL #2]\n        B        |L1.196|\n|L1.172|\n        CMP      r5,r7\n        BEQ      |L1.196|\n        LDR      r1,[r8,r4,LSL #2]\n        CMP      r1,r0\n        MOVLT    r0,r1\n        STR      r0,[r8,r4,LSL #2]\n|L1.196|\n        LDR      r0,[r11,#0]  ; n\n        ADD      r5,r5,#1\n        CMP      r5,r0\n        BLT      |L1.112|\n|L1.212|\n        LDR      r0,[r8,r4,LSL #2]\n        LDR      r1,[r9,r4,LSL #2]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r11,lr}\n        BXNE     lr\n        MOV      r0,#0\n        LDR      r3,|L1.508|\n        LDR      r2,|L1.520|\n|L1.244|\n        LDR      r1,[r3,#8]  ; top\n        SUB      r12,r1,#1\n        STR      r12,[r3,#8]  ; top\n        LDR      r1,[r2,r1,LSL #2]\n        STR      r0,[r10,r1,LSL #2]\n        CMP      r1,r4\n        BNE      |L1.244|\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\nfindBridges__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r5,|L1.512|\n        MOV      r1,#0xfa0\n        MOV      r0,r5\n        BL       __rt_memclr_w\n        MOV      r1,#0xfa0\n        LDR      r0,|L1.524|\n        BL       __rt_memclr_w\n        LDR      r6,|L1.508|\n        MOV      r0,#0\n        STR      r0,[r6,#0xc]  ; timer\n        STR      r0,[r6,#8]  ; top\n        LDR      r0,[r6,#0]  ; n\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.348|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        MVNEQ    r1,#0\n        MOVEQ    r0,r4\n        BLEQ     tarjan__FiT1\n        LDR      r0,[r6,#0]  ; n\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.348|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAXN 1000\n\nint n, m;\nint low[MAXN], dfn[MAXN], stk[MAXN], top;\nint bridge[MAXN][MAXN];\nint timer;\nint visited[MAXN];\n\nvoid tarjan(int u, int fa) {\n    low[u] = dfn[u] = ++timer;\n    stk[++top] = u;\n    visited[u] = 1;\n    for (int v = 0; v < n; v++) {\n        if (bridge[u][v]) {\n            if (!dfn[v]) {\n                tarjan(v, u);\n                low[u] = low[u] < low[v] ? low[u] : low[v];\n                if (low[v] > dfn[u]) {\n                    //bridge found\n                }\n            } else if (v != fa) {\n                low[u] = low[u] < dfn[v] ? low[u] : dfn[v];\n            }\n        }\n    }\n    if (low[u] == dfn[u]) {\n        int v;\n        do {\n            v = stk[top--];\n            visited[v] = 0;\n        } while (v != u);\n    }\n}\n\nvoid findBridges() {\n    memset(dfn, 0, sizeof(dfn));\n    memset(visited,0,sizeof(visited));\n    timer = 0;\n    top = 0;\n    for (int i = 0; i < n; i++) {\n        if (!dfn[i]) {\n            tarjan(i, -1);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_vector__Fi PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        STR      r5,[r0,#4]\n        MOV      r0,r5,LSL #3\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ncreate_matrix__FiT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#0xc\n        MOV      r7,r1\n        BL       malloc\n        MOV      r5,r0\n        STMIB    r0,{r6,r7}\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        MOV      r4,#0\n        CMP      r6,#0\n        STR      r0,[r5,#0]\n        BLE      |L1.132|\n        MOV      r7,r7,LSL #3\n|L1.104|\n        MOV      r0,r7\n        BL       malloc\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.104|\n|L1.132|\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nfree_vector__FP6vector PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nfree_matrix__FP6matrix PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#4]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.224|\n|L1.196|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        BL       free\n        LDR      r0,[r5,#4]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.196|\n|L1.224|\n        LDR      r0,[r5,#0]\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n\nspectral_clustering__FPPdiT2 PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r9,r2\n        MOV      r5,r1\n        BL       create_matrix__FiT1\n        MOV      r8,r0\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.360|\n        ADR      r11,|L1.608|\n|L1.288|\n        MOV      r4,#0\n        CMP      r5,#0\n        LDMIA    r11,{r0,r1}\n        BLE      |L1.332|\n        LDR      r7,[r10,r6,LSL #2]\n|L1.308|\n        ADD      r2,r7,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.308|\n|L1.332|\n        LDR      r2,[r8,#0]\n        LDR      r2,[r2,r6,LSL #2]\n        ADD      r2,r2,r6,LSL #3\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        STMIA    r2,{r0,r1}\n        BLT      |L1.288|\n|L1.360|\n        MOV      r1,r5\n        MOV      r0,r5\n        BL       create_matrix__FiT1\n        MOV      r11,r0\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.492|\n|L1.388|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.480|\n|L1.400|\n        CMP      r6,r4\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BL       _dflt\n        LDR      r2,[r8,#0]\n        LDR      r2,[r2,r6,LSL #2]\n        ADD      r2,r2,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        LDR      r3,[r11,#0]\n        LDR      r2,[r10,r6,LSL #2]\n        LDR      r3,[r3,r6,LSL #2]\n        ADD      r2,r2,r4,LSL #3\n        ADD      r7,r3,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dsub\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        STMIA    r7,{r0,r1}\n        BLT      |L1.400|\n|L1.480|\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        BLT      |L1.388|\n|L1.492|\n        MOV      r0,r8\n        BL       free_matrix__FP6matrix\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       create_matrix__FiT1\n        MOV      r8,r0\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.588|\n|L1.528|\n        MOV      r4,#0\n        CMP      r9,#0\n        BLE      |L1.576|\n|L1.540|\n        LDR      r0,[r8,#0]\n        LDR      r0,[r0,r6,LSL #2]\n        ADD      r7,r0,r4,LSL #3\n        MUL      r0,r4,r6\n        BL       _dflt\n        ADD      r4,r4,#1\n        CMP      r4,r9\n        STMIA    r7,{r0,r1}\n        BLT      |L1.540|\n|L1.576|\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        BLT      |L1.528|\n|L1.588|\n        MOV      r0,r11\n        BL       free_matrix__FP6matrix\n        MOV      r0,r8\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.608|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_ITER 1000\n\ntypedef struct {\n    double *data;\n    int size;\n} vector;\n\ntypedef struct {\n    double **data;\n    int rows;\n    int cols;\n} matrix;\n\n\nvector* create_vector(int size) {\n    vector* v = (vector*)malloc(sizeof(vector));\n    v->size = size;\n    v->data = (double*)malloc(sizeof(double) * size);\n    return v;\n}\n\nmatrix* create_matrix(int rows, int cols) {\n    matrix* m = (matrix*)malloc(sizeof(matrix));\n    m->rows = rows;\n    m->cols = cols;\n    m->data = (double**)malloc(sizeof(double*) * rows);\n    for (int i = 0; i < rows; i++) {\n        m->data[i] = (double*)malloc(sizeof(double) * cols);\n    }\n    return m;\n}\n\nvoid free_vector(vector* v) {\n    free(v->data);\n    free(v);\n}\n\nvoid free_matrix(matrix* m) {\n    for (int i = 0; i < m->rows; i++) {\n        free(m->data[i]);\n    }\n    free(m->data);\n    free(m);\n}\n\n\nmatrix* spectral_clustering(double **adj_matrix, int n, int k) {\n    //Simplistic implementation, lacks many aspects of true spectral clustering.  Error checking omitted for brevity.\n\n    //1.  Compute the degree matrix\n    matrix* d_matrix = create_matrix(n,n);\n    for(int i =0; i<n; ++i){\n        double sum = 0;\n        for(int j=0; j<n; ++j){\n            sum += adj_matrix[i][j];\n        }\n        d_matrix->data[i][i] = sum;\n    }\n\n\n    //2. Compute the Laplacian matrix  (Unnormalized for simplicity)\n    matrix* laplacian = create_matrix(n,n);\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            laplacian->data[i][j] = d_matrix->data[i][j] * (i==j) - adj_matrix[i][j];\n        }\n    }\n\n    free_matrix(d_matrix);\n\n\n    //3. Eigen decomposition (extremely simplified -  replace with proper algorithm)\n    //In a real implementation, use a robust eigendecomposition library.\n\n    matrix* eigenvectors = create_matrix(n,k); //Only take top k eigenvectors.\n\n    for(int i =0; i<n; ++i){\n        for(int j=0; j<k; ++j){\n            eigenvectors->data[i][j] = (double)(i*j); //replace with actual eigenvector computation\n        }\n    }\n\n    free_matrix(laplacian);\n\n    return eigenvectors;\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nareCharsUnique__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x100\n        MOVS     r5,r0\n        ADDEQ    sp,sp,#0x100\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0x100\n        ADDGT    sp,sp,#0x100\n        MOV      r4,r0\n        LDMGTFD  sp!,{r4-r6,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        MOV      r1,#0x100\n        MOV      r6,sp\n        MOV      r0,sp\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.172|\n        MOV      r2,#1\n|L1.92|\n        LDRB     r1,[r5,r0]\n        CMP      r1,#0\n        BLT      |L1.112|\n        CMP      r1,#0xff\n        BLE      |L1.128|\n|L1.112|\n        ADD      sp,sp,#0x100\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.128|\n        LDRB     r12,[r6,r1]\n        MOV      r3,r6\n        CMP      r12,#0\n        ADDNE    sp,sp,#0x100\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        STRB     r2,[r3,r1]\n        BLT      |L1.92|\n|L1.172|\n        ADD      sp,sp,#0x100\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint areCharsUnique(const char* str) {\n    if (str == 0) return 1;\n    int len = strlen(str);\n    if (len > 256) return 0;\n    char chars[256] = {0};\n    for (int i = 0; i < len; i++) {\n        int val = str[i];\n        if (val < 0 || val > 255) return 0;\n        if (chars[val]) return 0;\n        chars[val] = 1;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompare__FPCvT1 PROC\n        LDR      r0,[r0,#0]\n        LDR      r1,[r1,#0]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n\ncalculateStatistics__FPcPdN32 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0xc00\n        MOV      r10,r1\n        ADR      r1,|L1.484|\n        SUB      sp,sp,#0x3a4\n        MOV      r5,r2\n        BL       fopen\n        MOVS     r6,r0\n        ADDEQ    sp,sp,#0xc00\n        ADDEQ    sp,sp,#0x3b4\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r8,sp\n        B        |L1.80|\n|L1.76|\n        ADD      r4,r4,#1\n|L1.80|\n        ADD      r2,r8,r4,LSL #2\n        ADR      r1,|L1.488|\n        MOV      r0,r6\n        BL       _fscanf\n        CMP      r0,#1\n        BNE      |L1.112|\n        CMP      r4,#0x3e8\n        BLT      |L1.76|\n|L1.112|\n        MOV      r0,r6\n        BL       fclose\n        CMP      r4,#0\n        ADDEQ    sp,sp,#0xc00\n        ADDEQ    sp,sp,#0x3b4\n        ADR      r6,|L1.492|\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r11,#0\n        LDMIA    r6,{r7,r9}\n        BLE      |L1.196|\n|L1.156|\n        LDR      r0,[r8,r11,LSL #2]\n        BL       _dflt\n        MOV      r3,r9\n        MOV      r2,r7\n        BL       _dadd\n        ADD      r11,r11,#1\n        CMP      r11,r4\n        MOV      r7,r0\n        MOV      r9,r1\n        BLT      |L1.156|\n|L1.196|\n        MOV      r0,r4\n        BL       _dflt\n        MOV      r11,r1\n        MOV      r3,r9\n        MOV      r2,r7\n        STR      r0,[sp,#0xfa0]\n        BL       _drdiv\n        STMIA    r10,{r0,r1}\n        MOV      r1,r4\n        MOV      r0,r8\n        LDR      r3,|L1.500|\n        MOV      r2,#4\n        BL       qsort\n        TST      r4,#1\n        ADD      r0,r4,r4,LSR #31\n        BNE      |L1.304|\n        MOV      r1,r0,ASR #1\n        ADD      r0,r8,r1,LSL #2\n        LDR      r0,[r0,#-4]\n        LDR      r1,[r8,r1,LSL #2]\n        ADD      r0,r0,r1\n        BL       _dflt\n        ADR      r2,|L1.504|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        STMIA    r5,{r0,r1}\n        B        |L1.320|\n|L1.304|\n        MOV      r0,r0,ASR #1\n        LDR      r0,[r8,r0,LSL #2]\n        BL       _dflt\n        STMIA    r5,{r0,r1}\n|L1.320|\n        MOV      r0,r6\n        LDR      r6,[r6,#0]\n        LDR      r7,[r0,#4]\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.428|\n|L1.344|\n        LDR      r0,[sp,r5,LSL #2]\n        BL       _dflt\n        LDMIA    r10,{r2,r3}\n        BL       _dsub\n        MOV      r8,r0\n        MOV      r0,#2\n        MOV      r9,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_pow\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        MOV      r6,r0\n        MOV      r7,r1\n        BLT      |L1.344|\n|L1.428|\n        MOV      r1,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        LDR      r0,[sp,#0xfa0]\n        BL       _drdiv\n        LDR      r2,[sp,#0xfd8]\n        STMIA    r2,{r0,r1}\n        BL       __softfp_sqrt\n        LDR      r2,[sp,#0xfb0]\n        STMIA    r2,{r0,r1}\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3b4\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.484|\n        DCB      \"r\\0\\0\\0\"\n|L1.488|\n        DCB      \"%d\\0\\0\"\n|L1.492|\n        DCFD     0x0000000000000000\n|L1.500|\n        DCD      compare__FPCvT1\n|L1.504|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 1000\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nvoid calculateStatistics(char *filename, double *mean, double *median, double *stddev, double *variance) {\n    FILE *fp = fopen(filename, \"r\");\n    if (fp == NULL) return;\n\n    int data[MAX_SIZE];\n    int count = 0;\n    while (fscanf(fp, \"%d\", &data[count]) == 1 && count < MAX_SIZE) {\n        count++;\n    }\n    fclose(fp);\n\n    if (count == 0) return;\n\n    double sum = 0;\n    for (int i = 0; i < count; i++) {\n        sum += data[i];\n    }\n    *mean = sum / count;\n\n    qsort(data, count, sizeof(int), compare);\n    if (count % 2 == 0) {\n        *median = (double)(data[count / 2 - 1] + data[count / 2]) / 2;\n    } else {\n        *median = data[count / 2];\n    }\n\n    double sqDiffSum = 0;\n    for (int i = 0; i < count; i++) {\n        sqDiffSum += pow(data[i] - *mean, 2);\n    }\n    *variance = sqDiffSum / count;\n    *stddev = sqrt(*variance);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntrapezoid_area__FdN21 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADD      r5,sp,#0x20\n        LDMIA    r5,{r4,r5}\n        ADR      r10,|L1.148|\n        MOV      r7,r3\n        MOV      r6,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       _dcmple\n        BCC      |L1.84|\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r10,{r2,r3}\n        BL       _dcmple\n        BCC      |L1.84|\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMIA    r10,{r2,r3}\n        BL       _dcmple\n        BCS      |L1.100|\n|L1.84|\n        ADR      r1,|L1.156|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.100|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dadd\n        ADR      r2,|L1.164|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r10,lr}\n        B        _dmul\n|L1.148|\n        DCFD     0x0000000000000000\n|L1.156|\n        DCFD     0xbff0000000000000\n|L1.164|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble trapezoid_area(double base1, double base2, double height) {\n    if (base1 < 0 || base2 < 0 || height < 0) return -1.0;\n    return 0.5 * (base1 + base2) * height;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__FPCc PROC\n        LDRB     r3,[r0,#0]\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r3,#0\n        BEQ      |L1.48|\n|L1.20|\n        LDRB     r3,[r0,r1]\n        RSB      r2,r2,r2,LSL #5\n        ADD      r1,r1,#1\n        ADD      r2,r2,r3\n        LDRB     r3,[r0,r1]\n        CMP      r3,#0\n        BNE      |L1.20|\n|L1.48|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0xa\n        MOV      r1,#0\n        STMIB    r4,{r0,r1}\n        MOV      r1,#8\n        BL       calloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        MOV      r0,r4\n        LDMNEFD  sp!,{r4,lr}\n        BXNE     lr\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfreeHashTable__FP9HashTable PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#4]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.204|\n|L1.160|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #3]\n        BL       free\n        LDR      r0,[r5,#0]\n        ADD      r0,r0,r4,LSL #3\n        LDR      r0,[r0,#4]\n        BL       free\n        LDR      r0,[r5,#4]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.160|\n|L1.204|\n        LDR      r0,[r5,#0]\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n\ninsert__FP9HashTablePCcT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r6,r1\n        MOVS     r5,r0\n        CMPNE    r6,#0\n        MOV      r7,r2\n        CMPNE    r7,#0\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r0,r6\n        BL       hash__FPCc\n        MOV      r1,r0\n        LDR      r0,[r5,#4]\n        MOV      r8,r0\n        BL       __rt_udiv\n        LDR      r9,[r5,#0]\n        MOV      r4,r1\n        LDR      r0,[r9,r1,LSL #3]\n        CMP      r0,#0\n        BEQ      |L1.332|\n|L1.304|\n        ADD      r1,r4,#1\n        MOV      r0,r8\n        BL       __rt_udiv\n        LDR      r0,[r9,r1,LSL #3]\n        MOV      r4,r1\n        CMP      r0,#0\n        BNE      |L1.304|\n|L1.332|\n        MOV      r0,r6\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #3]\n        MOV      r0,r7\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        LDR      r1,[r5,#0]\n        ADD      r1,r1,r4,LSL #3\n        STR      r0,[r1,#4]\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #3]\n        CMP      r1,#0\n        CMPNE    r0,#0\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r0,r1\n        MOV      r1,r6\n        BL       strcpy\n        LDR      r0,[r5,#0]\n        MOV      r1,r7\n        ADD      r0,r0,r4,LSL #3\n        LDR      r0,[r0,#4]\n        BL       strcpy\n        LDR      r0,[r5,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r5,#8]\n        BL       _dflt\n        MOV      r4,r0\n        LDR      r0,[r5,#4]\n        MOV      r6,r1\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r4\n        BL       _drdiv\n        ADR      r2,|L1.512|\n        LDMIA    r2,{r2,r3}\n        BL       _dcmpge\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.512|\n        DCFD     0x3fe8000000000000\n        ENDP\n\nget__FP9HashTablePCc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r5,r0\n        CMPNE    r6,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r0,r6\n        BL       hash__FPCc\n        MOV      r1,r0\n        LDR      r0,[r5,#4]\n        BL       __rt_udiv\n        LDR      r0,[r5,#0]\n        MOV      r4,r1\n        LDR      r0,[r0,r1,LSL #3]\n        CMP      r0,#0\n        BEQ      |L1.660|\n|L1.588|\n        LDR      r0,[r5,#0]\n        MOV      r1,r6\n        LDR      r0,[r0,r4,LSL #3]\n        BL       strcmp\n        CMP      r0,#0\n        LDREQ    r0,[r5,#0]\n        ADDEQ    r0,r0,r4,LSL #3\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADD      r1,r4,#1\n        LDR      r0,[r5,#4]\n        BL       __rt_udiv\n        LDR      r0,[r5,#0]\n        MOV      r4,r1\n        LDR      r0,[r0,r1,LSL #3]\n        CMP      r0,#0\n        BNE      |L1.588|\n|L1.660|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define INITIAL_CAPACITY 10\n#define LOAD_FACTOR 0.75\n\ntypedef struct {\n    char* key;\n    char* value;\n} Entry;\n\ntypedef struct {\n    Entry* entries;\n    int capacity;\n    int size;\n} HashTable;\n\nunsigned int hash(const char* key) {\n    unsigned int hashValue = 0;\n    for (int i = 0; key[i] != '\\0'; i++) {\n        hashValue = 31 * hashValue + key[i];\n    }\n    return hashValue;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    if (ht == NULL) return NULL;\n    ht->capacity = INITIAL_CAPACITY;\n    ht->size = 0;\n    ht->entries = (Entry*)calloc(ht->capacity, sizeof(Entry));\n    if (ht->entries == NULL) {\n        free(ht);\n        return NULL;\n    }\n    return ht;\n}\n\n\nvoid freeHashTable(HashTable* ht) {\n    for (int i = 0; i < ht->capacity; i++) {\n        free(ht->entries[i].key);\n        free(ht->entries[i].value);\n    }\n    free(ht->entries);\n    free(ht);\n}\n\nint insert(HashTable* ht, const char* key, const char* value) {\n    if (ht == NULL || key == NULL || value == NULL) return 0;\n    unsigned int index = hash(key) % ht->capacity;\n    while (ht->entries[index].key != NULL) {\n        index = (index + 1) % ht->capacity;\n    }\n    ht->entries[index].key = (char*)malloc(strlen(key) + 1);\n    ht->entries[index].value = (char*)malloc(strlen(value) + 1);\n    if (ht->entries[index].key == NULL || ht->entries[index].value == NULL) return 0;\n    strcpy(ht->entries[index].key, key);\n    strcpy(ht->entries[index].value, value);\n    ht->size++;\n    if ((double)ht->size / ht->capacity >= LOAD_FACTOR) {\n        //Resize not implemented\n    }\n    return 1;\n}\n\n\nchar* get(HashTable* ht, const char* key) {\n    if (ht == NULL || key == NULL) return NULL;\n    unsigned int index = hash(key) % ht->capacity;\n    while (ht->entries[index].key != NULL) {\n        if (strcmp(ht->entries[index].key, key) == 0) {\n            return ht->entries[index].value;\n        }\n        index = (index + 1) % ht->capacity;\n    }\n    return NULL;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nserialize__FP4NodeP6__FILE PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        MOV      r4,r1\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        ADREQ    r1,|L1.112|\n        BEQ      _fprintf\n        ADR      r1,|L1.116|\n        MOV      r0,r4\n        LDR      r2,[r5,#0]\n        BL       _fprintf\n        MOV      r1,r4\n        LDR      r0,[r5,#4]\n        BL       serialize__FP4NodeP6__FILE\n        MOV      r1,r4\n        LDR      r0,[r5,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        B        serialize__FP4NodeP6__FILE\n|L1.112|\n        DCB      \"N \\0\\0\"\n|L1.116|\n        DCB      \"%d \\0\"\n        ENDP\n\ndeserialize__FP6__FILE PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0xc\n        MOV      r4,sp\n        MOV      r2,sp\n        MOV      r5,r0\n        ADR      r1,|L1.252|\n        BL       _fscanf\n        CMN      r0,#1\n        ADDEQ    sp,sp,#0xc\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r0,r4\n        ADR      r1,|L1.256|\n        BL       strcmp\n        CMP      r0,#0\n        ADDEQ    sp,sp,#0xc\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       atoi\n        BL       newNode__Fi\n        MOV      r4,r0\n        MOV      r0,r5\n        BL       deserialize__FP6__FILE\n        STR      r0,[r4,#4]\n        MOV      r0,r5\n        BL       deserialize__FP6__FILE\n        STR      r0,[r4,#8]\n        ADD      sp,sp,#0xc\n        MOV      r0,r4\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.252|\n        DCB      \"%s\\0\\0\"\n|L1.256|\n        DCB      \"N\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid serialize(struct Node* root, FILE* fp) {\n    if (root == NULL) {\n        fprintf(fp, \"N \");\n        return;\n    }\n    fprintf(fp, \"%d \", root->data);\n    serialize(root->left, fp);\n    serialize(root->right, fp);\n}\n\nstruct Node* deserialize(FILE* fp) {\n    char buffer[10];\n    if (fscanf(fp, \"%s\", buffer) == EOF) return NULL;\n    if (strcmp(buffer, \"N\") == 0) return NULL;\n    int data = atoi(buffer);\n    struct Node* node = newNode(data);\n    node->left = deserialize(fp);\n    node->right = deserialize(fp);\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nformatDateTime__FPcUiPC2tm PROC\n        CMP      r0,#0\n        CMPNE    r1,#0\n        CMPNE    r2,#0\n        BXEQ     lr\n        MOV      r3,r2\n        ADR      r2,|L1.28|\n        B        strftime\n|L1.28|\n        DCB      \"%Y-%\"\n        DCB      \"m-%d\"\n        DCB      \" %H:\"\n        DCB      \"%M:%\"\n        DCB      \"S\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid formatDateTime(char* output, size_t outputSize, const struct tm* timeinfo) {\n    if (!output || outputSize == 0 || !timeinfo) return;\n\n    strftime(output, outputSize, \"%Y-%m-%d %H:%M:%S\", timeinfo);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitializeBoard__Fv PROC\n|L1.0|\n        LDR      r12,|L1.440|\n        MOV      r1,#0\n        MOV      r2,#0x20\n|L1.12|\n        ADD      r3,r1,r1,LSL #1\n        ADD      r3,r3,r12\n        MOV      r0,#0\n|L1.24|\n        STRB     r2,[r3,r0]\n        ADD      r0,r0,#1\n        CMP      r0,#3\n        BLT      |L1.24|\n        ADD      r1,r1,#1\n        CMP      r1,#3\n        BLT      |L1.12|\n        LDR      r1,|L1.444|\n        MOV      r0,#1\n        STR      r0,[r1,#0]  ; currentPlayer\n        BX       lr\n        ENDP\n\ncheckWin__Fv PROC\n        LDR      r2,|L1.440|\n        MOV      r0,#0\n|L1.76|\n        ADD      r1,r0,r0,LSL #1\n        LDRB     r12,[r2,r1]\n        CMP      r12,#0x20\n        BEQ      |L1.128|\n        ADD      r3,r1,r2\n        LDRB     r1,[r3,#1]\n        CMP      r12,r1\n        LDREQB   r3,[r3,#2]\n        CMPEQ    r1,r3\n        ADDEQ    r0,r0,r0,LSL #1\n        LDREQB   r0,[r2,r0]\n        SUBEQ    r0,r0,#0x30\n        BXEQ     lr\n|L1.128|\n        LDRB     r12,[r2,r0]\n        CMP      r12,#0x20\n        BEQ      |L1.172|\n        ADD      r3,r2,r0\n        LDRB     r1,[r3,#3]\n        CMP      r12,r1\n        LDREQB   r3,[r3,#6]\n        CMPEQ    r1,r3\n        LDREQB   r0,[r2,r0]\n        SUBEQ    r0,r0,#0x30\n        BXEQ     lr\n|L1.172|\n        ADD      r0,r0,#1\n        CMP      r0,#3\n        BLT      |L1.76|\n        LDRB     r1,[r2,#0]  ; board\n        LDR      r0,|L1.440|\n        LDRB     r0,[r0,#4]\n        CMP      r1,#0x20\n        BEQ      |L1.224|\n        CMP      r1,r0\n        LDREQB   r3,[r2,#8]  ; board\n        CMPEQ    r0,r3\n        SUBEQ    r0,r1,#0x30\n        BXEQ     lr\n|L1.224|\n        LDRB     r1,[r2,#2]  ; board\n        CMP      r1,#0x20\n        BEQ      |L1.256|\n        CMP      r1,r0\n        LDREQB   r3,[r2,#6]  ; board\n        CMPEQ    r0,r3\n        SUBEQ    r0,r1,#0x30\n        BXEQ     lr\n|L1.256|\n        MOV      r1,#0\n        MOV      r3,r2\n|L1.264|\n        ADD      r2,r1,r1,LSL #1\n        ADD      r2,r2,r3\n        MOV      r0,#0\n|L1.276|\n        LDRB     r12,[r2,r0]\n        CMP      r12,#0x20\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,#3\n        BLT      |L1.276|\n        ADD      r1,r1,#1\n        CMP      r1,#3\n        BLT      |L1.264|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nmakeMove__FiT1 PROC\n        CMP      r0,#3\n        CMPCC    r1,#3\n        BXCS     lr\n        ADD      r2,r0,r0,LSL #1\n        LDR      r0,|L1.440|\n        ADD      r2,r2,r0\n        LDRB     r0,[r2,r1]\n        CMP      r0,#0x20\n        BXNE     lr\n        LDR      r12,|L1.444|\n        LDR      r3,[r12,#0]  ; currentPlayer\n        CMP      r3,#1\n        MOVNE    r0,#0x4f\n        MOVEQ    r0,#0x58\n        STRB     r0,[r2,r1]\n        RSB      r0,r3,#3\n        STR      r0,[r12,#0]  ; currentPlayer\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define SIZE 3\n\nchar board[SIZE][SIZE];\nint currentPlayer;\n\nvoid initializeBoard() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            board[i][j] = ' ';\n        }\n    }\n    currentPlayer = 1;\n}\n\nint checkWin() {\n    // Check rows and columns\n    for (int i = 0; i < SIZE; i++) {\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) return board[i][0] - '0';\n        if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i]) return board[0][i] - '0';\n    }\n    // Check diagonals\n    if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) return board[0][0] - '0';\n    if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) return board[0][2] - '0';\n    \n    // Check draw\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (board[i][j] == ' ') return 0;\n        }\n    }\n    return -1; // Draw\n}\n\nvoid makeMove(int row, int col) {\n    if (row >= 0 && row < SIZE && col >= 0 && col < SIZE && board[row][col] == ' ') {\n        board[row][col] = (currentPlayer == 1) ? 'X' : 'O';\n        currentPlayer = 3 - currentPlayer;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncelsiusToFahrenheit__Fd PROC\n        STMFD    sp!,{r3,lr}\n        ADR      r2,|L1.48|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.56|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        ADR      r2,|L1.64|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDR      lr,[sp],#4\n        B        _dadd\n|L1.48|\n        DCFD     0x4022000000000000\n|L1.56|\n        DCFD     0x4014000000000000\n|L1.64|\n        DCFD     0x4040000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble celsiusToFahrenheit(double celsius) {\n    return (celsius * 9.0 / 5.0) + 32.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninit__FP16DoublyLinkedList PROC\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        BX       lr\n        ENDP\n\nappend__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#8]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        STREQ    r0,[r4,#4]\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#4]\n        STR      r0,[r1,#4]\n        LDR      r1,[r4,#4]\n        STR      r1,[r0,#8]\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nreverse__FP16DoublyLinkedList PROC\n        LDR      r2,[r0,#0]\n        MOV      r1,r0\n        CMP      r2,#0\n        LDRNE    r0,[r2,#4]\n        CMPNE    r0,#0\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        STMIA    r1,{r0,r2}\n        MOV      r2,#0\n        CMP      r0,#0\n        BXEQ     lr\n|L1.160|\n        LDR      r1,[r0,#4]\n        STR      r1,[r0,#8]\n        STR      r2,[r0,#4]\n        MOV      r2,r0\n        MOVS     r0,r1\n        BNE      |L1.160|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n    Node *prev;\n};\n\nstruct DoublyLinkedList {\n    Node *head;\n    Node *tail;\n};\n\nvoid init(DoublyLinkedList *list) {\n    list->head = NULL;\n    list->tail = NULL;\n}\n\nvoid append(DoublyLinkedList *list, int data) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    if (newNode == NULL) return;\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\n    if (list->head == NULL) {\n        list->head = newNode;\n        list->tail = newNode;\n    } else {\n        list->tail->next = newNode;\n        newNode->prev = list->tail;\n        list->tail = newNode;\n    }\n}\n\n\nvoid reverse(DoublyLinkedList *list) {\n    if (list->head == NULL || list->head->next == NULL) return;\n    Node *temp = list->head;\n    list->head = list->tail;\n    list->tail = temp;\n    Node *current = list->head;\n    Node *next;\n    Node *prev = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        current->prev = next;\n        prev = current;\n        current = next;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateRNN__Fv PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r0,#0x2e8\n        ADD      r0,r0,#0x400\n        BL       malloc\n        MOV      r7,r0\n        MOV      r6,#0\n        ADR      r9,|L1.220|\n|L1.28|\n        ADD      r0,r6,r6,LSL #2\n        ADD      r8,r7,r0,LSL #4\n        MOV      r4,#0\n|L1.40|\n        BL       rand\n        BL       _dflt\n        ADD      r5,r8,r4,LSL #3\n        LDMIA    r9,{r2,r3}\n        BL       _ddiv\n        STMIA    r5,{r0,r1}\n        BL       rand\n        BL       _dflt\n        ADD      r5,r5,#0x320\n        LDMIA    r9,{r2,r3}\n        BL       _ddiv\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        STMIA    r5,{r0,r1}\n        BLT      |L1.40|\n        BL       rand\n        BL       _dflt\n        ADD      r2,r7,r6,LSL #3\n        ADD      r4,r2,#0x640\n        LDMIA    r9,{r2,r3}\n        BL       _ddiv\n        ADD      r6,r6,#1\n        CMP      r6,#0xa\n        STMIA    r4,{r0,r1}\n        BLT      |L1.28|\n        MOV      r4,#0\n|L1.144|\n        BL       rand\n        BL       _dflt\n        ADD      r2,r7,r4,LSL #3\n        ADD      r5,r2,#0x690\n        LDMIA    r9,{r2,r3}\n        BL       _ddiv\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        STMIA    r5,{r0,r1}\n        BLT      |L1.144|\n        BL       rand\n        BL       _dflt\n        LDMIA    r9,{r2,r3}\n        BL       _ddiv\n        ADD      r2,r7,#0x6e0\n        STMIA    r2,{r0,r1}\n        MOV      r0,r7\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.220|\n        DCFD     0x41dfffffffc00000\n        ENDP\n\nsigmoid__Fd PROC\n        STMFD    sp!,{r4,lr}\n        EOR      r1,r1,#0x80000000\n        BL       __softfp_exp\n        ADR      r4,|L1.264|\n        LDMIA    r4,{r2,r3}\n        BL       _dadd\n        LDMIA    r4,{r2,r3}\n        LDMFD    sp!,{r4,lr}\n        B        _drdiv\n|L1.264|\n        DCFD     0x3ff0000000000000\n        ENDP\n\nrnn_forward__FP3RNNPdiT2 PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x64\n        MOV      r11,r0\n        LDR      r0,[sp,#0x6c]\n        MOV      r8,r3\n        MOV      r0,r0,LSL #3\n        BL       malloc\n        STR      r0,[sp,#0x58]\n        LDR      r0,[sp,#0x6c]\n        MOV      r1,#0\n        STR      r1,[sp,#0x54]\n        CMP      r0,#0\n        BLE      |L1.656|\n|L1.324|\n        ADD      r4,sp,#4\n        MOV      r0,r4\n        MOV      r1,#0x50\n        BL       __rt_memclr_w\n        LDR      r1,[sp,#0x54]\n        MOV      r6,#0\n        ADD      r0,r1,r1,LSL #2\n        STR      r0,[sp,#0x60]\n|L1.356|\n        ADD      r0,r6,r6,LSL #2\n        ADD      r0,r11,r0,LSL #4\n        ADD      r1,sp,#4\n        ADD      r5,r1,r6,LSL #3\n        STR      r0,[sp,#0x5c]\n        MOV      r4,#0\n|L1.380|\n        LDR      r0,[sp,#0x5c]\n        LDR      r1,[sp,#0x68]\n        ADD      r7,r0,r4,LSL #3\n        LDR      r0,[sp,#0x60]\n        ADD      r0,r4,r0,LSL #1\n        ADD      r0,r1,r0,LSL #3\n        LDMIA    r0,{r2,r3}\n        LDMIA    r7,{r0,r1}\n        BL       _dmul\n        LDMIA    r5,{r2,r3}\n        BL       _dadd\n        STR      r0,[r5,#0]\n        STR      r1,[r5,#4]\n        MOV      r10,r1\n        ADD      r1,r8,r4,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r1,r7,#0x320\n        MOV      r9,r0\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        STMIA    r5,{r0,r1}\n        BLT      |L1.380|\n        ADD      r0,r11,r6,LSL #3\n        ADD      r0,r0,#0x640\n        LDMIA    r0,{r2,r3}\n        LDMIA    r5,{r0,r1}\n        BL       _dadd\n        ADD      r4,r8,r6,LSL #3\n        STMIA    r5,{r0,r1}\n        BL       sigmoid__Fd\n        ADD      r6,r6,#1\n        CMP      r6,#0xa\n        STMIA    r4,{r0,r1}\n        BLT      |L1.356|\n        ADD      r6,r11,#0x6e0\n        LDMIA    r6,{r5,r6}\n        MOV      r4,#0\n|L1.548|\n        ADD      r1,r8,r4,LSL #3\n        ADD      r0,r11,r4,LSL #3\n        ADD      r0,r0,#0x690\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        MOV      r5,r0\n        MOV      r6,r1\n        BLT      |L1.548|\n        LDR      r0,[sp,#0x58]\n        LDR      r1,[sp,#0x54]\n        ADD      r4,r0,r1,LSL #3\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       sigmoid__Fd\n        STMIA    r4,{r0,r1}\n        LDR      r1,[sp,#0x54]\n        LDR      r0,[sp,#0x6c]\n        ADD      r1,r1,#1\n        STR      r1,[sp,#0x54]\n        CMP      r1,r0\n        BLT      |L1.324|\n|L1.656|\n        LDR      r0,[sp,#0x58]\n        ADD      sp,sp,#0x74\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SEQ_LEN 100\n#define HIDDEN_SIZE 10\n\ntypedef struct {\n    double weight_ih[HIDDEN_SIZE][HIDDEN_SIZE];\n    double weight_hh[HIDDEN_SIZE][HIDDEN_SIZE];\n    double bias_h[HIDDEN_SIZE];\n    double weight_ho[1][HIDDEN_SIZE];\n    double bias_o[1];\n} RNN;\n\n\nRNN* createRNN() {\n    RNN* rnn = (RNN*)malloc(sizeof(RNN));\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            rnn->weight_ih[i][j] = (double)rand() / RAND_MAX;\n            rnn->weight_hh[i][j] = (double)rand() / RAND_MAX;\n\n        }\n        rnn->bias_h[i] = (double)rand() / RAND_MAX;\n\n    }\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        rnn->weight_ho[0][i] = (double)rand() / RAND_MAX;\n\n    }\n    rnn->bias_o[0] = (double)rand() / RAND_MAX;\n    return rnn;\n}\n\n\ndouble sigmoid(double x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\ndouble* rnn_forward(RNN* rnn, double* input, int seq_len, double* hidden_state) {\n    double* output = (double*)malloc(seq_len * sizeof(double));\n    for(int t = 0; t < seq_len; t++){\n        double hidden_sum[HIDDEN_SIZE];\n        memset(hidden_sum,0,sizeof(hidden_sum));\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                hidden_sum[i] += rnn->weight_ih[i][j] * input[t*HIDDEN_SIZE + j];\n                hidden_sum[i] += rnn->weight_hh[i][j] * hidden_state[j];\n            }\n            hidden_sum[i] += rnn->bias_h[i];\n            hidden_state[i] = sigmoid(hidden_sum[i]);\n        }\n        double o = rnn->bias_o[0];\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            o += rnn->weight_ho[0][i] * hidden_state[i];\n\n        }\n        output[t] = sigmoid(o);\n    }\n    return output;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nluDecomposition__FPdiN21 PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        MUL      r0,r1,r1\n        MOV      r5,r0,LSL #3\n        MOV      r4,r1\n        MOV      r1,r5\n        MOV      r0,r2\n        SUB      sp,sp,#0xc\n        MOV      r11,r3\n        MOV      r10,r2\n        BL       __rt_memclr_w\n        MOV      r1,r5\n        MOV      r0,r11\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.96|\n        ADR      r12,|L1.448|\n|L1.68|\n        MLA      r1,r4,r0,r0\n        ADD      r1,r10,r1,LSL #3\n        LDMIA    r12,{r2,r3}\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        STMIA    r1,{r2,r3}\n        BLT      |L1.68|\n|L1.96|\n        CMP      r4,#0\n        ADDLE    sp,sp,#0x1c\n        MOV      r5,#0\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n|L1.116|\n        MOV      r7,r5\n        CMP      r5,r4\n        BGE      |L1.256|\n|L1.128|\n        ADR      r0,|L1.456|\n        LDMIA    r0,{r8,r9}\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.208|\n|L1.148|\n        MLA      r0,r4,r6,r7\n        ADD      r1,r11,r0,LSL #3\n        MLA      r0,r4,r5,r6\n        ADD      r0,r10,r0,LSL #3\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        MOV      r8,r0\n        MOV      r9,r1\n        BLT      |L1.148|\n|L1.208|\n        MLA      r1,r4,r5,r7\n        LDR      r0,[sp,#0xc]\n        ADD      r6,r11,r1,LSL #3\n        ADD      r0,r0,r1,LSL #3\n        LDMIA    r0,{r0,r1}\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        ADD      r7,r7,#1\n        CMP      r7,r4\n        STMIA    r6,{r0,r1}\n        BLT      |L1.128|\n|L1.256|\n        ADD      r7,r5,#1\n        STR      r7,[sp,#8]\n        CMP      r7,r4\n        BGE      |L1.424|\n        MLA      r0,r4,r5,r5\n        ADD      r2,r11,r0,LSL #3\n        STR      r2,[sp,#4]\n|L1.284|\n        ADR      r0,|L1.456|\n        LDMIA    r0,{r8,r9}\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.364|\n|L1.304|\n        MLA      r0,r4,r6,r5\n        ADD      r1,r11,r0,LSL #3\n        MLA      r0,r4,r7,r6\n        ADD      r0,r10,r0,LSL #3\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        MOV      r8,r0\n        MOV      r9,r1\n        BLT      |L1.304|\n|L1.364|\n        LDR      r0,[sp,#0xc]\n        MLA      r6,r4,r7,r5\n        ADD      r0,r0,r6,LSL #3\n        LDMIA    r0,{r0,r1}\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        LDR      r2,[sp,#4]\n        ADD      r6,r10,r6,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        ADD      r7,r7,#1\n        CMP      r7,r4\n        STMIA    r6,{r0,r1}\n        BLT      |L1.284|\n|L1.424|\n        LDR      r5,[sp,#8]\n        CMP      r5,r4\n        BLT      |L1.116|\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.448|\n        DCFD     0x3ff0000000000000\n|L1.456|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid luDecomposition(double *a, int n, double *l, double *u) {\n    memset(l, 0, n * n * sizeof(double));\n    memset(u, 0, n * n * sizeof(double));\n\n    for (int i = 0; i < n; i++) {\n        l[i * n + i] = 1.0;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int k = i; k < n; k++) {\n            double sum = 0.0;\n            for (int j = 0; j < i; j++) {\n                sum += l[i * n + j] * u[j * n + k];\n            }\n            u[i * n + k] = a[i * n + k] - sum;\n        }\n\n        for (int k = i + 1; k < n; k++) {\n            double sum = 0.0;\n            for (int j = 0; j < i; j++) {\n                sum += l[k * n + j] * u[j * n + i];\n            }\n            l[k * n + i] = (a[k * n + i] - sum) / u[i * n + i];\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsearch__FP4Nodei PROC\n|L1.0|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#8]\n        LDRGT    r0,[r0,#4]\n        B        |L1.0|\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int val) : data(val), left(NULL), right(NULL) {}\n};\n\nNode* search(Node* root, int key) {\n    if (root == NULL || root->data == key)\n        return root;\n    if (key < root->data)\n        return search(root->left, key);\n    return search(root->right, key);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nallocate_memory__FUi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        STRNE    r5,[r4,#4]\n        MOVNE    r0,r4\n        LDMNEFD  sp!,{r3-r5,lr}\n        BXNE     lr\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfree_memory__FP11MemoryBlock PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nget_memory_usage__Fv PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x194\n        MOV      r6,#0\n        BL       clock\n        MOV      r5,#0\n        MOV      r4,#0\n        ADD      r7,sp,#4\n|L1.144|\n        BL       rand\n        MOV      r1,r0,ASR #31\n        ADD      r1,r0,r1,LSR #22\n        MOV      r1,r1,ASR #10\n        SUB      r0,r0,r1,LSL #10\n        ADD      r0,r0,#1\n        BL       allocate_memory__FUi\n        STR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.208|\n        LDR      r0,[r0,#4]\n        ADD      r4,r4,#1\n        CMP      r4,#0x64\n        ADD      r5,r5,#1\n        ADD      r6,r0,r6\n        BLT      |L1.144|\n|L1.208|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.240|\n|L1.220|\n        LDR      r0,[r7,r4,LSL #2]\n        BL       free_memory__FP11MemoryBlock\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.220|\n|L1.240|\n        BL       clock\n        MOV      r0,r6\n        ADD      sp,sp,#0x194\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct MemoryBlock {\n    void* ptr;\n    size_t size;\n};\n\nMemoryBlock* allocate_memory(size_t size) {\n    MemoryBlock* block = (MemoryBlock*)malloc(sizeof(MemoryBlock));\n    if (block == NULL) return NULL;\n    block->ptr = malloc(size);\n    if (block->ptr == NULL) {\n        free(block);\n        return NULL;\n    }\n    block->size = size;\n    return block;\n}\n\nvoid free_memory(MemoryBlock* block) {\n    if (block != NULL) {\n        free(block->ptr);\n        free(block);\n    }\n}\n\nsize_t get_memory_usage() {\n    size_t total_memory_usage = 0;\n    clock_t start = clock();\n    MemoryBlock* blocks[100];\n    int count = 0;\n    for(int i = 0; i < 100; ++i) {\n        size_t size = (rand() % 1024) + 1;\n        blocks[i] = allocate_memory(size);\n        if(blocks[i] == NULL) break;\n        total_memory_usage += blocks[i]->size;\n        count++;\n    }\n    \n    for(int i = 0; i < count; ++i){\n        free_memory(blocks[i]);\n    }\n    clock_t end = clock();\n    \n    return total_memory_usage;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n|L1.0|\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbuildAVLTree__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BXLE     lr\n|L1.640|\n        LDR      r1,[r6,r4,LSL #2]\n        BL       insert__FP4Nodei\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.640|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left, *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return (node);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\nNode* buildAVLTree(int preOrder[], int n) {\n    Node* root = NULL;\n    for(int i = 0; i < n; i++) {\n        root = insert(root, preOrder[i]);\n    }\n    return root;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPiT1 PROC\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        ADD      r2,r2,r3\n        STR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        SUB      r2,r2,r3\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#0]\n        SUB      r1,r1,r2\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(int *x, int *y) {\n    *x = *x + *y;\n    *y = *x - *y;\n    *x = *x - *y;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_of_squares__FPii PROC\n|L1.0|\n        CMP      r1,#0\n        BLE      |L1.16|\n        CMP      r0,#0\n        BNE      |L1.24|\n|L1.16|\n        MOV      r0,#0\n        BX       lr\n|L1.24|\n        MOV      r3,#0\n        MOV      r2,#0\n|L1.32|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        MLA      r3,r12,r12,r3\n        BLT      |L1.32|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_of_squares(int arr[], int n) {\n    if (n <= 0 || arr == NULL) return 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i] * arr[i];\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npostOrderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r1,r0\n        MOV      r0,#0\n        MOV      r6,sp\n        MVN      r4,#0\n|L1.72|\n        CMP      r1,#0\n        BEQ      |L1.100|\n|L1.80|\n        ADD      r4,r4,#1\n        STR      r1,[r6,r4,LSL #2]\n        LDR      r1,[r1,#4]\n        CMP      r1,#0\n        BNE      |L1.80|\n|L1.100|\n        CMN      r4,#1\n        ADDEQ    sp,sp,#0xfa0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r5,[r6,r4,LSL #2]\n        LDR      r1,[r5,#8]\n        CMP      r1,#0\n        CMPNE    r1,r0\n        BNE      |L1.72|\n        ADR      r0,|L1.164|\n        LDR      r1,[r5,#0]\n        BL       _printf\n        SUB      r4,r4,#1\n        MOV      r0,r5\n        MOV      r1,#0\n        B        |L1.72|\n|L1.164|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nvoid postOrderIterative(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* stack[1000];\n    int top = -1;\n    struct Node* current = root;\n    struct Node* visited = NULL;\n\n    while (1) {\n        while (current != NULL) {\n            stack[++top] = current;\n            current = current->left;\n        }\n\n        if (top == -1) break;\n\n        current = stack[top];\n        if (current->right == NULL || current->right == visited){\n            printf(\"%d \", current->data);\n            top--;\n            visited = current;\n            current = NULL;\n        } else {\n            current = current->right;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci_even_sum__Fx PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r11,r1\n        ADR      r1,|L1.168|\n        LDMIA    r1,{r4,r5}\n        MOV      r10,r0\n        ADR      r0,|L1.160|\n        ADR      r0,|L1.160|\n        LDMIA    r0,{r8,r9}\n        SUBS     r0,r10,r4\n        SBCS     r1,r11,r5\n        MOV      r6,r4\n        MOV      r7,r5\n        BLT      |L1.144|\n|L1.52|\n        ADR      r0,|L1.176|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _ll_sdiv\n        MOV      r0,r2\n        ADR      r2,|L1.160|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.108|\n        ADDS     r8,r8,r4\n        ADC      r9,r9,r5\n|L1.108|\n        MOV      r0,r4\n        MOV      r4,r6\n        MOV      r1,r5\n        MOV      r5,r7\n        ADDS     r6,r0,r6\n        ADC      r7,r1,r7\n        SUBS     r0,r10,r4\n        SBCS     r1,r11,r5\n        BGE      |L1.52|\n|L1.144|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.160|\n        DCQ      0x0000000000000000\n|L1.168|\n        DCQ      0x0000000000000001\n|L1.176|\n        DCQ      0x0000000000000002\n        ENDP\n```",
        "output": "```cpp\n\nlong long fibonacci_even_sum(long long limit) {\n    long long a = 1, b = 1, sum = 0;\n    while (a <= limit) {\n        if (a % 2 == 0) sum += a;\n        long long temp = a;\n        a = b;\n        b = temp + b;\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhasCycleUtil__FiPiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r0,#1\n        STR      r0,[r1,r7,LSL #2]\n        STR      r0,[r2,r7,LSL #2]\n        MOV      r6,r1\n        ADD      r1,r7,r7,LSL #3\n        LDR      r0,|L1.364|\n        ADD      r1,r1,r7,LSL #4\n        ADD      r8,r0,r1,LSL #4\n        MOV      r5,r2\n        MOV      r4,#0\n|L1.48|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.128|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.108|\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       hasCycleUtil__FiPiT2\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n        B        |L1.128|\n|L1.108|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.128|\n        ADD      r4,r4,#1\n        CMP      r4,#0x64\n        BLT      |L1.48|\n        MOV      r0,#0\n        STR      r0,[r5,r7,LSL #2]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nhasCycle__Fi PROC\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r6,|L1.368|\n        MOV      r5,r0\n        MOV      r0,r6\n        SUB      sp,sp,#0x194\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        ADD      r7,sp,#4\n        MOV      r0,r7\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.272|\n|L1.212|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.260|\n        MOV      r2,r7\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       hasCycleUtil__FiPiT2\n        CMP      r0,#0\n        ADDNE    sp,sp,#0x194\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.260|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.212|\n|L1.272|\n        ADD      sp,sp,#0x194\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint graph[MAX_VERTICES][MAX_VERTICES];\n\nint hasCycleUtil(int v, int visited[], int recStack[]) {\n    visited[v] = 1;\n    recStack[v] = 1;\n    for (int i = 0; i < MAX_VERTICES; i++) {\n        if (graph[v][i]) {\n            if (!visited[i]) {\n                if (hasCycleUtil(i, visited, recStack))\n                    return 1;\n            } else if (recStack[i])\n                return 1;\n        }\n    }\n    recStack[v] = 0;\n    return 0;\n}\n\nint hasCycle(int V) {\n    memset(visited, 0, sizeof(visited));\n    int recStack[MAX_VERTICES];\n    memset(recStack, 0, sizeof(recStack));\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            if (hasCycleUtil(i, visited, recStack))\n                return 1;\n        }\n    }\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       inorder__FP4Node\n        ADR      r0,|L1.88|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        inorder__FP4Node\n|L1.88|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nvoid inorder(struct Node *root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcdExtended__FxT1PxT3 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#0x18\n        ADD      r7,sp,#0x38\n        LDMIA    r7,{r6,r7}\n        ADR      r10,|L1.240|\n        MOV      r9,r3\n        MOV      r8,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r5,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r4,r0\n        BNE      |L1.100|\n        LDMIA    r10,{r0,r1}\n        STMIA    r6,{r0,r1}\n        ADR      r0,|L1.248|\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[r7,#4]\n        STR      r1,[r7,#0]\n        ADD      sp,sp,#0x18\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.100|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _ll_sdiv\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r0,r2\n        MOV      r1,r3\n        ADD      r3,sp,#8\n        ADD      r2,sp,#0x10\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       gcdExtended__FxT1PxT3\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        MOV      r4,r0\n        UMULL    r0,r12,r8,r2\n        MLA      r12,r2,r9,r12\n        MOV      r5,r1\n        MLA      r1,r3,r8,r12\n        ADD      r3,sp,#8\n        LDMIA    r3,{r2,r3}\n        RSBS     r0,r0,r2\n        RSC      r1,r1,r3\n        STMIA    r6,{r0,r1}\n        ADD      r1,sp,#0x10\n        LDMIA    r1,{r0,r1}\n        STMIA    r7,{r0,r1}\n        ADD      sp,sp,#0x18\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.240|\n        DCQ      0x0000000000000000\n|L1.248|\n        DCQ      0x0000000000000001\n        ENDP\n\nmodInverse__FxT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c\n        MOV      r5,r3\n        MOV      r4,r2\n        ADD      r2,sp,#0x14\n        ADD      r3,sp,#0xc\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       gcdExtended__FxT1PxT3\n        ADR      r2,|L1.248|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        ADRNE    r1,|L1.392|\n        LDMNEIA  r1,{r0,r1}\n        ADDNE    sp,sp,#0x1c\n        LDMNEFD  sp!,{r4,r5,lr}\n        BXNE     lr\n        ADD      r1,sp,#0x14\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_sdiv\n        ADDS     r0,r2,r4\n        ADC      r1,r3,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_sdiv\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r2\n        MOV      r1,r3\n        BX       lr\n|L1.392|\n        DCQ      0xffffffffffffffff\n        ENDP\n```",
        "output": "```cpp\n\nlong long gcdExtended(long long a, long long b, long long *x, long long *y) {\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    long long x1, y1;\n    long long gcd = gcdExtended(b % a, a, &x1, &y1);\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return gcd;\n}\n\nlong long modInverse(long long a, long long m) {\n    long long x, y;\n    long long g = gcdExtended(a, m, &x, &y);\n    if (g != 1)\n        return -1;\n    else {\n        long long res = (x % m + m) % m;\n        return res;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nparseNumber__FP10Expression PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r4,r0\n        ADR      r0,|L1.212|\n        LDMIA    r0,{r6,r7}\n        LDR      r0,[r4,#0]\n        MOV      r10,#1\n        BL       strlen\n        LDR      r1,[r4,#4]\n        CMP      r0,r1\n        BLS      |L1.64|\n        LDR      r0,[r4,#0]\n        LDRB     r0,[r0,r1]\n        CMP      r0,#0x2d\n        ADDEQ    r0,r1,#1\n        STREQ    r0,[r4,#4]\n        MVNEQ    r10,#0\n|L1.64|\n        ADR      r11,|L1.220|\n        BL       __rt_ctype_table\n        MOV      r9,r0\n        B        |L1.140|\n|L1.80|\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r11,{r2,r3}\n        BL       _dmul\n        MOV      r6,r0\n        SUB      r0,r8,#0x30\n        MOV      r7,r1\n        BL       _dflt\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      r6,r0\n        ADD      r0,r5,#1\n        STR      r0,[r4,#4]\n        MOV      r7,r1\n|L1.140|\n        LDR      r0,[r4,#0]\n        BL       strlen\n        LDR      r5,[r4,#4]\n        CMP      r0,r5\n        BLS      |L1.184|\n        LDR      r0,[r4,#0]\n        LDRB     r8,[r0,r5]\n        LDR      r0,[r9,#0]\n        LDRB     r0,[r0,r8]\n        TST      r0,#0x20\n        BNE      |L1.80|\n|L1.184|\n        MOV      r0,r10\n        BL       _dflt\n        MOV      r3,r7\n        MOV      r2,r6\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dmul\n|L1.212|\n        DCFD     0x0000000000000000\n|L1.220|\n        DCFD     0x4024000000000000\n        ENDP\n\nprecedence__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVEQ    r0,#2\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\napplyOp__FdT1c PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        LDR      r1,[sp,#0x18]\n        MOV      r6,r0\n        MOV      r5,r3\n        MOV      r4,r2\n        CMP      r1,#0x2a\n        BEQ      |L1.460|\n        CMP      r1,#0x2b\n        BEQ      |L1.404|\n        CMP      r1,#0x2d\n        BEQ      |L1.432|\n        ADR      r0,|L1.212|\n        CMP      r1,#0x2f\n        MOVNE    r1,r0\n        LDRNE    r1,[r1,#4]\n        LDRNE    r0,[r0,#0]\n        LDMNEFD  sp!,{r3-r7,lr}\n        BXNE     lr\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _dcmpeq\n        BNE      |L1.376|\n        ADR      r0,|L1.488|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.376|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        _ddiv\n|L1.404|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        _dadd\n|L1.432|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        _dsub\n|L1.460|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        _dmul\n|L1.488|\n        DCB      \"Erro\"\n        DCB      \"r: D\"\n        DCB      \"ivis\"\n        DCB      \"ion \"\n        DCB      \"by z\"\n        DCB      \"ero\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n\nevaluate__FP10Expression PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        MOV      r4,r0\n        BL       parseNumber__FP10Expression\n        MOV      r11,r0\n        STR      r1,[sp,#8]\n        LDR      r0,[r4,#0]\n        BL       strlen\n        LDR      r1,[r4,#4]\n        CMP      r0,r1\n        BLS      |L1.840|\n|L1.560|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        LDRB     r6,[r1,r0]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        ADR      r0,|L1.860|\n        MOV      r1,r6\n        BL       strchr\n        CMP      r0,#0\n        BNE      |L1.616|\n        ADR      r0,|L1.868|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.616|\n        MOV      r0,r4\n        BL       parseNumber__FP10Expression\n        MOV      r7,r0\n        LDR      r0,[r4,#0]\n        MOV      r8,r1\n        BL       strlen\n        LDR      r1,[r4,#4]\n        CMP      r0,r1\n        LDRHI    r0,[r4,#0]\n        MOVLS    r5,#0\n        LDRHIB   r5,[r0,r1]\n        B        |L1.752|\n|L1.664|\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       parseNumber__FP10Expression\n        MOV      r9,r0\n        LDR      r0,[r4,#0]\n        MOV      r10,r1\n        BL       strlen\n        LDR      r1,[r4,#4]\n        MOV      r3,r10\n        CMP      r0,r1\n        LDRHI    r0,[r4,#0]\n        MOVLS    r5,#0\n        LDRHIB   r5,[r0,r1]\n        STR      r6,[sp,#0]\n        MOV      r1,r8\n        MOV      r0,r7\n        MOV      r2,r9\n        BL       applyOp__FdT1c\n        MOV      r7,r0\n        MOV      r8,r1\n|L1.752|\n        CMP      r5,#0\n        BEQ      |L1.788|\n        MOV      r0,r5\n        BL       precedence__Fc\n        MOV      r1,r0\n        MOV      r0,r6\n        BL       precedence__Fc\n        CMP      r1,r0\n        BGE      |L1.664|\n|L1.788|\n        MOV      r3,r8\n        MOV      r2,r7\n        STR      r6,[sp,#0]\n        MOV      r0,r11\n        LDR      r1,[sp,#8]\n        BL       applyOp__FdT1c\n        MOV      r11,r0\n        STR      r1,[sp,#8]\n        LDR      r0,[r4,#0]\n        BL       strlen\n        LDR      r1,[r4,#4]\n        CMP      r0,r1\n        BHI      |L1.560|\n|L1.840|\n        LDR      r1,[sp,#8]\n        ADD      sp,sp,#0xc\n        MOV      r0,r11\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.860|\n        DCB      \"+-*/\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.868|\n        DCB      \"Inva\"\n        DCB      \"lid \"\n        DCB      \"oper\"\n        DCB      \"ator\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    char* expression;\n    int pos;\n} Expression;\n\ndouble parseNumber(Expression* expr) {\n    double num = 0;\n    int sign = 1;\n    if (expr->pos < strlen(expr->expression) && expr->expression[expr->pos] == '-') {\n        sign = -1;\n        expr->pos++;\n    }\n    while (expr->pos < strlen(expr->expression) && isdigit(expr->expression[expr->pos])) {\n        num = num * 10 + (expr->expression[expr->pos] - '0');\n        expr->pos++;\n    }\n    return num * sign;\n}\n\nint precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n\ndouble applyOp(double a, double b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': \n            if (b == 0) {\n                printf(\"Error: Division by zero\\n\");\n                exit(1);\n            }\n            return a / b;\n    }\n    return 0; \n}\n\ndouble evaluate(Expression* expr) {\n    double result = parseNumber(expr);\n    while (expr->pos < strlen(expr->expression)) {\n        char op = expr->expression[expr->pos];\n        expr->pos++;\n        if (!strchr(\"+-*/\", op)) {\n            printf(\"Invalid operator\\n\");\n            exit(1);\n        }\n        double nextNum = parseNumber(expr);\n        \n        char nextOp = expr->pos < strlen(expr->expression) ? expr->expression[expr->pos] : '\\0';\n        while(nextOp != '\\0' && precedence(nextOp) >= precedence(op)){\n            double temp = nextNum;\n            expr->pos++;\n            nextNum = parseNumber(expr);\n            nextOp = expr->pos < strlen(expr->expression) ? expr->expression[expr->pos] : '\\0';\n            temp = applyOp(temp, nextNum, op);\n            nextNum = temp;\n\n        }\n\n        result = applyOp(result, nextNum, op);\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.320|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.468|\n|L1.320|\n        BGE      |L1.340|\n        LDR      r0,[r4,#0xc]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#0xc]\n        B        |L1.468|\n|L1.340|\n        LDR      r1,[r4,#8]\n        CMP      r1,#0\n        LDRNE    r0,[r4,#0xc]\n        CMPNE    r0,#0\n        BNE      |L1.400|\n        CMP      r1,#0\n        LDREQ    r0,[r4,#0xc]\n        MOVNE    r0,r1\n        CMP      r0,#0\n        LDMNEIA  r0,{r1-r3,r12}\n        STMNEIA  r4,{r1-r3,r12}\n        MOVEQ    r0,r4\n        MOVEQ    r4,#0\n        BL       free\n        B        |L1.452|\n|L1.400|\n        LDR      r2,[r0,#8]\n        MOV      r1,r0\n        CMP      r2,#0\n        BEQ      |L1.432|\n|L1.416|\n        LDR      r1,[r1,#8]\n        LDR      r2,[r1,#8]\n        CMP      r2,#0\n        BNE      |L1.416|\n|L1.432|\n        LDR      r2,[r1,#0]\n        STR      r2,[r4,#0]\n        LDR      r1,[r1,#0]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.452|\n        CMP      r4,#0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n|L1.468|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        MOV      r3,r0\n        CMP      r0,#1\n        BLE      |L1.584|\n        LDR      r0,[r4,#8]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r4,lr}\n        BGE      rightRotate__FP4Node\n        LDR      r0,[r4,#8]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        BGE      |L1.584|\n        LDR      r0,[r4,#8]\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        rightRotate__FP4Node\n|L1.584|\n        CMN      r3,#1\n        BGE      |L1.656|\n        LDR      r0,[r4,#0xc]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4,lr}\n        BLE      leftRotate__FP4Node\n        LDR      r0,[r4,#0xc]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        BLE      |L1.656|\n        LDR      r0,[r4,#0xc]\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        leftRotate__FP4Node\n|L1.656|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* deleteNode(Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->key)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->key)\n        root->right = deleteNode(root->right, key);\n    else {\n        if ((root->left == NULL) || (root->right == NULL)) {\n            Node *temp = root->left ? root->left : root->right;\n            if (temp == NULL) {\n                temp = root;\n                root = NULL;\n            } else\n                *root = *temp;\n            free(temp);\n        } else {\n            Node* temp = root->right;\n            while (temp->left != NULL)\n                temp = temp->left;\n            root->key = temp->key;\n            root->right = deleteNode(root->right, temp->key);\n        }\n    }\n    if (root == NULL) return root;\n    root->height = 1 + max(height(root->left), height(root->right));\n    int balance = getBalance(root);\n    if (balance > 1 && getBalance(root->left) >= 0)\n        return rightRotate(root);\n    if (balance > 1 && getBalance(root->left) < 0) {\n        root->left = leftRotate(root->left);\n        return rightRotate(root);\n    }\n    if (balance < -1 && getBalance(root->right) <= 0)\n        return leftRotate(root);\n    if (balance < -1 && getBalance(root->right) > 0) {\n        root->right = rightRotate(root->right);\n        return leftRotate(root);\n    }\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\npreOrderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        STR      r0,[sp,#0]\n        MOV      r4,#0\n|L1.68|\n        MOV      r0,r4\n        LDR      r5,[r6,r0,LSL #2]\n        ADR      r0,|L1.144|\n        SUB      r4,r4,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r0,[r5,#8]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        LDR      r0,[r5,#4]\n        CMP      r0,#0\n        ADDNE    r4,r4,#1\n        STRNE    r0,[r6,r4,LSL #2]\n        CMP      r4,#0\n        BGE      |L1.68|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.144|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nvoid preOrderIterative(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* stack[1000];\n    int top = -1;\n\n    stack[++top] = root;\n\n    while (top >= 0) {\n        struct Node* node = stack[top--];\n        printf(\"%d \", node->data);\n\n        if (node->right)\n            stack[++top] = node->right;\n        if (node->left)\n            stack[++top] = node->left;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncomputeStats__FPdi PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x1c\n        MOV      r11,r0\n        MOV      r8,r1\n        MOV      r5,r2\n        CMP      r2,#0\n        BGT      |L1.72|\n        ADD      r0,sp,#4\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r4,#0\n        STMIA    r0,{r1-r4}\n        LDMIA    r0,{r1-r4}\n        STMIA    r11,{r1-r4}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.72|\n        ADR      r4,|L1.324|\n        LDMIA    r4,{r6,r7}\n        MOV      r9,#0\n|L1.84|\n        ADD      r0,r8,r9,LSL #3\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dadd\n        ADD      r9,r9,#1\n        CMP      r9,r5\n        MOV      r6,r0\n        MOV      r7,r1\n        BLT      |L1.84|\n        MOV      r0,r5\n        BL       _dflt\n        MOV      r3,r7\n        MOV      r2,r6\n        STR      r0,[sp,#0x18]\n        STR      r1,[sp,#0x14]\n        BL       _drdiv\n        LDMIA    r4,{r6,r7}\n        MOV      r4,#0\n        MOV      r9,r0\n        MOV      r10,r1\n        CMP      r5,#0\n        BLE      |L1.240|\n|L1.176|\n        ADD      r0,r8,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dsub\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r6,r0\n        MOV      r7,r1\n        BLT      |L1.176|\n|L1.240|\n        MOV      r3,r7\n        MOV      r2,r6\n        LDR      r0,[sp,#0x18]\n        LDR      r1,[sp,#0x14]\n        BL       _drdiv\n        BL       __softfp_sqrt\n        MOV      lr,r1\n        MOV      r1,#0\n        ADD      r4,sp,#4\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r5,#0\n        STMIA    r4,{r1-r3,r5}\n        ADD      r1,sp,#0xc\n        STMIA    r1,{r0,lr}\n        STMIB    sp,{r9,r10}\n        LDMIA    r4,{r0-r3}\n        STMIA    r11,{r0-r3}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.324|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct Result {\n    double mean;\n    double stdev;\n};\n\nResult computeStats(double arr[], int n) {\n    if (n <= 0) {\n        Result res = {0, 0};\n        return res;\n    }\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    double mean = sum / n;\n    double sqDiffSum = 0;\n    for (int i = 0; i < n; i++) {\n        sqDiffSum += (arr[i] - mean) * (arr[i] - mean);\n    }\n    double stdev = sqrt(sqDiffSum / n);\n    Result res = {mean, stdev};\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nromanToInt__FPCc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,#0\n        MOV      r4,#0\n        BL       strlen\n        SUBS     r1,r0,#1\n        BMI      |L1.148|\n|L1.28|\n        LDRB     r0,[r6,r1]\n        CMP      r0,#0x4c\n        MOVEQ    r0,#0x32\n        BEQ      |L1.124|\n        BGT      |L1.88|\n        CMP      r0,#0x43\n        MOVEQ    r0,#0x64\n        BEQ      |L1.124|\n        CMP      r0,#0x44\n        MOVEQ    r0,#0x1f4\n        BEQ      |L1.124|\n        CMP      r0,#0x49\n        MOVEQ    r0,#1\n        BEQ      |L1.124|\n        B        |L1.160|\n|L1.88|\n        CMP      r0,#0x4d\n        MOVEQ    r0,#0x3e8\n        BEQ      |L1.124|\n        CMP      r0,#0x56\n        MOVEQ    r0,#5\n        BEQ      |L1.124|\n        CMP      r0,#0x58\n        BNE      |L1.160|\n        MOV      r0,#0xa\n|L1.124|\n        CMP      r0,r5\n        ADDGE    r4,r4,r0\n        SUBLT    r4,r4,r0\n        SUBS     r1,r1,#1\n        MOV      r5,r0\n        BPL      |L1.28|\n|L1.148|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.160|\n        LDMFD    sp!,{r4-r6,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint romanToInt(const char *roman) {\n    int result = 0;\n    int prevValue = 0;\n    int len = strlen(roman);\n\n    for (int i = len - 1; i >= 0; --i) {\n        int currentValue = 0;\n        switch (roman[i]) {\n            case 'I': currentValue = 1; break;\n            case 'V': currentValue = 5; break;\n            case 'X': currentValue = 10; break;\n            case 'L': currentValue = 50; break;\n            case 'C': currentValue = 100; break;\n            case 'D': currentValue = 500; break;\n            case 'M': currentValue = 1000; break;\n            default: return -1; // Handle invalid characters\n        }\n\n        if (currentValue < prevValue) {\n            result -= currentValue;\n        } else {\n            result += currentValue;\n        }\n        prevValue = currentValue;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__FP5Stackd PROC\n        LDR      r3,[r0,#0]\n        CMP      r3,#0x63\n        BXEQ     lr\n        ADD      r3,r3,#1\n        STR      r3,[r0,#0]\n        ADD      r0,r0,r3,LSL #3\n        STMIB    r0,{r1,r2}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        LDR      r1,[r0,#0]\n        CMN      r1,#1\n        ADREQ    r1,|L1.72|\n        LDMEQIA  r1,{r0,r1}\n        BXEQ     lr\n        SUB      r2,r1,#1\n        STR      r2,[r0,#0]\n        ADD      r1,r0,r1,LSL #3\n        LDMIB    r1,{r0,r1}\n        BX       lr\n|L1.72|\n        DCFD     0x0000000000000000\n        ENDP\n\nevaluate__FPc PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r5,r0\n        MVN      r0,#0\n        SUB      sp,sp,#0x32c\n        STR      r0,[sp,#4]\n        LDRB     r0,[r5,#0]\n        ADD      r10,sp,#4\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.576|\n        BL       __rt_ctype_table\n        STR      r0,[sp,#0x328]\n        ADR      r11,|L1.72|\n|L1.132|\n        LDRB     r1,[r5,r4]\n        LDR      r0,[sp,#0x328]\n        LDR      r8,[r0,#0]\n        LDRB     r0,[r8,r1]\n        TST      r0,#0x20\n        BEQ      |L1.244|\n        LDMIA    r11,{r0,r1}\n        ADR      r9,|L1.596|\n|L1.164|\n        LDMIA    r9,{r2,r3}\n        BL       _dmul\n        MOV      r6,r0\n        LDRB     r0,[r5,r4]\n        MOV      r7,r1\n        SUB      r0,r0,#0x30\n        BL       _dflt\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        ADD      r4,r4,#1\n        LDRB     r2,[r5,r4]\n        LDRB     r2,[r8,r2]\n        TST      r2,#0x20\n        BNE      |L1.164|\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r10\n        BL       push__FP5Stackd\n        B        |L1.564|\n|L1.244|\n        CMP      r1,#0x2b\n        CMPNE    r1,#0x2d\n        CMPNE    r1,#0x2a\n        CMPNE    r1,#0x2f\n        ADDNE    r4,r4,#1\n        BNE      |L1.564|\n        MOV      r0,r10\n        BL       pop__FP5Stack\n        MOV      r7,r0\n        MOV      r0,r10\n        MOV      r6,r1\n        BL       pop__FP5Stack\n        MOV      r8,r0\n        LDRB     r0,[r5,r4]\n        MOV      r9,r1\n        CMP      r0,#0x2b\n        BNE      |L1.352|\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dadd\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r10\n        BL       push__FP5Stackd\n        B        |L1.560|\n|L1.352|\n        CMP      r0,#0x2d\n        BNE      |L1.400|\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dsub\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r10\n        BL       push__FP5Stackd\n        B        |L1.560|\n|L1.400|\n        CMP      r0,#0x2a\n        BNE      |L1.448|\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dmul\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r10\n        BL       push__FP5Stackd\n        B        |L1.560|\n|L1.448|\n        CMP      r0,#0x2f\n        BNE      |L1.560|\n        MOV      r1,r6\n        MOV      r0,r7\n        LDMIA    r11,{r2,r3}\n        BL       _dcmpeq\n        BEQ      |L1.516|\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _ddiv\n        MOV      r2,r1\n        MOV      r1,r0\n        MOV      r0,r10\n        BL       push__FP5Stackd\n        B        |L1.560|\n|L1.516|\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0x2f\n        BNE      |L1.560|\n        MOV      r1,r6\n        MOV      r0,r7\n        LDMIA    r11,{r2,r3}\n        BL       _dcmpeq\n        LDMEQIA  r11,{r0,r1}\n        ADDEQ    sp,sp,#0x32c\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n|L1.560|\n        ADD      r4,r4,#1\n|L1.564|\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.132|\n|L1.576|\n        MOV      r0,r10\n        BL       pop__FP5Stack\n        ADD      sp,sp,#0x32c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.596|\n        DCFD     0x4024000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int top;\n    double data[MAX_SIZE];\n} Stack;\n\nvoid push(Stack *s, double value) {\n    if (s->top == MAX_SIZE - 1) return;\n    s->data[++(s->top)] = value;\n}\n\ndouble pop(Stack *s) {\n    if (s->top == -1) return 0; \n    return s->data[(s->top)--];\n}\n\ndouble evaluate(char *expression) {\n    Stack operandStack;\n    operandStack.top = -1;\n    double op1, op2;\n    int i = 0;\n    while (expression[i] != '\\0') {\n        if (isdigit(expression[i])) {\n            double num = 0;\n            while (isdigit(expression[i])) {\n                num = num * 10 + (expression[i] - '0');\n                i++;\n            }\n            push(&operandStack, num);\n        } else if (expression[i] == '+' || expression[i] == '-' || expression[i] == '*' || expression[i] == '/') {\n            op2 = pop(&operandStack);\n            op1 = pop(&operandStack);\n            if (expression[i] == '+') push(&operandStack, op1 + op2);\n            else if (expression[i] == '-') push(&operandStack, op1 - op2);\n            else if (expression[i] == '*') push(&operandStack, op1 * op2);\n            else if (expression[i] == '/' && op2 != 0) push(&operandStack, op1 / op2);\n            else if (expression[i] == '/' && op2 == 0) return 0;\n            i++;\n        } else {\n            i++;\n        }\n    }\n    return pop(&operandStack);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateAccount__Fi PROC\n        ADR      r3,|L1.16|\n        LDMIA    r3,{r2,r3}\n        STMIA    r0,{r1-r3}\n        BX       lr\n|L1.16|\n        DCFD     0x0000000000000000\n        ENDP\n\ndeposit__FP7Accountd PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r4,r0\n        ADR      r0,|L1.16|\n        MOV      r5,r1\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r5\n        MOV      r1,r6\n        BL       _dcmple\n        LDMLSFD  sp!,{r4-r6,lr}\n        MOVLS    r0,#0\n        BXLS     lr\n        MOV      r3,r6\n        MOV      r2,r5\n        LDMIB    r4,{r0,r1}\n        BL       _dadd\n        STMIB    r4,{r0,r1}\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nwithdraw__FP7Accountd PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r4,r0\n        ADR      r0,|L1.16|\n        MOV      r5,r1\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r5\n        MOV      r1,r6\n        BL       _dcmple\n        BLS      |L1.164|\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMIB    r4,{r2,r3}\n        BL       _dcmpge\n        BLS      |L1.176|\n|L1.164|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.176|\n        MOV      r3,r6\n        MOV      r2,r5\n        LDMIB    r4,{r0,r1}\n        BL       _dsub\n        STMIB    r4,{r0,r1}\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Account {\n    int accountNumber;\n    double balance;\n};\n\nAccount createAccount(int accountNumber) {\n    Account acc;\n    acc.accountNumber = accountNumber;\n    acc.balance = 0.0;\n    return acc;\n}\n\nint deposit(Account* acc, double amount) {\n    if (amount <= 0) return 0;\n    acc->balance += amount;\n    return 1;\n}\n\nint withdraw(Account* acc, double amount) {\n    if (amount <= 0 || amount > acc->balance) return 0;\n    acc->balance -= amount;\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nchat__FPcT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r1\n        ADR      r1,|L1.200|\n        SUB      sp,sp,#0x400\n        BL       fopen\n        MOV      r5,r0\n        MOV      r0,r4\n        ADR      r1,|L1.200|\n        BL       fopen\n        MOV      r4,r0\n        CMP      r5,#0\n        CMPNE    r4,#0\n        ADDEQ    sp,sp,#0x400\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r6,sp\n|L1.64|\n        MOV      r2,r5\n        MOV      r1,#0x400\n        MOV      r0,r6\n        BL       fgets\n        MOV      r0,r5\n        BL       feof\n        CMP      r0,#0\n        BNE      |L1.172|\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       fputs\n        MOV      r0,r4\n        BL       fflush\n        MOV      r2,r4\n        MOV      r1,#0x400\n        MOV      r0,r6\n        BL       fgets\n        MOV      r0,r4\n        BL       feof\n        CMP      r0,#0\n        BNE      |L1.172|\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       fputs\n        MOV      r0,r5\n        BL       fflush\n        B        |L1.64|\n|L1.172|\n        MOV      r0,r5\n        BL       fclose\n        MOV      r0,r4\n        BL       fclose\n        ADD      sp,sp,#0x400\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.200|\n        DCB      \"r+\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define BUFFER_SIZE 1024\n\nvoid chat(char* name1, char* name2) {\n    char buffer[BUFFER_SIZE];\n    FILE* fp1 = fopen(name1, \"r+\");\n    FILE* fp2 = fopen(name2, \"r+\");\n    if (!fp1 || !fp2) return;\n\n    while (1) {\n        fgets(buffer, BUFFER_SIZE, fp1);\n        if (feof(fp1)) break;\n        fputs(buffer, fp2);\n        fflush(fp2);\n        fgets(buffer, BUFFER_SIZE, fp2);\n        if (feof(fp2)) break;\n        fputs(buffer, fp1);\n        fflush(fp1);\n    }\n\n    fclose(fp1);\n    fclose(fp2);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid permute(char *str, int l, int r) {\n    if (l == r)\n        printf(\"%s\\n\", str);\n    else {\n        for (int i = l; i <= r; i++) {\n            swap((str + l), (str + i));\n            permute(str, l + 1, r);\n            swap((str + l), (str + i)); \n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateAdjList__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STMIA    r0,{r1,r5}\n        MOV      r4,r0\n        MOV      r0,r5,LSL #3\n        BL       malloc\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP7AdjListiN22 PROC\n        LDMIA    r0,{r1,r12}\n        CMP      r1,r12\n        BXGE     lr\n        LDR      r12,[r0,#8]\n        STR      r2,[r12,r1,LSL #3]\n        LDR      r1,[r0,#8]\n        LDR      r2,[r0,#0]\n        ADD      r1,r1,r2,LSL #3\n        STR      r3,[r1,#4]\n        LDR      r1,[r0,#0]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n\ndijkstra__FPP7AdjListiN22 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r8,r1,LSL #2\n        MOV      r7,r0\n        MOV      r0,r8\n        MOV      r9,r2\n        MOV      r6,r1\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,r8\n        BL       malloc\n        MOV      r5,r0\n        MOV      r0,r8\n        BL       malloc\n        MOV      r8,r0\n        MOV      r0,#0\n        MOV      r2,#0\n        CMP      r6,#0\n        BLE      |L1.208|\n        MVN      r3,#0\n        MVN      r1,#0x80000000\n|L1.184|\n        STR      r1,[r4,r0,LSL #2]\n        STR      r2,[r5,r0,LSL #2]\n        STR      r3,[r8,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.184|\n|L1.208|\n        SUB      lr,r6,#1\n        CMP      lr,#0\n        STR      r2,[r4,r9,LSL #2]\n        MOV      r12,#0\n        BLE      |L1.420|\n        MOV      r9,#1\n|L1.232|\n        MVN      r3,#0x80000000\n        MVN      r0,#0\n        MOV      r1,#0\n        CMP      r6,#0\n        BLE      |L1.420|\n|L1.252|\n        LDR      r2,[r5,r1,LSL #2]\n        CMP      r2,#0\n        BNE      |L1.280|\n        LDR      r2,[r4,r1,LSL #2]\n        CMP      r2,r3\n        MOVLE    r3,r2\n        MOVLE    r0,r1\n|L1.280|\n        ADD      r1,r1,#1\n        CMP      r1,r6\n        BLT      |L1.252|\n        CMN      r0,#1\n        BEQ      |L1.420|\n        STR      r9,[r5,r0,LSL #2]\n        LDR      r2,[r7,r0,LSL #2]\n        MOV      r1,#0\n        LDR      r2,[r2,#0]\n        CMP      r2,#0\n        BLE      |L1.408|\n|L1.324|\n        LDR      r2,[r7,r0,LSL #2]\n        LDR      r3,[r2,#8]\n        LDR      r2,[r3,r1,LSL #3]\n        ADD      r3,r3,r1,LSL #3\n        LDR      r10,[r3,#4]\n        LDR      r3,[r5,r2,LSL #2]\n        CMP      r3,#0\n        BNE      |L1.388|\n        LDR      r3,[r4,r0,LSL #2]\n        CMN      r3,#0x80000001\n        ADDNE    r3,r3,r10\n        LDRNE    r10,[r4,r2,LSL #2]\n        CMPNE    r3,r10\n        BGE      |L1.388|\n        STR      r3,[r4,r2,LSL #2]\n        STR      r0,[r8,r2,LSL #2]\n|L1.388|\n        LDR      r2,[r7,r0,LSL #2]\n        ADD      r1,r1,#1\n        LDR      r2,[r2,#0]\n        CMP      r2,r1\n        BGT      |L1.324|\n|L1.408|\n        ADD      r12,r12,#1\n        CMP      r12,lr\n        BLT      |L1.232|\n|L1.420|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define INFINITY INT_MAX\n\ntypedef struct {\n    int vertex;\n    int weight;\n} Edge;\n\ntypedef struct {\n    int size;\n    int capacity;\n    Edge* edges;\n} AdjList;\n\n\nAdjList* createAdjList(int capacity) {\n    AdjList* list = (AdjList*)malloc(sizeof(AdjList));\n    list->size = 0;\n    list->capacity = capacity;\n    list->edges = (Edge*)malloc(capacity * sizeof(Edge));\n    return list;\n}\n\nvoid addEdge(AdjList* adjList, int u, int v, int w) {\n    if (adjList->size >= adjList->capacity) return;\n    adjList->edges[adjList->size].vertex = v;\n    adjList->edges[adjList->size].weight = w;\n    adjList->size++;\n}\n\n\nint* dijkstra(AdjList* graph[], int numVertices, int source, int destination) {\n    int* distances = (int*)malloc(numVertices * sizeof(int));\n    int* visited = (int*)malloc(numVertices * sizeof(int));\n    int* previous = (int*)malloc(numVertices * sizeof(int));\n\n    for (int i = 0; i < numVertices; i++) {\n        distances[i] = INFINITY;\n        visited[i] = 0;\n        previous[i] = -1;\n    }\n    distances[source] = 0;\n\n    for (int count = 0; count < numVertices - 1; count++) {\n        int minDistance = INFINITY;\n        int minVertex = -1;\n        for (int v = 0; v < numVertices; v++) {\n            if (!visited[v] && distances[v] <= minDistance) {\n                minDistance = distances[v];\n                minVertex = v;\n            }\n        }\n\n        if (minVertex == -1) break;\n        visited[minVertex] = 1;\n\n        for (int i = 0; i < graph[minVertex]->size; i++) {\n            int v = graph[minVertex]->edges[i].vertex;\n            int weight = graph[minVertex]->edges[i].weight;\n            if (!visited[v] && distances[minVertex] != INFINITY && distances[minVertex] + weight < distances[v]) {\n                distances[v] = distances[minVertex] + weight;\n                previous[v] = minVertex;\n            }\n        }\n    }\n    free(visited);\n    return previous;\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.408|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0xa\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP9HashTableiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       hash__Fi\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        STMIA    r0,{r6,r7}\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #2]\n        STR      r1,[r0,#8]\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nsearch__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r4,r1\n        BL       hash__Fi\n        LDR      r1,[r5,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.220|\n|L1.188|\n        LDR      r1,[r0,#0]\n        CMP      r1,r4\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.188|\n|L1.220|\n        LDMFD    sp!,{r4,r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nfreeHashTable__FP9HashTable PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r4,#0\n|L1.244|\n        LDR      r0,[r6,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.276|\n|L1.260|\n        LDR      r5,[r0,#8]\n        BL       free\n        MOVS     r0,r5\n        BNE      |L1.260|\n|L1.276|\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        BLT      |L1.244|\n        LDR      r0,[r6,#0]\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct Node {\n    int key;\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct HashTable {\n    Node** table;\n} HashTable;\n\n\nunsigned int hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    ht->table = (Node**)calloc(TABLE_SIZE, sizeof(Node*));\n    return ht;\n}\n\nvoid insert(HashTable* ht, int key, int value) {\n    unsigned int index = hash(key);\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->value = value;\n    newNode->next = ht->table[index];\n    ht->table[index] = newNode;\n}\n\nint search(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    Node* current = ht->table[index];\n    while (current != NULL) {\n        if (current->key == key) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return -1; \n}\n\n\nvoid freeHashTable(HashTable* ht){\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        Node* current = ht->table[i];\n        while (current != NULL) {\n            Node* next = current->next;\n            free(current);\n            current = next;\n        }\n    }\n    free(ht->table);\n    free(ht);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FPA100_iiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r8,|L1.340|\n        MOV      r6,r0\n        MOV      r0,#1\n        STR      r0,[r8,r1,LSL #2]\n        MOV      r5,r2\n        MOV      r4,#0\n        CMP      r2,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        ADD      r0,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        ADD      r7,r6,r0,LSL #4\n|L1.52|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r8,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.88|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       dfs__FPA100_iiT2\n|L1.88|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.52|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\n\nvoid dfs(int adj[][MAX_VERTICES], int v, int n) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (adj[v][i] == 1 && !visited[i]) {\n            dfs(adj, i, n);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npreorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.48|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       preorder__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        preorder__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid preorder(Node *root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    preorder(root->left);\n    preorder(root->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisTreeHelper__FPPiiN22 PROC\n|L1.0|\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r9,|L1.452|\n        MOV      r5,r1\n        LDR      r1,[r9,#0]  ; visited\n        MOV      r7,r0\n        MOV      r0,#1\n        STR      r0,[r1,r5,LSL #2]\n        MOV      r8,r2\n        MOV      r6,r3\n        MOV      r4,#0\n        CMP      r3,#0\n        BLE      |L1.140|\n|L1.48|\n        LDR      r0,[r7,r5,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#1\n        BNE      |L1.128|\n        CMP      r4,r8\n        BEQ      |L1.128|\n        LDR      r0,[r9,#0]  ; visited\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#1\n        LDMEQFD  sp!,{r4-r9,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r3,r6\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r7\n        BL       isTreeHelper__FPPiiN22\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r9,lr}\n        BXEQ     lr\n|L1.128|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.48|\n|L1.140|\n        LDMFD    sp!,{r4-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nisTree__FPPii PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        MOV      r5,r1,LSL #2\n        MOV      r0,r5\n        MOV      r4,r1\n        BL       malloc\n        LDR      r6,|L1.452|\n        MOV      r1,r5\n        STR      r0,[r6,#0]  ; visited\n        BL       __rt_memclr_w\n        MOV      r3,r4\n        MVN      r2,#0\n        MOV      r1,#0\n        MOV      r0,r7\n        BL       isTreeHelper__FPPiiN22\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BXEQ     lr\n        CMP      r4,#0\n        BLE      |L1.272|\n        LDR      r1,[r6,#0]\n|L1.240|\n        LDR      r2,[r1,r0,LSL #2]\n        CMP      r2,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.240|\n|L1.272|\n        LDR      r0,[r6,#0]  ; visited\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint* visited;\n\nint isTreeHelper(int** adj, int v, int parent, int n) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (adj[v][i] == 1) {\n            if (i != parent) {\n                if (visited[i] == 1) {\n                    return 0;\n                }\n                if (!isTreeHelper(adj, i, v, n))\n                    return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint isTree(int** adj, int n) {\n    visited = (int*)malloc(n * sizeof(int));\n    memset(visited, 0, n * sizeof(int));\n    \n    if (!isTreeHelper(adj, 0, -1, n)) return 0;\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i] == 0)\n            return 0;\n    }\n    free(visited);\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompare__FPCvT1 PROC\n|L1.0|\n        LDR      r1,[r1,#0]\n        LDR      r0,[r0,#0]\n        B        strcmp\n        ENDP\n\nbwt__FPc PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        BL       strlen\n        MOV      r4,r0\n        MOV      r0,#4\n        ADD      r0,r0,r4,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.104|\n        ADD      r8,r4,#1\n|L1.60|\n        MOV      r0,r8\n        BL       malloc\n        STR      r0,[r6,r5,LSL #2]\n        ADD      r1,r7,r5\n        BL       strcpy\n        LDR      r0,[r6,r5,LSL #2]\n        MOV      r1,r7\n        BL       strcat\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        BLT      |L1.60|\n|L1.104|\n        MOV      r5,#0\n        STR      r5,[r6,r4,LSL #2]\n        LDR      r3,|L1.316|\n        MOV      r2,#4\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       qsort\n        ADD      r0,r4,#1\n        BL       malloc\n        MOV      r7,r0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.184|\n|L1.156|\n        LDR      r1,[r6,r0,LSL #2]\n        ADD      r1,r1,r4\n        LDRB     r1,[r1,#-1]\n        STRB     r1,[r7,r0]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.156|\n|L1.184|\n        STRB     r5,[r7,r4]\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.220|\n|L1.200|\n        LDR      r0,[r6,r5,LSL #2]\n        BL       free\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        BLT      |L1.200|\n|L1.220|\n        MOV      r0,r6\n        BL       free\n        MOV      r0,r7\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint compare(const void* a, const void* b) {\n    return strcmp(*(const char**)a, *(const char**)b);\n}\n\nchar* bwt(char* text) {\n    int n = strlen(text);\n    char** rotations = (char**)malloc((n + 1) * sizeof(char*));\n    for (int i = 0; i < n; ++i) {\n        rotations[i] = (char*)malloc((n + 1) * sizeof(char));\n        strcpy(rotations[i], text + i);\n        strcat(rotations[i], text);\n    }\n    rotations[n] = 0;\n\n    qsort(rotations, n, sizeof(char*), compare);\n\n    char* result = (char*)malloc((n + 1) * sizeof(char));\n    for (int i = 0; i < n; ++i) {\n        result[i] = rotations[i][n - 1];\n    }\n    result[n] = '\\0';\n\n    for (int i = 0; i < n; ++i) {\n        free(rotations[i]);\n    }\n    free(rotations);\n\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x14\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r4,[r0,#0]\n        STRB     r1,[r0,#4]\n        STR      r1,[r0,#8]\n        STR      r1,[r0,#0xc]\n        STR      r1,[r0,#0x10]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrotateLeft__FPP4nodeP4node PROC\n        LDR      r2,[r1,#0xc]\n        LDR      r3,[r2,#8]\n        STR      r3,[r1,#0xc]\n        LDR      r3,[r2,#8]\n        CMP      r3,#0\n        STRNE    r1,[r3,#0x10]\n        LDR      r3,[r1,#0x10]\n        STR      r3,[r2,#0x10]\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.124|\n        LDR      r0,[r3,#8]\n        CMP      r0,r1\n        STRNE    r2,[r3,#0xc]\n        STREQ    r2,[r3,#8]\n|L1.124|\n        STR      r1,[r2,#8]\n        STR      r2,[r1,#0x10]\n        BX       lr\n        ENDP\n\nrotateRight__FPP4nodeP4node PROC\n        LDR      r2,[r1,#8]\n        LDR      r3,[r2,#0xc]\n        STR      r3,[r1,#8]\n        LDR      r3,[r2,#0xc]\n        CMP      r3,#0\n        STRNE    r1,[r3,#0x10]\n        LDR      r3,[r1,#0x10]\n        STR      r3,[r2,#0x10]\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.200|\n        LDR      r0,[r3,#0xc]\n        CMP      r0,r1\n        STRNE    r2,[r3,#8]\n        STREQ    r2,[r3,#0xc]\n|L1.200|\n        STR      r1,[r2,#0xc]\n        STR      r2,[r1,#0x10]\n        BX       lr\n        ENDP\n\ninsertFixup__FPP4nodeP4node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,#0\n        MOV      r6,#1\n        MOV      r5,r0\n        MOV      r4,r1\n        B        |L1.492|\n|L1.236|\n        LDR      r2,[r0,#0x10]\n        LDR      r1,[r2,#8]\n        CMP      r0,r1\n        BNE      |L1.376|\n        LDR      r1,[r2,#0xc]\n        CMP      r1,#0\n        BEQ      |L1.308|\n        LDRB     r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.308|\n        STRB     r6,[r0,#4]\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r4,[r0,#0x10]\n        B        |L1.492|\n|L1.308|\n        LDR      r1,[r0,#0xc]\n        CMP      r1,r4\n        BNE      |L1.336|\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n|L1.336|\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0x10]\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n        B        |L1.492|\n|L1.376|\n        CMP      r1,#0\n        BEQ      |L1.428|\n        LDRB     r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.428|\n        STRB     r6,[r0,#4]\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r4,[r0,#0x10]\n        B        |L1.492|\n|L1.428|\n        LDR      r1,[r0,#8]\n        CMP      r1,r4\n        BNE      |L1.456|\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n|L1.456|\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0x10]\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n|L1.492|\n        CMP      r4,#0\n        LDRNE    r0,[r5,#0]\n        CMPNE    r0,r4\n        BEQ      |L1.524|\n        LDR      r0,[r4,#0x10]\n        LDRB     r1,[r0,#4]\n        CMP      r1,#0\n        BEQ      |L1.236|\n|L1.524|\n        LDR      r0,[r5,#0]\n        STRB     r6,[r0,#4]\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\ninsert__FPP4nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        BL       createNode__Fi\n        LDR      r2,[r4,#0]\n        MOV      r1,#0\n        CMP      r2,#0\n        BEQ      |L1.604|\n        LDR      r3,[r0,#0]\n|L1.576|\n        LDR      r12,[r2,#0]\n        MOV      r1,r2\n        CMP      r3,r12\n        LDRGE    r2,[r2,#0xc]\n        LDRLT    r2,[r2,#8]\n        CMP      r2,#0\n        BNE      |L1.576|\n|L1.604|\n        STR      r1,[r0,#0x10]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        BEQ      |L1.640|\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        STRGE    r0,[r1,#0xc]\n        STRLT    r0,[r1,#8]\n|L1.640|\n        MOV      r1,r0\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        insertFixup__FPP4nodeP4node\n        ENDP\n```",
        "output": "```cpp\n\ntypedef enum {RED, BLACK} color;\n\ntypedef struct node {\n    int key;\n    color c;\n    struct node *left;\n    struct node *right;\n    struct node *parent;\n} node;\n\nnode* createNode(int key) {\n    node* newNode = (node*)malloc(sizeof(node));\n    if (newNode == NULL) return NULL;\n    newNode->key = key;\n    newNode->c = RED;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    newNode->parent = NULL;\n    return newNode;\n}\n\n\nvoid rotateLeft(node **root, node *x) {\n    node *y = x->right;\n    x->right = y->left;\n    if (y->left != NULL) y->left->parent = x;\n    y->parent = x->parent;\n    if (x->parent == NULL) *root = y;\n    else if (x == x->parent->left) x->parent->left = y;\n    else x->parent->right = y;\n    y->left = x;\n    x->parent = y;\n}\n\nvoid rotateRight(node **root, node *x) {\n    node *y = x->left;\n    x->left = y->right;\n    if (y->right != NULL) y->right->parent = x;\n    y->parent = x->parent;\n    if (x->parent == NULL) *root = y;\n    else if (x == x->parent->right) x->parent->right = y;\n    else x->parent->left = y;\n    y->right = x;\n    x->parent = y;\n}\n\nvoid insertFixup(node **root, node *z) {\n    while (z != NULL && z != *root && z->parent->c == RED) {\n        if (z->parent == z->parent->parent->left) {\n            node *y = z->parent->parent->right;\n            if (y != NULL && y->c == RED) {\n                z->parent->c = BLACK;\n                y->c = BLACK;\n                z->parent->parent->c = RED;\n                z = z->parent->parent;\n            } else {\n                if (z == z->parent->right) {\n                    z = z->parent;\n                    rotateLeft(root, z);\n                }\n                z->parent->c = BLACK;\n                z->parent->parent->c = RED;\n                rotateRight(root, z->parent->parent);\n            }\n        } else {\n            node *y = z->parent->parent->left;\n            if (y != NULL && y->c == RED) {\n                z->parent->c = BLACK;\n                y->c = BLACK;\n                z->parent->parent->c = RED;\n                z = z->parent->parent;\n            } else {\n                if (z == z->parent->left) {\n                    z = z->parent;\n                    rotateRight(root, z);\n                }\n                z->parent->c = BLACK;\n                z->parent->parent->c = RED;\n                rotateLeft(root, z->parent->parent);\n            }\n        }\n    }\n    (*root)->c = BLACK;\n}\n\n\nvoid insert(node **root, int key) {\n    node *z = createNode(key);\n    node *y = NULL;\n    node *x = *root;\n    while (x != NULL) {\n        y = x;\n        if (z->key < x->key) x = x->left;\n        else x = x->right;\n    }\n    z->parent = y;\n    if (y == NULL) *root = z;\n    else if (z->key < y->key) y->left = z;\n    else y->right = z;\n    insertFixup(root, z);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindMin__FPii PROC\n|L1.0|\n        CMP      r1,#0\n        MVNLE    r0,#0\n        BXLE     lr\n        SUB      r1,r1,#1\n        CMP      r1,#0\n        STR      lr,[sp,#-4]!\n        MOV      r2,#0\n        BLE      |L1.72|\n|L1.32|\n        SUB      r3,r1,r2\n        ADD      r3,r3,r3,LSR #31\n        ADD      r3,r2,r3,ASR #1\n        LDR      r12,[r0,r3,LSL #2]\n        LDR      lr,[r0,r1,LSL #2]\n        CMP      r12,lr\n        MOVLE    r1,r3\n        ADDGT    r2,r3,#1\n        CMP      r2,r1\n        BLT      |L1.32|\n|L1.72|\n        LDR      r0,[r0,r2,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findMin(int arr[], int size) {\n    if (size <= 0) return -1; //Handle empty array case.\n\n    int left = 0;\n    int right = size - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] > arr[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return arr[left];\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\neigen2x2__F6Matrix PROC\n|L1.0|\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r7,sp,#0x44\n        LDMIA    r7,{r6,r7}\n        ADD      r11,sp,#0x38\n        MOV      r9,r2\n        MOV      r8,r1\n        MOV      r0,r8\n        MOV      r1,r9\n        MOV      r2,r6\n        LDMIA    r11,{r10,r11}\n        MOV      r3,r7\n        BL       _dadd\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r10\n        LDR      r0,[sp,#0x34]\n        MOV      r2,r11\n        LDR      r3,[sp,#0x40]\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _drsb\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r6,r0\n        ADR      r0,|L1.352|\n        LDMIA    r0,{r2,r3}\n        MOV      r7,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _drsb\n        MOV      r6,r0\n        ADR      r0,|L1.360|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r7,r1\n        BL       _dcmpge\n        BCC      |L1.296|\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        ADR      r10,|L1.368|\n        LDMIA    r10,{r2,r3}\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        LDMIA    r10,{r2,r3}\n        BL       _dmul\n        B        |L1.324|\n|L1.296|\n        ADR      r0,|L1.368|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n|L1.324|\n        LDR      r2,[sp,#0x28]\n        STMIA    r2,{r8,r9}\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDMFD    sp!,{r3-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.352|\n        DCFD     0x4010000000000000\n|L1.360|\n        DCFD     0x0000000000000000\n|L1.368|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct Matrix {\n    double a, b, c, d;\n};\n\nstruct Eigenvalues {\n    double lambda1, lambda2;\n};\n\nEigenvalues eigen2x2(Matrix m) {\n    double trace = m.a + m.d;\n    double determinant = m.a * m.d - m.b * m.c;\n    double discriminant = trace * trace - 4 * determinant;\n\n    Eigenvalues result;\n    if (discriminant >= 0) {\n        result.lambda1 = (trace + sqrt(discriminant)) / 2;\n        result.lambda2 = (trace - sqrt(discriminant)) / 2;\n    } else {\n        result.lambda1 = trace / 2;\n        result.lambda2 = trace / 2;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculate_circumference__Fd PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        ADR      r0,|L1.104|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        ADR      r6,|L1.96|\n        MOV      r5,r1\n        BL       _dcmple\n        LDMCCIA  r6,{r0,r1}\n        LDMCCFD  sp!,{r4-r6,lr}\n        BXCC     lr\n        MOV      r1,r5\n        ADR      r0,|L1.112|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        LDMIA    r6,{r0,r1}\n        BL       __softfp_acos\n        MOV      r3,r5\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r6,lr}\n        B        _dmul\n|L1.96|\n        DCFD     0xbff0000000000000\n|L1.104|\n        DCFD     0x0000000000000000\n|L1.112|\n        DCFD     0x4000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble calculate_circumference(double radius) {\n    if (radius < 0) return -1.0; //Error handling for negative radius.\n    return 2 * radius * acos(-1.0);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculate__FdcT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r4,[sp,#0x18]\n        MOV      r7,r1\n        MOV      r6,r0\n        MOV      r5,r3\n        CMP      r2,#0x2a\n        BEQ      |L1.144|\n        CMP      r2,#0x2b\n        BEQ      |L1.96|\n        CMP      r2,#0x2d\n        BEQ      |L1.120|\n        ADR      r8,|L1.212|\n        CMP      r2,#0x2f\n        BNE      |L1.192|\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMIA    r8,{r2,r3}\n        BL       _dcmpeq\n        BNE      |L1.168|\n        ADR      r0,|L1.220|\n        BL       _printf\n        LDMIA    r8,{r0,r1}\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.96|\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r8,lr}\n        B        _dadd\n|L1.120|\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r8,lr}\n        B        _dsub\n|L1.144|\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r8,lr}\n        B        _dmul\n|L1.168|\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r8,lr}\n        B        _ddiv\n|L1.192|\n        ADR      r0,|L1.248|\n        BL       _printf\n        LDMIA    r8,{r0,r1}\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.212|\n        DCFD     0x0000000000000000\n|L1.220|\n        DCB      \"Erro\"\n        DCB      \"r: D\"\n        DCB      \"ivis\"\n        DCB      \"ion \"\n        DCB      \"by z\"\n        DCB      \"ero\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.248|\n        DCB      \"Erro\"\n        DCB      \"r: I\"\n        DCB      \"nval\"\n        DCB      \"id o\"\n        DCB      \"pera\"\n        DCB      \"tor\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\ndouble calculate(double num1, char op, double num2) {\n    switch (op) {\n    case '+': return num1 + num2;\n    case '-': return num1 - num2;\n    case '*': return num1 * num2;\n    case '/': \n        if (num2 == 0) {\n            printf(\"Error: Division by zero\\n\");\n            return 0;\n        }\n        return num1 / num2;\n    default: \n        printf(\"Error: Invalid operator\\n\");\n        return 0;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntriangle_area__FdN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r5,sp,#0x28\n        LDMIA    r5,{r4,r5}\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r7,r3\n        MOV      r6,r2\n        BL       _dadd\n        MOV      r10,r0\n        ADR      r0,|L1.376|\n        LDMIA    r0,{r2,r3}\n        MOV      r11,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dcmple\n        BLS      |L1.208|\n        ADR      r0,|L1.376|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dcmple\n        BLS      |L1.208|\n        ADR      r0,|L1.376|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _dcmple\n        BLS      |L1.208|\n        MOV      r0,r10\n        MOV      r1,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dcmple\n        BLS      |L1.208|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dadd\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dcmple\n        BLS      |L1.208|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dadd\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dcmple\n        BHI      |L1.224|\n|L1.208|\n        ADR      r1,|L1.384|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.224|\n        MOV      r0,r10\n        MOV      r1,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        ADR      r2,|L1.392|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dsub\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dsub\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMFD    sp!,{r3-r11,lr}\n        B        __softfp_sqrt\n|L1.376|\n        DCFD     0x0000000000000000\n|L1.384|\n        DCFD     0xbff0000000000000\n|L1.392|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble triangle_area(double a, double b, double c) {\n    if (a <= 0 || b <= 0 || c <= 0 || a + b <= c || a + c <= b || b + c <= a) {\n        return -1.0;\n    }\n    double s = (a + b + c) / 2.0;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisFull__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0\n        LDRNE    r1,[r4,#8]\n        CMPNE    r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        BL       isFull__FP4Node\n        CMP      r0,#0\n        BEQ      |L1.148|\n        LDR      r0,[r4,#8]\n        BL       isFull__FP4Node\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.148|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nint isFull(struct Node* root) {\n    if (root == NULL)\n        return 1;\n    if (root->left == NULL && root->right == NULL)\n        return 1;\n    if ((root->left) && (root->right))\n        return (isFull(root->left) && isFull(root->right));\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r1\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,r0\n        MOV      r0,r4\n        BL       __rt_sdiv\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        gcd__FiT1\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npackInts__FUiN31 PROC\n        MOV      r0,r0,LSL #24\n        ORR      r0,r0,r1,LSL #16\n        ORR      r0,r0,r2,LSL #8\n        ORR      r0,r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int packInts(unsigned int a, unsigned int b, unsigned int c, unsigned int d) {\n    return (a << 24) | (b << 16) | (c << 8) | d;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateSet__Fi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        MOV      r0,r1,LSL #2\n        SUB      sp,sp,#0xc\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r0,[sp,#0]\n        MOV      r2,sp\n        CMP      r0,#0\n        BNE      |L1.72|\n        STR      r1,[sp,#4]\n        STR      r1,[sp,#8]\n        LDMIA    r2,{r0,r1,r3}\n        STMIA    r4,{r0,r1,r3}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.72|\n        STMIB    sp,{r1,r5}\n        LDMIA    r2,{r0,r1,r3}\n        STMIA    r4,{r0,r1,r3}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\ndestroySet__F3Set PROC\n        B        free\n        ENDP\n\naddElement__FP3Seti PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        LDMIA    r0,{r0,r2}\n        MOV      r5,r1\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.160|\n|L1.128|\n        LDR      r3,[r0,r1,LSL #2]\n        CMP      r3,r5\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r2,r1\n        BGT      |L1.128|\n|L1.160|\n        LDR      r1,[r4,#8]\n        CMP      r2,r1\n        BNE      |L1.208|\n        MOV      r6,r1,LSL #1\n        MOV      r1,r6,LSL #2\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r6,[r4,#8]\n|L1.208|\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nsetUnion__F3SetT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#0x10\n        LDR      r5,[sp,#0x34]\n        ADD      r8,sp,#4\n        MOV      r10,r1\n        MOV      r9,r0\n        MOV      r0,r8\n        ADD      r1,r2,r5\n        LDR      r7,[sp,#0x30]\n        MOV      r6,r2\n        BL       createSet__Fi\n        LDR      r0,[sp,#0xc]\n        CMP      r0,#0\n        LDMEQIA  r8,{r0-r2}\n        STMEQIA  r9,{r0-r2}\n        ADDEQ    sp,sp,#0x10\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.348|\n|L1.324|\n        LDR      r1,[r10,r4,LSL #2]\n        MOV      r0,r8\n        BL       addElement__FP3Seti\n        ADD      r4,r4,#1\n        CMP      r6,r4\n        BGT      |L1.324|\n|L1.348|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.384|\n|L1.360|\n        LDR      r1,[r7,r4,LSL #2]\n        MOV      r0,r8\n        BL       addElement__FP3Seti\n        ADD      r4,r4,#1\n        CMP      r5,r4\n        BGT      |L1.360|\n|L1.384|\n        LDMIA    r8,{r0-r2}\n        STMIA    r9,{r0-r2}\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Set {\n    int* data;\n    int size;\n    int capacity;\n};\n\nstruct Set createSet(int capacity) {\n    struct Set set;\n    set.data = (int*)malloc(capacity * sizeof(int));\n    if (set.data == NULL) {\n        set.size = 0;\n        set.capacity = 0;\n        return set;\n    }\n    set.size = 0;\n    set.capacity = capacity;\n    return set;\n}\n\n\nvoid destroySet(struct Set set) {\n    free(set.data);\n}\n\n\nint addElement(struct Set* set, int element) {\n    for (int i = 0; i < set->size; i++) {\n        if (set->data[i] == element) return 0; \n    }\n    if (set->size == set->capacity) {\n        int newCapacity = set->capacity * 2;\n        int* newData = (int*)realloc(set->data, newCapacity * sizeof(int));\n        if (newData == NULL) return -1;\n        set->data = newData;\n        set->capacity = newCapacity;\n    }\n    set->data[set->size++] = element;\n    return 1;\n}\n\n\nstruct Set setUnion(struct Set set1, struct Set set2) {\n    struct Set unionSet = createSet(set1.size + set2.size);\n    if(unionSet.capacity == 0) return unionSet;\n\n    for (int i = 0; i < set1.size; i++) {\n        addElement(&unionSet, set1.data[i]);\n    }\n    for (int i = 0; i < set2.size; i++) {\n        addElement(&unionSet, set2.data[i]);\n    }\n    return unionSet;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nread_csv__FPCc PROC\n        STMFD    sp!,{r4-r9,lr}\n        MOV      r8,r0\n        MOV      r0,r1\n        ADR      r1,|L1.312|\n        SUB      sp,sp,#0x3f4\n        BL       fopen\n        MOVS     r5,r0\n        ADD      r0,sp,#0x3ec\n        MOV      r1,#0\n        MOV      r2,#0\n        STMIA    r0,{r1,r2}\n        BNE      |L1.72|\n        ADD      r1,sp,#0x3ec\n        LDMIA    r1,{r0,r1}\n        STMIA    r8,{r0,r1}\n        ADD      sp,sp,#0x3f4\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n|L1.72|\n        ADD      r7,sp,#4\n        MOV      r0,r7\n        MOV      r2,r5\n        MOV      r1,#0x3e8\n        BL       fgets\n        CMP      r0,#0\n        BEQ      |L1.280|\n        MOV      r9,#0x2a4\n        ADD      r9,r9,#0x18400\n        MOV      r6,r9,ASR #2\n|L1.112|\n        LDR      r0,[sp,#0x3f0]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0x3f0]\n        MUL      r1,r9,r0\n        LDR      r0,[sp,#0x3ec]\n        BL       realloc\n        STR      r0,[sp,#0x3ec]\n        MOV      r0,r7\n        ADR      r1,|L1.316|\n        BL       strtok\n        MOV      r4,#0\n        B        |L1.224|\n|L1.160|\n        ADD      r2,sp,#0x3ec\n        LDMIA    r2,{r1,r2}\n        MUL      r2,r6,r2\n        ADD      r1,r1,r2,LSL #2\n        ADD      r2,r4,r4,LSL #1\n        RSB      r2,r2,r4,LSL #7\n        ADD      r1,r1,r2,LSL #3\n        SUB      r2,r1,#0x18400\n        SUB      r2,r2,#0x2a4\n        MOV      r1,r0\n        MOV      r0,r2\n        BL       strcpy\n        ADD      r4,r4,#1\n        ADR      r1,|L1.316|\n        MOV      r0,#0\n        BL       strtok\n|L1.224|\n        CMP      r0,#0\n        CMPNE    r4,#0x64\n        BLT      |L1.160|\n        ADD      r1,sp,#0x3ec\n        LDMIA    r1,{r0,r1}\n        MOV      r2,r5\n        MUL      r1,r6,r1\n        ADD      r0,r0,r1,LSL #2\n        STR      r4,[r0,#-4]\n        MOV      r0,r7\n        MOV      r1,#0x3e8\n        BL       fgets\n        CMP      r0,#0\n        BNE      |L1.112|\n|L1.280|\n        MOV      r0,r5\n        BL       fclose\n        ADD      r1,sp,#0x3ec\n        LDMIA    r1,{r0,r1}\n        STMIA    r8,{r0,r1}\n        ADD      sp,sp,#0x3f4\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n|L1.312|\n        DCB      \"r\\0\\0\\0\"\n|L1.316|\n        DCB      \",\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_FIELDS 100\n#define MAX_LINE 1000\n\ntypedef struct {\n    char fields[MAX_FIELDS][MAX_LINE];\n    int num_fields;\n} Row;\n\ntypedef struct {\n    Row* rows;\n    int num_rows;\n} CSVData;\n\n\nCSVData read_csv(const char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) {\n        CSVData empty = {NULL, 0};\n        return empty;\n    }\n\n    CSVData data = {NULL, 0};\n    char line[MAX_LINE];\n\n    while (fgets(line, MAX_LINE, file) != NULL) {\n        data.num_rows++;\n        data.rows = (Row*)realloc(data.rows, data.num_rows * sizeof(Row));\n        char* token = strtok(line, \",\");\n        int field_index = 0;\n        while (token != NULL && field_index < MAX_FIELDS) {\n            strcpy(data.rows[data.num_rows - 1].fields[field_index], token);\n            field_index++;\n            token = strtok(NULL, \",\");\n        }\n        data.rows[data.num_rows-1].num_fields = field_index;\n\n    }\n    fclose(file);\n    return data;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nabsolute__Fi PROC\n        CMP      r0,#0\n        RSBLT    r0,r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint absolute(int num) {\n    return abs(num);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountLines__FPCc PROC\n        STMFD    sp!,{r3-r5,lr}\n        ADR      r1,|L1.104|\n        BL       fopen\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r5,#0\n        MOV      r0,r4\n        BL       fgetc\n        CMN      r0,#1\n        BEQ      |L1.68|\n|L1.44|\n        CMP      r0,#0xa\n        ADDEQ    r5,r5,#1\n        MOV      r0,r4\n        BL       fgetc\n        CMN      r0,#1\n        BNE      |L1.44|\n|L1.68|\n        MOV      r0,r4\n        BL       fclose\n        MOV      r0,r4\n        BL       feof\n        CMP      r0,#0\n        MOVNE    r0,#1\n        ADD      r0,r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.104|\n        DCB      \"r\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint countLines(const char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) return 0;\n\n    int lines = 0;\n    int ch;\n    while ((ch = fgetc(file)) != EOF) {\n        if (ch == '\\n') {\n            lines++;\n        }\n    }\n    fclose(file);\n    return lines + (feof(file) != 0);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbinary_search__FPiiT2 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r3,#0\n        SUBS     r12,r1,#1\n        BMI      |L1.64|\n|L1.16|\n        SUB      r1,r12,r3\n        ADD      r1,r1,r1,LSR #31\n        ADD      r1,r3,r1,ASR #1\n        LDR      lr,[r0,r1,LSL #2]\n        CMP      lr,r2\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,r1\n        BXEQ     lr\n        SUBGE    r12,r1,#1\n        ADDLT    r3,r1,#1\n        CMP      r3,r12\n        BLE      |L1.16|\n|L1.64|\n        LDR      lr,[sp],#4\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint binary_search(int arr[], int len, int target) {\n    int low = 0;\n    int high = len - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        STR      r0,[r5,#0xc]\n        LDR      r1,[r5,#0]\n        ADR      r0,|L1.92|\n        BL       _printf\n        LDR      r0,[r5,#8]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.48|\n        LDR      r0,[r5,#4]\n        LDR      r0,[r0,r4,LSL #2]\n        LDR      r1,[r0,#0xc]\n        CMP      r1,#0\n        BLEQ     dfs__FP4Node\n        LDR      r0,[r5,#8]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.48|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.92|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int data;\n    struct Node** adj;\n    int adjSize;\n    int visited;\n} Node;\n\nvoid dfs(Node* node) {\n    node->visited = 1;\n    printf(\"%d \", node->data);\n    for (int i = 0; i < node->adjSize; i++) {\n        if (!node->adj[i]->visited) {\n            dfs(node->adj[i]);\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__Fi PROC\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0x10\n        ADD      r4,sp,#4\n        MOV      r2,r0\n        MOV      r0,r4\n        ADR      r1,|L1.120|\n        BL       _sprintf\n        MOV      r0,r4\n        BL       strlen\n        ADD      r2,r0,r0,LSR #31\n        MOV      r2,r2,ASR #1\n        CMP      r2,#0\n        MOV      r1,#0\n        BLE      |L1.104|\n        SUB      r0,r0,#1\n|L1.60|\n        LDRB     r3,[r4,r1]\n        SUB      r12,r0,r1\n        LDRB     r12,[r4,r12]\n        CMP      r3,r12\n        ADDNE    sp,sp,#0x10\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r1,r1,#1\n        CMP      r2,r1\n        BGT      |L1.60|\n|L1.104|\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.120|\n        DCB      \"%d\\0\\0\"\n        ENDP\n\nisPrime__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r4,#2\n        CMP      r5,#4\n        BLT      |L1.204|\n|L1.160|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __rt_sdiv\n        CMP      r1,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r4,r4,#1\n        MUL      r0,r4,r4\n        CMP      r0,r5\n        BLE      |L1.160|\n|L1.204|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nisPalindromicPrime__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       isPalindrome__Fi\n        CMP      r0,#0\n        BEQ      |L1.260|\n        MOV      r0,r4\n        BL       isPrime__Fi\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.260|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint isPalindrome(int n) {\n    char s[12];\n    sprintf(s, \"%d\", n);\n    int len = strlen(s);\n    for (int i = 0; i < len / 2; i++) {\n        if (s[i] != s[len - 1 - i]) return 0;\n    }\n    return 1;\n}\n\nint isPrime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint isPalindromicPrime(int n) {\n    return isPalindrome(n) && isPrime(n);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmorrisTraversal__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r5,#0\n|L1.20|\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.56|\n        ADR      r0,|L1.120|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r4,[r4,#8]\n        B        |L1.104|\n|L1.52|\n        MOV      r0,r1\n|L1.56|\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        STREQ    r4,[r0,#8]\n        LDREQ    r4,[r4,#4]\n        BEQ      |L1.104|\n        CMP      r1,r4\n        BNE      |L1.52|\n        STR      r5,[r0,#8]\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.120|\n        BL       _printf\n        LDR      r4,[r4,#8]\n|L1.104|\n        CMP      r4,#0\n        BNE      |L1.20|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.120|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid morrisTraversal(Node *root) {\n    Node *current = root;\n    while (current != NULL) {\n        if (current->left == NULL) {\n            printf(\"%d \", current->data);\n            current = current->right;\n        } else {\n            Node *predecessor = current->left;\n            while (predecessor->right != NULL && predecessor->right != current) {\n                predecessor = predecessor->right;\n            }\n            if (predecessor->right == NULL) {\n                predecessor->right = current;\n                current = current->left;\n            } else {\n                predecessor->right = NULL;\n                printf(\"%d \", current->data);\n                current = current->right;\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r8,|L1.316|\n        MOV      r6,r0\n        MOV      r0,#1\n        STR      r0,[r8,r6,LSL #2]\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        BLE      |L1.128|\n        ADD      r1,r6,r6,LSL #3\n        LDR      r0,|L1.320|\n        ADD      r1,r1,r6,LSL #4\n        ADD      r7,r0,r1,LSL #4\n|L1.52|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#1\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        CMP      r0,#0\n        BNE      |L1.116|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       dfs__FiT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.116|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.52|\n|L1.128|\n        MOV      r0,#2\n        STR      r0,[r8,r6,LSL #2]\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\ndetectCycle__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r6,|L1.316|\n        MOV      r5,r0\n        MOV      r0,r6\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.236|\n|L1.184|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.224|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       dfs__FiT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.224|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.184|\n|L1.236|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint graph[MAX_VERTICES][MAX_VERTICES];\n\nint dfs(int vertex, int vertices) {\n    visited[vertex] = 1;\n    for (int i = 0; i < vertices; i++) {\n        if (graph[vertex][i]) {\n            if (visited[i] == 1) return 1;\n            if (visited[i] == 0 && dfs(i, vertices)) return 1;\n        }\n    }\n    visited[vertex] = 2;\n    return 0;\n}\n\nint detectCycle(int vertices) {\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < vertices; i++) {\n        if (visited[i] == 0 && dfs(i, vertices)) return 1;\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndecToBin__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        ADD      r0,r4,r4,LSR #31\n        MOV      r5,r0,ASR #1\n        MOV      r0,r5\n        BL       decToBin__Fi\n        SUB      r1,r4,r5,LSL #1\n        LDMFD    sp!,{r3-r5,lr}\n        ADR      r0,|L1.48|\n        B        _printf\n|L1.48|\n        DCB      \"%d\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid decToBin(int n) {\n    if (n == 0) {\n        return;\n    }\n    decToBin(n / 2);\n    printf(\"%d\", n % 2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npolygonArea__FPdT1i PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r8,r0\n        ADR      r0,|L1.172|\n        LDMIA    r0,{r5,r6}\n        SUB      sp,sp,#0xc\n        MOV      r9,r1\n        MOV      r7,r2\n        MOV      r4,#0\n        CMP      r2,#0\n        BLE      |L1.144|\n|L1.40|\n        ADD      r1,r4,#1\n        MOV      r11,r1\n        MOV      r0,r7\n        BL       __rt_sdiv\n        ADD      r0,r9,r1,LSL #3\n        LDMIA    r0,{r2,r3}\n        ADD      r0,r8,r4,LSL #3\n        MOV      r10,r1\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        ADD      r1,r8,r10,LSL #3\n        LDMIA    r1,{r0,r1}\n        ADD      r2,r9,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        MOV      r5,r0\n        MOV      r6,r1\n        MOV      r4,r11\n        CMP      r11,r7\n        BLT      |L1.40|\n|L1.144|\n        ADR      r2,|L1.180|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#0xc\n        MOV      r0,r5\n        BIC      r1,r6,#0x80000000\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dmul\n|L1.172|\n        DCFD     0x0000000000000000\n|L1.180|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble polygonArea(double* x, double* y, int n) {\n    double area = 0.0;\n    int i;\n    for (i = 0; i < n; i++) {\n        area += (x[i] * y[(i + 1) % n] - x[(i + 1) % n] * y[i]);\n    }\n    return fabs(area) / 2.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitialize_student__FP7StudentPci PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r2\n        MOV      r4,r0\n        BL       strcpy\n        MOV      r0,#0\n        STR      r5,[r4,#0x34]!\n        STR      r0,[r4,#0x2c]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nadd_grade__FP7Studenti PROC\n        LDR      r2,[r0,#0x60]\n        CMP      r2,#0xa\n        BXGE     lr\n        ADD      r2,r0,r2,LSL #2\n        STR      r1,[r2,#0x38]\n        LDR      r1,[r0,#0x60]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0x60]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Student {\n    char name[50];\n    int id;\n    int grades[10];\n    int num_grades;\n};\n\nvoid initialize_student(struct Student* student, char* name, int id) {\n    strcpy(student->name, name);\n    student->id = id;\n    student->num_grades = 0;\n}\n\nvoid add_grade(struct Student* student, int grade) {\n    if (student->num_grades < 10) {\n        student->grades[student->num_grades] = grade;\n        student->num_grades++;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncommunity_detection__FP5GraphP9Community PROC\n        LDR      r3,[r0,#0]\n        MOV      r2,#0\n        CMP      r3,#0\n        BXLE     lr\n|L1.16|\n        STR      r2,[r1,r2,LSL #3]\n        ADD      r3,r1,r2,LSL #3\n        STR      r2,[r3,#4]\n        LDR      r3,[r0,#0]\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.16|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_NODES 1000\n\nstruct Graph {\n    int num_nodes;\n    int adj_matrix[MAX_NODES][MAX_NODES];\n};\n\nstruct Community {\n    int node_id;\n    int community_id;\n};\n\nvoid community_detection(struct Graph* graph, struct Community* communities) {\n    //This is a placeholder.  A real implementation would require a complex algorithm \n    //like Louvain algorithm or Leiden algorithm which are beyond the scope of this \n    //constrained environment.  Error handling is also omitted for brevity.\n    for (int i = 0; i < graph->num_nodes; i++) {\n        communities[i].node_id = i;\n        communities[i].community_id = i;\n    }\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fx PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        ADR      r0,|L1.100|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r4\n        MOV      r5,r1\n        SBCS     r1,r3,r1\n        MOVGE    r0,r4\n        MOVGE    r1,r5\n        LDMGEFD  sp!,{r3-r7,lr}\n        BXGE     lr\n        MOV      r2,#1\n        SUBS     r0,r4,r2\n        SBC      r1,r5,#0\n        BL       fibonacci__Fx\n        MOV      r6,r0\n        MOV      r2,#2\n        SUBS     r0,r4,r2\n        MOV      r7,r1\n        SBC      r1,r5,#0\n        BL       fibonacci__Fx\n        ADDS     r0,r0,r6\n        ADC      r1,r1,r7\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.100|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nlong long fibonacci(long long n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbinToDec__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        MOV      r3,#0\n        MOV      r2,#1\n        SUBS     r1,r0,#1\n        BMI      |L1.72|\n|L1.28|\n        LDRB     r0,[r4,r1]\n        CMP      r0,#0x31\n        ADDEQ    r3,r3,r2\n        BEQ      |L1.60|\n        CMP      r0,#0x30\n        LDMNEFD  sp!,{r4,lr}\n        MVNNE    r0,#0\n        BXNE     lr\n|L1.60|\n        MOV      r2,r2,LSL #1\n        SUBS     r1,r1,#1\n        BPL      |L1.28|\n|L1.72|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint binToDec(char *bin) {\n    int len = strlen(bin);\n    int dec = 0;\n    int power = 1;\n    for (int i = len - 1; i >= 0; i--) {\n        if (bin[i] == '1') {\n            dec += power;\n        } else if (bin[i] != '0'){\n            return -1;\n        }\n        power *= 2;\n    }\n    return dec;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitializeDeck__FP4Deck PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x28\n        ADD      r5,sp,#0xc\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r2,#0x1a\n        LDR      r1,|L1.328|\n        BL       __rt_memcpy\n        LDR      r1,|L1.332|\n        ADD      r2,sp,#4\n        LDRH     r0,[r1,#0]  ; <Anon3_line_20>\n        STRH     r0,[sp,#4]\n        LDRH     r0,[r1,#2]  ; <Anon3_line_20>\n        STRH     r0,[sp,#6]\n        LDRH     r0,[r1,#4]  ; <Anon3_line_20>\n        STRH     r0,[sp,#8]\n        LDRH     r0,[r1,#6]  ; <Anon3_line_20>\n        MOV      r1,#0\n        STRH     r0,[sp,#0xa]\n        MOV      r0,#0\n|L1.80|\n        MOV      r3,#0\n        ADD      r6,r2,r1,LSL #1\n|L1.88|\n        ADD      r12,r5,r3,LSL #1\n        LDRH     lr,[r12,#0]\n        ADD      r12,r4,r0,LSL #2\n        ADD      r3,r3,#1\n        STRH     lr,[r12,#0]\n        LDRH     lr,[r6,#0]\n        CMP      r3,#0xd\n        ADD      r0,r0,#1\n        STRH     lr,[r12,#2]\n        BLT      |L1.88|\n        ADD      r1,r1,#1\n        CMP      r1,#4\n        BLT      |L1.80|\n        MOV      r0,#0\n        STR      r0,[r4,#0xd0]\n        ADD      sp,sp,#0x28\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nshuffleDeck__FP4Deck PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        MOV      r4,#0x33\n|L1.184|\n        BL       rand\n        MOV      r1,r0\n        ADD      r0,r4,#1\n        BL       __rt_sdiv\n        ADD      r0,r5,r4,LSL #2\n        LDRH     r2,[r0,#0]\n        ADD      r1,r5,r1,LSL #2\n        SUB      r4,r4,#1\n        STRH     r2,[sp,#0]\n        LDRH     r2,[r0,#2]\n        CMP      r4,#0\n        STRH     r2,[sp,#2]\n        LDRH     r2,[r1,#0]\n        STRH     r2,[r0,#0]\n        LDRH     r2,[r1,#2]\n        STRH     r2,[r0,#2]\n        LDRH     r0,[sp,#0]\n        STRH     r0,[r1,#0]\n        LDRH     r0,[sp,#2]\n        STRH     r0,[r1,#2]\n        BGT      |L1.184|\n        MOV      r0,#0\n        STR      r0,[r5,#0xd0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned short wchar_t;\n\nstruct Card {\n    wchar_t rank;\n    wchar_t suit;\n};\n\nstruct Deck {\n    Card cards[52];\n    int top;\n};\n\nvoid initializeDeck(Deck* deck) {\n    wchar_t ranks[] = {L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'T', L'J', L'Q', L'K', L'A'};\n    wchar_t suits[] = {L'C', L'D', L'H', L'S'};\n    int i = 0;\n    for (int suitIndex = 0; suitIndex < 4; suitIndex++) {\n        for (int rankIndex = 0; rankIndex < 13; rankIndex++) {\n            deck->cards[i].rank = ranks[rankIndex];\n            deck->cards[i].suit = suits[suitIndex];\n            i++;\n        }\n    }\n    deck->top = 0;\n}\n\n\nvoid shuffleDeck(Deck* deck) {\n    srand(time(NULL));\n    for (int i = 51; i > 0; i--) {\n        int j = rand() % (i + 1);\n        Card temp = deck->cards[i];\n        deck->cards[i] = deck->cards[j];\n        deck->cards[j] = temp;\n    }\n    deck->top = 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmultiplyMatrices__FPA100_dN21i PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#4\n        MOV      r10,r1\n        MOV      r9,#0\n        MOV      r6,r3\n        CMP      r3,#0\n        BLE      |L1.172|\n|L1.28|\n        MOV      r5,#0\n        CMP      r6,#0\n        BLE      |L1.160|\n        ADD      r0,r9,r9,LSL #3\n        LDR      r1,[sp,#4]\n        ADD      r0,r0,r9,LSL #4\n        ADD      r8,r1,r0,LSL #5\n        LDR      r1,[sp,#0xc]\n        ADD      r11,r1,r0,LSL #5\n|L1.64|\n        ADR      r1,|L1.188|\n        LDMIA    r1,{r0,r1}\n        ADD      r7,r11,r5,LSL #3\n        STMIA    r7,{r0,r1}\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.148|\n|L1.92|\n        ADD      r0,r4,r4,LSL #3\n        ADD      r0,r0,r4,LSL #4\n        ADD      r0,r10,r0,LSL #5\n        ADD      r1,r0,r5,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r8,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDMIA    r7,{r2,r3}\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        STMIA    r7,{r0,r1}\n        BLT      |L1.92|\n|L1.148|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BLT      |L1.64|\n|L1.160|\n        ADD      r9,r9,#1\n        CMP      r9,r6\n        BLT      |L1.28|\n|L1.172|\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.188|\n        DCFD     0x0000000000000000\n        ENDP\n\nisOrthogonal__FPA100_di PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r5,r1\n        SUB      sp,sp,#0x27400\n        ADD      r1,sp,#0x10000\n        ADD      r1,r1,#0x3b80\n        CMP      r5,#0\n        MOV      r3,#0\n        BLE      |L1.304|\n|L1.228|\n        MOV      r2,#0\n        CMP      r5,#0\n        BLE      |L1.292|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r6,r1,r12,LSL #5\n|L1.252|\n        ADD      r4,r2,r2,LSL #3\n        ADD      r4,r4,r2,LSL #4\n        ADD      r4,r0,r4,LSL #5\n        ADD      r12,r4,r3,LSL #3\n        ADD      lr,r6,r2,LSL #3\n        LDMIA    r12,{r4,r12}\n        ADD      r2,r2,#1\n        CMP      r2,r5\n        STMIA    lr,{r4,r12}\n        BLT      |L1.252|\n|L1.292|\n        ADD      r3,r3,#1\n        CMP      r3,r5\n        BLT      |L1.228|\n|L1.304|\n        ADD      r10,sp,#0x300\n        MOV      r2,r10\n        MOV      r3,r5\n        BL       multiplyMatrices__FPA100_dN21i\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.476|\n        ADR      r9,|L1.492|\n        ADR      r8,|L1.500|\n|L1.340|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.464|\n        ADD      r0,r6,r6,LSL #3\n        ADD      r0,r0,r6,LSL #4\n        ADD      r7,r10,r0,LSL #5\n|L1.364|\n        CMP      r6,r4\n        ADD      r0,r7,r4,LSL #3\n        BNE      |L1.420|\n        LDMIA    r9,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dsub\n        BIC      r1,r1,#0x80000000\n        LDMIA    r8,{r2,r3}\n        BL       _dcmpge\n        ADDHI    sp,sp,#0x27400\n        LDMHIFD  sp!,{r4-r10,lr}\n        MOVHI    r0,#0\n        BXHI     lr\n        B        |L1.452|\n|L1.420|\n        LDMIA    r0,{r0,r1}\n        LDMIA    r8,{r2,r3}\n        BIC      r1,r1,#0x80000000\n        BL       _dcmpge\n        ADDHI    sp,sp,#0x27400\n        LDMHIFD  sp!,{r4-r10,lr}\n        MOVHI    r0,#0\n        BXHI     lr\n|L1.452|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.364|\n|L1.464|\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        BLT      |L1.340|\n|L1.476|\n        ADD      sp,sp,#0x27400\n        LDMFD    sp!,{r4-r10,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.492|\n        DCFD     0x3ff0000000000000\n|L1.500|\n        DCFD     0x3eb0c6f7a0b5ed8d\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\nint multiplyMatrices(double a[][MAX_SIZE], double b[][MAX_SIZE], double c[][MAX_SIZE], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            c[i][j] = 0;\n            for (int k = 0; k < n; k++) {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }\n    }\n    return 0;\n}\n\nint isOrthogonal(double a[][MAX_SIZE], int n) {\n    double b[MAX_SIZE][MAX_SIZE], c[MAX_SIZE][MAX_SIZE];\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            b[i][j] = a[j][i];\n        }\n    }\n    \n    multiplyMatrices(a, b, c, n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                if (fabs(c[i][j] - 1) > 1e-6) return 0;\n            } else {\n                if (fabs(c[i][j]) > 1e-6) return 0;\n            }\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__FxN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r6,r2\n        ADR      r2,|L1.228|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.228|\n        LDMIA    r2,{r8,r9}\n        MOV      r7,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        ADR      r0,|L1.236|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BGE      |L1.212|\n|L1.72|\n        ADR      r0,|L1.244|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _ll_sdiv\n        MOV      r6,r0\n        MOV      r0,r2\n        MOV      r7,r1\n        MOV      r1,r3\n        ADR      r2,|L1.228|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.160|\n        UMULL    r0,r12,r8,r4\n        MLA      r12,r4,r9,r12\n        MLA      r1,r5,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.160|\n        UMULL    r0,r12,r4,r4\n        MLA      r12,r4,r5,r12\n        MLA      r1,r5,r4,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        ADR      r0,|L1.236|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BLT      |L1.72|\n|L1.212|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.228|\n        DCQ      0x0000000000000001\n|L1.236|\n        DCQ      0x0000000000000000\n|L1.244|\n        DCQ      0x0000000000000002\n        ENDP\n\nmillerRabin__Fxi PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        MOV      r2,#1\n        MOV      r7,r0\n        SUBS     r0,r0,r2\n        SUB      sp,sp,#0x28\n        MOV      r8,r1\n        SBC      r1,r1,#0\n        STR      r1,[sp,#0x20]\n        STR      r0,[sp,#0x24]\n        ADR      r4,|L1.228|\n        LDMIA    r4,{r2,r3}\n        SUBS     r0,r2,r7\n        SBCS     r1,r3,r8\n        ADR      r6,|L1.244|\n        ADR      r5,|L1.236|\n        BGE      |L1.340|\n        ADR      r0,|L1.892|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r7\n        CMP      r8,r3\n        CMPEQ    r0,r2\n        BNE      |L1.356|\n|L1.340|\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.356|\n        ADR      r0,|L1.900|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r7\n        SBCS     r1,r3,r8\n        ADDGE    sp,sp,#0x34\n        LDMGEFD  sp!,{r4-r11,lr}\n        MOVGE    r0,#1\n        BXGE     lr\n        LDMIA    r5,{r9,r10}\n        ADD      r11,sp,#0x20\n        LDMIA    r11,{r1,r11}\n        STR      r1,[sp,#0xc]\n        LDMIA    r6,{r2,r3}\n        MOV      r0,r11\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r5,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.508|\n|L1.440|\n        MOV      r2,#1\n        ADDS     r9,r9,r2\n        LDMIA    r6,{r2,r3}\n        LDR      r1,[sp,#0xc]\n        ADC      r10,r10,#0\n        MOV      r0,r11\n        BL       _ll_sdiv\n        STR      r1,[sp,#0xc]\n        LDMIA    r6,{r2,r3}\n        MOV      r11,r0\n        BL       _ll_sdiv\n        MOV      r0,r2\n        MOV      r1,r3\n        LDMIA    r5,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BEQ      |L1.440|\n|L1.508|\n        LDR      r1,[sp,#0x30]\n        MOV      r0,#0\n        STR      r0,[sp,#8]\n        CMP      r1,#0\n        BLE      |L1.876|\n        MOV      r2,#4\n        SUBS     r0,r7,r2\n        STR      r0,[sp,#0x1c]\n        MOV      r0,#0\n        SBC      r1,r8,#0\n        STR      r1,[sp,#0x18]\n        MOV      r1,r0,ASR #31\n        STR      r1,[sp,#0x10]\n        STR      r0,[sp,#0x14]\n|L1.564|\n        BL       rand\n        MOV      r3,r0,ASR #31\n        MOV      r2,r0\n        LDR      r0,[sp,#0x1c]\n        LDR      r1,[sp,#0x18]\n        BL       _ll_srdv\n        MOV      r0,r2\n        MOV      r2,#2\n        ADDS     r0,r0,r2\n        ADC      r1,r3,#0\n        STMIA    sp,{r7,r8}\n        LDR      r3,[sp,#0xc]\n        MOV      r2,r11\n        BL       power__FxN21\n        MOV      r4,r0\n        ADR      r0,|L1.228|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r5,r1\n        BEQ      |L1.852|\n        LDR      r1,[sp,#0x20]\n        LDR      r0,[sp,#0x24]\n        MOV      r2,r4\n        CMP      r1,r5\n        CMPEQ    r0,r2\n        BEQ      |L1.852|\n        LDR      r0,[sp,#0x14]\n        LDR      r1,[sp,#0x10]\n        STMIA    sp,{r0,r1}\n        MOV      r2,#1\n        SUBS     r0,r9,r2\n        SBC      r1,r10,#0\n        LDMIA    sp,{r2,r3}\n        SUBS     r0,r2,r0\n        SBCS     r1,r3,r1\n        MOV      r6,#0\n        BGE      |L1.816|\n|L1.720|\n        UMULL    r0,r12,r4,r4\n        MLA      r12,r4,r5,r12\n        MLA      r1,r5,r4,r12\n        MOV      r3,r8\n        MOV      r2,r7\n        BL       _ll_sdiv\n        LDR      r1,[sp,#0x20]\n        LDR      r0,[sp,#0x24]\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r4,r2\n        MOV      r5,r3\n        BEQ      |L1.816|\n        ADD      r6,r6,#1\n        MOV      r1,r6,ASR #31\n        STR      r1,[sp,#4]\n        MOV      r2,#1\n        SUBS     r0,r9,r2\n        SBC      r1,r10,#0\n        LDR      r3,[sp,#4]\n        SUBS     r0,r6,r0\n        SBCS     r1,r3,r1\n        STR      r6,[sp,#0]\n        BLT      |L1.720|\n|L1.816|\n        LDR      r1,[sp,#0x20]\n        LDR      r0,[sp,#0x24]\n        MOV      r2,r4\n        CMP      r1,r5\n        CMPEQ    r0,r2\n        ADDNE    sp,sp,#0x34\n        LDMNEFD  sp!,{r4-r11,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.852|\n        LDR      r0,[sp,#8]\n        LDR      r1,[sp,#0x30]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#8]\n        CMP      r0,r1\n        BLT      |L1.564|\n|L1.876|\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.892|\n        DCQ      0x0000000000000004\n|L1.900|\n        DCQ      0x0000000000000003\n        ENDP\n\ngeneratePrime__FiT1 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADR      r11,|L1.228|\n        MOV      r10,r1\n        SUB      r2,r0,#1\n        LDMIA    r11,{r0,r1}\n        BL       _ll_shift_l\n        MOV      r6,r0\n        MOV      r2,#1\n        SUBS     r0,r0,r2\n        MOV      r7,r1\n        SBC      r1,r1,#0\n        MVN      r9,r1\n        MVN      r8,r0\n|L1.960|\n        BL       rand\n        MOV      r3,r0,ASR #31\n        ORR      r1,r7,r3\n        LDMIA    r11,{r2,r3}\n        ORR      r0,r6,r0\n        ORR      r2,r0,r2\n        ORR      r3,r1,r3\n        AND      r5,r9,r3\n        AND      r4,r8,r2\n        ADR      r0,|L1.244|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _ll_sdiv\n        MOV      r0,r2\n        ADR      r2,|L1.236|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.1056|\n        MOV      r2,#1\n        ADDS     r4,r4,r2\n        ADC      r5,r5,#0\n|L1.1056|\n        MOV      r2,r10\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       millerRabin__Fxi\n        CMP      r0,#0\n        BEQ      |L1.960|\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nlong long int power(long long int base, long long int exp, long long int mod) {\n    long long int res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\nint millerRabin(long long int n, int iter) {\n    if (n <= 1 || n == 4) return 0;\n    if (n <= 3) return 1;\n    long long int a, s = 0, r;\n    long long int d = n - 1;\n    while (d % 2 == 0) {\n        s++;\n        d /= 2;\n    }\n    for (int i = 0; i < iter; i++) {\n        a = rand() % (n - 4) + 2;\n        long long int x = power(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        for (int j = 0; j < s - 1; j++) {\n            x = (x * x) % n;\n            if (x == n - 1) break;\n        }\n        if (x != n - 1) return 0;\n    }\n    return 1;\n}\n\nlong long int generatePrime(int bits, int iter) {\n    long long int n;\n    do {\n        n = rand();\n        n |= (1LL << (bits-1));\n        n = (n | 1) & ~((1LL << (bits-1))-1); //Make sure the number has bits bits\n        if (n % 2 == 0) n++;\n    } while (!millerRabin(n, iter));\n    return n;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntopologicalSort__FP6VertexiPi PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        MOV      r0,r1,LSL #2\n        MOV      r9,r2\n        MOV      r8,r1\n        MOV      r6,#0\n        MOV      r4,#0\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        CMP      r8,#0\n        BLE      |L1.88|\n|L1.56|\n        LDR      r2,[r5,r1,LSL #3]\n        CMP      r2,#0\n        MOVEQ    r2,r4\n        STREQ    r1,[r0,r2,LSL #2]\n        ADD      r1,r1,#1\n        ADDEQ    r4,r4,#1\n        CMP      r1,r8\n        BLT      |L1.56|\n|L1.88|\n        MOV      r7,#0\n        CMP      r6,r4\n        BGE      |L1.208|\n|L1.100|\n        MOV      r1,r6\n        LDR      r2,[r0,r1,LSL #2]\n        MOV      r1,r7\n        STR      r2,[r9,r1,LSL #2]\n        ADD      r12,r5,r2,LSL #3\n        LDR      r2,[r12,#4]\n        MOV      r1,#0\n        LDR      r2,[r2,#0]\n        ADD      r7,r7,#1\n        ADD      r6,r6,#1\n        CMN      r2,#1\n        BEQ      |L1.200|\n|L1.148|\n        LDR      r2,[r12,#4]\n        LDR      r2,[r2,r1,LSL #3]\n        ADD      r1,r1,#1\n        LDR      r3,[r5,r2,LSL #3]\n        SUBS     r3,r3,#1\n        STR      r3,[r5,r2,LSL #3]\n        MOVEQ    r3,r4\n        STREQ    r2,[r0,r3,LSL #2]\n        LDR      r2,[r12,#4]\n        ADDEQ    r4,r4,#1\n        LDR      r2,[r2,r1,LSL #3]\n        CMN      r2,#1\n        BNE      |L1.148|\n|L1.200|\n        CMP      r6,r4\n        BLT      |L1.100|\n|L1.208|\n        BL       free\n        CMP      r7,r8\n        LDMFD    sp!,{r3-r9,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertex;\n    int next;\n} Edge;\n\ntypedef struct {\n    int inDegree;\n    Edge *adjList;\n} Vertex;\n\n\nint topologicalSort(Vertex *vertices, int numVertices, int *sortedVertices) {\n    int i, v;\n    int queueIndex = 0;\n    int queueSize = 0;\n    int *queue = (int *)malloc(sizeof(int) * numVertices);\n    if(queue == NULL) return 0;\n\n    for (i = 0; i < numVertices; i++) {\n        if (vertices[i].inDegree == 0) {\n            queue[queueSize++] = i;\n        }\n    }\n\n    int sortedIndex = 0;\n    while (queueIndex < queueSize) {\n        v = queue[queueIndex++];\n        sortedVertices[sortedIndex++] = v;\n\n        for (int j = 0; vertices[v].adjList[j].vertex != -1; j++) {\n            int neighbor = vertices[v].adjList[j].vertex;\n            vertices[neighbor].inDegree--;\n            if (vertices[neighbor].inDegree == 0) {\n                queue[queueSize++] = neighbor;\n            }\n        }\n    }\n    free(queue);\n    return (sortedIndex == numVertices) ? 1 : 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbabylonianSqrt__Fd PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADR      r4,|L1.240|\n        LDMIA    r4,{r2,r3}\n        ADR      r10,|L1.248|\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       _dcmple\n        LDMCCIA  r4,{r0,r1}\n        LDMCCFD  sp!,{r3-r11,lr}\n        BXCC     lr\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMIA    r4,{r2,r3}\n        BL       _dcmpeq\n        LDMEQIA  r4,{r0,r1}\n        LDMEQFD  sp!,{r3-r11,lr}\n        BXEQ     lr\n        MOV      r4,r8\n        MOV      r5,r9\n        MOV      r1,r9\n        ADR      r0,|L1.256|\n        LDMIA    r0,{r6,r7}\n        MOV      r2,r6\n        MOV      r0,r8\n        MOV      r3,r7\n        BL       _dsub\n        BIC      r1,r1,#0x80000000\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpge\n        BLS      |L1.224|\n        ADR      r11,|L1.264|\n|L1.124|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dadd\n        LDMIA    r11,{r2,r3}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       _ddiv\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _dsub\n        BIC      r1,r1,#0x80000000\n        LDMIA    r10,{r2,r3}\n        BL       _dcmpge\n        BHI      |L1.124|\n|L1.224|\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.240|\n        DCFD     0x0000000000000000\n|L1.248|\n        DCFD     0x3e112e0be826d695\n|L1.256|\n        DCFD     0x3ff0000000000000\n|L1.264|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble babylonianSqrt(double num) {\n    if (num < 0) return 0; // Handle negative input\n    if (num == 0) return 0; // Handle zero input\n\n    double x = num;\n    double y = 1;\n    while (fabs(x - y) > 1e-9) {\n        x = (x + y) / 2;\n        y = num / x;\n    }\n    return x;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompare__FPCvT1 PROC\n|L1.0|\n        LDR      r0,[r0,#0]\n        LDR      r1,[r1,#0]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n\nquicksort__FPiiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r2\n        MOV      r4,r0\n        CMP      r1,r2\n        LDMGEFD  sp!,{r4-r6,lr}\n        BXGE     lr\n        SUB      r6,r5,#1\n        CMP      r1,r6\n        LDR      lr,[r4,r5,LSL #2]\n        SUB      r2,r1,#1\n        MOV      r0,r1\n        BGT      |L1.104|\n|L1.64|\n        LDR      r12,[r4,r0,LSL #2]\n        CMP      r12,lr\n        BGE      |L1.92|\n        ADD      r2,r2,#1\n        LDR      r3,[r4,r2,LSL #2]\n        STR      r12,[r4,r2,LSL #2]\n        STR      r3,[r4,r0,LSL #2]\n|L1.92|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.64|\n|L1.104|\n        ADD      r3,r4,r2,LSL #2\n        LDR      r12,[r4,r5,LSL #2]\n        LDR      r0,[r3,#4]\n        STR      r12,[r3,#4]\n        STR      r0,[r4,r5,LSL #2]\n        ADD      r6,r2,#1\n        SUB      r2,r6,#1\n        MOV      r0,r4\n        BL       quicksort__FPiiT2\n        MOV      r2,r5\n        ADD      r1,r6,#1\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        B        quicksort__FPiiT2\n        ENDP\n```",
        "output": "```cpp\n\nint compare(const void* a, const void* b) {\n  return *(int*)a - *(int*)b;\n}\n\nvoid quicksort(int* arr, int left, int right) {\n  if (left < right) {\n    int pivot = arr[right];\n    int i = left - 1;\n    for (int j = left; j <= right - 1; j++) {\n      if (arr[j] < pivot) {\n        i++;\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[right];\n    arr[right] = temp;\n    int partition = i + 1;\n    quicksort(arr, left, partition - 1);\n    quicksort(arr, partition + 1, right);\n  }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidXMLTag__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r5,r0\n        BEQ      |L1.28|\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.40|\n|L1.28|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.40|\n        MOV      r0,r5\n        BL       strlen\n        LDRB     r1,[r5,#0]\n        CMP      r1,#0x3c\n        ADDEQ    r1,r5,r0\n        LDREQB   r1,[r1,#-1]\n        CMPEQ    r1,#0x3e\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        CMP      r0,#3\n        LDMLTFD  sp!,{r4-r6,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        SUB      r6,r0,#1\n        CMP      r6,#1\n        MOV      r4,#1\n        BLE      |L1.164|\n        BL       __rt_ctype_table\n        LDR      r1,[r0,#0]\n|L1.120|\n        LDRB     r0,[r5,r4]\n        LDRB     r2,[r1,r0]\n        TST      r2,#0x38\n        BNE      |L1.152|\n        CMP      r0,#0x5f\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.152|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.120|\n|L1.164|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isValidXMLTag(char *str) {\n    if (str == 0 || strlen(str) == 0) return 0;\n    int len = strlen(str);\n    if (str[0] != '<' || str[len - 1] != '>') return 0;\n    if (len < 3) return 0;\n    for (int i = 1; i < len - 1; i++) {\n        if (!isalnum(str[i]) && str[i] != '_') return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else \n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidTriangle__FdN21 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADD      r5,sp,#0x20\n        LDMIA    r5,{r4,r5}\n        ADR      r10,|L1.224|\n        MOV      r7,r3\n        MOV      r6,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       _dcmple\n        BLS      |L1.84|\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r10,{r2,r3}\n        BL       _dcmple\n        BLS      |L1.84|\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMIA    r10,{r2,r3}\n        BL       _dcmple\n        BHI      |L1.96|\n|L1.84|\n        LDMFD    sp!,{r4-r10,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.96|\n        MOV      r3,r7\n        MOV      r2,r6\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dadd\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dcmpge\n        BLS      |L1.212|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _dadd\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dcmpge\n        BLS      |L1.212|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dadd\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dcmpge\n        LDMHIFD  sp!,{r4-r10,lr}\n        MOVHI    r0,#1\n        BXHI     lr\n|L1.212|\n        LDMFD    sp!,{r4-r10,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.224|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nint isValidTriangle(double a, double b, double c) {\n    if (a <= 0 || b <= 0 || c <= 0) return 0;\n    return (a + b > c) && (a + c > b) && (b + c > a);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstring_to_upper__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDRB     r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.60|\n|L1.32|\n        LDRB     r0,[r5,r4]\n        BL       toupper\n        STRB     r0,[r5,r4]\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.32|\n|L1.60|\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* string_to_upper(char* str) {\n    if (str == 0) return 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n    return str;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninsert__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        LDR      r1,|L1.340|\n        STR      r4,[r0,#0]\n        LDR      r2,[r1,#0]  ; head\n        CMP      r2,#0\n        STREQ    r0,[r0,#4]\n        STREQ    r0,[r1,#0]  ; head\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r3,[r2,#4]\n        MOV      r1,r2\n        CMP      r3,r2\n        BEQ      |L1.80|\n|L1.64|\n        LDR      r1,[r1,#4]\n        LDR      r3,[r1,#4]\n        CMP      r3,r2\n        BNE      |L1.64|\n|L1.80|\n        STR      r0,[r1,#4]\n        STR      r2,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndeleteNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.340|\n        MOV      r3,r0\n        LDR      r1,[r4,#0]  ; head\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,r1\n        MOV      r2,#0\n|L1.132|\n        LDR      r12,[r0,#0]\n        CMP      r12,r3\n        BNE      |L1.252|\n        CMP      r0,r1\n        LDREQ    r3,[r0,#4]\n        CMPEQ    r3,r1\n        BNE      |L1.180|\n        BL       free\n        MOV      r0,#0\n        STR      r0,[r4,#0]  ; head\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.180|\n        CMP      r0,r1\n        LDRNE    r1,[r0,#4]\n        MOV      lr,r4\n        STRNE    r1,[r2,#4]\n        LDMNEFD  sp!,{r4,lr}\n        BNE      free\n        LDR      r12,[r1,#4]\n        MOV      r2,r1\n        CMP      r12,r1\n        BEQ      |L1.236|\n|L1.220|\n        LDR      r2,[r2,#4]\n        LDR      r3,[r2,#4]\n        CMP      r3,r1\n        BNE      |L1.220|\n|L1.236|\n        STR      r12,[lr,#0]  ; head\n        STR      r12,[r2,#4]\n        LDMFD    sp!,{r4,lr}\n        B        free\n|L1.252|\n        MOV      r2,r0\n        LDR      r0,[r0,#4]\n        CMP      r0,r1\n        BNE      |L1.132|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ntraverse__Fv PROC\n        STMFD    sp!,{r3-r5,lr}\n        LDR      r5,|L1.340|\n        LDR      r4,[r5,#0]  ; head\n        CMP      r4,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n|L1.300|\n        ADR      r0,|L1.344|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r4,[r4,#4]\n        LDR      r0,[r5,#0]  ; head\n        CMP      r4,r0\n        BNE      |L1.300|\n        ADR      r0,|L1.348|\n        LDMFD    sp!,{r3-r5,lr}\n        B        _printf\n|L1.340|\n        DCD      ||.bss$2||\n|L1.344|\n        DCB      \"%d \\0\"\n|L1.348|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* head;\n\nvoid insert(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    if (head == NULL) {\n        newNode->next = newNode;\n        head = newNode;\n    } else {\n        struct Node* temp = head;\n        while (temp->next != head)\n            temp = temp->next;\n        temp->next = newNode;\n        newNode->next = head;\n    }\n}\n\nvoid deleteNode(int data) {\n    if (head == NULL) return;\n    struct Node* temp = head;\n    struct Node* prev = NULL;\n    do {\n        if (temp->data == data) {\n            if (temp == head && temp->next == head) {\n                free(temp);\n                head = NULL;\n                return;\n            } else if (temp == head) {\n                struct Node* last = head;\n                while (last->next != head)\n                    last = last->next;\n                head = head->next;\n                last->next = head;\n                free(temp);\n                return;\n            } else {\n                prev->next = temp->next;\n                free(temp);\n                return;\n            }\n        }\n        prev = temp;\n        temp = temp->next;\n    } while (temp != head);\n}\n\nvoid traverse() {\n    if (head == NULL) return;\n    struct Node* temp = head;\n    do {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    } while (temp != head);\n    printf(\"\\n\");\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x14\n        BL       malloc\n        MOV      r1,#0\n        STR      r4,[r0,#0]\n        STRB     r1,[r0,#4]\n        STR      r1,[r0,#0x10]\n        STR      r1,[r0,#0xc]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrotateLeft__FPP4nodeP4node PROC\n        LDR      r2,[r1,#0xc]\n        LDR      r3,[r2,#8]\n        STR      r3,[r1,#0xc]\n        LDR      r3,[r2,#8]\n        CMP      r3,#0\n        STRNE    r1,[r3,#0x10]\n        LDR      r3,[r1,#0x10]\n        STR      r3,[r2,#0x10]\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.112|\n        LDR      r0,[r3,#8]\n        CMP      r0,r1\n        STRNE    r2,[r3,#0xc]\n        STREQ    r2,[r3,#8]\n|L1.112|\n        STR      r1,[r2,#8]\n        STR      r2,[r1,#0x10]\n        BX       lr\n        ENDP\n\nrotateRight__FPP4nodeP4node PROC\n        LDR      r2,[r1,#8]\n        LDR      r3,[r2,#0xc]\n        STR      r3,[r1,#8]\n        LDR      r3,[r2,#0xc]\n        CMP      r3,#0\n        STRNE    r1,[r3,#0x10]\n        LDR      r3,[r1,#0x10]\n        STR      r3,[r2,#0x10]\n        LDR      r3,[r1,#0x10]\n        CMP      r3,#0\n        STREQ    r2,[r0,#0]\n        BEQ      |L1.188|\n        LDR      r0,[r3,#0xc]\n        CMP      r0,r1\n        STRNE    r2,[r3,#8]\n        STREQ    r2,[r3,#0xc]\n|L1.188|\n        STR      r1,[r2,#0xc]\n        STR      r2,[r1,#0x10]\n        BX       lr\n        ENDP\n\ninsertFixup__FPP4nodeP4node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r7,#0\n        MOV      r6,#1\n        MOV      r5,r0\n        MOV      r4,r1\n        B        |L1.480|\n|L1.224|\n        LDR      r2,[r0,#0x10]\n        LDR      r1,[r2,#8]\n        CMP      r0,r1\n        BNE      |L1.364|\n        LDR      r1,[r2,#0xc]\n        CMP      r1,#0\n        BEQ      |L1.296|\n        LDRB     r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.296|\n        STRB     r6,[r0,#4]\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r4,[r0,#0x10]\n        B        |L1.480|\n|L1.296|\n        LDR      r1,[r0,#0xc]\n        CMP      r1,r4\n        BNE      |L1.324|\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n|L1.324|\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0x10]\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n        B        |L1.480|\n|L1.364|\n        CMP      r1,#0\n        BEQ      |L1.416|\n        LDRB     r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.416|\n        STRB     r6,[r0,#4]\n        STRB     r6,[r1,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r4,[r0,#0x10]\n        B        |L1.480|\n|L1.416|\n        LDR      r1,[r0,#8]\n        CMP      r1,r4\n        BNE      |L1.444|\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       rotateRight__FPP4nodeP4node\n|L1.444|\n        LDR      r0,[r4,#0x10]\n        STRB     r6,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r0,[r0,#0x10]\n        STRB     r7,[r0,#4]\n        LDR      r0,[r4,#0x10]\n        LDR      r1,[r0,#0x10]\n        MOV      r0,r5\n        BL       rotateLeft__FPP4nodeP4node\n|L1.480|\n        LDR      r0,[r5,#0]\n        CMP      r0,r4\n        BEQ      |L1.508|\n        LDR      r0,[r4,#0x10]\n        LDRB     r1,[r0,#4]\n        CMP      r1,#0\n        BEQ      |L1.224|\n|L1.508|\n        LDR      r0,[r5,#0]\n        STRB     r6,[r0,#4]\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\ninsert__FPP4nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        BL       createNode__Fi\n        LDR      r2,[r4,#0]\n        MOV      r1,#0\n        CMP      r2,#0\n        BEQ      |L1.588|\n        LDR      r3,[r0,#0]\n|L1.560|\n        LDR      r12,[r2,#0]\n        MOV      r1,r2\n        CMP      r3,r12\n        LDRGE    r2,[r2,#0xc]\n        LDRLT    r2,[r2,#8]\n        CMP      r2,#0\n        BNE      |L1.560|\n|L1.588|\n        STR      r1,[r0,#0x10]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        BEQ      |L1.624|\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        STRGE    r0,[r1,#0xc]\n        STRLT    r0,[r1,#8]\n|L1.624|\n        MOV      r1,r0\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        insertFixup__FPP4nodeP4node\n        ENDP\n\nsearch__FP4nodei PROC\n        B        |L1.652|\n|L1.644|\n        LDRLE    r0,[r0,#0xc]\n        LDRGT    r0,[r0,#8]\n|L1.652|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BNE      |L1.644|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef enum { RED, BLACK } color;\n\ntypedef struct node {\n    int data;\n    color color;\n    struct node *left;\n    struct node *right;\n    struct node *parent;\n} node;\n\nnode* createNode(int data) {\n    node* newNode = (node*)malloc(sizeof(node));\n    newNode->data = data;\n    newNode->color = RED;\n    newNode->left = newNode->right = newNode->parent = NULL;\n    return newNode;\n}\n\nvoid rotateLeft(node** root, node* x) {\n    node* y = x->right;\n    x->right = y->left;\n    if (y->left != NULL) y->left->parent = x;\n    y->parent = x->parent;\n    if (x->parent == NULL) *root = y;\n    else if (x == x->parent->left) x->parent->left = y;\n    else x->parent->right = y;\n    y->left = x;\n    x->parent = y;\n}\n\nvoid rotateRight(node** root, node* x) {\n    node* y = x->left;\n    x->left = y->right;\n    if (y->right != NULL) y->right->parent = x;\n    y->parent = x->parent;\n    if (x->parent == NULL) *root = y;\n    else if (x == x->parent->right) x->parent->right = y;\n    else x->parent->left = y;\n    y->right = x;\n    x->parent = y;\n}\n\nvoid insertFixup(node** root, node* z) {\n    while (z != *root && z->parent->color == RED) {\n        if (z->parent == z->parent->parent->left) {\n            node* y = z->parent->parent->right;\n            if (y != NULL && y->color == RED) {\n                z->parent->color = BLACK;\n                y->color = BLACK;\n                z->parent->parent->color = RED;\n                z = z->parent->parent;\n            } else {\n                if (z == z->parent->right) {\n                    z = z->parent;\n                    rotateLeft(root, z);\n                }\n                z->parent->color = BLACK;\n                z->parent->parent->color = RED;\n                rotateRight(root, z->parent->parent);\n            }\n        } else {\n            node* y = z->parent->parent->left;\n            if (y != NULL && y->color == RED) {\n                z->parent->color = BLACK;\n                y->color = BLACK;\n                z->parent->parent->color = RED;\n                z = z->parent->parent;\n            } else {\n                if (z == z->parent->left) {\n                    z = z->parent;\n                    rotateRight(root, z);\n                }\n                z->parent->color = BLACK;\n                z->parent->parent->color = RED;\n                rotateLeft(root, z->parent->parent);\n            }\n        }\n    }\n    (*root)->color = BLACK;\n}\n\nvoid insert(node** root, int data) {\n    node* z = createNode(data);\n    node* y = NULL;\n    node* x = *root;\n    while (x != NULL) {\n        y = x;\n        if (z->data < x->data) x = x->left;\n        else x = x->right;\n    }\n    z->parent = y;\n    if (y == NULL) *root = z;\n    else if (z->data < y->data) y->left = z;\n    else y->right = z;\n    insertFixup(root, z);\n}\n\n\nnode* search(node* root, int data) {\n    while (root != NULL && root->data != data) {\n        if (data < root->data) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsearch__FP4Nodei PROC\n|L1.604|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#0xc]\n        LDRGT    r0,[r0,#8]\n        B        |L1.604|\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *node) {\n    if (node == NULL) return 0;\n    return node->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\nNode* search(Node* root, int key) {\n    if (root == NULL || root->key == key)\n        return root;\n    if (key < root->key)\n        return search(root->left, key);\n    return search(root->right, key);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_set__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r6,r5,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r6\n        BL       malloc\n        STMIB    r4,{r0,r5}\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.92|\n        MOV      r1,#0\n|L1.64|\n        LDR      r2,[r4,#0]\n        STR      r0,[r2,r0,LSL #2]\n        LDR      r2,[r4,#4]\n        STR      r1,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.64|\n|L1.92|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfind__FP12disjoint_seti PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        MOV      r4,r1\n        LDR      r1,[r0,r1,LSL #2]\n        CMP      r1,r4\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r0,r5\n        BL       find__FP12disjoint_seti\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nunite__FP12disjoint_setiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r4,r0\n        BL       find__FP12disjoint_seti\n        MOV      r5,r0\n        MOV      r0,r4\n        MOV      r1,r6\n        BL       find__FP12disjoint_seti\n        CMP      r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#4]\n        LDR      r2,[r1,r5,LSL #2]\n        LDR      r1,[r1,r0,LSL #2]\n        CMP      r2,r1\n        LDRLT    r1,[r4,#0]\n        STRLT    r0,[r1,r5,LSL #2]\n        LDMLTFD  sp!,{r4-r6,lr}\n        BXLT     lr\n        LDRGT    r1,[r4,#0]\n        STRGT    r5,[r1,r0,LSL #2]\n        LDMGTFD  sp!,{r4-r6,lr}\n        BXGT     lr\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,r5,LSL #2\n        LDR      r1,[r0,#0]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct disjoint_set {\n    int *parent;\n    int *rank;\n    int n;\n};\n\nstruct disjoint_set* create_set(int n) {\n    struct disjoint_set* set = (struct disjoint_set*)malloc(sizeof(struct disjoint_set));\n    set->parent = (int*)malloc(n * sizeof(int));\n    set->rank = (int*)malloc(n * sizeof(int));\n    set->n = n;\n    for (int i = 0; i < n; i++) {\n        set->parent[i] = i;\n        set->rank[i] = 0;\n    }\n    return set;\n}\n\nint find(struct disjoint_set* set, int i) {\n    if (set->parent[i] == i)\n        return i;\n    return set->parent[i] = find(set, set->parent[i]);\n}\n\nvoid unite(struct disjoint_set* set, int i, int j) {\n    int root_i = find(set, i);\n    int root_j = find(set, j);\n    if (root_i != root_j) {\n        if (set->rank[root_i] < set->rank[root_j])\n            set->parent[root_i] = root_j;\n        else if (set->rank[root_i] > set->rank[root_j])\n            set->parent[root_j] = root_i;\n        else {\n            set->parent[root_j] = root_i;\n            set->rank[root_i]++;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r1\n        LDR      r7,|L1.372|\n        MOV      r1,#1\n        STR      r1,[r7,r0,LSL #2]\n        CMP      r5,#0\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.376|\n        ADD      r6,r0,r1,LSL #4\n|L1.52|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r7,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.84|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       dfs__FiT1\n|L1.84|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.52|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nisTree__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        LDR      r5,|L1.372|\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r1,r4\n        MOV      r0,#0\n        BL       dfs__FiT1\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.184|\n|L1.152|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.152|\n|L1.184|\n        MOV      r1,#0\n        MOV      lr,#0\n        CMP      r4,#0\n        BLE      |L1.264|\n        LDR      r3,|L1.376|\n|L1.204|\n        ADD      r0,lr,#1\n        MOV      r2,r0\n        CMP      r0,r4\n        BGE      |L1.252|\n        ADD      r12,lr,lr,LSL #3\n        ADD      r12,r12,lr,LSL #4\n        ADD      r12,r3,r12,LSL #4\n|L1.232|\n        LDR      lr,[r12,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        ADD      r1,lr,r1\n        BLT      |L1.232|\n|L1.252|\n        MOV      lr,r2\n        CMP      r2,r4\n        BLT      |L1.204|\n|L1.264|\n        SUB      r0,r4,#1\n        CMP      r0,r1\n        LDMFD    sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint graph[MAX_VERTICES][MAX_VERTICES];\nint visited[MAX_VERTICES];\n\nvoid dfs(int vertex, int numVertices) {\n    visited[vertex] = 1;\n    for (int i = 0; i < numVertices; i++) {\n        if (graph[vertex][i] == 1 && !visited[i]) {\n            dfs(i, numVertices);\n        }\n    }\n}\n\nint isTree(int numVertices) {\n    memset(visited, 0, sizeof(visited));\n    dfs(0, numVertices);\n    for (int i = 0; i < numVertices; i++) {\n        if (!visited[i]) return 0;\n    }\n    int edges = 0;\n    for (int i = 0; i < numVertices; i++) {\n        for (int j = i + 1; j < numVertices; j++) {\n            edges += graph[i][j];\n        }\n    }\n    return edges == numVertices - 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\neuclidean_distance__FdN31 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r9,r3\n        MOV      r8,r2\n        MOV      r2,r0\n        MOV      r3,r1\n        ADD      r7,sp,#0x20\n        LDMIA    r7,{r0,r1,r6,r7}\n        BL       _dsub\n        MOV      r4,r0\n        MOV      r0,#2\n        MOV      r5,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __softfp_pow\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        MOV      r6,r0\n        MOV      r0,#2\n        MOV      r7,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       __softfp_pow\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        LDMFD    sp!,{r3-r9,lr}\n        B        __softfp_sqrt\n        ENDP\n```",
        "output": "```cpp\n\ndouble euclidean_distance(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r) {\n        printf(\"%s\\n\", a);\n    } else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i)); \n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountSetBits__Fi PROC\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.32|\n|L1.12|\n        AND      r2,r0,#1\n        MOV      r0,r0,ASR #1\n        CMP      r0,#0\n        ADD      r1,r2,r1\n        BGT      |L1.12|\n|L1.32|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += (n & 1);\n        n >>= 1;\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateSet__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,r1,LSL #2\n        MOV      r4,r1\n        BL       malloc\n        MOVS     r5,r0\n        MOVEQ    r0,#1\n        BLEQ     exit\n        MOV      r0,#0\n        STMIB    r6,{r0,r4}\n        STR      r5,[r6,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndestroySet__F3Set PROC\n        B        free\n        ENDP\n\naddElement__FP3Seti PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        LDR      r1,[r0,#4]\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        CMP      r1,r0\n        BNE      |L1.120|\n        MOV      r0,r0,LSL #1\n        STR      r0,[r4,#8]\n        MOV      r1,r0,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        MOVEQ    r0,#1\n        BLEQ     exit\n|L1.120|\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ncontains__F3Seti PROC\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.188|\n|L1.160|\n        LDR      r12,[r0,r2,LSL #2]\n        CMP      r12,r3\n        MOVEQ    r0,#1\n        BXEQ     lr\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.160|\n|L1.188|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nsetUnion__F3SetT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#0x10\n        LDR      r5,[sp,#0x34]\n        ADD      r9,sp,#4\n        MOV      r10,r0\n        MOV      r8,r1\n        ADD      r1,r2,r5\n        MOV      r0,r9\n        LDR      r6,[sp,#0x30]\n        MOV      r7,r2\n        BL       createSet__Fi\n        MOV      r4,#0\n        CMP      r7,#0\n        BLE      |L1.276|\n|L1.252|\n        LDR      r1,[r8,r4,LSL #2]\n        MOV      r0,r9\n        BL       addElement__FP3Seti\n        ADD      r4,r4,#1\n        CMP      r7,r4\n        BGT      |L1.252|\n|L1.276|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.328|\n|L1.288|\n        LDR      r3,[r6,r4,LSL #2]\n        LDMIB    sp,{r0-r2}\n        BL       contains__F3Seti\n        CMP      r0,#0\n        LDREQ    r1,[r6,r4,LSL #2]\n        MOVEQ    r0,r9\n        BLEQ     addElement__FP3Seti\n        ADD      r4,r4,#1\n        CMP      r5,r4\n        BGT      |L1.288|\n|L1.328|\n        LDMIA    r9,{r0-r2}\n        STMIA    r10,{r0-r2}\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\nsetIntersection__F3SetT1 PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        ADD      r9,sp,#0x34\n        LDMIA    r9,{r6,r9}\n        CMP      r2,r6\n        MOV      r7,r1\n        MOV      r11,r0\n        MOV      r5,r2\n        MOVLT    r1,r5\n        MOV      r0,sp\n        MOVGE    r1,r6\n        LDR      r8,[sp,#0x30]\n        MOV      r10,sp\n        BL       createSet__Fi\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.464|\n|L1.416|\n        LDR      r3,[r7,r4,LSL #2]\n        MOV      r2,r9\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       contains__F3Seti\n        CMP      r0,#0\n        LDRNE    r1,[r7,r4,LSL #2]\n        MOVNE    r0,r10\n        BLNE     addElement__FP3Seti\n        ADD      r4,r4,#1\n        CMP      r5,r4\n        BGT      |L1.416|\n|L1.464|\n        LDMIA    r10,{r0-r2}\n        STMIA    r11,{r0-r2}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\nsetDifference__F3SetT1 PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        ADD      r9,sp,#0x30\n        MOV      r11,r0\n        MOV      r6,r1\n        MOV      r1,r2\n        MOV      r0,sp\n        LDMIA    r9,{r7-r9}\n        MOV      r10,sp\n        MOV      r5,r2\n        BL       createSet__Fi\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.588|\n|L1.540|\n        LDR      r3,[r6,r4,LSL #2]\n        MOV      r2,r9\n        MOV      r1,r8\n        MOV      r0,r7\n        BL       contains__F3Seti\n        CMP      r0,#0\n        LDREQ    r1,[r6,r4,LSL #2]\n        MOVEQ    r0,r10\n        BLEQ     addElement__FP3Seti\n        ADD      r4,r4,#1\n        CMP      r5,r4\n        BGT      |L1.540|\n|L1.588|\n        LDMIA    r10,{r0-r2}\n        STMIA    r11,{r0-r2}\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Set {\n    int* elements;\n    int size;\n    int capacity;\n};\n\nstruct Set createSet(int capacity) {\n    struct Set set;\n    set.elements = (int*)malloc(capacity * sizeof(int));\n    if (set.elements == NULL) exit(1);\n    set.size = 0;\n    set.capacity = capacity;\n    return set;\n}\n\nvoid destroySet(struct Set set) {\n    free(set.elements);\n}\n\nvoid addElement(struct Set* set, int element) {\n    if (set->size == set->capacity) {\n        set->capacity *= 2;\n        set->elements = (int*)realloc(set->elements, set->capacity * sizeof(int));\n        if (set->elements == NULL) exit(1);\n\n    }\n    set->elements[set->size++] = element;\n}\n\n\nint contains(const struct Set set, int element) {\n    for (int i = 0; i < set.size; i++) {\n        if (set.elements[i] == element) return 1;\n    }\n    return 0;\n}\n\n\nstruct Set setUnion(const struct Set set1, const struct Set set2) {\n    struct Set result = createSet(set1.size + set2.size);\n    for (int i = 0; i < set1.size; i++) {\n        addElement(&result, set1.elements[i]);\n    }\n    for (int i = 0; i < set2.size; i++) {\n        if (!contains(result, set2.elements[i])) {\n            addElement(&result, set2.elements[i]);\n        }\n    }\n    return result;\n}\n\n\nstruct Set setIntersection(const struct Set set1, const struct Set set2) {\n    struct Set result = createSet( (set1.size < set2.size) ? set1.size : set2.size);\n    for (int i = 0; i < set1.size; i++) {\n        if (contains(set2, set1.elements[i])) {\n            addElement(&result, set1.elements[i]);\n        }\n    }\n    return result;\n}\n\nstruct Set setDifference(const struct Set set1, const struct Set set2) {\n    struct Set result = createSet(set1.size);\n    for (int i = 0; i < set1.size; i++) {\n        if (!contains(set2, set1.elements[i])) {\n            addElement(&result, set1.elements[i]);\n        }\n    }\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        CMP      r0,#0\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r2,#1\n        MOV      r1,#2\n        CMP      r0,#2\n        BLT      |L1.44|\n|L1.28|\n        MUL      r2,r1,r2\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLE      |L1.28|\n|L1.44|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint factorial(int n) {\n    if (n < 0) return 0; //Error handling for negative input.\n    int result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndayOfWeek__F4Date PROC\n|L1.0|\n        CMP      r1,#1\n        CMPNE    r1,#2\n        SUBEQ    r0,r0,#1\n        STMFD    sp!,{r4,lr}\n        LDR      r12,|L1.220|\n        MOV      r3,r0,ASR #31\n        SMULL    r4,lr,r12,r0\n        MOV      lr,lr,ASR #5\n        ADD      r3,r0,r3,LSR #30\n        ADD      r3,r0,r3,ASR #2\n        SUB      lr,lr,lr,ASR #31\n        SUB      r3,r3,lr\n        SMULL    lr,r0,r12,r0\n        MOV      r0,r0,ASR #7\n        SUB      r0,r0,r0,ASR #31\n        ADD      r0,r3,r0\n        LDR      r3,|L1.224|\n        ADDEQ    r1,r1,#0xc\n        ADD      r1,r3,r1,LSL #2\n        LDR      r1,[r1,#-4]\n        MOV      r3,#0\n        ADD      r0,r0,r1\n        ADD      r1,r0,r2\n        LDR      r2,|L1.228|\n        MOV      r0,r1\n        SMLAL    r3,r0,r2,r1\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #3\n        LDMFD    sp!,{r4,lr}\n        ADD      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Date {\n    int year;\n    int month;\n    int day;\n};\n\nint dayOfWeek(Date date) {\n    static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n    int y = date.year;\n    int m = date.month;\n    int d = date.day;\n\n    if (m == 1 || m == 2) {\n        y--;\n        m += 12;\n    }\n\n    int day = (y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7;\n    return day;\n}\n\n\nstruct Calendar {\n    int getDayOfWeek(int year, int month, int day){\n        Date date = {year, month, day};\n        return dayOfWeek(date);\n    }\n};\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsigmoid__Fd PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        EOR      r1,r1,#0x80000000\n        BL       __softfp_exp\n        ADR      r4,|L1.36|\n        LDMIA    r4,{r2,r3}\n        BL       _dadd\n        LDMIA    r4,{r2,r3}\n        LDMFD    sp!,{r4,lr}\n        B        _drdiv\n|L1.36|\n        DCFD     0x3ff0000000000000\n        ENDP\n\nsigmoid_derivative__Fd PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        ADR      r0,|L1.36|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r5,r1\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dmul\n        ENDP\n\ntrain__FPA2_dPdT1PA1_dN22id PROC\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0x44\n        ADD      r7,sp,#0x84\n        MOV      r10,r3\n        ADD      r3,sp,#0x34\n        LDMIA    r7,{r6,r7}\n        MOV      r1,#0\n        MOV      r0,#0\n        STMIA    r3,{r0,r1}\n        LDR      r1,[sp,#0x80]\n        CMP      r1,#0\n        ADDLE    sp,sp,#0x54\n        LDMLEFD  sp!,{r4-r11,lr}\n        BXLE     lr\n|L1.148|\n        LDR      r1,[sp,#0x38]\n        MOV      r0,#0\n        STR      r0,[sp,#0x30]\n        CMP      r1,#0\n        BLE      |L1.936|\n|L1.168|\n        LDR      r0,[sp,#0x30]\n        LDR      r1,[sp,#0x44]\n        MOV      r5,#0\n        ADD      r11,r1,r0,LSL #4\n|L1.184|\n        LDR      r2,[sp,#0x78]\n        MOV      r4,#0\n        ADD      r0,r2,r5,LSL #3\n        LDMIA    r0,{r8,r9}\n|L1.200|\n        LDR      r0,[sp,#0x4c]\n        ADD      r0,r0,r4,LSL #4\n        ADD      r1,r0,r5,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r11,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,#2\n        MOV      r8,r0\n        MOV      r9,r1\n        BLT      |L1.200|\n        ADD      r0,sp,#0x20\n        ADD      r4,r0,r5,LSL #3\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       sigmoid__Fd\n        ADD      r5,r5,#1\n        CMP      r5,#2\n        STMIA    r4,{r0,r1}\n        BLT      |L1.184|\n        MOV      r4,#0\n|L1.300|\n        LDR      r2,[sp,#0x7c]\n        MOV      r9,#0\n        ADD      r0,r2,r4,LSL #3\n        LDMIA    r0,{r5,r8}\n|L1.316|\n        ADD      r0,r10,r9,LSL #3\n        ADD      r1,r0,r4,LSL #3\n        ADD      r0,sp,#0x20\n        ADD      r0,r0,r9,LSL #3\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r8\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r9,r9,#1\n        CMP      r9,#2\n        MOV      r5,r0\n        MOV      r8,r1\n        BLT      |L1.316|\n        ADD      r9,sp,#0x18\n        ADD      r2,r9,r4,LSL #3\n        MOV      r0,r5\n        MOV      r5,r2\n        MOV      r1,r8\n        BL       sigmoid__Fd\n        ADD      r4,r4,#1\n        CMP      r4,#1\n        STMIA    r5,{r0,r1}\n        BLT      |L1.300|\n        LDR      r0,[sp,#0x30]\n        LDR      r1,[sp,#0x48]\n        MOV      r4,#0\n        ADD      r0,r1,r0,LSL #3\n        STR      r0,[sp,#0x40]\n|L1.436|\n        ADD      r0,sp,#0x18\n        ADD      r0,r0,r4,LSL #3\n        LDR      r3,[r0,#4]\n        LDR      r2,[r0,#0]\n        LDR      r0,[sp,#0x40]\n        MOV      r5,r3\n        MOV      r8,r2\n        LDMIA    r0,{r0,r1}\n        BL       _dsub\n        MOV      r9,r0\n        STR      r1,[sp,#0xc]\n        MOV      r1,r5\n        MOV      r0,r8\n        BL       sigmoid_derivative__Fd\n        ADD      r8,sp,#0x10\n        ADD      r5,r8,r4,LSL #3\n        MOV      r2,r9\n        LDR      r3,[sp,#0xc]\n        BL       _dmul\n        ADD      r4,r4,#1\n        CMP      r4,#1\n        STMIA    r5,{r0,r1}\n        BLT      |L1.436|\n        MOV      r5,#0\n|L1.532|\n        ADR      r0,|L1.972|\n        LDMIA    r0,{r8,r9}\n        ADD      r0,r10,r5,LSL #3\n        STR      r0,[sp,#0x3c]\n        MOV      r4,#0\n|L1.552|\n        LDR      r0,[sp,#0x3c]\n        ADD      r1,r0,r4,LSL #3\n        ADD      r0,sp,#0x10\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,#1\n        MOV      r8,r0\n        MOV      r9,r1\n        BLT      |L1.552|\n        ADD      r0,sp,#0x20\n        ADD      r0,r0,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       sigmoid_derivative__Fd\n        ADD      r4,sp,r5,LSL #3\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        ADD      r5,r5,#1\n        CMP      r5,#2\n        STMIA    r4,{r0,r1}\n        BLT      |L1.532|\n        MOV      r4,#0\n|L1.664|\n        ADD      r9,sp,r4,LSL #3\n        LDMIA    r9,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDR      r2,[sp,#0x78]\n        ADD      r5,r2,r4,LSL #3\n        LDMIA    r5,{r2,r3}\n        BL       _dadd\n        STMIA    r5,{r0,r1}\n        MOV      r5,#0\n|L1.708|\n        LDR      r0,[sp,#0x4c]\n        LDMIA    r9,{r2,r3}\n        ADD      r0,r0,r5,LSL #4\n        ADD      r8,r0,r4,LSL #3\n        ADD      r0,r11,r5,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIA    r8,{r2,r3}\n        BL       _dadd\n        ADD      r5,r5,#1\n        CMP      r5,#2\n        STMIA    r8,{r0,r1}\n        BLT      |L1.708|\n        ADD      r4,r4,#1\n        CMP      r4,#2\n        BLT      |L1.664|\n        MOV      r4,#0\n        ADD      r11,sp,#0x20\n|L1.792|\n        ADD      r0,sp,#0x10\n        ADD      r9,r0,r4,LSL #3\n        LDMIA    r9,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDR      r2,[sp,#0x7c]\n        ADD      r5,r2,r4,LSL #3\n        LDMIA    r5,{r2,r3}\n        BL       _dadd\n        STMIA    r5,{r0,r1}\n        MOV      r5,#0\n|L1.840|\n        ADD      r0,r10,r5,LSL #3\n        ADD      r8,r0,r4,LSL #3\n        ADD      r0,r11,r5,LSL #3\n        LDMIA    r9,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIA    r8,{r2,r3}\n        BL       _dadd\n        ADD      r5,r5,#1\n        CMP      r5,#2\n        STMIA    r8,{r0,r1}\n        BLT      |L1.840|\n        ADD      r4,r4,#1\n        CMP      r4,#1\n        BLT      |L1.792|\n        LDR      r0,[sp,#0x30]\n        LDR      r1,[sp,#0x38]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0x30]\n        CMP      r0,r1\n        BLT      |L1.168|\n|L1.936|\n        LDR      r0,[sp,#0x34]\n        LDR      r1,[sp,#0x80]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0x34]\n        CMP      r0,r1\n        BLT      |L1.148|\n        ADD      sp,sp,#0x54\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.972|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\n\n#define INPUT_SIZE 2\n#define HIDDEN_SIZE 2\n#define OUTPUT_SIZE 1\n\ndouble sigmoid(double x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\ndouble sigmoid_derivative(double x) {\n    return x * (1.0 - x);\n}\n\n\nvoid train(double input[][INPUT_SIZE], double target[], double weights_ih[][HIDDEN_SIZE], double weights_ho[][OUTPUT_SIZE], double bias_h[], double bias_o[], int epochs, double learning_rate) {\n    int n = sizeof(input)/sizeof(input[0]);\n\n    for (int e = 0; e < epochs; e++) {\n        for (int i = 0; i < n; i++) {\n            // Forward pass\n            double hidden_layer[HIDDEN_SIZE];\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                double sum = bias_h[j];\n                for (int k = 0; k < INPUT_SIZE; k++) {\n                    sum += input[i][k] * weights_ih[k][j];\n                }\n                hidden_layer[j] = sigmoid(sum);\n            }\n\n            double output_layer[OUTPUT_SIZE];\n            for (int j = 0; j < OUTPUT_SIZE; j++) {\n                double sum = bias_o[j];\n                for (int k = 0; k < HIDDEN_SIZE; k++) {\n                    sum += hidden_layer[k] * weights_ho[k][j];\n                }\n                output_layer[j] = sigmoid(sum);\n            }\n\n            // Backward pass\n            double delta_o[OUTPUT_SIZE];\n            for (int j = 0; j < OUTPUT_SIZE; j++) {\n                delta_o[j] = (target[i] - output_layer[j]) * sigmoid_derivative(output_layer[j]);\n            }\n\n            double delta_h[HIDDEN_SIZE];\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                double error = 0.0;\n                for (int k = 0; k < OUTPUT_SIZE; k++) {\n                    error += delta_o[k] * weights_ho[j][k];\n                }\n                delta_h[j] = error * sigmoid_derivative(hidden_layer[j]);\n            }\n\n            // Update weights and biases\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                bias_h[j] += delta_h[j] * learning_rate;\n                for (int k = 0; k < INPUT_SIZE; k++) {\n                    weights_ih[k][j] += input[i][k] * delta_h[j] * learning_rate;\n                }\n            }\n            for (int j = 0; j < OUTPUT_SIZE; j++) {\n                bias_o[j] += delta_o[j] * learning_rate;\n                for (int k = 0; k < HIDDEN_SIZE; k++) {\n                    weights_ho[k][j] += hidden_layer[k] * delta_o[j] * learning_rate;\n                }\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisSumTree__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        BEQ      |L1.72|\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        BNE      |L1.84|\n|L1.72|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.84|\n        MOVS     r1,r0\n        LDR      r2,[r4,#8]\n        LDRNE    r1,[r0,#0]\n        CMP      r2,#0\n        LDRNE    r2,[r2,#0]\n        ADD      r1,r1,r2\n        LDR      r2,[r4,#0]\n        CMP      r1,r2\n        BNE      |L1.156|\n        BL       isSumTree__FP4Node\n        CMP      r0,#0\n        BEQ      |L1.156|\n        LDR      r0,[r4,#8]\n        BL       isSumTree__FP4Node\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.156|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n};\n\nNode* newNode(int data) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint isSumTree(Node* node) {\n    if(node == NULL || (node->left == NULL && node->right == NULL)) return 1;\n\n    int ls, rs;\n    \n    if(node->left) ls = node->left->data; else ls = 0;\n    if(node->right) rs = node->right->data; else rs = 0;\n\n\n    if ((ls + rs == node->data) && isSumTree(node->left) && isSumTree(node->right))\n        return 1;\n    \n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlongest_increasing_subsequence__FPii PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOVS     r6,r1\n        MOV      r4,r0\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOVEQ    r0,#4\n        BEQ      malloc\n        MOV      r7,r6,LSL #2\n        MOV      r0,r7\n        BL       malloc\n        MOV      r5,r0\n        MOV      r0,r7\n        BL       malloc\n        MOV      r8,r0\n        MOV      r0,r5\n        MOV      r2,r7\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r0,#0\n        CMP      r6,#0\n        BLE      |L1.100|\n|L1.80|\n        LDR      r1,[r4,r0,LSL #2]\n        STR      r1,[r8,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.80|\n|L1.100|\n        MOV      r0,#1\n        CMP      r6,#1\n        BLE      |L1.192|\n|L1.112|\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.180|\n|L1.124|\n        LDR      r2,[r4,r0,LSL #2]\n        LDR      r3,[r4,r1,LSL #2]\n        CMP      r2,r3\n        BLE      |L1.168|\n        LDR      r3,[r5,r0,LSL #2]\n        LDR      r2,[r5,r1,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        STRLT    r2,[r5,r0,LSL #2]\n        LDRLT    r2,[r4,r0,LSL #2]\n        STRLT    r2,[r8,r0,LSL #2]\n|L1.168|\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.124|\n|L1.180|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLT      |L1.112|\n|L1.192|\n        MOV      r7,#0\n        MOV      r9,#0\n        MOV      r0,#0\n        CMP      r6,#0\n        BLE      |L1.240|\n|L1.212|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,r7\n        MOVGT    r9,r0\n        ADD      r0,r0,#1\n        MOVGT    r7,r1\n        CMP      r0,r6\n        BLT      |L1.212|\n|L1.240|\n        MOV      r0,#4\n        ADD      r0,r0,r7,LSL #2\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,r7,LSL #2]\n        SUBS     r1,r7,#1\n        MOV      r6,r0\n        BMI      |L1.340|\n|L1.272|\n        SUBS     r0,r9,#1\n        BMI      |L1.332|\n        ADD      r3,r1,#1\n|L1.284|\n        LDR      r2,[r5,r0,LSL #2]\n        CMP      r2,r3\n        BNE      |L1.324|\n        LDR      r2,[r4,r0,LSL #2]\n        LDR      r12,[r4,r9,LSL #2]\n        CMP      r2,r12\n        LDRLT    r2,[r4,r0,LSL #2]\n        MOVLT    r9,r0\n        STRLT    r2,[r6,r1,LSL #2]\n        BLT      |L1.332|\n|L1.324|\n        SUBS     r0,r0,#1\n        BPL      |L1.284|\n|L1.332|\n        SUBS     r1,r1,#1\n        BPL      |L1.272|\n|L1.340|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r8\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* longest_increasing_subsequence(int* arr, int n) {\n    if (n == 0) return (int*)malloc(sizeof(int));\n    int* dp = (int*)malloc(n * sizeof(int));\n    int* tail = (int*)malloc(n * sizeof(int));\n    int len = 0;\n    memset(dp, 1, n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        tail[i] = arr[i];\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1;\n                tail[i] = arr[i];\n            }\n        }\n    }\n    int maxLen = 0;\n    int maxIndex = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            maxIndex = i;\n        }\n    }\n    int* result = (int*)malloc((maxLen + 1) * sizeof(int));\n    result[maxLen] = 0;\n    int current = maxIndex;\n    for (int i = maxLen-1; i >=0; i--) {\n        for (int j = current-1; j >=0; j--) {\n            if (dp[j] == i+1 && arr[j] < arr[current]) {\n                result[i] = arr[j];\n                current = j;\n                break;\n            }\n        }\n    }\n    free(dp);\n    free(tail);\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindMin__FPii PROC\n|L1.0|\n        CMP      r1,#0\n        MVNLE    r0,#0\n        BXLE     lr\n        MOV      r2,#1\n        CMP      r1,#1\n        LDR      r3,[r0,#0]\n        BLE      |L1.52|\n|L1.28|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r12,r3\n        MOVLT    r3,r12\n        CMP      r2,r1\n        BLT      |L1.28|\n|L1.52|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findMin(int arr[], int size) {\n    if (size <= 0) return -1; // Handle empty array case\n\n    int min = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    return min;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisBipartiteUtil__FPiiN22 PROC\n|L1.0|\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r9,|L1.380|\n        MOV      r7,r0\n        LDR      r0,[r9,#0]  ; colors\n        MOV      r6,r1\n        MOV      r5,r3\n        MOV      r4,#0\n        CMP      r3,#0\n        STR      r2,[r0,r1,LSL #2]\n        BLE      |L1.144|\n        RSB      r8,r2,#1\n|L1.44|\n        MLA      r0,r5,r6,r4\n        LDR      r0,[r7,r0,LSL #2]\n        CMP      r0,#1\n        BNE      |L1.132|\n        LDR      r1,[r9,#0]  ; colors\n        LDR      r0,[r1,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.112|\n        MOV      r3,r5\n        MOV      r2,r8\n        MOV      r1,r4\n        MOV      r0,r7\n        BL       isBipartiteUtil__FPiiN22\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r9,lr}\n        BXEQ     lr\n        B        |L1.132|\n|L1.112|\n        LDR      r1,[r1,r6,LSL #2]\n        CMP      r0,r1\n        LDMEQFD  sp!,{r4-r9,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n|L1.132|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.44|\n|L1.144|\n        LDMFD    sp!,{r4-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nisBipartite__FPii PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r4,r1,LSL #2\n        MOV      r0,r4\n        MOV      r5,r1\n        BL       malloc\n        LDR      r7,|L1.380|\n        MOV      r2,r4\n        MVN      r1,#0\n        STR      r0,[r7,#0]  ; colors\n        BL       __rt_memset\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.288|\n|L1.212|\n        LDR      r0,[r7,#0]  ; colors\n        LDR      r0,[r0,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.276|\n        MOV      r3,r5\n        MOV      r2,#0\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       isBipartiteUtil__FPiiN22\n        CMP      r0,#0\n        BNE      |L1.276|\n        LDR      r0,[r7,#0]  ; colors\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.276|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.212|\n|L1.288|\n        LDR      r0,[r7,#0]  ; colors\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint* colors;\n\nint isBipartiteUtil(int* graph, int node, int color, int num_nodes) {\n    colors[node] = color;\n    for (int i = 0; i < num_nodes; ++i) {\n        if (graph[node * num_nodes + i] == 1) {\n            if (colors[i] == -1) {\n                if (!isBipartiteUtil(graph, i, 1 - color, num_nodes))\n                    return 0;\n            } else if (colors[i] == colors[node]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\n\nint isBipartite(int* graph, int num_nodes) {\n    colors = (int*)malloc(num_nodes * sizeof(int));\n    memset(colors, -1, num_nodes * sizeof(int));\n    for (int i = 0; i < num_nodes; ++i) {\n        if (colors[i] == -1) {\n            if (!isBipartiteUtil(graph, i, 0, num_nodes)) {\n                free(colors);\n                return 0;\n            }\n        }\n    }\n    free(colors);\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateHeap__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STMIB    r4,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nheapifyUp__FP10BinaryHeapi PROC\n        CMP      r1,#0\n        LDRGT    r2,[r0,#4]\n        CMPGT    r2,r1\n        BXLE     lr\n        STR      lr,[sp,#-4]!\n        LDR      lr,[r0,#0]\n        SUB      r2,r1,#1\n        ADD      r2,r2,r2,LSR #31\n        MOV      r2,r2,ASR #1\n        LDR      r3,[lr,r1,LSL #2]\n        LDR      r12,[lr,r2,LSL #2]\n        CMP      r3,r12\n        LDRLE    lr,[sp],#4\n        BXLE     lr\n        STR      r12,[lr,r1,LSL #2]\n        LDR      r1,[r0,#0]\n        STR      r3,[r1,r2,LSL #2]\n        LDR      lr,[sp],#4\n        MOV      r1,r2\n        B        heapifyUp__FP10BinaryHeapi\n        ENDP\n\ninsert__FP10BinaryHeapi PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP10BinaryHeapi\n        ENDP\n\nheapifyDown__FP10BinaryHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        CMP      r1,#0\n        LDRGE    lr,[r0,#4]\n        MOV      r2,r1\n        CMPGE    lr,r2\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        MOV      r3,#1\n        ADD      r3,r3,r2,LSL #1\n        MOV      r12,#2\n        ADD      r12,r12,r2,LSL #1\n        CMP      lr,r3\n        MOV      r1,r2\n        BLE      |L1.284|\n        LDR      r4,[r0,#0]\n        LDR      r5,[r4,r3,LSL #2]\n        LDR      r4,[r4,r1,LSL #2]\n        CMP      r5,r4\n        MOVGT    r1,r3\n|L1.284|\n        CMP      lr,r12\n        BLE      |L1.312|\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r12,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        CMP      lr,r3\n        MOVGT    r1,r12\n|L1.312|\n        CMP      r1,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r1,LSL #2]\n        LDR      r12,[r3,r2,LSL #2]\n        STR      lr,[r3,r2,LSL #2]\n        LDR      r2,[r0,#0]\n        STR      r12,[r2,r1,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP10BinaryHeapi\n        ENDP\n\ndeleteMax__FP10BinaryHeap PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        BL       heapifyDown__FP10BinaryHeapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nfreeHeap__FP10BinaryHeap PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define  LEFT(i) (2 * (i) + 1)\n#define RIGHT(i) (2 * (i) + 2)\n#define PARENT(i) ((i) - 1) / 2\n\ntypedef struct {\n    int* heap;\n    int size;\n    int capacity;\n} BinaryHeap;\n\n\nBinaryHeap* createHeap(int capacity) {\n    BinaryHeap* heap = (BinaryHeap*)malloc(sizeof(BinaryHeap));\n    if (heap == NULL) return NULL;\n    heap->heap = (int*)malloc(capacity * sizeof(int));\n    if (heap->heap == NULL) {\n        free(heap);\n        return NULL;\n    }\n    heap->size = 0;\n    heap->capacity = capacity;\n    return heap;\n}\n\nvoid heapifyUp(BinaryHeap* heap, int index) {\n    if (index <= 0 || index >= heap->size) return;\n    int parentIndex = PARENT(index);\n    if (heap->heap[index] > heap->heap[parentIndex]) {\n        int temp = heap->heap[index];\n        heap->heap[index] = heap->heap[parentIndex];\n        heap->heap[parentIndex] = temp;\n        heapifyUp(heap, parentIndex);\n    }\n}\n\nvoid insert(BinaryHeap* heap, int value) {\n    if (heap->size == heap->capacity) return;\n    heap->heap[heap->size] = value;\n    heap->size++;\n    heapifyUp(heap, heap->size -1);\n}\n\nvoid heapifyDown(BinaryHeap* heap, int index) {\n    if (index < 0 || index >= heap->size) return;\n    int largest = index;\n    int left = LEFT(index);\n    int right = RIGHT(index);\n    if (left < heap->size && heap->heap[left] > heap->heap[largest]) {\n        largest = left;\n    }\n    if (right < heap->size && heap->heap[right] > heap->heap[largest]) {\n        largest = right;\n    }\n    if (largest != index) {\n        int temp = heap->heap[index];\n        heap->heap[index] = heap->heap[largest];\n        heap->heap[largest] = temp;\n        heapifyDown(heap, largest);\n    }\n}\n\nint deleteMax(BinaryHeap* heap) {\n    if (heap->size == 0) return -1;\n    int max = heap->heap[0];\n    heap->heap[0] = heap->heap[heap->size - 1];\n    heap->size--;\n    heapifyDown(heap, 0);\n    return max;\n}\n\n\nvoid freeHeap(BinaryHeap* heap) {\n    free(heap->heap);\n    free(heap);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateHeap__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#8]\n        STR      r5,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nheapifyUp__FP4Heapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        SUB      r0,r1,#1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r4,r0,ASR #1\n        B        |L1.168|\n|L1.136|\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        SUB      r0,r4,#1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r1,r4\n        MOV      r4,r0,ASR #1\n|L1.168|\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        LDR      r0,[r5,#0]\n        LDR      r2,[r0,r1,LSL #2]\n        LDR      r3,[r0,r4,LSL #2]\n        CMP      r2,r3\n        BGT      |L1.136|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Heapi PROC\n        LDR      r2,[r0,#8]\n        LDR      r3,[r0,#4]\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#8]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP4Heapi\n        ENDP\n\nheapifyDown__FP4Heapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#8]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.312|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVGT    r4,r0\n|L1.312|\n        CMP      r3,r2\n        BLE      |L1.340|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVGT    r4,r2\n|L1.340|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP4Heapi\n        ENDP\n\ndeleteRoot__FP4Heap PROC\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#8]\n        MOV      r1,#0\n        BL       heapifyDown__FP4Heapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* arr;\n    int capacity;\n    int size;\n} Heap;\n\nHeap* createHeap(int capacity) {\n    Heap* heap = (Heap*)malloc(sizeof(Heap));\n    if (!heap) return 0;\n    heap->arr = (int*)malloc(capacity * sizeof(int));\n    if (!heap->arr) {\n        free(heap);\n        return 0;\n    }\n    heap->capacity = capacity;\n    heap->size = 0;\n    return heap;\n}\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapifyUp(Heap* heap, int index) {\n    int parent = (index - 1) / 2;\n    while (index > 0 && heap->arr[index] > heap->arr[parent]) {\n        swap(&heap->arr[index], &heap->arr[parent]);\n        index = parent;\n        parent = (index - 1) / 2;\n    }\n}\n\nvoid insert(Heap* heap, int data) {\n    if (heap->size == heap->capacity) return;\n    heap->arr[heap->size] = data;\n    heap->size++;\n    heapifyUp(heap, heap->size - 1);\n}\n\nvoid heapifyDown(Heap* heap, int index) {\n    int largest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < heap->size && heap->arr[left] > heap->arr[largest])\n        largest = left;\n    if (right < heap->size && heap->arr[right] > heap->arr[largest])\n        largest = right;\n    if (largest != index) {\n        swap(&heap->arr[index], &heap->arr[largest]);\n        heapifyDown(heap, largest);\n    }\n}\n\n\nint deleteRoot(Heap* heap) {\n    if (heap->size == 0) return -1;\n    int root = heap->arr[0];\n    heap->arr[0] = heap->arr[heap->size - 1];\n    heap->size--;\n    heapifyDown(heap, 0);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Listi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsortList__FP4List PROC\n        LDR      r1,[r0,#0]\n        CMP      r1,#0\n        LDRNE    r1,[r1,#4]\n        CMPNE    r1,#0\n        BXEQ     lr\n        STR      lr,[sp,#-4]!\n|L1.96|\n        LDR      r1,[r0,#0]\n        MOV      lr,#0\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n|L1.120|\n        LDR      r2,[r1,#4]\n        LDR      r3,[r1,#0]\n        LDR      r12,[r2,#0]\n        CMP      r3,r12\n        STRGT    r12,[r1,#0]\n        STRGT    r3,[r2,#0]\n        LDR      r1,[r1,#4]\n        MOVGT    lr,#1\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.120|\n        CMP      lr,#0\n        BNE      |L1.96|\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nstruct List {\n    Node *head;\n};\n\nList* createList() {\n    List* list = (List*)malloc(sizeof(List));\n    list->head = NULL;\n    return list;\n}\n\nvoid insert(List* list, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = list->head;\n    list->head = newNode;\n}\n\n\nvoid sortList(List* list) {\n    if (list->head == NULL || list->head->next == NULL) return;\n\n    Node* current = list->head;\n    Node* next;\n    int swapped;\n\n    do {\n        swapped = 0;\n        current = list->head;\n\n        while (current->next != NULL) {\n            next = current->next;\n            if (current->data > next->data) {\n                int temp = current->data;\n                current->data = next->data;\n                next->data = temp;\n                swapped = 1;\n            }\n            current = current->next;\n        }\n    } while (swapped);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntoDecimal__FPci PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r10,r0\n        ADR      r0,|L1.196|\n        LDMIA    r0,{r7,r8}\n        ADR      r0,|L1.204|\n        LDMIA    r0,{r5,r6}\n        MOV      r0,r10\n        MOV      r9,r1\n        BL       strlen\n        SUBS     r4,r0,#1\n        BMI      |L1.180|\n        ADR      r11,|L1.212|\n|L1.48|\n        LDRB     r0,[r10,r4]\n        SUB      r1,r0,#0x30\n        CMP      r1,#9\n        BLS      |L1.108|\n        SUB      r1,r0,#0x41\n        CMP      r1,#0x19\n        SUBLS    r1,r0,#0x37\n        BLS      |L1.108|\n        SUB      r1,r0,#0x61\n        CMP      r1,#0x19\n        SUBLS    r1,r0,#0x57\n        BLS      |L1.108|\n        LDMIA    r11,{r0,r1}\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.108|\n        CMP      r1,r9\n        LDMGEIA  r11,{r0,r1}\n        LDMGEFD  sp!,{r3-r11,lr}\n        BXGE     lr\n        UMULL    r0,r12,r5,r1\n        MOV      r2,r1\n        MOV      r3,r2,ASR #31\n        MLA      r12,r1,r6,r12\n        MLA      r1,r3,r5,r12\n        ADDS     r7,r0,r7\n        UMULL    r0,r12,r5,r9\n        MLA      r12,r9,r6,r12\n        MOV      r3,r9,ASR #31\n        MLA      r6,r3,r5,r12\n        ADC      r8,r1,r8\n        SUBS     r4,r4,#1\n        MOV      r5,r0\n        BPL      |L1.48|\n|L1.180|\n        MOV      r0,r7\n        MOV      r1,r8\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.196|\n        DCQ      0x0000000000000000\n|L1.204|\n        DCQ      0x0000000000000001\n|L1.212|\n        DCQ      0xffffffffffffffff\n        ENDP\n\nfromDecimal__Fxi PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.196|\n        MOV      r8,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r5,r0\n        LDMEQFD  sp!,{r4-r10,lr}\n        ADREQ    r0,|L1.476|\n        BXEQ     lr\n        LDMIA    r10,{r2,r3}\n        SUBS     r0,r5,r2\n        SBCS     r1,r6,r3\n        LDMLTFD  sp!,{r4-r10,lr}\n        ADRLT    r0,|L1.480|\n        BXLT     lr\n        MOV      r0,#0x41\n        BL       malloc\n        MOV      r4,r0\n        LDMIA    r10,{r2,r3}\n        SUBS     r0,r2,r5\n        SBCS     r1,r3,r6\n        MOV      r7,#0\n        BGE      |L1.404|\n        MOV      r9,r8,ASR #31\n|L1.324|\n        MOV      r0,r8\n        MOV      r1,r9\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _ll_srdv\n        MOV      r5,r0\n        MOV      r0,r2\n        CMP      r2,#0xa\n        ADDGE    r0,r0,#0x37\n        MOV      r6,r1\n        MOV      r1,r3\n        ADDLT    r0,r0,#0x30\n        AND      r1,r0,#0xff\n        MOV      r0,r7\n        STRB     r1,[r4,r0]\n        LDMIA    r10,{r2,r3}\n        SUBS     r0,r2,r5\n        SBCS     r1,r3,r6\n        ADD      r7,r7,#1\n        BLT      |L1.324|\n|L1.404|\n        ADD      r1,r7,r7,LSR #31\n        MOV      r1,r1,ASR #1\n        MOV      r0,#0\n        STRB     r0,[r4,r7]\n        CMP      r1,#0\n        BLE      |L1.464|\n        SUB      lr,r7,#1\n|L1.432|\n        SUB      r3,lr,r0\n        LDRB     r12,[r4,r3]\n        LDRB     r2,[r4,r0]\n        STRB     r12,[r4,r0]\n        ADD      r0,r0,#1\n        CMP      r1,r0\n        STRB     r2,[r4,r3]\n        BGT      |L1.432|\n|L1.464|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.476|\n        DCB      \"0\\0\\0\\0\"\n|L1.480|\n        DCB      \"-1\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nlong long toDecimal(char *str, int base) {\n    long long res = 0;\n    long long power = 1;\n    for (int i = strlen(str) - 1; i >= 0; i--) {\n        int val;\n        if (str[i] >= '0' && str[i] <= '9')\n            val = str[i] - '0';\n        else if (str[i] >= 'A' && str[i] <= 'Z')\n            val = str[i] - 'A' + 10;\n        else if (str[i] >= 'a' && str[i] <= 'z')\n            val = str[i] - 'a' + 10;\n        else\n            return -1; \n\n        if (val >= base) return -1;\n        res += val * power;\n        power *= base;\n    }\n    return res;\n}\n\n\nchar* fromDecimal(long long n, int base) {\n    if (n == 0) return \"0\";\n    if (n < 0) return \"-1\"; //Handle negative numbers as needed.\n    char *res = (char*)malloc(65); // Adjust size as needed for large numbers.\n    int i = 0;\n    while (n > 0) {\n        int rem = n % base;\n        char c;\n        if (rem < 10)\n            c = rem + '0';\n        else\n            c = rem - 10 + 'A';\n        res[i++] = c;\n        n /= base;\n    }\n    res[i] = '\\0';\n    for (int j = 0; j < i / 2; j++) {\n        char temp = res[j];\n        res[j] = res[i - 1 - j];\n        res[i - 1 - j] = temp;\n    }\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_prime__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r4,#3\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#1\n        BXLE     lr\n        TST      r4,#1\n        BEQ      |L1.72|\n        LDR      r1,|L1.236|\n        SMULL    r2,r0,r1,r4\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #2\n        ADDS     r0,r0,r4\n        BNE      |L1.84|\n|L1.72|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r5,#5\n        CMP      r4,#0x19\n        BLT      |L1.164|\n|L1.96|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BEQ      |L1.136|\n        MOV      r1,r4\n        ADD      r0,r5,#2\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.148|\n|L1.136|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.148|\n        ADD      r5,r5,#6\n        MUL      r0,r5,r5\n        CMP      r0,r4\n        BLE      |L1.96|\n|L1.164|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsphereSurfaceArea__Fd PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        ADR      r0,|L1.84|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r5,r1\n        BL       _dcmple\n        ADRCC    r1,|L1.92|\n        LDMCCIA  r1,{r0,r1}\n        LDMCCFD  sp!,{r3-r5,lr}\n        BXCC     lr\n        MOV      r1,r5\n        ADR      r0,|L1.100|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dmul\n|L1.84|\n        DCFD     0x0000000000000000\n|L1.92|\n        DCFD     0xbff0000000000000\n|L1.100|\n        DCFD     0x402921fb54442eea\n        ENDP\n```",
        "output": "```cpp\n\ndouble sphereSurfaceArea(double radius) {\n    if (radius < 0) return -1.0; //Error Handling for negative radius\n    return 4.0 * 3.14159265359 * radius * radius;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        CMP      r0,#0\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r2,#1\n        MOV      r1,#1\n        CMP      r0,#1\n        BLT      |L1.44|\n|L1.28|\n        MUL      r2,r1,r2\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLE      |L1.28|\n|L1.44|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint factorial(int n) {\n    if (n < 0) return 0; //Error handling for negative input.\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhanoi__FiN31 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r3\n        MOV      r5,r2\n        MOV      r4,r1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        SUB      r0,r0,#1\n        MOV      r7,r0\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r4\n        BL       hanoi__FiN31\n        MOV      r2,r5\n        MOV      r1,r4\n        ADR      r0,|L1.96|\n        BL       _printf\n        MOV      r3,r4\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r7\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        hanoi__FiN31\n|L1.96|\n        DCB      \"%d %\"\n        DCB      \"d\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid hanoi(int n, int source, int destination, int auxiliary) {\n    if (n > 0) {\n        hanoi(n - 1, source, auxiliary, destination);\n        printf(\"%d %d\\n\", source, destination);\n        hanoi(n - 1, auxiliary, destination, source);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstateOne__FP7Context PROC\n        MOV      r1,#2\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n\nstateTwo__FP7Context PROC\n        MOV      r1,#1\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n\nsetState__FP7Contexti PROC\n        CMP      r1,#1\n        MOVNE    r1,#2\n        MOVEQ    r1,#1\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n\nhandle__FP7Context PROC\n        LDR      r2,[r0,#0]\n        LDR      r1,|L1.124|\n        CMP      r2,#1\n        LDRNE    r1,[r1,#4]  ; stateTwoImpl\n        BXNE     r1\n        LDREQ    r1,[r1,#0]  ; stateOneImpl\n        BXEQ     r1\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Context {\n    int state;\n} Context;\n\n\ntypedef struct State {\n    void (*handle)(Context*);\n} State;\n\n\nvoid stateOne(Context* context) {\n    context->state = 2;\n}\n\nvoid stateTwo(Context* context) {\n    context->state = 1;\n}\n\n\nState stateOneImpl = {stateOne};\nState stateTwoImpl = {stateTwo};\n\n\nvoid setState(Context* context, int state) {\n    if(state == 1){\n        context->state = 1;\n    } else {\n        context->state = 2;\n    }\n}\n\nvoid handle(Context* context) {\n    if (context->state == 1) {\n        stateOneImpl.handle(context);\n    } else {\n        stateTwoImpl.handle(context);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BXEQ     lr\n|L1.284|\n        LDR      r0,[r0,#8]\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BNE      |L1.284|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.352|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.476|\n|L1.352|\n        BGE      |L1.372|\n        LDR      r0,[r4,#0xc]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#0xc]\n        B        |L1.476|\n|L1.372|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        LDRNE    r1,[r4,#0xc]\n        CMPNE    r1,#0\n        BNE      |L1.444|\n        CMP      r0,#0\n        LDREQ    r0,[r4,#0xc]\n        CMP      r0,#0\n        LDMNEIA  r0,{r1-r3,r12}\n        STMNEIA  r4,{r1-r3,r12}\n        MOVEQ    r0,r4\n        MOVEQ    r4,#0\n        BL       free\n        CMP      r4,#0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        B        |L1.476|\n|L1.444|\n        MOV      r0,r1\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#0xc]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.476|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        MOV      r3,r0\n        CMP      r0,#1\n        BLE      |L1.592|\n        LDR      r0,[r4,#8]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r4,lr}\n        BGE      rightRotate__FP4Node\n        LDR      r0,[r4,#8]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        BGE      |L1.592|\n        LDR      r0,[r4,#8]\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        rightRotate__FP4Node\n|L1.592|\n        CMN      r3,#1\n        BGE      |L1.664|\n        LDR      r0,[r4,#0xc]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4,lr}\n        BLE      leftRotate__FP4Node\n        LDR      r0,[r4,#0xc]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        BLE      |L1.664|\n        LDR      r0,[r4,#0xc]\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        leftRotate__FP4Node\n|L1.664|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* minValueNode(Node* node) {\n    Node* current = node;\n    while (current->left != NULL)\n        current = current->left;\n    return current;\n}\n\n\nNode* deleteNode(Node* root, int key) {\n    if (root == NULL) return root;\n    if (key < root->key)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->key)\n        root->right = deleteNode(root->right, key);\n    else {\n        if ((root->left == NULL) || (root->right == NULL)) {\n            Node *temp = root->left ? root->left : root->right;\n            if (temp == NULL) {\n                temp = root;\n                root = NULL;\n            } else\n                *root = *temp;\n            free(temp);\n        } else {\n            Node* temp = minValueNode(root->right);\n            root->key = temp->key;\n            root->right = deleteNode(root->right, temp->key);\n        }\n    }\n    if (root == NULL) return root;\n    root->height = 1 + max(height(root->left), height(root->right));\n    int balance = getBalance(root);\n    if (balance > 1 && getBalance(root->left) >= 0)\n        return rightRotate(root);\n    if (balance > 1 && getBalance(root->left) < 0) {\n        root->left = leftRotate(root->left);\n        return rightRotate(root);\n    }\n    if (balance < -1 && getBalance(root->right) <= 0)\n        return leftRotate(root);\n    if (balance < -1 && getBalance(root->right) > 0) {\n        root->right = rightRotate(root->right);\n        return leftRotate(root);\n    }\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        CMP      r12,r1\n        LDRLT    r4,[r0,r12,LSL #2]\n        LDRLT    r5,[r0,r2,LSL #2]\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        MOV      r3,r2\n        CMPLT    r4,r5\n        MOVLT    r2,r12\n        CMP      lr,r1\n        LDRLT    r12,[r0,lr,LSL #2]\n        LDRLT    r4,[r0,r2,LSL #2]\n        CMPLT    r12,r4\n        MOVLT    r2,lr\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nbuildMinHeap__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r4,r0,#1\n        MOV      r5,r1\n        LDMMIFD  sp!,{r4-r6,lr}\n        BXMI     lr\n|L1.132|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       heapify__FPiiT2\n        SUBS     r4,r4,#1\n        BPL      |L1.132|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] < arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] < arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\n\nvoid buildMinHeap(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r4,#1\n        BL       fibonacci__Fi\n        MOV      r5,r0\n        SUB      r0,r4,#2\n        BL       fibonacci__Fi\n        ADD      r0,r5,r0\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_string__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       strlen\n        ADD      r0,r4,r0\n        SUB      r0,r0,#1\n        CMP      r4,r0\n        LDMCSFD  sp!,{r4,lr}\n        BXCS     lr\n|L1.44|\n        LDRB     r2,[r0,#0]\n        LDRB     r1,[r4,#0]\n        STRB     r2,[r4],#1\n        STRB     r1,[r0],#-1\n        CMP      r4,r0\n        BCC      |L1.44|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverse_string(char *str) {\n    if (str == 0) return;\n    int n = strlen(str);\n    char *start = str;\n    char *end = str + n -1;\n    char temp;\n    while (start < end) {\n        temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateCustomException__FiPc PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        CMP      r0,#0\n        STMNEIA  r0,{r4,r5}\n        LDMFD    sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nfreeCustomException__FP15CustomException PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int code;\n    char* msg;\n} CustomException;\n\nCustomException* createCustomException(int code, char* msg) {\n    CustomException* e = (CustomException*)malloc(sizeof(CustomException));\n    if (e == NULL) {\n        return NULL; \n    }\n    e->code = code;\n    e->msg = msg;\n    return e;\n}\n\nvoid freeCustomException(CustomException* e) {\n    if (e != NULL) {\n        free(e->msg);\n        free(e);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitialize_graph__FP5Graphi PROC\n        MOV      r3,#0\n        STR      r1,[r0,#0]\n        CMP      r1,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        MOV      lr,#0\n|L1.24|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.68|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r12,r0,r12,LSL #4\n|L1.48|\n        ADD      r4,r12,r2,LSL #2\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        STR      lr,[r4,#4]\n        BLT      |L1.48|\n|L1.68|\n        ADD      r2,r0,r3,LSL #2\n        ADD      r2,r2,#0x9000\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        STR      lr,[r2,#0xc44]\n        BLT      |L1.24|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP5GraphiT2 PROC\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        ADD      r1,r0,r1,LSL #4\n        ADD      r1,r1,r2,LSL #2\n        ADD      r0,r0,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r1,#4]\n        ADD      r0,r0,#0x9000\n        LDR      r1,[r0,#0xc44]\n        ADD      r1,r1,r3\n        STR      r1,[r0,#0xc44]\n        BX       lr\n        ENDP\n\ntopological_sort__FP5GraphPi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        MOV      r0,r0,LSL #2\n        BL       malloc\n        LDR      r12,[r4,#0]\n        MOV      r3,#0\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r12,#0\n        BLE      |L1.240|\n|L1.196|\n        ADD      r12,r4,r1,LSL #2\n        ADD      r12,r12,#0x9000\n        LDR      r12,[r12,#0xc44]\n        CMP      r12,#0\n        MOVEQ    r12,r2\n        STREQ    r1,[r0,r12,LSL #2]\n        LDR      r12,[r4,#0]\n        ADD      r1,r1,#1\n        ADDEQ    r2,r2,#1\n        CMP      r12,r1\n        BGT      |L1.196|\n|L1.240|\n        MOV      lr,#0\n        CMP      r3,r2\n        BGE      |L1.380|\n|L1.252|\n        MOV      r1,r3\n        LDR      r12,[r0,r1,LSL #2]\n        MOV      r1,lr\n        STR      r12,[r5,r1,LSL #2]\n        LDR      r6,[r4,#0]\n        MOV      r1,#0\n        ADD      lr,lr,#1\n        ADD      r3,r3,#1\n        CMP      r6,#0\n        BLE      |L1.372|\n        MOV      r6,r12\n        ADD      r12,r6,r6,LSL #3\n        ADD      r12,r12,r6,LSL #4\n        ADD      r7,r4,r12,LSL #4\n|L1.308|\n        ADD      r12,r7,r1,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,#0\n        BEQ      |L1.356|\n        ADD      r12,r4,r1,LSL #2\n        ADD      r6,r12,#0x9000\n        LDR      r12,[r6,#0xc44]\n        SUBS     r12,r12,#1\n        STR      r12,[r6,#0xc44]\n        MOVEQ    r12,r2\n        STREQ    r1,[r0,r12,LSL #2]\n        ADDEQ    r2,r2,#1\n|L1.356|\n        LDR      r12,[r4,#0]\n        ADD      r1,r1,#1\n        CMP      r12,r1\n        BGT      |L1.308|\n|L1.372|\n        CMP      r3,r2\n        BLT      |L1.252|\n|L1.380|\n        LDMFD    sp!,{r3-r7,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj_matrix[MAX_VERTICES][MAX_VERTICES];\n    int in_degree[MAX_VERTICES];\n} Graph;\n\nvoid initialize_graph(Graph* graph, int vertices) {\n    graph->vertices = vertices;\n    for (int i = 0; i < vertices; i++) {\n        for (int j = 0; j < vertices; j++) {\n            graph->adj_matrix[i][j] = 0;\n        }\n        graph->in_degree[i] = 0;\n    }\n}\n\nvoid add_edge(Graph* graph, int u, int v) {\n    graph->adj_matrix[u][v] = 1;\n    graph->in_degree[v]++;\n}\n\nvoid topological_sort(Graph* graph, int* sorted_order) {\n    int* queue = (int*)malloc(graph->vertices * sizeof(int));\n    int head = 0;\n    int tail = 0;\n    for (int i = 0; i < graph->vertices; i++) {\n        if (graph->in_degree[i] == 0) {\n            queue[tail++] = i;\n        }\n    }\n    int count = 0;\n    while (head < tail) {\n        int u = queue[head++];\n        sorted_order[count++] = u;\n        for (int v = 0; v < graph->vertices; v++) {\n            if (graph->adj_matrix[u][v]) {\n                graph->in_degree[v]--;\n                if (graph->in_degree[v] == 0) {\n                    queue[tail++] = v;\n                }\n            }\n        }\n    }\n    free(queue);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        LDR      r1,|L1.268|\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\nquadratic_probing__FP5EntryiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r8,r2\n        MOV      r6,r1\n        BL       hash__Fi\n        LDR      r1,[r5,r0,LSL #3]\n        MOV      r4,#1\n        CMP      r1,#0\n        BEQ      |L1.144|\n        LDR      r7,|L1.268|\n|L1.76|\n        MOV      r0,r6\n        BL       hash__Fi\n        MLA      r0,r4,r4,r0\n        SMULL    r2,r1,r7,r0\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        LDMGTFD  sp!,{r4-r8,lr}\n        MVNGT    r0,#0\n        BXGT     lr\n        LDR      r1,[r5,r0,LSL #3]\n        CMP      r1,#0\n        BNE      |L1.76|\n|L1.144|\n        STR      r6,[r5,r0,LSL #3]\n        ADD      r1,r5,r0,LSL #3\n        STR      r8,[r1,#4]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct {\n    int key;\n    int value;\n} Entry;\n\nint hash(int key) {\n    return key % TABLE_SIZE;\n}\n\nint quadratic_probing(Entry *table, int key, int value) {\n    int index = hash(key);\n    int i = 1;\n    while (table[index].key != 0) {\n        index = (hash(key) + i * i) % TABLE_SIZE;\n        i++;\n        if (i > TABLE_SIZE) {\n            return -1; \n        }\n    }\n    table[index].key = key;\n    table[index].value = value;\n    return index;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npreorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.48|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       preorder__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        preorder__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n\ninorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       inorder__FP4Node\n        ADR      r0,|L1.48|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        inorder__FP4Node\n        ENDP\n\npostorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       postorder__FP4Node\n        LDR      r0,[r4,#8]\n        BL       postorder__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.48|\n        B        _printf\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid preorder(Node* node) {\n    if (node != NULL) {\n        printf(\"%d \", node->data);\n        preorder(node->left);\n        preorder(node->right);\n    }\n}\n\nvoid inorder(Node* node) {\n    if (node != NULL) {\n        inorder(node->left);\n        printf(\"%d \", node->data);\n        inorder(node->right);\n    }\n}\n\nvoid postorder(Node* node) {\n    if (node != NULL) {\n        postorder(node->left);\n        postorder(node->right);\n        printf(\"%d \", node->data);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_leap__Fi PROC\n        TST      r0,#3\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,|L1.132|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        MOVNE    r0,#1\n        BXNE     lr\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_leap(int year) {\n    if (year % 4 != 0) return 0;\n    if (year % 100 == 0) {\n        if (year % 400 == 0) return 1;\n        return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ncreateHeap__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        STR      r5,[r0,#4]!\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nswapNodes__FPP4NodeT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nheapifyUp__FP4Heapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        SUB      r0,r1,#1\n        ADD      r0,r0,r0,LSR #31\n        MOVS     r4,r0,ASR #1\n        LDMMIFD  sp!,{r4,r5,lr}\n        BXMI     lr\n        LDR      r0,[r5,#0]\n        LDR      r2,[r0,r4,LSL #2]\n        LDR      r3,[r0,r1,LSL #2]\n        LDR      r2,[r2,#0]\n        LDR      r3,[r3,#0]\n        CMP      r2,r3\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        ADD      r1,r0,r1,LSL #2\n        ADD      r0,r0,r4,LSL #2\n        BL       swapNodes__FPP4NodeT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyUp__FP4Heapi\n        ENDP\n\ninsert__FP4Heapi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r2,[r4,#8]\n        LDR      r3,[r4,#4]\n        MOV      r0,r1\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        BL       newNode__Fi\n        LDR      r1,[r4,#0]\n        LDR      r2,[r4,#8]\n        STR      r0,[r1,r2,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        SUB      r1,r0,#1\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        heapifyUp__FP4Heapi\n        ENDP\n\nheapifyDown__FP4Heapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#8]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.348|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        LDR      lr,[lr,#0]\n        LDR      r12,[r12,#0]\n        CMP      lr,r12\n        MOVLT    r4,r0\n|L1.348|\n        CMP      r3,r2\n        BLE      |L1.384|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        LDR      r3,[r3,#0]\n        LDR      r0,[r0,#0]\n        CMP      r3,r0\n        MOVLT    r4,r2\n|L1.384|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r1,r0,r1,LSL #2\n        ADD      r0,r0,r4,LSL #2\n        BL       swapNodes__FPP4NodeT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP4Heapi\n        ENDP\n\nextractMin__FP4Heap PROC\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        LDR      r3,[r1,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r3,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#8]\n        MOV      r1,#0\n        BL       heapifyDown__FP4Heapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n} Node;\n\ntypedef struct Heap {\n    Node **arr;\n    int capacity;\n    int size;\n} Heap;\n\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nHeap* createHeap(int capacity) {\n    Heap* heap = (Heap*)malloc(sizeof(Heap));\n    heap->capacity = capacity;\n    heap->size = 0;\n    heap->arr = (Node**)malloc(heap->capacity * sizeof(Node*));\n    return heap;\n}\n\nvoid swapNodes(Node** a, Node** b) {\n    Node* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapifyUp(Heap* heap, int index) {\n    int parent = (index - 1) / 2;\n    if (parent >= 0 && heap->arr[parent]->data > heap->arr[index]->data) {\n        swapNodes(&heap->arr[parent], &heap->arr[index]);\n        heapifyUp(heap, parent);\n    }\n}\n\nvoid insert(Heap* heap, int data) {\n    if (heap->size == heap->capacity) return;\n    heap->arr[heap->size] = newNode(data);\n    heap->size++;\n    heapifyUp(heap, heap->size - 1);\n}\n\nvoid heapifyDown(Heap* heap, int index) {\n    int smallest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < heap->size && heap->arr[left]->data < heap->arr[smallest]->data)\n        smallest = left;\n\n    if (right < heap->size && heap->arr[right]->data < heap->arr[smallest]->data)\n        smallest = right;\n\n    if (smallest != index) {\n        swapNodes(&heap->arr[smallest], &heap->arr[index]);\n        heapifyDown(heap, smallest);\n    }\n}\n\nint extractMin(Heap* heap) {\n    if (heap->size == 0) return -1; \n    int rootData = heap->arr[0]->data;\n    heap->arr[0] = heap->arr[heap->size - 1];\n    heap->size--;\n    heapifyDown(heap, 0);\n    return rootData;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmerge__FPvUiT2PFPCvT1_iN21N22 PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#0xc\n        ADD      r11,sp,#0x40\n        LDMIA    r11,{r1,r11}\n        ADD      r10,sp,#0x48\n        LDMIA    r10,{r9,r10}\n        STR      r1,[sp,#0]\n        MOV      r8,r0\n        MOV      r7,#0\n        MOV      r6,#0\n        MOV      r5,#0\n        MOV      r4,r2\n        B        |L1.132|\n|L1.52|\n        LDR      r0,[sp,#0]\n        MLA      r1,r4,r7,r11\n        LDR      r2,[sp,#0x18]\n        MLA      r0,r4,r6,r0\n        STR      r0,[sp,#4]\n        STR      r1,[sp,#8]\n        MOV      lr,pc\n        BX       r2\n        CMP      r0,#0\n        MLA      r0,r4,r5,r8\n        MOV      r2,r4\n        BGT      |L1.116|\n        LDR      r1,[sp,#4]\n        BL       __rt_memcpy\n        ADD      r6,r6,#1\n        B        |L1.128|\n|L1.116|\n        LDR      r1,[sp,#8]\n        BL       __rt_memcpy\n        ADD      r7,r7,#1\n|L1.128|\n        ADD      r5,r5,#1\n|L1.132|\n        CMP      r6,r9\n        CMPCC    r7,r10\n        BCC      |L1.52|\n        CMP      r6,r9\n        BCS      |L1.188|\n|L1.152|\n        LDR      r0,[sp,#0]\n        MOV      r2,r4\n        MLA      r1,r4,r6,r0\n        MLA      r0,r4,r5,r8\n        BL       __rt_memcpy\n        ADD      r6,r6,#1\n        CMP      r6,r9\n        ADD      r5,r5,#1\n        BCC      |L1.152|\n|L1.188|\n        CMP      r7,r10\n        ADDCS    sp,sp,#0x1c\n        LDMCSFD  sp!,{r4-r11,lr}\n        BXCS     lr\n|L1.204|\n        MLA      r1,r4,r7,r11\n        MLA      r0,r4,r5,r8\n        MOV      r2,r4\n        BL       __rt_memcpy\n        ADD      r7,r7,#1\n        CMP      r7,r10\n        ADD      r5,r5,#1\n        BCC      |L1.204|\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n\nmerge_sort_recursive__FPvUiT2PFPCvT1_i PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x1c\n        CMP      r1,#1\n        ADDLS    sp,sp,#0x1c\n        MOV      r10,r3\n        MOV      r7,r0\n        MOV      r6,r1\n        MOV      r4,r2\n        LDMLSFD  sp!,{r4-r11,lr}\n        BXLS     lr\n        MOV      r5,r6,LSR #1\n        MOV      r1,r5\n        MOV      r3,r10\n        MOV      r2,r4\n        MOV      r0,r7\n        BL       merge_sort_recursive__FPvUiT2PFPCvT1_i\n        SUB      r0,r6,r5\n        MOV      r1,r0\n        STR      r0,[sp,#0x18]\n        MLA      r0,r4,r5,r7\n        STR      r0,[sp,#0x14]\n        MOV      r3,r10\n        MOV      r2,r4\n        BL       merge_sort_recursive__FPvUiT2PFPCvT1_i\n        MUL      r0,r4,r5\n        STR      r0,[sp,#0x10]\n        BL       malloc\n        MOV      r8,r0\n        LDR      r0,[sp,#0x18]\n        MUL      r11,r4,r0\n        MOV      r0,r11\n        BL       malloc\n        MOV      r9,r0\n        MOV      r0,r8\n        MOV      r1,r7\n        LDR      r2,[sp,#0x10]\n        BL       __rt_memcpy\n        MOV      r2,r11\n        MOV      r0,r9\n        LDR      r1,[sp,#0x14]\n        BL       __rt_memcpy\n        LDR      r3,[sp,#0x18]\n        STR      r5,[sp,#8]\n        STR      r3,[sp,#0xc]\n        STMIA    sp,{r8,r9}\n        MOV      r3,r10\n        MOV      r2,r4\n        MOV      r1,r6\n        MOV      r0,r7\n        BL       merge__FPvUiT2PFPCvT1_iN21N22\n        MOV      r0,r8\n        BL       free\n        MOV      r0,r9\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        B        free\n        ENDP\n\nmerge_sort__FPvUiT2PFPCvT1_i PROC\n        B        merge_sort_recursive__FPvUiT2PFPCvT1_i\n        ENDP\n\nint_compar__FPCvT1 PROC\n        LDR      r0,[r0,#0]\n        LDR      r1,[r1,#0]\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid merge(void *base, size_t nel, size_t width, int (*compar)(const void *, const void *), void *left, void *right, size_t len_left, size_t len_right) {\n    char *left_ptr = (char *)left;\n    char *right_ptr = (char *)right;\n    char *merged_ptr = (char *)base;\n    size_t left_idx = 0;\n    size_t right_idx = 0;\n    size_t merged_idx = 0;\n    while (left_idx < len_left && right_idx < len_right) {\n        if (compar(left_ptr + left_idx * width, right_ptr + right_idx * width) <= 0) {\n            memcpy(merged_ptr + merged_idx * width, left_ptr + left_idx * width, width);\n            left_idx++;\n        } else {\n            memcpy(merged_ptr + merged_idx * width, right_ptr + right_idx * width, width);\n            right_idx++;\n        }\n        merged_idx++;\n    }\n    while (left_idx < len_left) {\n        memcpy(merged_ptr + merged_idx * width, left_ptr + left_idx * width, width);\n        left_idx++;\n        merged_idx++;\n    }\n    while (right_idx < len_right) {\n        memcpy(merged_ptr + merged_idx * width, right_ptr + right_idx * width, width);\n        right_idx++;\n        merged_idx++;\n    }\n}\n\nvoid merge_sort_recursive(void *base, size_t nel, size_t width, int (*compar)(const void *, const void *)) {\n    if (nel <= 1) return;\n    size_t mid = nel / 2;\n    merge_sort_recursive(base, mid, width, compar);\n    merge_sort_recursive((char *)base + mid * width, nel - mid, width, compar);\n    void *left = malloc(mid * width);\n    void *right = malloc((nel - mid) * width);\n    memcpy(left, base, mid * width);\n    memcpy(right, (char *)base + mid * width, (nel - mid) * width);\n    merge(base, nel, width, compar, left, right, mid, nel - mid);\n    free(left);\n    free(right);\n}\n\nvoid merge_sort(void *base, size_t nel, size_t width, int (*compar)(const void *, const void *)) {\n    merge_sort_recursive(base, nel, width, compar);\n}\n\n\nint int_compar(const void *a, const void *b) {\n    return *(int *)a - *(int *)b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\niterativeInorder__FP8TreeNodePiT2 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        MVN      r3,#0\n|L1.24|\n        CMP      r0,#0\n        BEQ      |L1.52|\n|L1.32|\n        ADD      r3,r3,#1\n        STR      r0,[r6,r3,LSL #2]\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BNE      |L1.32|\n|L1.52|\n        MOV      r0,r3\n        LDR      r0,[r6,r0,LSL #2]\n        LDR      lr,[r2,#0]\n        LDR      r4,[r0,#0]\n        ADD      r5,lr,#1\n        STR      r5,[r2,#0]\n        STR      r4,[r1,lr,LSL #2]\n        LDR      r0,[r0,#8]\n        SUB      r3,r3,#1\n        CMP      r0,#0\n        CMNEQ    r3,#1\n        BNE      |L1.24|\n        ADD      sp,sp,#0xfa0\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n\nvoid iterativeInorder(TreeNode* root, int* result, int* index) {\n    if (root == NULL) return;\n    TreeNode* stack[1000];\n    int top = -1;\n    TreeNode* curr = root;\n    while (curr != NULL || top != -1) {\n        while (curr != NULL) {\n            top++;\n            stack[top] = curr;\n            curr = curr->left;\n        }\n        curr = stack[top--];\n        result[(*index)++] = curr->val;\n        curr = curr->right;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninorderIterative__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0xfa0\n        MOV      r6,sp\n        MVN      r4,#0\n|L1.64|\n        CMP      r0,#0\n        BEQ      |L1.92|\n|L1.72|\n        ADD      r4,r4,#1\n        STR      r0,[r6,r4,LSL #2]\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BNE      |L1.72|\n|L1.92|\n        CMN      r4,#1\n        ADDEQ    sp,sp,#0xfa0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r5,[r6,r4,LSL #2]\n        SUB      r4,r4,#1\n        LDR      r1,[r5,#0]\n        ADR      r0,|L1.136|\n        BL       _printf\n        LDR      r0,[r5,#8]\n        B        |L1.64|\n|L1.136|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nvoid inorderIterative(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* stack[1000];\n    int top = -1;\n    struct Node* current = root;\n\n    while (1) {\n        while (current != NULL) {\n            top++;\n            stack[top] = current;\n            current = current->left;\n        }\n        if (top == -1) break;\n\n        current = stack[top];\n        top--;\n        printf(\"%d \", current->data);\n        current = current->right;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmaxSubArraySum__FPii PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        LDR      r12,[r0,#0]\n        MOV      r2,#0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.60|\n|L1.24|\n        LDR      lr,[r0,r3,LSL #2]\n        ADD      r3,r3,#1\n        ADD      r2,lr,r2\n        CMP      r12,r2\n        MOVLT    r12,r2\n        CMP      r2,#0\n        MOVLT    r2,#0\n        CMP      r3,r1\n        BLT      |L1.24|\n|L1.60|\n        LDR      lr,[sp],#4\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint maxSubArraySum(int arr[], int n) {\n    int max_so_far = arr[0];\n    int max_ending_here = 0;\n\n    for (int i = 0; i < n; i++) {\n        max_ending_here = max_ending_here + arr[i];\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n        if (max_ending_here < 0)\n            max_ending_here = 0;\n    }\n    return max_so_far;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerateRandomNumber__FiT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        CMP      r0,r1\n        LDMGTFD  sp!,{r3-r5,lr}\n        MVNGT    r0,#0\n        BXGT     lr\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        SUB      r0,r5,r4\n        ADD      r5,r0,#1\n        BL       rand\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       __rt_sdiv\n        ADD      r0,r1,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint generateRandomNumber(int min, int max) {\n    if (min > max) {\n        return -1; // Indicate an error\n    }\n    srand(time(0));\n    int range = max - min + 1;\n    return min + rand() % range;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        ADR      r1,|L1.92|\n        LDMIA    r1,{r0,r1}\n        CMP      r5,#0\n        ADRLT    r1,|L1.100|\n        LDMLTIA  r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n        MOV      r4,#1\n        CMP      r5,#1\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n|L1.52|\n        UMULL    lr,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r3,r4,ASR #31\n        MLA      r1,r3,r0,r12\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r0,lr\n        BLE      |L1.52|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.92|\n        DCQ      0x0000000000000001\n|L1.100|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nlong long factorial(int n) {\n    long long result = 1;\n    if (n < 0) return 0; //Error handling for negative input.\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_bitset__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        ADD      r0,r0,#0x1f\n        MOV      r1,r0,ASR #31\n        ADD      r0,r0,r1,LSR #27\n        MOV      r6,r0,ASR #5\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,#4\n        MOV      r0,r6\n        BL       calloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        STRNE    r5,[r4,#4]\n        MOVNE    r0,r4\n        LDMNEFD  sp!,{r4-r6,lr}\n        BXNE     lr\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nset_bit__FP6bitseti PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r2,[r0,#4]\n        CMPGE    r2,r1\n        BXLE     lr\n        MOV      r2,r1,ASR #31\n        ADD      r2,r1,r2,LSR #27\n        MOV      r2,r2,ASR #5\n        LDR      r0,[r0,#0]\n        SUB      r1,r1,r2,LSL #5\n        ADD      r0,r0,r2,LSL #2\n        LDR      r2,[r0,#0]\n        MOV      r3,#1\n        ORR      r1,r2,r3,LSL r1\n        STR      r1,[r0,#0]\n        BX       lr\n        ENDP\n\nget_bit__FP6bitseti PROC\n        CMP      r0,#0\n        BEQ      |L1.192|\n        CMP      r1,#0\n        LDRGE    r2,[r0,#4]\n        CMPGE    r2,r1\n        BGT      |L1.200|\n|L1.192|\n        MOV      r0,#0\n        BX       lr\n|L1.200|\n        MOV      r2,r1,ASR #31\n        ADD      r2,r1,r2,LSR #27\n        LDR      r0,[r0,#0]\n        MOV      r2,r2,ASR #5\n        LDR      r0,[r0,r2,LSL #2]\n        SUB      r1,r1,r2,LSL #5\n        MOV      r0,r0,ASR r1\n        AND      r0,r0,#1\n        BX       lr\n        ENDP\n\ndestroy_bitset__FP6bitset PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define BITSET_SIZE 1024\n#define INT_SIZE 4\n\n\ntypedef struct {\n    int *bits;\n    int size;\n} bitset;\n\n\nbitset* create_bitset(int size) {\n    int num_ints = (size + (INT_SIZE * 8) - 1) / (INT_SIZE * 8);\n    bitset *bs = (bitset*)malloc(sizeof(bitset));\n    if (bs == NULL) return NULL;\n    bs->bits = (int*)calloc(num_ints, sizeof(int));\n    if (bs->bits == NULL) {\n        free(bs);\n        return NULL;\n    }\n    bs->size = size;\n    return bs;\n}\n\n\nvoid set_bit(bitset *bs, int index) {\n    if (bs == NULL || index < 0 || index >= bs->size) return;\n    int int_index = index / (INT_SIZE * 8);\n    int bit_index = index % (INT_SIZE * 8);\n    bs->bits[int_index] |= (1 << bit_index);\n}\n\n\nint get_bit(bitset *bs, int index) {\n    if (bs == NULL || index < 0 || index >= bs->size) return 0;\n    int int_index = index / (INT_SIZE * 8);\n    int bit_index = index % (INT_SIZE * 8);\n    return (bs->bits[int_index] >> bit_index) & 1;\n}\n\n\nvoid destroy_bitset(bitset *bs) {\n    if (bs != NULL) {\n        free(bs->bits);\n        free(bs);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPerfectRecursive__FP4nodeiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        ADD      r5,r2,#1\n        CMP      r0,#0\n        LDREQ    r1,[r4,#4]\n        CMPEQ    r1,#0\n        BNE      |L1.68|\n        CMP      r5,r6\n        LDMFD    sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n|L1.68|\n        CMP      r0,#0\n        LDRNE    r1,[r4,#4]\n        CMPNE    r1,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r2,r5\n        MOV      r1,r6\n        BL       isPerfectRecursive__FP4nodeiT2\n        CMP      r0,#0\n        BEQ      |L1.144|\n        MOV      r2,r5\n        MOV      r1,r6\n        LDR      r0,[r4,#4]\n        BL       isPerfectRecursive__FP4nodeiT2\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.144|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\ndepth__FP4node PROC\n        MOV      r1,#0\n        CMP      r0,#0\n        BEQ      |L1.184|\n|L1.168|\n        LDR      r0,[r0,#0]\n        ADD      r1,r1,#1\n        CMP      r0,#0\n        BNE      |L1.168|\n|L1.184|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n\nisPerfectIterative__FP4node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r3,r0\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r0,r3\n        BL       depth__FP4node\n        MOV      r1,r0\n        MOV      r0,r3\n        MOV      r2,#0\n        LDR      lr,[sp],#4\n        B        isPerfectRecursive__FP4nodeiT2\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    struct node *left;\n    struct node *right;\n};\n\nint isPerfectRecursive(struct node *root, int d, int level) {\n    if (root == NULL)\n        return 1;\n    if (root->left == NULL && root->right == NULL)\n        return (d == level + 1);\n    if (root->left == NULL || root->right == NULL)\n        return 0;\n    return isPerfectRecursive(root->left, d, level + 1) &&\n           isPerfectRecursive(root->right, d, level + 1);\n}\n\nint depth(struct node *root) {\n    int d = 0;\n    while (root != NULL) {\n        d++;\n        root = root->left;\n    }\n    return d;\n}\n\nint isPerfectIterative(struct node *root) {\n    if (root == NULL) return 1;\n    int d = depth(root);\n    return isPerfectRecursive(root, d, 0);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbstToAVL__FP4Node PROC\n        CMP      r0,#0\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    Node *left, *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return (node);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return(newNode(key));\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nNode* bstToAVL(Node* root) {\n  if(root == NULL) return NULL;\n  Node* newRoot = NULL;\n  //Inorder traversal to insert into a new AVL tree\n  return newRoot;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nleastSignificantBit__FUi PROC\n        RSB      r1,r0,#0\n        AND      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int leastSignificantBit(unsigned int n) {\n    return n & -n;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPerfectRec__FP4nodeiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        ADD      r5,r2,#1\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        BNE      |L1.68|\n        CMP      r5,r6\n        LDMFD    sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n|L1.68|\n        CMP      r0,#0\n        LDRNE    r1,[r4,#8]\n        CMPNE    r1,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r2,r5\n        MOV      r1,r6\n        BL       isPerfectRec__FP4nodeiT2\n        CMP      r0,#0\n        BEQ      |L1.144|\n        MOV      r2,r5\n        MOV      r1,r6\n        LDR      r0,[r4,#8]\n        BL       isPerfectRec__FP4nodeiT2\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.144|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nisPerfect__FP4node PROC\n        MOV      r1,#0\n        MOVS     r2,r0\n        BEQ      |L1.184|\n|L1.168|\n        LDR      r2,[r2,#4]\n        ADD      r1,r1,#1\n        CMP      r2,#0\n        BNE      |L1.168|\n|L1.184|\n        MOV      r2,#0\n        B        isPerfectRec__FP4nodeiT2\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nint isPerfectRec(struct node* root, int d, int level) {\n    if (root == NULL)\n        return 1;\n    if (root->left == NULL && root->right == NULL)\n        return (d == level + 1);\n    if (root->left == NULL || root->right == NULL)\n        return 0;\n    return isPerfectRec(root->left, d, level + 1) &&\n           isPerfectRec(root->right, d, level + 1);\n}\n\nint isPerfect(struct node* root) {\n    int d = 0;\n    struct node* temp = root;\n    while (temp != NULL) {\n        d++;\n        temp = temp->left;\n    }\n    return isPerfectRec(root, d, 0);\n}\n\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbalanceTree__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        MOV      r0,#0\n        BL       insert__FP4Nodei\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BEQ      |L1.656|\n        BL       balanceTree__FP4Node\n        STR      r0,[r4,#4]\n|L1.656|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BEQ      |L1.676|\n        BL       balanceTree__FP4Node\n        STR      r0,[r4,#8]\n|L1.676|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return (node);\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n\n    x->right = y;\n    y->left = T2;\n\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n\n    return x;\n}\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n\n    y->left = x;\n    x->right = T2;\n\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n\n    if (data < node->data)\n        node->left  = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left),\n                           height(node->right));\n\n    int balance = getBalance(node);\n\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n\nNode* balanceTree(Node* root){\n    if(root == NULL) return NULL;\n    root = insert(NULL,root->data);\n    if(root->left) root->left = balanceTree(root->left);\n    if(root->right) root->right = balanceTree(root->right);\n    return root;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npopulationCount__Fi PROC\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.32|\n|L1.12|\n        AND      r2,r0,#1\n        MOV      r0,r0,ASR #1\n        CMP      r0,#0\n        ADD      r1,r2,r1\n        BGT      |L1.12|\n|L1.32|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint populationCount(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += (n & 1);\n        n >>= 1;\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nmirror__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n|L1.48|\n        LDR      r1,[r0,#8]\n        LDR      r2,[r0,#4]\n        STMIB    r0,{r1,r2}\n        CMP      r1,#0\n        MOVNE    r0,r1\n        BNE      |L1.48|\n        B        |L1.80|\n|L1.76|\n        LDR      r0,[r0,#4]\n|L1.80|\n        CMP      r0,#0\n        BEQ      |L1.100|\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BEQ      |L1.76|\n|L1.100|\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.48|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nvoid mirror(struct Node* root) {\n    if (root == NULL) return;\n    \n    struct Node* temp;\n    \n    while(root != NULL) {\n        temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n\n        if(root->left != NULL) {\n            root = root->left;\n        } else {\n            while(root != NULL && root->right == NULL) {\n                root = root->left;\n            }\n            root = root->right;\n\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fv PROC\n|L1.0|\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0x6c\n        BL       malloc\n        MOV      r2,#0\n        STR      r2,[r0,#0]\n        MOV      r1,#0\n|L1.24|\n        ADD      r3,r0,r1,LSL #2\n        ADD      r1,r1,#1\n        CMP      r1,#0x1a\n        STR      r2,[r3,#4]\n        BLT      |L1.24|\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP8TrieNodePc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        LDRB     r1,[r1,#0]\n        MOV      r4,#0\n        CMP      r1,#0\n        BEQ      |L1.128|\n|L1.76|\n        LDRB     r1,[r6,r4]\n        SUB      r1,r1,#0x61\n        ADD      r5,r0,r1,LSL #2\n        LDR      r0,[r5,#4]\n        CMP      r0,#0\n        BNE      |L1.108|\n        BL       createNode__Fv\n        STR      r0,[r5,#4]\n|L1.108|\n        ADD      r4,r4,#1\n        LDR      r0,[r5,#4]\n        LDRB     r1,[r6,r4]\n        CMP      r1,#0\n        BNE      |L1.76|\n|L1.128|\n        MOV      r1,#1\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nsearch__FP8TrieNodePc PROC\n        LDRB     r3,[r1,#0]\n        MOV      r2,r0\n        MOV      r0,#0\n        CMP      r3,#0\n        BEQ      |L1.208|\n|L1.164|\n        LDRB     r3,[r1,r0]\n        SUB      r3,r3,#0x61\n        ADD      r2,r2,r3,LSL #2\n        LDR      r2,[r2,#4]\n        CMP      r2,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        LDRB     r3,[r1,r0]\n        CMP      r3,#0\n        BNE      |L1.164|\n|L1.208|\n        LDR      r0,[r2,#0]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_CHAR 26\n\ntypedef struct TrieNode {\n    int isEndOfWord;\n    struct TrieNode* children[MAX_CHAR];\n} TrieNode;\n\nTrieNode* createNode() {\n    TrieNode* node = (TrieNode*)malloc(sizeof(TrieNode));\n    node->isEndOfWord = 0;\n    for (int i = 0; i < MAX_CHAR; i++)\n        node->children[i] = NULL;\n    return node;\n}\n\n\nvoid insert(TrieNode* root, char* key) {\n    TrieNode* curr = root;\n    for (int i = 0; key[i]; i++) {\n        int index = key[i] - 'a';\n        if (!curr->children[index])\n            curr->children[index] = createNode();\n        curr = curr->children[index];\n    }\n    curr->isEndOfWord = 1;\n}\n\n\nint search(TrieNode* root, char* key) {\n    TrieNode* curr = root;\n    for (int i = 0; key[i]; i++) {\n        int index = key[i] - 'a';\n        if (!curr->children[index])\n            return 0;\n        curr = curr->children[index];\n    }\n    return curr->isEndOfWord;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       inorder__FP4Node\n        ADR      r0,|L1.48|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        inorder__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int val) : data(val), left(NULL), right(NULL) {}\n};\n\n\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndecimalToBinaryRecursive__FiT1 PROC\n|L1.0|\n        CMP      r0,#0\n        MOVEQ    r0,r1\n        BXEQ     lr\n        MOV      r2,r0\n        ADD      r0,r0,r0,LSR #31\n        MOV      r0,r0,ASR #1\n        SUB      r2,r2,r0,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r2,r1,LSL #1\n        B        |L1.0|\n        ENDP\n\ndecimalToBinary__Fi PROC\n        CMP      r0,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOVGE    r1,#0\n        BGE      decimalToBinaryRecursive__FiT1\n        MVNLT    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint decimalToBinaryRecursive(int n, int accumulator) {\n    if (n == 0) return accumulator;\n    return decimalToBinaryRecursive(n / 2, accumulator * 10 + n % 2);\n}\n\nint decimalToBinary(int n) {\n    if (n == 0) return 0;\n    if (n < 0) return -1; // Handle negative input (optional)\n\n    return decimalToBinaryRecursive(n, 0);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfind_blank__FPCi PROC\n|L1.0|\n        MOV      r1,r0\n        MOV      r0,#0\n|L1.8|\n        LDR      r2,[r1,r0,LSL #2]\n        CMP      r2,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,#9\n        BLT      |L1.8|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\ncompare_states__FPCiT1 PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r2,#0x24\n        BL       memcmp\n        RSBS     r0,r0,#1\n        LDMFD    sp!,{r3,lr}\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nsolve_8_puzzle__FPiT1 PROC\n        STMFD    sp!,{r0,r1,r4-r11,lr}\n        MOV      r4,r0\n        MOV      r0,#0xbe0\n        ADD      r0,r0,#0xa000\n        SUB      sp,sp,#0x7c\n        BL       malloc\n        MVN      r1,#0\n        STR      r1,[r0,#0x24]\n        MOV      r1,#0\n        STR      r1,[r0,#0x28]\n        LDMIA    r4,{r1-r3,r5,r8,r10-r12,lr}\n        STMIA    r0,{r1-r3,r5,r8,r10-r12,lr}\n        MOV      r10,sp\n        MOV      r7,r0\n        MOV      r6,#0\n        MOV      r9,#1\n|L1.132|\n        MOV      r0,r6\n        ADD      r12,r0,r0,LSL #1\n        ADD      r0,r12,r0,LSL #3\n        ADD      r0,r7,r0,LSL #2\n        LDMIA    r0!,{r1-r3,r5,r8,r11,r12,lr}\n        ADD      r4,sp,#0x4c\n        STMIA    r4!,{r1-r3,r5,r8,r11,r12,lr}\n        LDMIA    r0,{r1-r3}\n        STMIA    r4,{r1-r3}\n        SUB      r4,r4,#0x20\n        MOV      r0,r4\n        LDR      r1,[sp,#0x80]\n        ADD      r6,r6,#1\n        BL       compare_states__FPCiT1\n        CMP      r0,#0\n        LDRNE    r0,[sp,#0x74]\n        ADDNE    sp,sp,#0x84\n        LDMNEFD  sp!,{r4-r11,lr}\n        BXNE     lr\n        MOV      r0,r4\n        BL       find_blank__FPCi\n        LDR      r1,|L1.612|\n        MOV      r8,r0\n        ADD      r0,sp,#0x3c\n        LDMIA    r1,{r2,r3,r5,r11}\n        STMIA    r0,{r2,r3,r5,r11}\n        LDR      r1,|L1.616|\n        ADD      lr,sp,#0x2c\n        LDMIA    r1,{r2,r3,r5,r11}\n        STMIA    lr,{r2,r3,r5,r11}\n        SUB      r1,r6,#1\n        STR      r1,[sp,#0x78]\n        MOV      r5,#0\n|L1.264|\n        ADD      r0,sp,#0x3c\n        LDR      r0,[r0,r5,LSL #2]\n        ADD      r1,sp,#0x2c\n        LDR      r1,[r1,r5,LSL #2]\n        ADD      r0,r0,r0,LSL #1\n        ADD      r0,r0,r8\n        ADD      r0,r0,r1\n        CMP      r0,#9\n        BCS      |L1.464|\n        ADD      lr,sp,#0x4c\n        LDMIA    lr!,{r1-r4,r11,r12}\n        STMIA    r10!,{r1-r4,r11,r12}\n        LDMIA    lr,{r1-r4,r11}\n        STMIA    r10,{r1-r4,r11}\n        LDR      r1,[sp,#0x28]\n        SUB      r10,r10,#0x18\n        ADD      r1,r1,#1\n        STR      r1,[sp,#0x28]\n        LDR      r1,[sp,#0x78]\n        MOV      r11,#0\n        STR      r1,[sp,#0x24]\n        LDR      r2,[r10,r0,LSL #2]\n        LDR      r1,[r10,r8,LSL #2]\n        STR      r2,[r10,r8,LSL #2]\n        STR      r1,[r10,r0,LSL #2]\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.424|\n|L1.376|\n        ADD      r0,r4,r4,LSL #1\n        ADD      r0,r0,r4,LSL #3\n        ADD      r1,r7,r0,LSL #2\n        MOV      r0,r10\n        BL       compare_states__FPCiT1\n        CMP      r0,#0\n        BNE      |L1.464|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.376|\n        CMP      r11,#0\n        BNE      |L1.464|\n|L1.424|\n        MOV      r0,r9\n        ADD      r12,r0,r0,LSL #1\n        ADD      r0,r12,r0,LSL #3\n        ADD      r0,r7,r0,LSL #2\n        LDMIA    r10!,{r1-r4,r11,r12,lr}\n        STMIA    r0!,{r1-r4,r11,r12,lr}\n        LDMIA    r10,{r1-r4}\n        STMIA    r0,{r1-r4}\n        SUB      r10,r10,#0x1c\n        ADD      r9,r9,#1\n|L1.464|\n        ADD      r5,r5,#1\n        CMP      r5,#4\n        BLT      |L1.264|\n        CMP      r6,r9\n        BLT      |L1.132|\n        MOV      r0,r7\n        BL       free\n        ADD      sp,sp,#0x84\n        LDMFD    sp!,{r4-r11,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define N 3\n\ntypedef struct {\n    int state[N * N];\n    int parent_index;\n    int moves;\n} Node;\n\n\nint find_blank(const int* state) {\n    for (int i = 0; i < N * N; ++i) {\n        if (state[i] == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\nint compare_states(const int* state1, const int* state2) {\n    return memcmp(state1, state2, sizeof(int) * N * N) == 0;\n}\n\n\nint solve_8_puzzle(int initial_state[N * N], int final_state[N * N]) {\n    Node* queue = (Node*)malloc(sizeof(Node) * 1000);\n    int head = 0;\n    int tail = 1;\n\n    queue[0].parent_index = -1;\n    queue[0].moves = 0;\n    memcpy(queue[0].state, initial_state, sizeof(int) * N * N);\n\n    while (head < tail) {\n        Node current = queue[head++];\n        \n        if (compare_states(current.state, final_state)) {\n            return current.moves;\n        }\n\n        int blank_index = find_blank(current.state);\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_blank_index = blank_index + dx[i] * N + dy[i];\n            if (new_blank_index >= 0 && new_blank_index < N * N) {\n                Node next = current;\n                next.moves++;\n                next.parent_index = head -1;\n                \n                int temp = next.state[blank_index];\n                next.state[blank_index] = next.state[new_blank_index];\n                next.state[new_blank_index] = temp;\n\n                int duplicate = 0;\n                for(int k=0; k < head; ++k){\n                    if(compare_states(next.state, queue[k].state)){\n                        duplicate = 1;\n                        break;\n                    }\n                }\n\n                if (!duplicate){\n                    queue[tail++] = next;\n                }\n            }\n        }\n    }\n    free(queue);\n    return -1;\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nallocateMemory__FiP11MemoryBlockT1 PROC\n        CMP      r0,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r1,#0\n        BEQ      |L1.88|\n        ADD      r3,r1,r2\n|L1.24|\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.60|\n        LDR      r2,[r1,#0]\n        CMP      r2,r0\n        MOVGE    r0,#1\n        STRGE    r0,[r1,#4]\n        MOVGE    r0,r1\n        BXGE     lr\n|L1.60|\n        LDR      r2,[r1,#0]\n        ADD      r1,r2,r1\n        ADD      r1,r1,#0xc\n        CMP      r3,r1\n        BCC      |L1.88|\n        CMP      r1,#0\n        BNE      |L1.24|\n|L1.88|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfreeMemory__FP11MemoryBlock PROC\n        CMP      r0,#0\n        MOVNE    r1,#0\n        STRNE    r1,[r0,#4]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int size;\n    int used;\n    char* data;\n} MemoryBlock;\n\nMemoryBlock* allocateMemory(int size, MemoryBlock* memory, int totalSize) {\n    if (size <= 0) return 0;\n\n    MemoryBlock* current = memory;\n    while (current) {\n        if (current->used == 0 && current->size >= size) {\n            current->used = 1;\n            return current;\n        }\n        current = (MemoryBlock*)((char*)current + sizeof(MemoryBlock) + current->size);\n        if ((char*)current > (char*)memory + totalSize) break;\n    }\n    return 0;\n}\n\n\nvoid freeMemory(MemoryBlock* block) {\n    if (block) block->used = 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__FPc PROC\n        LDRB     r3,[r0,#0]\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r3,#0\n        BEQ      |L1.44|\n|L1.20|\n        LDRB     r3,[r0,r1]\n        ADD      r1,r1,#1\n        ADD      r2,r3,r2\n        LDRB     r3,[r0,r1]\n        CMP      r3,#0\n        BNE      |L1.20|\n|L1.44|\n        LDR      r0,|L1.340|\n        SMULL    r3,r1,r0,r2\n        MOV      r0,r1,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r2,r0,LSL #1\n        BX       lr\n        ENDP\n\ninsert__FP5EntryPci PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       hash__FPc\n        LDR      r1,[r5,r0,LSL #3]\n        MOV      r4,r0\n        CMP      r1,#0\n        BEQ      |L1.176|\n        LDR      r1,|L1.340|\n|L1.120|\n        ADD      r2,r4,#1\n        SMULL    r12,r3,r1,r2\n        MOV      r3,r3,ASR #2\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r4,r2,r3,LSL #1\n        CMP      r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,[r5,r4,LSL #3]\n        CMP      r2,#0\n        BNE      |L1.120|\n|L1.176|\n        MOV      r0,r6\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        STR      r0,[r5,r4,LSL #3]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r1,r6\n        BL       strcpy\n        ADD      r0,r5,r4,LSL #3\n        STR      r7,[r0,#4]\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct {\n    char* key;\n    int value;\n} Entry;\n\nint hash(char* key) {\n    int sum = 0;\n    for (int i = 0; key[i] != '\\0'; i++) {\n        sum += key[i];\n    }\n    return sum % TABLE_SIZE;\n}\n\nint insert(Entry* table, char* key, int value) {\n    int index = hash(key);\n    int i = index;\n    while (table[i].key != NULL) {\n        i = (i + 1) % TABLE_SIZE;\n        if (i == index) return 0; \n    }\n    table[i].key = (char*)malloc(strlen(key) + 1);\n    if(table[i].key == NULL) return 0;\n    strcpy(table[i].key, key);\n    table[i].value = value;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#8\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsertAtHead__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STRNE    r0,[r1,#8]\n        STR      r0,[r4,#0]\n        LDR      r1,[r4,#4]\n        CMP      r1,#0\n        STREQ    r0,[r4,#4]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ninsertAtTail__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#4]\n        STR      r1,[r0,#8]\n        LDR      r1,[r4,#4]\n        CMP      r1,#0\n        STRNE    r0,[r1,#4]\n        STR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n    Node *prev;\n};\n\nstruct DoublyLinkedList {\n    Node *head;\n    Node *tail;\n};\n\n\nDoublyLinkedList* createList() {\n    DoublyLinkedList* list = (DoublyLinkedList*)malloc(sizeof(DoublyLinkedList));\n    list->head = NULL;\n    list->tail = NULL;\n    return list;\n}\n\nvoid insertAtHead(DoublyLinkedList* list, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = list->head;\n    newNode->prev = NULL;\n    if (list->head != NULL) {\n        list->head->prev = newNode;\n    }\n    list->head = newNode;\n    if (list->tail == NULL) {\n        list->tail = newNode;\n    }\n}\n\nvoid insertAtTail(DoublyLinkedList* list, int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = list->tail;\n    if (list->tail != NULL) {\n        list->tail->next = newNode;\n    }\n    list->tail = newNode;\n    if (list->head == NULL) {\n        list->head = newNode;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#8\n        MOVS     r4,r0\n        BEQ      |L1.32|\n        MOV      r0,r4\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.48|\n|L1.32|\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.48|\n        MOV      r0,r4\n        BL       strlen\n        ADD      r0,r0,r4\n        STR      r0,[sp,#4]\n        CMP      r4,r0\n        BEQ      |L1.124|\n|L1.72|\n        LDRB     r0,[r4,#0]\n        LDR      r1,[sp,#4]\n        LDRB     r2,[r1,#0]\n        CMP      r0,r2\n        ADDNE    sp,sp,#8\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r0,r1,#1\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        STR      r0,[sp,#4]\n        BNE      |L1.72|\n|L1.124|\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct StringIterator {\n    char* ptr;\n    StringIterator(char* p) : ptr(p) {}\n    char operator*() const { return *ptr; }\n    StringIterator& operator++() { ++ptr; return *this; }\n    bool operator!=(const StringIterator& other) const { return ptr != other.ptr; }\n};\n\nint isPalindrome(char* str) {\n    if (str == 0 || strlen(str) == 0) return 1;\n    StringIterator begin(str);\n    StringIterator end(str + strlen(str) -1);\n    while (begin != ++end) {\n        if (*begin != *end) return 0;\n        ++begin;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#0]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#0]\n        LDR      r2,[r0,#4]\n        LDR      r4,[r0,#0]\n        STR      r2,[r1,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Stack {\n    struct Node* top;\n};\n\nstruct Stack* createStack() {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nint isEmpty(struct Stack* stack) {\n    return stack->top == NULL;\n}\n\nvoid push(struct Stack* stack, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nint pop(struct Stack* stack) {\n    if (isEmpty(stack)) {\n        return -1; //Error handling for empty stack\n    }\n    int data = stack->top->data;\n    struct Node* temp = stack->top;\n    stack->top = stack->top->next;\n    free(temp);\n    return data;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nheight__FP4node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4node\n        CMP      r5,r0\n        ADDLE    r0,r0,#1\n        ADDGT    r0,r5,#1\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\ndiameter__FP4node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4node\n        MOV      r6,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4node\n        MOV      r7,r0\n        LDR      r0,[r4,#4]\n        BL       diameter__FP4node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       diameter__FP4node\n        ADD      r1,r6,r7\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        MOVLE    r0,r5\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        CMP      r1,r0\n        LDMFD    sp!,{r4-r7,lr}\n        MOVGT    r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint height(struct node* node) {\n    if (node == NULL)\n        return 0;\n    else {\n        int lheight = height(node->left);\n        int rheight = height(node->right);\n        return (lheight > rheight) ? (lheight + 1) : (rheight + 1);\n    }\n}\n\nint diameter(struct node *tree) {\n    if (tree == NULL)\n        return 0;\n\n    int lheight = height(tree->left);\n    int rheight = height(tree->right);\n    int ldiameter = diameter(tree->left);\n    int rdiameter = diameter(tree->right);\n\n    return  (lheight + rheight + 1) > ldiameter ? (lheight + rheight + 1) > rdiameter ? (lheight + rheight + 1) : rdiameter : ldiameter;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r1\n        LDMEQFD  sp!,{r4,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.88|\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.104|\n|L1.88|\n        BGE      |L1.104|\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.104|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        B        |L1.124|\n|L1.120|\n        MOV      r0,r1\n|L1.124|\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BNE      |L1.120|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.192|\n        LDR      r0,[r4,#4]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.308|\n|L1.192|\n        BGE      |L1.212|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.308|\n|L1.212|\n        LDR      r5,[r4,#4]\n        CMP      r5,#0\n        BNE      |L1.248|\n        LDR      r5,[r4,#8]\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.248|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.280|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.280|\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.308|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsearch__FP4Nodei PROC\n|L1.320|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#8]\n        LDRGT    r0,[r0,#4]\n        B        |L1.320|\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* insert(struct Node* node, int data) {\n    if (node == NULL) return newNode(data);\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    return node;\n}\n\nstruct Node* minValueNode(struct Node* node) {\n    struct Node* current = node;\n    while (current && current->left != NULL)\n        current = current->left;\n    return current;\n}\n\nstruct Node* deleteNode(struct Node* root, int data) {\n    if (root == NULL) return root;\n    if (data < root->data)\n        root->left = deleteNode(root->left, data);\n    else if (data > root->data)\n        root->right = deleteNode(root->right, data);\n    else {\n        if (root->left == NULL) {\n            struct Node *temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node *temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\nstruct Node* search(struct Node* root, int data) {\n    if (root == NULL || root->data == data)\n        return root;\n    if (data < root->data)\n        return search(root->left, data);\n    return search(root->right, data);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompareStrings__FPcT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r9,lr}\n        SUB      sp,sp,#0xd4\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       strlen\n        MOV      r5,r0\n        MOV      r0,r7\n        BL       strlen\n        CMP      r5,r0\n        ADDNE    sp,sp,#0xd4\n        MOV      r4,r0\n        LDMNEFD  sp!,{r4-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r8,sp,#0x6c\n        MOV      r0,r8\n        MOV      r1,#0x68\n        BL       __rt_memclr_w\n        ADD      r9,sp,#4\n        MOV      r0,r9\n        MOV      r1,#0x68\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.176|\n|L1.100|\n        LDRB     r1,[r6,r0]\n        SUB      r2,r1,#0x61\n        CMP      r2,#0x19\n        BHI      |L1.136|\n        ADD      r1,r8,r1,LSL #2\n        LDR      r2,[r1,#-0x184]!\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        B        |L1.164|\n|L1.136|\n        SUB      r2,r1,#0x41\n        CMP      r2,#0x19\n        BHI      |L1.164|\n        ADD      r1,r8,r1,LSL #2\n        LDR      r2,[r1,#-0x104]!\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n|L1.164|\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.100|\n|L1.176|\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.264|\n|L1.188|\n        LDRB     r1,[r7,r0]\n        SUB      r2,r1,#0x61\n        CMP      r2,#0x19\n        BHI      |L1.224|\n        ADD      r1,r9,r1,LSL #2\n        LDR      r2,[r1,#-0x184]!\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        B        |L1.252|\n|L1.224|\n        SUB      r2,r1,#0x41\n        CMP      r2,#0x19\n        BHI      |L1.252|\n        ADD      r1,r9,r1,LSL #2\n        LDR      r2,[r1,#-0x104]!\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n|L1.252|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.188|\n|L1.264|\n        MOV      r0,#0\n|L1.268|\n        LDR      r1,[r8,r0,LSL #2]\n        LDR      r2,[r9,r0,LSL #2]\n        CMP      r1,r2\n        ADDNE    sp,sp,#0xd4\n        LDMNEFD  sp!,{r4-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r0,r0,#1\n        CMP      r0,#0x1a\n        BLT      |L1.268|\n        ADD      sp,sp,#0xd4\n        LDMFD    sp!,{r4-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint compareStrings(char* a, char* b) {\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    if (lenA != lenB) return 0;\n    int lettersA[26] = {0};\n    int lettersB[26] = {0};\n    for (int i = 0; i < lenA; i++) {\n        if (a[i] >= 'a' && a[i] <= 'z') {\n            lettersA[a[i] - 'a']++;\n        } else if (a[i] >= 'A' && a[i] <= 'Z') {\n            lettersA[a[i] - 'A']++;\n        }\n    }\n    for (int i = 0; i < lenB; i++) {\n        if (b[i] >= 'a' && b[i] <= 'z') {\n            lettersB[b[i] - 'a']++;\n        } else if (b[i] >= 'A' && b[i] <= 'Z') {\n            lettersB[b[i] - 'A']++;\n        }\n    }\n    for (int i = 0; i < 26; i++) {\n        if (lettersA[i] != lettersB[i]) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninsertion_sort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        CMP      r1,#1\n        LDMLEFD  sp!,{r4,lr}\n        MOV      r3,#1\n        BXLE     lr\n|L1.20|\n        LDR      r12,[r0,r3,LSL #2]\n        SUB      r2,r3,#1\n        B        |L1.44|\n|L1.32|\n        ADD      r4,r0,r2,LSL #2\n        STR      lr,[r4,#4]\n        SUB      r2,r2,#1\n|L1.44|\n        CMP      r2,#0\n        LDRGE    lr,[r0,r2,LSL #2]\n        CMPGE    lr,r12\n        BGT      |L1.32|\n        ADD      r2,r0,r2,LSL #2\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        STR      r12,[r2,#4]\n        BLT      |L1.20|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid insertion_sort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BXEQ     lr\n|L1.616|\n        LDR      r0,[r0,#8]\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        BNE      |L1.616|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.684|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.808|\n|L1.684|\n        BGE      |L1.704|\n        LDR      r0,[r4,#0xc]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#0xc]\n        B        |L1.808|\n|L1.704|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        LDRNE    r1,[r4,#0xc]\n        CMPNE    r1,#0\n        BNE      |L1.776|\n        CMP      r0,#0\n        LDREQ    r0,[r4,#0xc]\n        CMP      r0,#0\n        LDMNEIA  r0,{r1-r3,r12}\n        STMNEIA  r4,{r1-r3,r12}\n        MOVEQ    r0,r4\n        MOVEQ    r4,#0\n        BL       free\n        CMP      r4,#0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        B        |L1.808|\n|L1.776|\n        MOV      r0,r1\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#0xc]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.808|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        MOV      r3,r0\n        CMP      r0,#1\n        BLE      |L1.924|\n        LDR      r0,[r4,#8]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r4,lr}\n        BGE      rightRotate__FP4Node\n        LDR      r0,[r4,#8]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        BGE      |L1.924|\n        LDR      r0,[r4,#8]\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        rightRotate__FP4Node\n|L1.924|\n        CMN      r3,#1\n        BGE      |L1.996|\n        LDR      r0,[r4,#0xc]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4,lr}\n        BLE      leftRotate__FP4Node\n        LDR      r0,[r4,#0xc]\n        BL       getBalance__FP4Node\n        CMP      r0,#0\n        BLE      |L1.996|\n        LDR      r0,[r4,#0xc]\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        leftRotate__FP4Node\n|L1.996|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsuccessor__FP4Nodei PROC\n        MOVS     r2,r0\n        MOV      r0,#0\n        BXEQ     lr\n|L1.1020|\n        LDR      r3,[r2,#0]\n        CMP      r3,r1\n        LDRLE    r2,[r2,#0xc]\n        MOVGT    r0,r2\n        LDRGT    r2,[r2,#8]\n        CMP      r2,#0\n        BNE      |L1.1020|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL)\n        return(new Node(key));\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nNode * minValueNode(Node* node) {\n    Node* current = node;\n    while (current->left != NULL)\n        current = current->left;\n    return current;\n}\n\n\nNode* deleteNode(Node* root, int key) {\n    if (root == NULL)\n        return root;\n    if ( key < root->key )\n        root->left = deleteNode(root->left, key);\n    else if( key > root->key )\n        root->right = deleteNode(root->right, key);\n    else\n    {\n        if( (root->left == NULL) || (root->right == NULL) )\n        {\n            Node *temp = root->left ? root->left : root->right;\n            if (temp == NULL)\n            {\n                temp = root;\n                root = NULL;\n            }\n            else\n                *root = *temp;\n            free(temp);\n        }\n        else\n        {\n            Node* temp = minValueNode(root->right);\n            root->key = temp->key;\n            root->right = deleteNode(root->right, temp->key);\n        }\n    }\n    if (root == NULL)\n      return root;\n    root->height = 1 + max(height(root->left), height(root->right));\n    int balance = getBalance(root);\n    if (balance > 1 && getBalance(root->left) >= 0)\n        return rightRotate(root);\n    if (balance > 1 && getBalance(root->left) < 0)\n    {\n        root->left = leftRotate(root->left);\n        return rightRotate(root);\n    }\n    if (balance < -1 && getBalance(root->right) <= 0)\n        return leftRotate(root);\n    if (balance < -1 && getBalance(root->right) > 0)\n    {\n        root->right = rightRotate(root->right);\n        return leftRotate(root);\n    }\n    return root;\n}\n\n\nNode* successor(Node* root, int key){\n    Node* current = root;\n    Node* successor = NULL;\n\n    while(current != NULL){\n        if(current->key > key){\n            successor = current;\n            current = current->left;\n        } else {\n            current = current->right;\n        }\n    }\n    return successor;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        CMP      r12,r1\n        MOV      r3,r2\n        BGE      |L1.48|\n        LDR      r4,[r0,r12,LSL #2]\n        LDR      r5,[r0,r2,LSL #2]\n        CMP      r4,r5\n        MOVGT    r2,r12\n|L1.48|\n        CMP      lr,r1\n        BGE      |L1.72|\n        LDR      r12,[r0,lr,LSL #2]\n        LDR      r4,[r0,r2,LSL #2]\n        CMP      r12,r4\n        MOVGT    r2,lr\n|L1.72|\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nbuildHeap__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r4,r0,#1\n        MOV      r5,r1\n        LDMMIFD  sp!,{r4-r6,lr}\n        BXMI     lr\n|L1.140|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       heapify__FPiiT2\n        SUBS     r4,r4,#1\n        BPL      |L1.140|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid buildHeap(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncube_surface_area__Fd PROC\n        STMFD    sp!,{r4-r6,lr}\n        ADR      r6,|L1.72|\n        LDMIA    r6,{r2,r3}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       _dcmple\n        LDMCCIA  r6,{r0,r1}\n        LDMCCFD  sp!,{r4-r6,lr}\n        BXCC     lr\n        MOV      r1,r5\n        ADR      r0,|L1.80|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r6,lr}\n        B        _dmul\n|L1.72|\n        DCFD     0x0000000000000000\n|L1.80|\n        DCFD     0x4018000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble cube_surface_area(double side) {\n    if (side < 0) return 0;\n    return 6 * side * side;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPiT1 PROC\n|L1.0|\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\npartition__FPiiT2 PROC\n        STMFD    sp!,{r4-r9,lr}\n        SUB      r9,r2,#1\n        CMP      r1,r9\n        LDR      r8,[r0,r2,LSL #2]\n        MOV      r7,r2\n        SUB      r6,r1,#1\n        MOV      r5,r0\n        MOV      r4,r1\n        BGT      |L1.96|\n|L1.56|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,r8\n        BGE      |L1.84|\n        ADD      r6,r6,#1\n        ADD      r0,r5,r6,LSL #2\n        ADD      r1,r5,r4,LSL #2\n        BL       swap__FPiT1\n|L1.84|\n        ADD      r4,r4,#1\n        CMP      r4,r9\n        BLE      |L1.56|\n|L1.96|\n        ADD      r0,r5,r6,LSL #2\n        ADD      r0,r0,#4\n        ADD      r1,r5,r7,LSL #2\n        BL       swap__FPiT1\n        ADD      r0,r6,#1\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n\nquickSort__FPiiT2 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r0\n        MOV      r5,r2\n        MOV      r4,r1\n        CMP      r1,r2\n        LDMGEFD  sp!,{r4-r7,lr}\n        BXGE     lr\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       partition__FPiiT2\n        MOV      r7,r0\n        SUB      r2,r0,#1\n        MOV      r0,r6\n        MOV      r1,r4\n        BL       quickSort__FPiiT2\n        MOV      r2,r5\n        ADD      r1,r7,#1\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r7,lr}\n        B        quickSort__FPiiT2\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntranspose__FPA100_iT1i PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      lr,#0\n        CMP      r2,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n|L1.20|\n        MOV      r3,#0\n        CMP      r2,#0\n        BLE      |L1.76|\n        ADD      r12,lr,lr,LSL #3\n        ADD      r12,r12,lr,LSL #4\n        ADD      r5,r0,r12,LSL #4\n|L1.44|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        LDR      r4,[r5,r3,LSL #2]\n        ADD      r3,r3,#1\n        ADD      r12,r1,r12,LSL #4\n        STR      r4,[r12,lr,LSL #2]\n        CMP      r3,r2\n        BLT      |L1.44|\n|L1.76|\n        ADD      lr,lr,#1\n        CMP      lr,r2\n        BLT      |L1.20|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid transpose(int a[][100], int b[][100], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            b[j][i] = a[i][j];\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        CMP      r12,r1\n        MOV      r3,r2\n        BGE      |L1.48|\n        LDR      r4,[r0,r12,LSL #2]\n        LDR      r5,[r0,r2,LSL #2]\n        CMP      r4,r5\n        MOVGT    r2,r12\n|L1.48|\n        CMP      lr,r1\n        BGE      |L1.72|\n        LDR      r12,[r0,lr,LSL #2]\n        LDR      r4,[r0,r2,LSL #2]\n        CMP      r12,r4\n        MOVGT    r2,lr\n|L1.72|\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nheapsort__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r5,r0,#1\n        MOV      r6,r1\n        BMI      |L1.160|\n|L1.136|\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       heapify__FPiiT2\n        SUBS     r5,r5,#1\n        BPL      |L1.136|\n|L1.160|\n        SUBS     r5,r6,#1\n        LDMMIFD  sp!,{r4-r6,lr}\n        BXMI     lr\n|L1.172|\n        LDR      r1,[r4,r5,LSL #2]\n        LDR      r0,[r4,#0]\n        STR      r1,[r4,#0]\n        STR      r0,[r4,r5,LSL #2]\n        MOV      r0,r4\n        MOV      r1,r5\n        MOV      r2,#0\n        BL       heapify__FPiiT2\n        SUBS     r5,r5,#1\n        BPL      |L1.172|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapsort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i >= 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\naddContact__FP11ContactBookPCcT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        ADD      r4,r0,#0x1000\n        LDR      r0,[r4,#0xb58]\n        MOV      r7,r2\n        CMP      r0,#0x64\n        LDMGEFD  sp!,{r3-r7,lr}\n        BXGE     lr\n        RSB      r0,r0,r0,LSL #3\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        MOV      r2,#0x31\n        BL       strncpy\n        LDR      r0,[r4,#0xb58]\n        MOV      r6,#0\n        RSB      r0,r0,r0,LSL #3\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        STRB     r6,[r0,#0x31]\n        LDR      r0,[r4,#0xb58]\n        MOV      r2,#0x13\n        RSB      r0,r0,r0,LSL #3\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r0,#0x32\n        MOV      r1,r7\n        BL       strncpy\n        LDR      r0,[r4,#0xb58]\n        RSB      r0,r0,r0,LSL #3\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        STRB     r6,[r0,#0x45]\n        LDR      r0,[r4,#0xb58]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xb58]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_CONTACTS 100\n#define MAX_NAME_LENGTH 50\n#define MAX_PHONE_LENGTH 20\n\nstruct Contact {\n    char name[MAX_NAME_LENGTH];\n    char phone[MAX_PHONE_LENGTH];\n};\n\nstruct ContactBook {\n    struct Contact contacts[MAX_CONTACTS];\n    int count;\n};\n\nvoid addContact(struct ContactBook* book, const char* name, const char* phone) {\n    if (book->count >= MAX_CONTACTS) return;\n    strncpy(book->contacts[book->count].name, name, MAX_NAME_LENGTH - 1);\n    book->contacts[book->count].name[MAX_NAME_LENGTH - 1] = '\\0';\n    strncpy(book->contacts[book->count].phone, phone, MAX_PHONE_LENGTH - 1);\n    book->contacts[book->count].phone[MAX_PHONE_LENGTH - 1] = '\\0';\n    book->count++;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__FdT1 PROC\n        B        _dadd\n        ENDP\n\nsubtract__FdT1 PROC\n        B        _dsub\n        ENDP\n\nmultiply__FdT1 PROC\n        B        _dmul\n        ENDP\n\ndivide__FdT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r3\n        MOV      r4,r2\n        ADR      r6,|L1.88|\n        MOV      r8,r1\n        MOV      r7,r0\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMIA    r6,{r2,r3}\n        BL       _dcmpeq\n        LDMEQIA  r6,{r0,r1}\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r8\n        MOV      r0,r7\n        LDMFD    sp!,{r4-r8,lr}\n        B        _ddiv\n|L1.88|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ntypedef double (*math_op)(double, double);\n\ndouble add(double a, double b) { return a + b; }\ndouble subtract(double a, double b) { return a - b; }\ndouble multiply(double a, double b) { return a * b; }\ndouble divide(double a, double b) { return b == 0 ? 0 : a / b; }\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nqueue_create__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        ADD      r1,r4,#8\n        STMIA    r1,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nqueue_enqueue__FP5queuei PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r5,[r4,#8]\n        LDR      r0,[r4,#0xc]\n        ADD      r1,r5,#1\n        BL       __rt_sdiv\n        LDR      r0,[r4,#4]\n        CMP      r1,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        STR      r6,[r0,r5,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#8]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nqueue_dequeue__FP5queuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDMIB    r4,{r0,r2}\n        CMP      r0,r2\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,[r4,#0]\n        LDR      r0,[r2,r0,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#4]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nqueue_destroy__FP5queue PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int *data;\n    int head;\n    int tail;\n    int capacity;\n} queue;\n\nqueue* queue_create(int capacity) {\n    queue* q = (queue*)malloc(sizeof(queue));\n    if (q == NULL) return NULL;\n    q->data = (int*)malloc(sizeof(int) * capacity);\n    if (q->data == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->head = 0;\n    q->tail = 0;\n    q->capacity = capacity;\n    return q;\n}\n\nint queue_enqueue(queue* q, int value) {\n    if (q == NULL) return 0;\n    if ((q->tail + 1) % q->capacity == q->head) return 0;\n    q->data[q->tail] = value;\n    q->tail = (q->tail + 1) % q->capacity;\n    return 1;\n}\n\nint queue_dequeue(queue* q, int* value) {\n    if (q == NULL) return 0;\n    if (q->head == q->tail) return 0;\n    *value = q->data[q->head];\n    q->head = (q->head + 1) % q->capacity;\n    return 1;\n}\n\nvoid queue_destroy(queue* q) {\n    if (q == NULL) return;\n    free(q->data);\n    free(q);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninvertTree__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r5,[r4,#4]\n        BL       invertTree__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r5\n        BL       invertTree__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int val) : data(val), left(NULL), right(NULL) {}\n};\n\n\nNode* invertTree(Node* root) {\n    if (root == NULL) return NULL;\n    Node* temp = root->left;\n    root->left = invertTree(root->right);\n    root->right = invertTree(temp);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_valid_email__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MVN      r7,#0\n        MVN      r6,#0\n        MOV      r5,r0\n        BL       strlen\n        MOV      r4,r0\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BXEQ     lr\n        BLE      |L1.92|\n|L1.44|\n        LDRB     r1,[r5,r0]\n        CMP      r1,#0x40\n        MOVEQ    r6,r0\n        BEQ      |L1.72|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.44|\n|L1.72|\n        CMN      r6,#1\n        CMPNE    r6,#0\n        SUBNE    r0,r4,#1\n        CMPNE    r0,r6\n        BNE      |L1.104|\n|L1.92|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.104|\n        ADD      r1,r6,#1\n        MOV      r2,r1\n        CMP      r1,r4\n        BGE      |L1.148|\n|L1.120|\n        LDRB     r3,[r5,r1]\n        CMP      r3,#0x2e\n        MOVEQ    r7,r1\n        BEQ      |L1.148|\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLT      |L1.120|\n|L1.148|\n        CMN      r7,#1\n        CMPNE    r2,r7\n        CMPNE    r0,r7\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r6,#0\n        CMP      r4,#0\n        BLE      |L1.244|\n        BL       __rt_ctype_table\n        LDR      r1,[r0,#0]\n|L1.192|\n        LDRB     r0,[r5,r6]\n        LDRB     r2,[r1,r0]\n        TST      r2,#0x38\n        BNE      |L1.232|\n        CMP      r0,#0x2e\n        CMPNE    r0,#0x40\n        CMPNE    r0,#0x5f\n        LDMNEFD  sp!,{r3-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.232|\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        BLT      |L1.192|\n|L1.244|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_valid_email(char* email) {\n    int at_index = -1;\n    int dot_index = -1;\n    int len = strlen(email);\n\n    if (len == 0) return 0;\n\n    for (int i = 0; i < len; i++) {\n        if (email[i] == '@') {\n            at_index = i;\n            break;\n        }\n    }\n\n    if (at_index == -1 || at_index == 0 || at_index == len - 1) return 0;\n\n    for (int i = at_index + 1; i < len; i++) {\n        if (email[i] == '.') {\n            dot_index = i;\n            break;\n        }\n    }\n\n    if (dot_index == -1 || dot_index == at_index + 1 || dot_index == len - 1) return 0;\n\n    for (int i = 0; i < len; i++) {\n        if (!isalnum(email[i]) && email[i] != '.' && email[i] != '@' && email[i] != '_') return 0;\n    }\n\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__FP5Stackc PROC\n        LDR      r2,[r0,#0x64]\n        CMP      r2,#0x63\n        ADDNE    r2,r2,#1\n        STRNE    r2,[r0,#0x64]\n        STRNEB   r1,[r0,r2]\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        LDR      r1,[r0,#0x64]\n        CMN      r1,#1\n        SUBNE    r2,r1,#1\n        STRNE    r2,[r0,#0x64]\n        LDRNEB   r0,[r0,r1]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nprecedence__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVEQ    r0,#2\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\ninfixToPostfix__FPcT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MVN      r0,#0\n        SUB      sp,sp,#0x68\n        STR      r0,[sp,#0x64]\n        LDRB     r0,[r7,#0]\n        MOV      r6,r1\n        MOV      r5,#0\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.404|\n        BL       __rt_ctype_table\n        MOV      r8,r0\n        MOV      r3,sp\n|L1.144|\n        LDRB     r1,[r7,r5]\n        LDR      r0,[r8,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        MOVNE    r0,r4\n        STRNEB   r1,[r6,r0]\n        ADDNE    r4,r4,#1\n        BNE      |L1.344|\n        CMP      r1,#0x28\n        BNE      |L1.196|\n        MOV      r0,r3\n        BL       push__FP5Stackc\n        B        |L1.344|\n|L1.196|\n        CMP      r1,#0x29\n        BNE      |L1.288|\n        B        |L1.228|\n|L1.208|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        MOV      r1,r4\n        STRB     r0,[r6,r1]\n        ADD      r4,r4,#1\n|L1.228|\n        LDR      r0,[sp,#0x64]\n        CMN      r0,#1\n        BEQ      |L1.344|\n        LDR      r0,[sp,#0x64]\n        LDRB     r0,[r3,r0]\n        CMP      r0,#0x28\n        BNE      |L1.208|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        B        |L1.344|\n|L1.268|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        MOV      r1,r4\n        STRB     r0,[r6,r1]\n        ADD      r4,r4,#1\n|L1.288|\n        LDR      r0,[sp,#0x64]\n        CMN      r0,#1\n        BEQ      |L1.332|\n        LDRB     r0,[r7,r5]\n        BL       precedence__Fc\n        MOV      r1,r0\n        LDR      r0,[sp,#0x64]\n        LDRB     r0,[r3,r0]\n        BL       precedence__Fc\n        CMP      r1,r0\n        BLE      |L1.268|\n|L1.332|\n        LDRB     r1,[r7,r5]\n        MOV      r0,r3\n        BL       push__FP5Stackc\n|L1.344|\n        ADD      r5,r5,#1\n        LDRB     r0,[r7,r5]\n        CMP      r0,#0\n        BNE      |L1.144|\n        LDR      r0,[sp,#0x64]\n        CMN      r0,#1\n        BEQ      |L1.404|\n|L1.372|\n        MOV      r0,r3\n        BL       pop__FP5Stack\n        MOV      r1,r4\n        STRB     r0,[r6,r1]\n        LDR      r0,[sp,#0x64]\n        ADD      r4,r4,#1\n        CMN      r0,#1\n        BNE      |L1.372|\n|L1.404|\n        MOV      r0,#0\n        STRB     r0,[r6,r4]\n        ADD      sp,sp,#0x68\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    char data[MAX_SIZE];\n    int top;\n} Stack;\n\nvoid push(Stack *s, char item) {\n    if (s->top == MAX_SIZE - 1) return;\n    s->data[++s->top] = item;\n}\n\nchar pop(Stack *s) {\n    if (s->top == -1) return '\\0';\n    return s->data[s->top--];\n}\n\nint precedence(char ch) {\n    if (ch == '+' || ch == '-') return 1;\n    if (ch == '*' || ch == '/') return 2;\n    return 0;\n}\n\nvoid infixToPostfix(char infix[], char postfix[]) {\n    Stack s;\n    s.top = -1;\n    int i, j = 0;\n    for (i = 0; infix[i] != '\\0'; i++) {\n        if (isalnum(infix[i])) {\n            postfix[j++] = infix[i];\n        } else if (infix[i] == '(') {\n            push(&s, infix[i]);\n        } else if (infix[i] == ')') {\n            while (s.top != -1 && s.data[s.top] != '(') {\n                postfix[j++] = pop(&s);\n            }\n            if (s.top != -1 && s.data[s.top] == '(') {\n                pop(&s);\n            }\n        } else {\n            while (s.top != -1 && precedence(infix[i]) <= precedence(s.data[s.top])) {\n                postfix[j++] = pop(&s);\n            }\n            push(&s, infix[i]);\n        }\n    }\n    while (s.top != -1) {\n        postfix[j++] = pop(&s);\n    }\n    postfix[j] = '\\0';\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindMax__FPii PROC\n|L1.0|\n        CMP      r1,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r2,#1\n        CMP      r1,#1\n        LDR      r3,[r0,#0]\n        BLE      |L1.52|\n|L1.28|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r12,r3\n        MOVGT    r3,r12\n        CMP      r2,r1\n        BLT      |L1.28|\n|L1.52|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findMax(int arr[], int size) {\n    if (size <= 0) return 0;\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncatalan__Fi PROC\n        STMFD    sp!,{r3-r9,lr}\n        CMP      r0,#1\n        ADRLE    r1,|L1.116|\n        MOV      r7,r0\n        LDMLEIA  r1,{r0,r1}\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        MOV      r4,#0\n        ADR      r0,|L1.124|\n        LDMIA    r0,{r5,r6}\n|L1.40|\n        MOV      r0,r4\n        BL       catalan__Fi\n        MOV      r8,r0\n        SUB      r0,r7,r4\n        SUB      r0,r0,#1\n        MOV      r9,r1\n        BL       catalan__Fi\n        UMULL    r2,r12,r0,r8\n        MLA      r12,r8,r1,r12\n        MLA      r3,r9,r0,r12\n        ADDS     r5,r5,r2\n        ADC      r6,r6,r3\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.40|\n        MOV      r0,r5\n        MOV      r1,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.116|\n        DCQ      0x0000000000000001\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long long catalan(int n) {\n    if (n <= 1) return 1;\n    unsigned long long res = 0;\n    for (int i = 0; i < n; ++i)\n        res += catalan(i) * catalan(n - i - 1);\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsortedArrayToBST__FPiiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        MOV      r7,r2\n        MOV      r6,r1\n        CMP      r1,r2\n        LDMGTFD  sp!,{r4-r8,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        ADD      r0,r6,r7\n        ADD      r0,r0,r0,LSR #31\n        MOV      r5,r0,ASR #1\n        LDR      r0,[r8,r5,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        MOV      r0,r8\n        SUB      r2,r5,#1\n        MOV      r1,r6\n        BL       sortedArrayToBST__FPiiT2\n        STR      r0,[r4,#4]\n        MOV      r0,r8\n        MOV      r2,r7\n        ADD      r1,r5,#1\n        BL       sortedArrayToBST__FPiiT2\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\n\nstruct node* sortedArrayToBST(int arr[], int start, int end) {\n    if (start > end) return NULL;\n    int mid = (start + end) / 2;\n    struct node *root = newNode(arr[mid]);\n    root->left = sortedArrayToBST(arr, start, mid - 1);\n    root->right = sortedArrayToBST(arr, mid + 1, end);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncross_product__F7vector3T1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r6,sp,#0x28\n        LDMIA    r6,{r4-r6}\n        MOV      r11,r0\n        MOV      r7,r1\n        MOV      r1,r6\n        MOV      r0,r2\n        MOV      r9,r3\n        MOV      r8,r2\n        BL       _fmul\n        MOV      r10,r0\n        MOV      r0,r9\n        MOV      r1,r5\n        BL       _fmul\n        MOV      r1,r10\n        BL       _frsb\n        MOV      r10,r0\n        MOV      r0,r9\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r9,r0\n        MOV      r0,r7\n        MOV      r1,r6\n        BL       _fmul\n        MOV      r1,r9\n        BL       _frsb\n        MOV      r6,r0\n        MOV      r0,r7\n        MOV      r1,r5\n        BL       _fmul\n        MOV      r5,r0\n        MOV      r0,r8\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r1,r5\n        BL       _frsb\n        STR      r0,[r11,#8]\n        STR      r6,[r11,#4]\n        STR      r10,[r11,#0]\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct vector3 {\n    float x, y, z;\n};\n\nstruct vector3 cross_product(struct vector3 a, struct vector3 b) {\n    struct vector3 result;\n    result.x = a.y * b.z - a.z * b.y;\n    result.y = a.z * b.x - a.x * b.z;\n    result.z = a.x * b.y - a.y * b.x;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntrailingZeroesFactorial__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        CMP      r0,#0\n        LDMLTFD  sp!,{r4-r6,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r4,#5\n        MOV      r0,r4\n        MOV      r6,#0\n        MOV      r1,r5\n        BL       __rt_sdiv\n        CMP      r0,#1\n        BLT      |L1.92|\n|L1.52|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __rt_sdiv\n        ADD      r6,r0,r6\n        ADD      r4,r4,r4,LSL #2\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       __rt_sdiv\n        CMP      r0,#1\n        BGE      |L1.52|\n|L1.92|\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint trailingZeroesFactorial(int n) {\n    if (n < 0) return 0;\n    int count = 0;\n    for (int i = 5; n / i >= 1; i *= 5)\n        count += n / i;\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMinHeap__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        STR      r5,[r0,#4]!\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nminHeapify__FP7MinHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#8]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.136|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVLT    r4,r0\n|L1.136|\n        CMP      r3,r2\n        BLE      |L1.164|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVLT    r4,r2\n|L1.164|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r1,r0,r1,LSL #2\n        ADD      r0,r0,r4,LSL #2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        minHeapify__FP7MinHeapi\n        ENDP\n\nextractMin__FP7MinHeap PROC\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        MVNLE    r0,#0x80000000\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#8]\n        MOV      r1,#0\n        BL       minHeapify__FP7MinHeapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsertKey__FP7MinHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        LDR      r2,[r4,#4]\n        CMP      r0,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDR      r2,[r4,#0]\n        SUB      r0,r0,#1\n        STR      r1,[r2,r0,LSL #2]\n        B        |L1.348|\n|L1.332|\n        ADD      r1,r2,r5,LSL #2\n        ADD      r0,r2,r0,LSL #2\n        BL       swap__FPiT1\n        MOV      r0,r5\n|L1.348|\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        SUB      r1,r0,#1\n        ADD      r1,r1,r1,LSR #31\n        LDR      r2,[r4,#0]\n        MOV      r5,r1,ASR #1\n        LDR      r1,[r2,r5,LSL #2]\n        LDR      r3,[r2,r0,LSL #2]\n        CMP      r1,r3\n        BGT      |L1.332|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct MinHeap {\n    int *array;\n    int capacity;\n    int size;\n};\n\nstruct MinHeap* createMinHeap(int capacity) {\n    struct MinHeap* minHeap = (struct MinHeap*)malloc(sizeof(struct MinHeap));\n    minHeap->capacity = capacity;\n    minHeap->size = 0;\n    minHeap->array = (int*)malloc(minHeap->capacity * sizeof(int));\n    return minHeap;\n}\n\n\nvoid swap(int *x, int *y) {\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid minHeapify(struct MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n\n    if (left < minHeap->size && minHeap->array[left] < minHeap->array[smallest])\n        smallest = left;\n\n    if (right < minHeap->size && minHeap->array[right] < minHeap->array[smallest])\n        smallest = right;\n\n    if (smallest != idx) {\n        swap(&minHeap->array[smallest], &minHeap->array[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n\nint extractMin(struct MinHeap* minHeap) {\n    if (minHeap->size <= 0)\n        return 0x7FFFFFFF;\n\n    int root = minHeap->array[0];\n    minHeap->array[0] = minHeap->array[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return root;\n}\n\nvoid insertKey(struct MinHeap* minHeap, int key) {\n    if (minHeap->size == minHeap->capacity)\n        return;\n\n    minHeap->size++;\n    int i = minHeap->size - 1;\n    minHeap->array[i] = key;\n\n    while (i != 0 && minHeap->array[i] < minHeap->array[(i - 1) / 2]) {\n        swap(&minHeap->array[i], &minHeap->array[(i - 1) / 2]);\n        i = (i - 1) / 2;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstump__FPddT2 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r3\n        MOV      r3,r2\n        MOV      r2,r1\n        LDR      r4,[sp,#0x10]\n        LDMIA    r0,{r0,r1}\n        BL       _dcmpge\n        MOVHI    r0,r5\n        MOV      r1,r4\n        MOVLS    r0,r5\n        LDMLSFD  sp!,{r3-r5,lr}\n        EORLS    r1,r1,#0x80000000\n        BXLS     lr\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nloss__Fdi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,r2\n        MOV      r5,r1\n        BL       _dflt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dcmpeq\n        ADREQ    r1,|L1.124|\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        ADR      r1,|L1.132|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.124|\n        DCFD     0x0000000000000000\n|L1.132|\n        DCFD     0x3ff0000000000000\n        ENDP\n\ngradient__Fdi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,r2\n        MOV      r6,r1\n        MOV      r4,r2\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dcmpeq\n        ADREQ    r1,|L1.124|\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r4,#1\n        ADREQ    r1,|L1.132|\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADR      r1,|L1.228|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.228|\n        DCFD     0xbff0000000000000\n        ENDP\n\ngbm_classification__FP9DataPointiT2d PROC\n        STMFD    sp!,{r4-r8,lr}\n        ADR      r8,|L1.324|\n        MOV      r7,r0\n        MOV      r6,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        BLE      |L1.312|\n|L1.264|\n        RSB      r0,r4,r4,LSL #3\n        ADD      r0,r0,r0,LSL #1\n        ADD      r5,r7,r0,LSL #2\n        LDMIA    r8,{r2,r3}\n        LDMIA    r5,{r0,r1}\n        BL       _dcmpge\n        MOVLS    r0,#0\n        MOVHI    r0,#1\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        STR      r0,[r5,#0x50]\n        BLT      |L1.264|\n|L1.312|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.324|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct DataPoint {\n    double features[10]; // Assuming 10 features max. Adjust as needed.\n    int label;\n};\n\n\ndouble stump(double* features, double threshold, double polarity) {\n    return (features[0] > threshold) ? polarity : -polarity;\n}\n\ndouble loss(double prediction, int label) {\n    return (prediction == label) ? 0.0 : 1.0;\n}\n\ndouble gradient(double prediction, int label) {\n    return prediction == label ? 0.0 : (label == 1 ? 1.0 : -1.0);\n}\n\nint gbm_classification(struct DataPoint* data, int num_data_points, int num_iterations, double learning_rate) {\n    //simplified implementation- lacks many features of a real GBM\n    double initial_prediction = 0.5;\n    for (int i = 0; i < num_data_points; i++)\n    {\n        data[i].label = (data[i].features[0] > 0.5) ? 1 : 0; //Simplified prediction based on first feature. Replace with your actual prediction model.\n    }\n    return 0;\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisVowel__Fc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0x10\n        MOV      r4,r0\n        ADD      r0,sp,#4\n        MOV      r2,#0xb\n        LDR      r1,|L1.156|\n        BL       __rt_memcpy\n        MOV      r1,r4\n        ADD      r0,sp,#4\n        BL       strchr\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4,lr}\n        CMP      r0,#0\n        MOVNE    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isVowel(char c) {\n    char vowels[] = \"aeiouAEIOU\";\n    return strchr(vowels, c) != 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r1\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,r0\n        MOV      r0,r4\n        BL       __rt_sdiv\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        gcd__FiT1\n        ENDP\n\ngcd_multiple__FiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r5,#1\n        LDREQ    r0,[r6,#0]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDMIA    r6,{r0,r1}\n        BL       gcd__FiT1\n        MOV      r4,#2\n        CMP      r5,#2\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.108|\n        LDR      r1,[r6,r4,LSL #2]\n        BL       gcd__FiT1\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.108|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint gcd_multiple(int count, int* numbers) {\n    if (count <= 0) return 0;\n    if (count == 1) return numbers[0];\n    int result = gcd(numbers[0], numbers[1]);\n    for (int i = 2; i < count; i++) {\n        result = gcd(result, numbers[i]);\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfahrenheitToCelsius__Fd PROC\n        STMFD    sp!,{r3,lr}\n        ADR      r2,|L1.48|\n        LDMIA    r2,{r2,r3}\n        BL       _dsub\n        ADR      r2,|L1.56|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.64|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDR      lr,[sp],#4\n        B        _ddiv\n|L1.48|\n        DCFD     0x4040000000000000\n|L1.56|\n        DCFD     0x4014000000000000\n|L1.64|\n        DCFD     0x4022000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble fahrenheitToCelsius(double fahrenheit) {\n    return (fahrenheit - 32.0) * 5.0 / 9.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nareEqual__FiT1 PROC\n        TEQ      r0,r1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint areEqual(int a, int b) {\n    return !(a ^ b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nshuffleDeck__FP4Card PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0\n        BL       time\n        BL       srand\n        MOV      r4,#0x33\n|L1.24|\n        BL       rand\n        MOV      r1,r0\n        ADD      r0,r4,#1\n        BL       __rt_sdiv\n        ADD      r0,r5,r4,LSL #3\n        ADD      r1,r5,r1,LSL #3\n        LDMIA    r1,{r12,lr}\n        LDMIA    r0,{r2,r3}\n        STMIA    r0,{r12,lr}\n        SUB      r4,r4,#1\n        CMP      r4,#0\n        STMIA    r1,{r2,r3}\n        BGT      |L1.24|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define DECK_SIZE 52\n#define HAND_SIZE 5\n\ntypedef struct {\n    int rank;\n    int suit;\n} Card;\n\nvoid shuffleDeck(Card *deck) {\n    srand(time(0));\n    for (int i = DECK_SIZE - 1; i > 0; i--) {\n        int j = rand() % (i + 1);\n        Card temp = deck[i];\n        deck[i] = deck[j];\n        deck[j] = temp;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x14\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r4,[r0,#0]\n        STRB     r1,[r0,#4]\n        STR      r1,[r0,#8]\n        STR      r1,[r0,#0xc]\n        STR      r1,[r0,#0x10]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r1\n        LDMEQFD  sp!,{r4,lr}\n        BEQ      createNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.108|\n        LDR      r0,[r4,#8]\n        BL       insert__FP4nodei\n        STR      r0,[r4,#8]\n        B        |L1.120|\n|L1.108|\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4nodei\n        STR      r0,[r4,#0xc]\n|L1.120|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef enum { RED, BLACK } color;\n\ntypedef struct node {\n    int key;\n    color col;\n    struct node *left;\n    struct node *right;\n    struct node *parent;\n} node;\n\nnode* createNode(int key) {\n    node* newNode = (node*)malloc(sizeof(node));\n    if (newNode == NULL) return NULL;\n    newNode->key = key;\n    newNode->col = RED;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    newNode->parent = NULL;\n    return newNode;\n}\n\n\nnode* insert(node* root, int key) {\n    if (root == NULL) return createNode(key);\n    if (key < root->key) root->left = insert(root->left, key);\n    else root->right = insert(root->right, key);\n    return root;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.316|\n        MOV      r1,r0\n        LDR      r0,[r2,#0]  ; top\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0]  ; top\n        LDR      r2,|L1.320|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.316|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.320|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\ndfs__FPA100_iiT2 PROC\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r9,|L1.324|\n        MOV      r7,r0\n        MOV      r0,#1\n        STR      r0,[r9,r2,LSL #2]\n        MOV      r6,r2\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        BLE      |L1.164|\n        ADD      r0,r6,r6,LSL #3\n        ADD      r0,r0,r6,LSL #4\n        ADD      r8,r7,r0,LSL #4\n|L1.112|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r0,[r9,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.152|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r7\n        BL       dfs__FPA100_iiT2\n|L1.152|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.112|\n|L1.164|\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r9,lr}\n        B        push__Fi\n        ENDP\n\ntopologicalSort__FPA100_ii PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r7,|L1.324|\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r1,#0x190\n        MOV      r0,r7\n        BL       __rt_memclr_w\n        LDR      r8,|L1.316|\n        MVN      r0,#0\n        STR      r0,[r8,#0]  ; top\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.268|\n|L1.228|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.256|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       dfs__FPA100_iiT2\n|L1.256|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.228|\n|L1.268|\n        LDR      r4,[r8,#0]  ; top\n        CMP      r4,#0\n        BLT      |L1.304|\n        LDR      r5,|L1.320|\n|L1.284|\n        LDR      r1,[r5,r4,LSL #2]\n        ADR      r0,|L1.328|\n        BL       _printf\n        SUBS     r4,r4,#1\n        BPL      |L1.284|\n|L1.304|\n        ADR      r0,|L1.332|\n        LDMFD    sp!,{r4-r8,lr}\n        B        _printf\n|L1.316|\n        DCD      top\n|L1.320|\n        DCD      ||.bss$2|| + 400\n|L1.324|\n        DCD      ||.bss$2||\n|L1.328|\n        DCB      \"%d \\0\"\n|L1.332|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint stack[MAX_VERTICES];\nint top = -1;\n\nvoid push(int vertex) {\n    stack[++top] = vertex;\n}\n\nint pop() {\n    return stack[top--];\n}\n\nvoid dfs(int graph[MAX_VERTICES][MAX_VERTICES], int numVertices, int vertex) {\n    visited[vertex] = 1;\n    for (int i = 0; i < numVertices; i++) {\n        if (graph[vertex][i] && !visited[i]) {\n            dfs(graph, numVertices, i);\n        }\n    }\n    push(vertex);\n}\n\nvoid topologicalSort(int graph[MAX_VERTICES][MAX_VERTICES], int numVertices) {\n    memset(visited, 0, sizeof(visited));\n    top = -1;\n    for (int i = 0; i < numVertices; i++) {\n        if (!visited[i]) {\n            dfs(graph, numVertices, i);\n        }\n    }\n    for (int i = top; i >= 0; i--) {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r6,r0\n        BL       strlen\n        MOVS     r8,r0\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        SUB      r4,r8,#1\n        CMP      r4,#0\n        MOV      r5,#0\n        BLE      |L1.184|\n        BL       __rt_ctype_table\n        MOV      r7,r0\n        B        |L1.60|\n|L1.56|\n        ADD      r5,r5,#1\n|L1.60|\n        CMP      r5,r8\n        BGE      |L1.96|\n        LDRB     r1,[r6,r5]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.56|\n        B        |L1.96|\n|L1.92|\n        SUB      r4,r4,#1\n|L1.96|\n        CMP      r4,#0\n        BLT      |L1.124|\n        LDRB     r1,[r6,r4]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.92|\n|L1.124|\n        CMP      r5,r4\n        BGE      |L1.184|\n        LDRB     r0,[r6,r5]\n        BL       tolower\n        MOV      r9,r0\n        LDRB     r0,[r6,r4]\n        BL       tolower\n        CMP      r9,r0\n        LDMNEFD  sp!,{r3-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        CMP      r5,r4\n        BLT      |L1.60|\n|L1.184|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    if (len == 0) return 1;\n    int left = 0;\n    int right = len - 1;\n    while (left < right) {\n        while (left < len && !isalnum(str[left])) left++;\n        while (right >= 0 && !isalnum(str[right])) right--;\n        if (left >= right) break;\n        if (tolower(str[left]) != tolower(str[right])) return 0;\n        left++;\n        right--;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nromanToInt__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r4,#0\n        BL       strlen\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.244|\n|L1.28|\n        LDRB     r2,[r5,r1]\n        CMP      r2,#0x49\n        BNE      |L1.84|\n        ADD      r2,r1,#1\n        CMP      r2,r0\n        BGE      |L1.76|\n        ADD      r2,r5,r1\n        LDRB     r2,[r2,#1]\n        CMP      r2,#0x56\n        CMPNE    r2,#0x58\n        SUBEQ    r4,r4,#1\n        BEQ      |L1.232|\n|L1.76|\n        ADD      r4,r4,#1\n        B        |L1.232|\n|L1.84|\n        CMP      r2,#0x56\n        ADDEQ    r4,r4,#5\n        BEQ      |L1.232|\n        CMP      r2,#0x58\n        BNE      |L1.148|\n        ADD      r2,r1,#1\n        CMP      r2,r0\n        BGE      |L1.140|\n        ADD      r2,r5,r1\n        LDRB     r2,[r2,#1]\n        CMP      r2,#0x4c\n        CMPNE    r2,#0x43\n        SUBEQ    r4,r4,#0xa\n        BEQ      |L1.232|\n|L1.140|\n        ADD      r4,r4,#0xa\n        B        |L1.232|\n|L1.148|\n        CMP      r2,#0x4c\n        ADDEQ    r4,r4,#0x32\n        BEQ      |L1.232|\n        CMP      r2,#0x43\n        BNE      |L1.212|\n        ADD      r2,r1,#1\n        CMP      r2,r0\n        BGE      |L1.204|\n        ADD      r2,r5,r1\n        LDRB     r2,[r2,#1]\n        CMP      r2,#0x44\n        CMPNE    r2,#0x4d\n        SUBEQ    r4,r4,#0x64\n        BEQ      |L1.232|\n|L1.204|\n        ADD      r4,r4,#0x64\n        B        |L1.232|\n|L1.212|\n        CMP      r2,#0x44\n        ADDEQ    r4,r4,#0x1f4\n        BEQ      |L1.232|\n        CMP      r2,#0x4d\n        ADDEQ    r4,r4,#0x3e8\n|L1.232|\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.28|\n|L1.244|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint romanToInt(const char* s) {\n    int result = 0;\n    int n = strlen(s);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'I') {\n            if (i + 1 < n && (s[i + 1] == 'V' || s[i + 1] == 'X')) {\n                result -= 1;\n            } else {\n                result += 1;\n            }\n        } else if (s[i] == 'V') {\n            result += 5;\n        } else if (s[i] == 'X') {\n            if (i + 1 < n && (s[i + 1] == 'L' || s[i + 1] == 'C')) {\n                result -= 10;\n            } else {\n                result += 10;\n            }\n        } else if (s[i] == 'L') {\n            result += 50;\n        } else if (s[i] == 'C') {\n            if (i + 1 < n && (s[i + 1] == 'D' || s[i + 1] == 'M')) {\n                result -= 100;\n            } else {\n                result += 100;\n            }\n        } else if (s[i] == 'D') {\n            result += 500;\n        } else if (s[i] == 'M') {\n            result += 1000;\n        }\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ninorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        BL       inorder__FP4Node\n        ADR      r0,|L1.652|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#0xc]\n        LDMFD    sp!,{r4,lr}\n        B        inorder__FP4Node\n|L1.652|\n        DCB      \"%d \\0\"\n        ENDP\n\nserialize__FP4NodeP6__FILE PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        MOV      r4,r1\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        ADREQ    r1,|L1.728|\n        BEQ      _fprintf\n        ADR      r1,|L1.652|\n        MOV      r0,r4\n        LDR      r2,[r5,#0]\n        BL       _fprintf\n        MOV      r1,r4\n        LDR      r0,[r5,#8]\n        BL       serialize__FP4NodeP6__FILE\n        MOV      r1,r4\n        LDR      r0,[r5,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        B        serialize__FP4NodeP6__FILE\n|L1.728|\n        DCB      \"N \\0\\0\"\n        ENDP\n\ndeserialize__FP6__FILE PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0xc\n        MOV      r4,sp\n        MOV      r2,sp\n        MOV      r5,r0\n        ADR      r1,|L1.884|\n        BL       _fscanf\n        ADR      r1,|L1.888|\n        MOV      r0,r4\n        BL       strcmp\n        CMP      r0,#0\n        ADDEQ    sp,sp,#0xc\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       atoi\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        BEQ      |L1.840|\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n|L1.840|\n        MOV      r4,r0\n        MOV      r0,r5\n        BL       deserialize__FP6__FILE\n        STR      r0,[r4,#8]\n        MOV      r0,r5\n        BL       deserialize__FP6__FILE\n        STR      r0,[r4,#0xc]\n        ADD      sp,sp,#0xc\n        MOV      r0,r4\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.884|\n        DCB      \"%s\\0\\0\"\n|L1.888|\n        DCB      \"N\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else \n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\nvoid inorder(Node *root) {\n    if(root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->key);\n        inorder(root->right);\n    }\n}\n\n\nvoid serialize(Node *root, FILE *fp) {\n    if (root == NULL) {\n        fprintf(fp, \"N \");\n        return;\n    }\n    fprintf(fp, \"%d \", root->key);\n    serialize(root->left, fp);\n    serialize(root->right, fp);\n}\n\nNode* deserialize(FILE *fp) {\n    char str[10];\n    fscanf(fp, \"%s\", str);\n    if (strcmp(str,\"N\") == 0) return NULL;\n    int key = atoi(str);\n    Node* root = new Node(key);\n    root->left = deserialize(fp);\n    root->right = deserialize(fp);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r) {\n        printf(\"%s\\n\", a);\n    } else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i)); \n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nromanToInt__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,#0\n        MOV      r4,#0\n        BL       strlen\n        SUBS     r1,r0,#1\n        BMI      |L1.148|\n|L1.28|\n        LDRB     r0,[r6,r1]\n        CMP      r0,#0x4c\n        MOVEQ    r0,#0x32\n        BEQ      |L1.124|\n        BGT      |L1.88|\n        CMP      r0,#0x43\n        MOVEQ    r0,#0x64\n        BEQ      |L1.124|\n        CMP      r0,#0x44\n        MOVEQ    r0,#0x1f4\n        BEQ      |L1.124|\n        CMP      r0,#0x49\n        MOVEQ    r0,#1\n        BEQ      |L1.124|\n        B        |L1.160|\n|L1.88|\n        CMP      r0,#0x4d\n        MOVEQ    r0,#0x3e8\n        BEQ      |L1.124|\n        CMP      r0,#0x56\n        MOVEQ    r0,#5\n        BEQ      |L1.124|\n        CMP      r0,#0x58\n        BNE      |L1.160|\n        MOV      r0,#0xa\n|L1.124|\n        CMP      r0,r5\n        ADDGE    r4,r4,r0\n        SUBLT    r4,r4,r0\n        SUBS     r1,r1,#1\n        MOV      r5,r0\n        BPL      |L1.28|\n|L1.148|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.160|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint romanToInt(char* s) {\n    int result = 0;\n    int prevValue = 0;\n    int len = strlen(s);\n    for (int i = len - 1; i >= 0; i--) {\n        int currentValue;\n        switch (s[i]) {\n            case 'I': currentValue = 1; break;\n            case 'V': currentValue = 5; break;\n            case 'X': currentValue = 10; break;\n            case 'L': currentValue = 50; break;\n            case 'C': currentValue = 100; break;\n            case 'D': currentValue = 500; break;\n            case 'M': currentValue = 1000; break;\n            default: return 0;\n        }\n        if (currentValue < prevValue) {\n            result -= currentValue;\n        } else {\n            result += currentValue;\n        }\n        prevValue = currentValue;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninsertHead__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        LDR      r2,|L1.356|\n        STR      r4,[r0,#0]\n        LDR      r1,[r2,#0]  ; head\n        STR      r1,[r0,#8]\n        CMP      r1,#0\n        STRNE    r0,[r1,#4]\n        STR      r0,[r2,#0]  ; head\n        LDR      r1,[r2,#4]  ; tail\n        CMP      r1,#0\n        STREQ    r0,[r2,#4]  ; tail\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsertTail__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        LDR      r2,|L1.356|\n        STR      r4,[r0,#0]\n        LDR      r1,[r2,#4]  ; tail\n        STR      r1,[r0,#4]\n        CMP      r1,#0\n        STRNE    r0,[r1,#8]\n        STR      r0,[r2,#4]  ; tail\n        LDR      r1,[r2,#0]  ; head\n        CMP      r1,#0\n        STREQ    r0,[r2,#0]  ; head\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndeleteNode__Fi PROC\n        LDR      r3,|L1.356|\n        MOV      r1,r0\n        LDR      r0,[r3,#0]  ; head\n        CMP      r0,#0\n        BXEQ     lr\n|L1.164|\n        LDR      r2,[r0,#0]\n        CMP      r2,r1\n        BNE      |L1.228|\n        LDR      r1,[r0,#4]\n        CMP      r1,#0\n        LDREQ    r1,[r0,#8]\n        LDRNE    r2,[r0,#8]\n        STREQ    r1,[r3,#0]  ; head\n        STRNE    r2,[r1,#8]\n        LDR      r1,[r0,#8]\n        CMP      r1,#0\n        LDREQ    r1,[r0,#4]\n        LDRNE    r2,[r0,#4]\n        STREQ    r1,[r3,#4]  ; tail\n        STRNE    r2,[r1,#4]\n        B        free\n|L1.228|\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.164|\n        BX       lr\n        ENDP\n\nreverseList__Fv PROC\n        LDR      r3,|L1.356|\n        LDR      r0,[r3,#0]  ; head\n        CMP      r0,#0\n        BXEQ     lr\n|L1.260|\n        LDMIB    r0,{r1,r2}\n        STR      r2,[r0,#4]!\n        STR      r1,[r0,#4]\n        MOVS     r0,r2\n        BNE      |L1.260|\n        CMP      r1,#0\n        LDRNE    r0,[r1,#4]\n        STRNE    r0,[r3,#0]  ; head\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *prev;\n    Node *next;\n};\n\nNode* head = NULL;\nNode* tail = NULL;\n\nvoid insertHead(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = head;\n    if (head != NULL) head->prev = newNode;\n    head = newNode;\n    if (tail == NULL) tail = newNode;\n}\n\nvoid insertTail(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = tail;\n    if (tail != NULL) tail->next = newNode;\n    tail = newNode;\n    if (head == NULL) head = newNode;\n}\n\n\nvoid deleteNode(int data) {\n    Node* current = head;\n    while (current != NULL) {\n        if (current->data == data) {\n            if (current->prev != NULL) current->prev->next = current->next;\n            else head = current->next;\n            if (current->next != NULL) current->next->prev = current->prev;\n            else tail = current->prev;\n            free(current);\n            return;\n        }\n        current = current->next;\n    }\n}\n\nvoid reverseList() {\n    Node* current = head;\n    Node* temp = NULL;\n    while (current != NULL) {\n        temp = current->prev;\n        current->prev = current->next;\n        current->next = temp;\n        current = current->prev;\n    }\n    if(temp != NULL) head = temp->prev;\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateList__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsertAtBeginning__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#8]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STRNE    r0,[r1,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ninsertAtEnd__FP16DoublyLinkedListi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        MOV      r2,#0\n        STR      r2,[r0,#8]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r2,[r0,#4]\n        STREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r2,[r1,#8]\n        CMP      r2,#0\n        BEQ      |L1.176|\n|L1.160|\n        LDR      r1,[r1,#8]\n        LDR      r2,[r1,#8]\n        CMP      r2,#0\n        BNE      |L1.160|\n|L1.176|\n        STR      r0,[r1,#8]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ninsertAtMiddle__FP16DoublyLinkedListiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r6,r2\n        CMP      r0,#0\n        CMPNE    r6,#1\n        MOV      r5,r1\n        MOVLE    r1,r5\n        MOVLE    r0,r4\n        LDMLEFD  sp!,{r4-r6,lr}\n        BLE      insertAtBeginning__FP16DoublyLinkedListi\n        MOV      r0,#0xc\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        MOV      r2,#1\n        SUB      r3,r6,#1\n        B        |L1.272|\n|L1.264|\n        LDR      r1,[r1,#8]\n        ADD      r2,r2,#1\n|L1.272|\n        CMP      r1,#0\n        MOVEQ    r1,r5\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r6,lr}\n        BEQ      insertAtEnd__FP16DoublyLinkedListi\n        CMP      r2,r3\n        BLT      |L1.264|\n        LDR      r2,[r1,#8]\n        STMIB    r0,{r1,r2}\n        LDR      r2,[r1,#8]\n        CMP      r2,#0\n        STRNE    r0,[r2,#4]\n        STR      r0,[r1,#8]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n\nstruct DoublyLinkedList {\n    struct Node* head;\n};\n\nstruct DoublyLinkedList* createList() {\n    struct DoublyLinkedList* list = (struct DoublyLinkedList*)malloc(sizeof(struct DoublyLinkedList));\n    list->head = NULL;\n    return list;\n}\n\nvoid insertAtBeginning(struct DoublyLinkedList* list, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = list->head;\n    if (list->head != NULL)\n        list->head->prev = newNode;\n    list->head = newNode;\n}\n\nvoid insertAtEnd(struct DoublyLinkedList* list, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    if (list->head == NULL) {\n        newNode->prev = NULL;\n        list->head = newNode;\n        return;\n    }\n    struct Node* temp = list->head;\n    while (temp->next != NULL)\n        temp = temp->next;\n    temp->next = newNode;\n    newNode->prev = temp;\n}\n\nvoid insertAtMiddle(struct DoublyLinkedList* list, int data, int pos) {\n    if(list->head == NULL || pos <=1){\n        insertAtBeginning(list, data);\n        return;\n    }\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    struct Node* temp = list->head;\n    int count = 1;\n    while (temp != NULL && count < pos -1) {\n        temp = temp->next;\n        count++;\n    }\n    if (temp == NULL) {\n        insertAtEnd(list,data);\n        return;\n    }\n    newNode->next = temp->next;\n    newNode->prev = temp;\n    if(temp->next != NULL)\n        temp->next->prev = newNode;\n    temp->next = newNode;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__FUi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x14\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        ADD      r1,r4,#8\n        STMIA    r1,{r0,r5}\n        STR      r0,[r4,#0x10]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0x10]\n        LDR      r2,[r4,#0xc]\n        CMP      r0,r2\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r2,[r4,#8]\n        STR      r1,[r0,r2,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_udiv\n        STR      r1,[r4,#8]\n        LDR      r0,[r4,#0x10]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0x10]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5QueuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0x10]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDMIA    r4,{r0,r2}\n        LDR      r0,[r0,r2,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_udiv\n        STR      r1,[r4,#4]\n        LDR      r0,[r4,#0x10]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#0x10]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nqueueSize__FP5Queue PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0x10]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\ndeleteQueue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned int size_t;\n\ntypedef struct {\n    int* buffer;\n    size_t head;\n    size_t tail;\n    size_t capacity;\n    size_t size;\n} Queue;\n\nQueue* createQueue(size_t capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    if (queue == NULL) return NULL;\n    queue->buffer = (int*)malloc(sizeof(int) * capacity);\n    if (queue->buffer == NULL) {\n        free(queue);\n        return NULL;\n    }\n    queue->head = 0;\n    queue->tail = 0;\n    queue->capacity = capacity;\n    queue->size = 0;\n    return queue;\n}\n\n\nint enqueue(Queue* queue, int value) {\n    if (queue == NULL) return 0;\n    if (queue->size == queue->capacity) return 0;\n    queue->buffer[queue->tail] = value;\n    queue->tail = (queue->tail + 1) % queue->capacity;\n    queue->size++;\n    return 1;\n}\n\n\nint dequeue(Queue* queue, int* value) {\n    if (queue == NULL) return 0;\n    if (queue->size == 0) return 0;\n    *value = queue->buffer[queue->head];\n    queue->head = (queue->head + 1) % queue->capacity;\n    queue->size--;\n    return 1;\n}\n\n\nsize_t queueSize(Queue* queue) {\n    if (queue == NULL) return 0;\n    return queue->size;\n}\n\nvoid deleteQueue(Queue* queue) {\n    if (queue == NULL) return;\n    free(queue->buffer);\n    free(queue);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndaysInMonth__FiT1 PROC\n|L1.0|\n        CMP      r1,#2\n        BNE      |L1.96|\n        TST      r0,#3\n        LDR      r1,|L1.440|\n        BNE      |L1.52|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        BNE      |L1.88|\n|L1.52|\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0x1c\n        BXNE     lr\n|L1.88|\n        MOV      r0,#0x1d\n        BX       lr\n|L1.96|\n        CMP      r1,#4\n        CMPNE    r1,#6\n        CMPNE    r1,#9\n        CMPNE    r1,#0xb\n        MOVNE    r0,#0x1f\n        BXNE     lr\n        MOV      r0,#0x1e\n        BX       lr\n        ENDP\n\ndaysSinceEpoch__FRC4Date PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        LDR      r3,[r6,#0]\n        MOV      r0,#1\n        MOV      r4,#0\n        CMP      r3,#1\n        BLE      |L1.268|\n        MOV      lr,#0x6e\n        ADD      lr,lr,#0x100\n        LDR      r1,|L1.440|\n        SUB      r5,lr,#1\n|L1.172|\n        TST      r0,#3\n        BNE      |L1.212|\n        SMULL    r12,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        BNE      |L1.248|\n|L1.212|\n        SMULL    r12,r2,r1,r0\n        MOV      r2,r2,ASR #7\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #4\n        MOVNE    r2,r5\n        BNE      |L1.252|\n|L1.248|\n        MOV      r2,lr\n|L1.252|\n        ADD      r0,r0,#1\n        CMP      r3,r0\n        ADD      r4,r2,r4\n        BGT      |L1.172|\n|L1.268|\n        LDR      r0,[r6,#4]\n        MOV      r5,#1\n        CMP      r0,#1\n        BLE      |L1.316|\n|L1.284|\n        MOV      r1,r5\n        LDR      r0,[r6,#0]\n        BL       daysInMonth__FiT1\n        ADD      r4,r0,r4\n        LDR      r0,[r6,#4]\n        ADD      r5,r5,#1\n        CMP      r0,r5\n        BGT      |L1.284|\n|L1.316|\n        LDR      r0,[r6,#8]\n        ADD      r0,r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndateDifference__FRC4DateT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r1\n        BL       daysSinceEpoch__FRC4Date\n        MOV      r4,r0\n        MOV      r0,r5\n        BL       daysSinceEpoch__FRC4Date\n        SUB      r0,r4,r0\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Date {\n    int year;\n    int month;\n    int day;\n};\n\nint daysInMonth(int year, int month) {\n    if (month == 2) {\n        return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 ? 29 : 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        return 30;\n    } else {\n        return 31;\n    }\n}\n\nlong daysSinceEpoch(const Date& date) {\n    long days = 0;\n    for (int y = 1; y < date.year; ++y) {\n        days += (y % 4 == 0 && y % 100 != 0) || y % 400 == 0 ? 366 : 365;\n    }\n    for (int m = 1; m < date.month; ++m) {\n        days += daysInMonth(date.year, m);\n    }\n    days += date.day;\n    return days;\n}\n\n\nlong dateDifference(const Date& d1, const Date& d2) {\n    return daysSinceEpoch(d1) - daysSinceEpoch(d2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1; \n    return (node);\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmerge__FP4NodeT1 PROC\n        STMFD    sp!,{r4,lr}\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,r1\n        BXEQ     lr\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        BGT      |L1.68|\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        BL       merge__FP4NodeT1\n        STR      r0,[r4,#4]\n        B        |L1.84|\n|L1.68|\n        MOV      r4,r1\n        LDR      r1,[r1,#4]\n        BL       merge__FP4NodeT1\n        STR      r0,[r4,#4]\n|L1.84|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nmergeSort__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDRNE    r0,[r4,#4]\n        CMPNE    r0,#0\n        MOVNE    r1,r4\n        BNE      |L1.148|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.132|\n        LDR      r1,[r1,#4]\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BEQ      |L1.160|\n|L1.148|\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BNE      |L1.132|\n|L1.160|\n        MOV      r2,#0\n        LDR      r0,[r1,#4]\n        STR      r2,[r1,#4]\n        BL       mergeSort__FP4Node\n        MOV      r5,r0\n        MOV      r0,r4\n        BL       mergeSort__FP4Node\n        MOV      r1,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        merge__FP4NodeT1\n        ENDP\n\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintList__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        BEQ      |L1.272|\n|L1.248|\n        ADR      r0,|L1.284|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r4,[r4,#4]\n        CMP      r4,#0\n        BNE      |L1.248|\n|L1.272|\n        ADR      r0,|L1.288|\n        LDMFD    sp!,{r4,lr}\n        B        _printf\n|L1.284|\n        DCB      \"%d \\0\"\n|L1.288|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nNode* merge(Node* a, Node* b) {\n    if (!a) return b;\n    if (!b) return a;\n    Node* result;\n    if (a->data <= b->data) {\n        result = a;\n        result->next = merge(a->next, b);\n    } else {\n        result = b;\n        result->next = merge(a, b->next);\n    }\n    return result;\n}\n\nNode* mergeSort(Node* head) {\n    if (!head || !head->next) return head;\n    Node* slow = head;\n    Node* fast = head->next;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    Node* second = slow->next;\n    slow->next = 0;\n    return merge(mergeSort(head), mergeSort(second));\n}\n\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = 0;\n    return newNode;\n}\n\n\nvoid printList(Node* head) {\n    while (head) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__FUxN21 PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r4,r2\n        ADR      r2,|L1.240|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.240|\n        LDMIA    r2,{r8,r9}\n        MOV      r5,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r6,r2\n        MOV      r7,r3\n        ADR      r0,|L1.248|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BLS      |L1.224|\n|L1.76|\n        ADR      r0,|L1.256|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _ll_udiv\n        MOV      r0,r2\n        ADR      r2,|L1.240|\n        MOV      r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.156|\n        UMULL    r0,r12,r8,r6\n        MLA      r12,r6,r9,r12\n        MLA      r1,r7,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.156|\n        UMULL    r0,r12,r6,r6\n        MLA      r12,r6,r7,r12\n        MLA      r1,r7,r6,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_udiv\n        MOV      r0,r4,LSR #1\n        ORR      r4,r0,r5,LSL #31\n        ADR      r0,|L1.248|\n        MOV      r6,r2\n        MOV      r7,r3\n        LDMIA    r0,{r2,r3}\n        MOV      r5,r5,LSR #1\n        CMP      r5,r3\n        MOV      r0,r4\n        CMPEQ    r0,r2\n        BHI      |L1.76|\n|L1.224|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.240|\n        DCQ      0x0000000000000001\n|L1.248|\n        DCQ      0x0000000000000000\n|L1.256|\n        DCQ      0x0000000000000002\n        ENDP\n\ngcd__FUxT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        ADR      r0,|L1.248|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        MOVEQ    r1,r7\n        MOVEQ    r0,r6\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_udiv\n        MOV      r1,r5\n        MOV      r0,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        B        gcd__FUxT1\n        ENDP\n\nextended_gcd__FUxT1PUxT3 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#0x18\n        ADD      r7,sp,#0x38\n        LDMIA    r7,{r6,r7}\n        ADR      r10,|L1.248|\n        MOV      r9,r3\n        MOV      r8,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r5,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r4,r0\n        BNE      |L1.460|\n        LDMIA    r10,{r0,r1}\n        STMIA    r6,{r0,r1}\n        ADR      r0,|L1.240|\n        LDR      r1,[r0,#0]\n        LDR      r0,[r0,#4]\n        STR      r0,[r7,#4]\n        STR      r1,[r7,#0]\n        ADD      sp,sp,#0x18\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.460|\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       _ll_udiv\n        MOV      r9,r1\n        MOV      r8,r0\n        MOV      r0,r2\n        MOV      r1,r3\n        ADD      r3,sp,#8\n        ADD      r2,sp,#0x10\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       extended_gcd__FUxT1PUxT3\n        ADD      r3,sp,#0x10\n        LDMIA    r3,{r2,r3}\n        MOV      r4,r0\n        UMULL    r0,r12,r8,r2\n        MLA      r12,r2,r9,r12\n        MOV      r5,r1\n        ADD      r1,sp,#8\n        MOV      r2,r0\n        LDMIA    r1,{r0,r1}\n        SUBS     r0,r0,r2\n        MLA      r3,r8,r3,r12\n        SBC      r1,r1,r3\n        STMIA    r6,{r0,r1}\n        ADD      r1,sp,#0x10\n        LDMIA    r1,{r0,r1}\n        STMIA    r7,{r0,r1}\n        ADD      sp,sp,#0x18\n        MOV      r1,r5\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\nmodInverse__FUxT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c\n        MOV      r5,r3\n        MOV      r4,r2\n        ADD      r2,sp,#0x14\n        ADD      r3,sp,#0xc\n        STMIA    sp,{r2,r3}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       extended_gcd__FUxT1PUxT3\n        ADR      r2,|L1.240|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        ADRNE    r1,|L1.248|\n        LDMNEIA  r1,{r0,r1}\n        ADDNE    sp,sp,#0x1c\n        LDMNEFD  sp!,{r4,r5,lr}\n        BXNE     lr\n        ADD      r1,sp,#0x14\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_udiv\n        ADDS     r0,r2,r4\n        ADC      r1,r3,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ll_udiv\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r2\n        MOV      r1,r3\n        BX       lr\n        ENDP\n\nrsa_encrypt__FPcUxT2 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        LDR      r11,[sp,#0x40]\n        MOV      r10,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r2,#1\n        ADDS     r0,r0,r2\n        MOV      r7,#0\n        ADC      r1,r7,#0\n        BL       malloc\n        MOV      r8,r0\n        ADR      r0,|L1.248|\n        LDMIA    r0,{r4,r5}\n        MOV      r0,r4\n        MOV      r2,r6\n        CMP      r5,r7\n        CMPEQ    r0,r2\n        BCS      |L1.884|\n|L1.820|\n        LDRB     r0,[r10,r4]\n        LDR      r2,[sp,#0x3c]\n        ADD      r3,sp,#0x34\n        STMIA    sp,{r2,r11}\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r0,ASR #31\n        BL       power__FUxN21\n        STRB     r0,[r8,r4]\n        MOV      r2,#1\n        ADDS     r4,r4,r2\n        ADC      r5,r5,#0\n        CMP      r5,r7\n        MOV      r0,r4\n        MOV      r2,r6\n        CMPEQ    r0,r2\n        BCC      |L1.820|\n|L1.884|\n        MOV      r1,#0\n        STRB     r1,[r8,r6]\n        ADD      sp,sp,#0xc\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\nrsa_decrypt__FPcUxT2 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0xc\n        LDR      r11,[sp,#0x40]\n        MOV      r10,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r2,#1\n        ADDS     r0,r0,r2\n        MOV      r7,#0\n        ADC      r1,r7,#0\n        BL       malloc\n        MOV      r8,r0\n        ADR      r0,|L1.248|\n        LDMIA    r0,{r4,r5}\n        MOV      r0,r4\n        MOV      r2,r6\n        CMP      r5,r7\n        CMPEQ    r0,r2\n        BCS      |L1.1056|\n|L1.992|\n        LDRB     r0,[r10,r4]\n        LDR      r2,[sp,#0x3c]\n        ADD      r3,sp,#0x34\n        STMIA    sp,{r2,r11}\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r0,ASR #31\n        BL       power__FUxN21\n        STRB     r0,[r8,r4]\n        MOV      r2,#1\n        ADDS     r4,r4,r2\n        ADC      r5,r5,#0\n        CMP      r5,r7\n        MOV      r0,r4\n        MOV      r2,r6\n        CMPEQ    r0,r2\n        BCC      |L1.992|\n|L1.1056|\n        MOV      r1,#0\n        STRB     r1,[r8,r6]\n        ADD      sp,sp,#0xc\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned long long ull;\n\null power(ull base, ull exp, ull mod) {\n    ull res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\null gcd(ull a, ull b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\null extended_gcd(ull a, ull b, ull *x, ull *y) {\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    ull x1, y1;\n    ull d = extended_gcd(b % a, a, &x1, &y1);\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return d;\n}\n\null modInverse(ull a, ull m) {\n    ull x, y;\n    ull g = extended_gcd(a, m, &x, &y);\n    if (g != 1) return 0;\n    return (x % m + m) % m;\n}\n\n\nchar* rsa_encrypt(char* message, ull e, ull n) {\n    ull len = strlen(message);\n    char* encrypted = (char*)malloc(len * sizeof(char) + 1);\n    for (ull i = 0; i < len; i++) {\n        ull num = message[i];\n        encrypted[i] = (char)(power(num, e, n));\n    }\n    encrypted[len] = '\\0';\n    return encrypted;\n}\n\nchar* rsa_decrypt(char* encrypted, ull d, ull n) {\n    ull len = strlen(encrypted);\n    char* decrypted = (char*)malloc(len * sizeof(char) + 1);\n    for (ull i = 0; i < len; i++) {\n        ull num = encrypted[i];\n        decrypted[i] = (char)(power(num,d, n));\n\n    }\n    decrypted[len] = '\\0';\n    return decrypted;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisAlphanumeric__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDRB     r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.80|\n        BL       __rt_ctype_table\n        LDR      r1,[r0,#0]\n|L1.40|\n        LDRB     r0,[r5,r4]\n        LDRB     r0,[r1,r0]\n        TST      r0,#0x38\n        LDMEQFD  sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.40|\n|L1.80|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isAlphanumeric(const char* str) {\n    if (str == 0) return 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (!isalnum(str[i])) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisDiagonal__FiT1PA100_i PROC\n|L1.0|\n        CMP      r0,r1\n        MOVNE    r0,#0\n        BXNE     lr\n        STMFD    sp!,{r4,lr}\n        MOV      lr,#0\n        CMP      r0,#0\n        BLE      |L1.100|\n|L1.28|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.88|\n        ADD      r12,lr,lr,LSL #3\n        ADD      r12,r12,lr,LSL #4\n        ADD      r12,r2,r12,LSL #4\n|L1.52|\n        CMP      lr,r3\n        LDRNE    r4,[r12,r3,LSL #2]\n        CMPNE    r4,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.52|\n|L1.88|\n        ADD      lr,lr,#1\n        CMP      lr,r0\n        BLT      |L1.28|\n|L1.100|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isDiagonal(int rows, int cols, int matrix[100][100]) {\n    if (rows != cols) return 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i != j && matrix[i][j] != 0) return 0;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__Fi PROC\n        STMFD    sp!,{r4,lr}\n        SUB      sp,sp,#0x10\n        ADD      r4,sp,#4\n        MOV      r2,r0\n        MOV      r0,r4\n        ADR      r1,|L1.120|\n        BL       _sprintf\n        MOV      r0,r4\n        BL       strlen\n        ADD      r2,r0,r0,LSR #31\n        MOV      r2,r2,ASR #1\n        CMP      r2,#0\n        MOV      r1,#0\n        BLE      |L1.104|\n        SUB      r0,r0,#1\n|L1.60|\n        LDRB     r3,[r4,r1]\n        SUB      r12,r0,r1\n        LDRB     r12,[r4,r12]\n        CMP      r3,r12\n        ADDNE    sp,sp,#0x10\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r1,r1,#1\n        CMP      r2,r1\n        BGT      |L1.60|\n|L1.104|\n        ADD      sp,sp,#0x10\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.120|\n        DCB      \"%d\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint isPalindrome(int n) {\n    char buffer[12]; // Assumes a max of 11 digits for an int, plus null terminator\n    sprintf(buffer, \"%d\", n);\n    int len = strlen(buffer);\n    for (int i = 0; i < len / 2; i++) {\n        if (buffer[i] != buffer[len - 1 - i])\n            return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        CMP      r0,#0\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r2,#1\n        MOV      r1,#1\n        CMP      r0,#1\n        BLT      |L1.44|\n|L1.28|\n        MUL      r2,r1,r2\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLE      |L1.28|\n|L1.44|\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint factorial(int n) {\n    if (n < 0) return 0; //Error handling for negative input\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerateWinningNumbers__FiT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        CMP      r0,#0\n        CMPGT    r7,#0\n        MOV      r5,r0\n        BLE      |L1.32|\n        CMP      r5,r7\n        BLE      |L1.44|\n|L1.32|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.44|\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        MOVS     r6,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BXEQ     lr\n        BL       time\n        BL       srand\n        MOV      r4,#0\n|L1.80|\n        BL       rand\n        MOV      r1,r0\n        MOV      r0,r7\n        BL       __rt_sdiv\n        ADD      r0,r1,#1\n        STR      r0,[r6,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.80|\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* generateWinningNumbers(int num_numbers, int max_number) {\n    if (num_numbers <= 0 || max_number <= 0 || num_numbers > max_number) {\n        return 0;\n    }\n    int* winning_numbers = (int*)malloc(num_numbers * sizeof(int));\n    if (winning_numbers == 0) {\n        return 0;\n    }\n    srand(time(0));\n    for (int i = 0; i < num_numbers; i++) {\n        winning_numbers[i] = rand() % max_number + 1;\n    }\n    return winning_numbers;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_prime__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r4,#3\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#1\n        BXLE     lr\n        TST      r4,#1\n        BEQ      |L1.72|\n        LDR      r1,|L1.212|\n        SMULL    r2,r0,r1,r4\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #2\n        ADDS     r0,r0,r4\n        BNE      |L1.84|\n|L1.72|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r5,#5\n        CMP      r4,#0x19\n        BLT      |L1.164|\n|L1.96|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BEQ      |L1.136|\n        MOV      r1,r4\n        ADD      r0,r5,#2\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.148|\n|L1.136|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.148|\n        ADD      r5,r5,#6\n        MUL      r0,r5,r5\n        CMP      r0,r4\n        BLE      |L1.96|\n|L1.164|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return 0;\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitGraph__FP5Graphi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        ADD      r0,r0,#0x13000\n        ADD      r3,r0,#0xa10\n        MOV      r2,#0\n        STMIA    r3,{r1,r2}\n        STR      r2,[r0,#0xa18]\n        ADD      r0,r4,#0x10000\n        ADD      r0,r0,#0x3880\n        MOV      r1,r1,LSL #2\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        MOV      r1,#0x3880\n        ADD      r1,r1,#0x10000\n        LDMFD    sp!,{r4,lr}\n        B        __rt_memclr_w\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        ADD      r1,r0,#0x13000\n        LDR      r3,[r1,#0xa18]\n        STR      r2,[r0,r3,LSL #3]\n        ADD      r2,r0,r2,LSL #2\n        ADD      r2,r2,#0x13000\n        LDR      r12,[r1,#0xa18]\n        LDR      r3,[r2,#0x880]\n        ADD      r0,r0,r12,LSL #3\n        STR      r3,[r0,#4]\n        LDR      r0,[r2,#0x880]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0x880]\n        LDR      r0,[r1,#0xa18]\n        ADD      r0,r0,#1\n        STR      r0,[r1,#0xa18]\n        LDR      r0,[r1,#0xa14]\n        ADD      r0,r0,#1\n        STR      r0,[r1,#0xa14]\n        BX       lr\n        ENDP\n\ntopologicalSort__FP5GraphPi PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r5,r0,#0x13000\n        MOV      r4,r0\n        LDR      r0,[r5,#0xa10]\n        MOV      r6,r1\n        MOV      r0,r0,LSL #2\n        BL       malloc\n        LDR      r2,[r5,#0xa10]\n        MOV      r8,#0\n        MOV      r12,#0\n        MOV      r10,#0\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.432|\n|L1.196|\n        ADD      r2,r4,r1,LSL #2\n        ADD      r2,r2,#0x13000\n        LDR      r2,[r2,#0x880]\n        CMP      r2,#0\n        MOVEQ    r2,r12\n        STREQ    r1,[r0,r2,LSL #2]\n        LDR      r2,[r5,#0xa10]\n        ADD      r1,r1,#1\n        ADDEQ    r12,r12,#1\n        CMP      r2,r1\n        BGT      |L1.196|\n        CMP      r8,r12\n        BGE      |L1.432|\n|L1.248|\n        MOV      r1,r8\n        LDR      r3,[r0,r1,LSL #2]\n        MOV      r1,r10\n        STR      r3,[r6,r1,LSL #2]\n        LDR      r1,[r5,#0xa18]\n        ADD      r10,r10,#1\n        ADD      r8,r8,#1\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.424|\n        ADD      r1,r4,r3,LSL #2\n        ADD      r7,r1,#0x13000\n|L1.296|\n        ADD      r1,r4,r2,LSL #3\n        LDR      r9,[r1,#4]\n        CMP      r9,#0\n        BEQ      |L1.408|\n        LDR      r1,[r4,r2,LSL #3]\n        CMP      r1,r3\n        BNE      |L1.408|\n        LDR      lr,[r5,#0xa18]\n        MOV      r1,#0\n        CMP      lr,#0\n        BLE      |L1.384|\n|L1.340|\n        LDR      r11,[r4,r1,LSL #3]\n        CMP      r11,r3\n        ADDEQ    r11,r4,r1,LSL #3\n        LDREQ    r11,[r11,#4]\n        CMPEQ    r11,r2\n        ADDEQ    r1,r4,r1,LSL #3\n        STREQ    r9,[r1,#4]\n        BEQ      |L1.384|\n        ADD      r1,r1,#1\n        CMP      lr,r1\n        BGT      |L1.340|\n|L1.384|\n        LDR      r1,[r7,#0x880]\n        SUBS     r1,r1,#1\n        STR      r1,[r7,#0x880]\n        MOVEQ    r1,r12\n        STREQ    r3,[r0,r1,LSL #2]\n        ADDEQ    r12,r12,#1\n|L1.408|\n        LDR      r1,[r5,#0xa18]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.296|\n|L1.424|\n        CMP      r8,r12\n        BLT      |L1.248|\n|L1.432|\n        LDMFD    sp!,{r3-r11,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertex;\n    int next;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_VERTICES * MAX_VERTICES];\n    int inDegree[MAX_VERTICES];\n    int numVertices;\n    int numEdges;\n    int edgeCount;\n} Graph;\n\nvoid initGraph(Graph* graph, int numVertices) {\n    graph->numVertices = numVertices;\n    graph->numEdges = 0;\n    graph->edgeCount = 0;\n    memset(graph->inDegree, 0, sizeof(int) * numVertices);\n    memset(graph->edges, 0, sizeof(Edge) * MAX_VERTICES * MAX_VERTICES);\n}\n\n\nvoid addEdge(Graph* graph, int u, int v) {\n    graph->edges[graph->edgeCount].vertex = v;\n    graph->edges[graph->edgeCount].next = graph->inDegree[v];\n    graph->inDegree[v]++;\n    graph->edgeCount++;\n    graph->numEdges++;\n}\n\n\nvoid topologicalSort(Graph* graph, int* sorted) {\n    int* queue = (int*)malloc(sizeof(int) * graph->numVertices);\n    int head = 0;\n    int tail = 0;\n    int i, j, k = 0;\n\n    for (i = 0; i < graph->numVertices; i++) {\n        if (graph->inDegree[i] == 0) {\n            queue[tail++] = i;\n        }\n    }\n\n    while (head < tail) {\n        int u = queue[head++];\n        sorted[k++] = u;\n\n        for (i = 0; i < graph->edgeCount; i++) {\n            if (graph->edges[i].next == 0) continue;\n            if (graph->edges[i].vertex == u) {\n                for (j = 0; j < graph->edgeCount; j++) {\n                    if (graph->edges[j].vertex == u && graph->edges[j].next == i) {\n                        graph->edges[j].next = graph->edges[i].next;\n                        break;\n                    }\n                }\n                graph->inDegree[u]--;\n                if(graph->inDegree[u] == 0) {\n                    queue[tail++] = u;\n                }\n                \n            }\n        }\n    }\n\n    free(queue);\n}\n\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbinarySearch__FPiiT2 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r3,#0\n        SUBS     r12,r1,#1\n        BMI      |L1.64|\n|L1.16|\n        SUB      r1,r12,r3\n        ADD      r1,r1,r1,LSR #31\n        ADD      r1,r3,r1,ASR #1\n        LDR      lr,[r0,r1,LSL #2]\n        CMP      lr,r2\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,r1\n        BXEQ     lr\n        SUBGE    r12,r1,#1\n        ADDLT    r3,r1,#1\n        CMP      r3,r12\n        BLE      |L1.16|\n|L1.64|\n        LDR      lr,[sp],#4\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash1__FPc PROC\n        LDRB     r3,[r0,#0]\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r3,#0\n        BEQ      |L1.48|\n|L1.20|\n        LDRB     r3,[r0,r1]\n        ADD      r2,r2,r2,LSL #5\n        ADD      r1,r1,#1\n        ADD      r2,r2,r3\n        LDRB     r3,[r0,r1]\n        CMP      r3,#0\n        BNE      |L1.20|\n|L1.48|\n        MOV      r0,r2,LSL #22\n        MOV      r0,r0,LSR #22\n        BX       lr\n        ENDP\n\nhash2__FPc PROC\n        MOV      r2,r0\n        LDRB     r0,[r0,#0]\n        MOV      r1,#5\n        ADD      r1,r1,#0x1500\n        ADD      r2,r2,#1\n        CMP      r0,#0\n        BEQ      |L1.108|\n|L1.88|\n        ADD      r1,r1,r1,LSL #5\n        ADD      r1,r1,r0\n        LDRB     r0,[r2],#1\n        CMP      r0,#0\n        BNE      |L1.88|\n|L1.108|\n        MOV      r0,r1,LSL #22\n        MOV      r0,r0,LSR #22\n        BX       lr\n        ENDP\n\nhash3__FPc PROC\n        LDRB     r3,[r0,#0]\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r3,#0\n        BEQ      |L1.176|\n|L1.140|\n        MOV      r3,r1\n        LDRB     r3,[r0,r3]\n        ADD      r1,r1,#1\n        ADD      r2,r3,r2\n        LDRB     r3,[r0,r1]\n        ADD      r2,r2,r2,LSL #10\n        EOR      r2,r2,r2,LSR #6\n        CMP      r3,#0\n        BNE      |L1.140|\n|L1.176|\n        ADD      r0,r2,r2,LSL #3\n        EOR      r0,r0,r0,LSR #11\n        ADD      r0,r0,r0,LSL #15\n        MOV      r0,r0,LSL #22\n        MOV      r0,r0,LSR #22\n        BX       lr\n        ENDP\n\nbloom_filter_add__FPcPUc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r4,r1\n        BL       hash1__FPc\n        MOV      r6,#1\n        STRB     r6,[r4,r0]\n        MOV      r0,r5\n        BL       hash2__FPc\n        STRB     r6,[r4,r0]\n        MOV      r0,r5\n        BL       hash3__FPc\n        STRB     r6,[r4,r0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nbloom_filter_contains__FPcPUc PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r4,r1\n        BL       hash1__FPc\n        LDRB     r0,[r4,r0]\n        CMP      r0,#0\n        BEQ      |L1.332|\n        MOV      r0,r5\n        BL       hash2__FPc\n        LDRB     r0,[r4,r0]\n        CMP      r0,#0\n        BEQ      |L1.332|\n        MOV      r0,r5\n        BL       hash3__FPc\n        LDRB     r0,[r4,r0]\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.332|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define BLOOM_FILTER_SIZE 1024\n#define NUMBER_OF_HASH_FUNCTIONS 3\n\nunsigned int hash1(char* str) {\n    unsigned int hash = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        hash = (hash << 5) + hash + str[i];\n    }\n    return hash % BLOOM_FILTER_SIZE;\n}\n\nunsigned int hash2(char* str) {\n    unsigned int hash = 5381;\n    int c;\n    while ((c = *str++))\n        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n    return hash % BLOOM_FILTER_SIZE;\n}\n\nunsigned int hash3(char* str) {\n    unsigned int hash = 0;\n    int i = 0;\n    while (str[i]) {\n        hash += str[i++];\n        hash += (hash << 10);\n        hash ^= (hash >> 6);\n    }\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n    return hash % BLOOM_FILTER_SIZE;\n\n}\n\nvoid bloom_filter_add(char* str, unsigned char* bloom_filter) {\n    bloom_filter[hash1(str)] = 1;\n    bloom_filter[hash2(str)] = 1;\n    bloom_filter[hash3(str)] = 1;\n}\n\n\nint bloom_filter_contains(char* str, unsigned char* bloom_filter) {\n    return bloom_filter[hash1(str)] && bloom_filter[hash2(str)] && bloom_filter[hash3(str)];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nlevelOrder__FP4node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        ADD      r7,sp,#4\n        STR      r0,[sp,#4]\n        MOV      r6,#0\n        MOV      r4,#1\n|L1.76|\n        MOV      r0,r6\n        LDR      r5,[r7,r0,LSL #2]\n        ADR      r0,|L1.164|\n        ADD      r6,r6,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r1,[r5,#4]\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        LDR      r1,[r5,#8]\n        ADDNE    r4,r4,#1\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        ADDNE    r4,r4,#1\n        CMP      r6,r4\n        BLT      |L1.76|\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.164|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nvoid levelOrder(struct node* root) {\n    if (root == NULL)  return;\n\n    struct node* queue[1000];\n    int front = 0, rear = 0;\n\n    queue[rear++] = root;\n\n    while (front < rear) {\n        struct node* node = queue[front++];\n        printf(\"%d \", node->data);\n\n        if (node->left != NULL)\n            queue[rear++] = node->left;\n        if (node->right != NULL)\n            queue[rear++] = node->right;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nunionSortedArrays__FPiiT1T2T1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        ADD      r0,r1,r3\n        MOV      r0,r0,LSL #2\n        LDR      r9,[sp,#0x20]\n        MOV      r8,r2\n        MOV      r7,r3\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r2,#0\n        MOV      r1,#0\n        MOV      r0,#0\n        B        |L1.168|\n|L1.64|\n        LDR      r3,[r5,r2,LSL #2]\n        LDR      r12,[r8,r1,LSL #2]\n        CMP      r3,r12\n        BGE      |L1.108|\n        MOV      r3,r2\n        LDR      r12,[r5,r3,LSL #2]\n        MOV      r3,r0\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r2,r2,#1\n        B        |L1.168|\n|L1.108|\n        BLE      |L1.140|\n        MOV      r3,r1\n        LDR      r12,[r8,r3,LSL #2]\n        MOV      r3,r0\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r1,r1,#1\n        B        |L1.168|\n|L1.140|\n        MOV      r3,r2\n        LDR      r12,[r5,r3,LSL #2]\n        MOV      r3,r0\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r2,r2,#1\n        ADD      r1,r1,#1\n|L1.168|\n        CMP      r2,r6\n        CMPLT    r1,r7\n        BLT      |L1.64|\n        CMP      r2,r6\n        BGE      |L1.220|\n|L1.188|\n        MOV      r3,r2\n        LDR      r12,[r5,r3,LSL #2]\n        MOV      r3,r0\n        ADD      r2,r2,#1\n        CMP      r2,r6\n        STR      r12,[r4,r3,LSL #2]\n        ADD      r0,r0,#1\n        BLT      |L1.188|\n|L1.220|\n        CMP      r1,r7\n        BGE      |L1.260|\n|L1.228|\n        MOV      r2,r1\n        LDR      r3,[r8,r2,LSL #2]\n        MOV      r2,r0\n        ADD      r1,r1,#1\n        CMP      r1,r7\n        STR      r3,[r4,r2,LSL #2]\n        ADD      r0,r0,#1\n        BLT      |L1.228|\n|L1.260|\n        STR      r0,[r9,#0]\n        MOV      r6,r0,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOVS     r5,r0\n        BNE      |L1.304|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.304|\n        MOV      r2,r6\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_memcpy_w\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* unionSortedArrays(int* arr1, int size1, int* arr2, int size2, int* sizeUnion) {\n    int* unionArr = (int*)malloc(sizeof(int) * (size1 + size2));\n    if (unionArr == NULL) return NULL;\n    int i = 0, j = 0, k = 0;\n    while (i < size1 && j < size2) {\n        if (arr1[i] < arr2[j]) {\n            unionArr[k++] = arr1[i++];\n        } else if (arr1[i] > arr2[j]) {\n            unionArr[k++] = arr2[j++];\n        } else {\n            unionArr[k++] = arr1[i++];\n            j++;\n        }\n    }\n    while (i < size1) {\n        unionArr[k++] = arr1[i++];\n    }\n    while (j < size2) {\n        unionArr[k++] = arr2[j++];\n    }\n    *sizeUnion = k;\n    int* result = (int*)malloc(sizeof(int) * k);\n    if(result == NULL) {\n        free(unionArr);\n        return NULL;\n    }\n    memcpy(result, unionArr, sizeof(int) * k);\n    free(unionArr);\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npriority__Fc PROC\n|L1.0|\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVEQ    r0,#2\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\ninfixToPrefix__FPc PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r9,r0\n        BL       strlen\n        MOV      r8,r0\n        ADD      r0,r0,#1\n        BL       malloc\n        MOV      r7,r0\n        MOV      r0,r8\n        BL       malloc\n        MVN      r4,#0\n        ADDS     r8,r8,r4\n        MOV      r6,r0\n        MOV      r5,#0\n        BMI      |L1.328|\n        BL       __rt_ctype_table\n        MOV      r3,r0\n|L1.100|\n        LDRB     r1,[r9,r8]\n        LDR      r0,[r3,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        MOVNE    r0,r5\n        STRNEB   r1,[r7,r0]\n        ADDNE    r5,r5,#1\n        BNE      |L1.280|\n        CMP      r1,#0x29\n        ADDEQ    r4,r4,#1\n        STREQB   r1,[r6,r4]\n        BEQ      |L1.280|\n        CMP      r1,#0x28\n        BNE      |L1.236|\n        B        |L1.184|\n|L1.160|\n        MOV      r0,r4\n        LDRB     r1,[r6,r0]\n        MOV      r0,r5\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        STRB     r1,[r7,r0]\n|L1.184|\n        CMN      r4,#1\n        BLE      |L1.280|\n        LDRB     r0,[r6,r4]\n        CMP      r0,#0x29\n        BNE      |L1.160|\n        SUB      r4,r4,#1\n        B        |L1.280|\n|L1.212|\n        MOV      r0,r4\n        LDRB     r2,[r6,r0]\n        MOV      r0,r5\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        STRB     r2,[r7,r0]\n|L1.236|\n        CMN      r4,#1\n        BLE      |L1.272|\n        LDRB     r0,[r6,r4]\n        BL       priority__Fc\n        MOV      r2,r0\n        MOV      r0,r1\n        BL       priority__Fc\n        CMP      r2,r0\n        BGE      |L1.212|\n|L1.272|\n        ADD      r4,r4,#1\n        STRB     r1,[r6,r4]\n|L1.280|\n        SUBS     r8,r8,#1\n        BPL      |L1.100|\n        CMN      r4,#1\n        BLE      |L1.328|\n|L1.296|\n        MOV      r0,r4\n        LDRB     r1,[r6,r0]\n        MOV      r0,r5\n        SUB      r4,r4,#1\n        CMN      r4,#1\n        ADD      r5,r5,#1\n        STRB     r1,[r7,r0]\n        BGT      |L1.296|\n|L1.328|\n        MOV      r0,#0\n        STRB     r0,[r7,r5]\n        MOV      r0,r6\n        BL       free\n        MOV      r0,r7\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint priority(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n\nchar* infixToPrefix(char* infix) {\n    int len = strlen(infix);\n    char* prefix = (char*)malloc(sizeof(char) * (len + 1));\n    char* stack = (char*)malloc(sizeof(char) * len);\n    int top = -1;\n    int prefixIndex = 0;\n\n    for (int i = len - 1; i >= 0; i--) {\n        char ch = infix[i];\n        if (isalnum(ch)) {\n            prefix[prefixIndex++] = ch;\n        } else if (ch == ')') {\n            stack[++top] = ch;\n        } else if (ch == '(') {\n            while (top > -1 && stack[top] != ')') {\n                prefix[prefixIndex++] = stack[top--];\n            }\n            if (top > -1) top--; \n        } else {\n            while (top > -1 && priority(stack[top]) >= priority(ch)) {\n                prefix[prefixIndex++] = stack[top--];\n            }\n            stack[++top] = ch;\n        }\n    }\n    while (top > -1) {\n        prefix[prefixIndex++] = stack[top--];\n    }\n    prefix[prefixIndex] = '\\0';\n    free(stack);\n    return prefix;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        BEQ      |L1.108|\n|L1.44|\n        MOV      r8,r4\n        MOV      r9,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r8\n        MOV      r7,r9\n        BNE      |L1.44|\n|L1.108|\n        MOV      r0,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n\nlcm__FxT1 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADR      r8,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r7,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r6,r0\n        BEQ      |L1.192|\n        LDMIA    r8,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BNE      |L1.204|\n|L1.192|\n        LDMIA    r8,{r0,r1}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.204|\n        UMULL    r8,r12,r6,r4\n        MLA      r12,r4,r7,r12\n        MLA      r9,r5,r6,r12\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       gcd__FxT1\n        MOV      r3,r9\n        MOV      r2,r8\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _ll_srdv\n        ENDP\n```",
        "output": "```cpp\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    if (a == 0 || b == 0) return 0;\n    return (a * b) / gcd(a, b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_divisors__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,#1\n        MOV      r4,#2\n        CMP      r0,#4\n        BLT      |L1.76|\n|L1.24|\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.60|\n        MUL      r1,r4,r4\n        CMP      r1,r6\n        ADD      r5,r5,r4\n        ADDNE    r5,r0,r5\n|L1.60|\n        ADD      r4,r4,#1\n        MUL      r0,r4,r4\n        CMP      r0,r6\n        BLE      |L1.24|\n|L1.76|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nisPerfect__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r4,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r0,r4\n        BL       sum_divisors__Fi\n        CMP      r0,r4\n        LDMFD    sp!,{r4,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_divisors(int n) {\n    int sum = 1;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            sum += i;\n            if (i * i != n) {\n                sum += n / i;\n            }\n        }\n    }\n    return sum;\n}\n\nint isPerfect(int n) {\n    if (n <= 1) return 0;\n    return sum_divisors(n) == n;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisBSTUtil__FP4nodeiT2 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLT      |L1.84|\n        CMP      r0,r5\n        BLE      |L1.96|\n|L1.84|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.96|\n        SUB      r2,r0,#1\n        LDR      r0,[r4,#4]\n        BL       isBSTUtil__FP4nodeiT2\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r0,[r4,#0]\n        MOV      r2,r5\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#8]\n        BL       isBSTUtil__FP4nodeiT2\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.152|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nisBST__FP4node PROC\n        MVN      r2,#0x80000000\n        MOV      r1,#0x80000000\n        B        isBSTUtil__FP4nodeiT2\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nint isBSTUtil(struct node* node, int min, int max) {\n    if (node == NULL) return 1;\n    if (node->data < min || node->data > max) return 0;\n    return isBSTUtil(node->left, min, node->data - 1) && isBSTUtil(node->right, node->data + 1, max);\n}\n\nint isBST(struct node* node) {\n    return isBSTUtil(node, -2147483648, 2147483647);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_array_recursive__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOVS     r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        SUB      r1,r4,#1\n        MOV      r0,r5\n        BL       sum_array_recursive__FPii\n        ADD      r1,r5,r4,LSL #2\n        LDR      r1,[r1,#-4]\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_array_recursive(int arr[], int size) {\n    if (size == 0) {\n        return 0;\n    } else {\n        return arr[size - 1] + sum_array_recursive(arr, size - 1);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.616|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #5\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0x320\n        BL       malloc\n        MOV      r1,#0\n        STMIA    r4,{r0,r1}\n        MOV      r1,#0x320\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        MVN      r1,#0\n|L1.92|\n        LDR      r2,[r4,#0]\n        STR      r1,[r2,r0,LSL #3]\n        ADD      r0,r0,#1\n        CMP      r0,#0x64\n        BLT      |L1.92|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP9HashTableiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        MOV      r6,r2\n        MOV      r5,r1\n        BL       hash__Fi\n        LDR      r2,|L1.616|\n        LDR      r1,[r4,#0]\n        B        |L1.188|\n|L1.160|\n        ADD      r0,r0,#1\n        UMULL    r12,r3,r2,r0\n        MOV      r3,r3,LSR #5\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r0,r0,r3,LSL #2\n|L1.188|\n        LDR      r3,[r1,r0,LSL #3]\n        CMP      r3,#0\n        CMNNE    r3,#1\n        BNE      |L1.160|\n        STR      r5,[r1,r0,LSL #3]\n        LDR      r1,[r4,#0]\n        ADD      r0,r1,r0,LSL #3\n        STR      r6,[r0,#4]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nsearch__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r4,r1\n        BL       hash__Fi\n        LDR      r1,[r5,#0]\n        LDR      r2,[r1,r0,LSL #3]\n        CMP      r2,#0\n        BEQ      |L1.344|\n        LDR      r2,|L1.616|\n|L1.280|\n        LDR      r3,[r1,r0,LSL #3]\n        CMP      r3,r4\n        ADDEQ    r0,r1,r0,LSL #3\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        ADD      r0,r0,#1\n        UMULL    r12,r3,r2,r0\n        MOV      r3,r3,LSR #5\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r0,r0,r3,LSL #2\n        LDR      r3,[r1,r0,LSL #3]\n        CMP      r3,#0\n        BNE      |L1.280|\n|L1.344|\n        LDMFD    sp!,{r4,r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\ndeleteEntry__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        MOV      r5,r1\n        BL       hash__Fi\n        LDR      r1,[r4,#0]\n        LDR      r2,[r1,r0,LSL #3]\n        CMP      r2,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r2,|L1.616|\n|L1.400|\n        LDR      r3,[r1,r0,LSL #3]\n        CMP      r3,r5\n        BNE      |L1.440|\n        MVN      r2,#0\n        STR      r2,[r1,r0,LSL #3]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,r2\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.440|\n        ADD      r0,r0,#1\n        UMULL    r12,r3,r2,r0\n        MOV      r3,r3,LSR #5\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r3,r3,LSL #2\n        ADD      r0,r0,r3,LSL #2\n        LDR      r3,[r1,r0,LSL #3]\n        CMP      r3,#0\n        BNE      |L1.400|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 100\n#define DELETED_MARKER -1\n\ntypedef struct {\n    int key;\n    int value;\n} Entry;\n\ntypedef struct {\n    Entry* entries;\n    int size;\n} HashTable;\n\nunsigned int hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    ht->entries = (Entry*)malloc(sizeof(Entry) * TABLE_SIZE);\n    ht->size = 0;\n    memset(ht->entries, 0, sizeof(Entry) * TABLE_SIZE);\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        ht->entries[i].key = DELETED_MARKER;\n    }\n    return ht;\n}\n\nvoid insert(HashTable* ht, int key, int value) {\n    unsigned int index = hash(key);\n    while (ht->entries[index].key != 0 && ht->entries[index].key != DELETED_MARKER) {\n        index = (index + 1) % TABLE_SIZE;\n    }\n    ht->entries[index].key = key;\n    ht->entries[index].value = value;\n    ht->size++;\n}\n\n\nint search(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    while (ht->entries[index].key != 0) {\n        if (ht->entries[index].key == key) {\n            return ht->entries[index].value;\n        }\n        index = (index + 1) % TABLE_SIZE;\n    }\n    return -1; \n}\n\nvoid deleteEntry(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    while (ht->entries[index].key != 0) {\n        if (ht->entries[index].key == key) {\n            ht->entries[index].key = DELETED_MARKER;\n            ht->size--;\n            return;\n        }\n        index = (index + 1) % TABLE_SIZE;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrotate_right__FUii PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x20\n        BL       __rt_sdiv\n        MOV      r0,r4,ROR r1\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int rotate_right(unsigned int value, int shift) {\n    int size = sizeof(value) * 8;\n    shift %= size;\n    return (value >> shift) | (value << (size - shift));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateSet__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r5,r6,LSL #2\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r1,r5\n        STR      r6,[r4,#4]\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nsetsAreEqual__FP3SetT1 PROC\n        MOVS     r12,r0\n        CMPNE    r1,#0\n        STR      lr,[sp,#-4]!\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r3,[r12,#4]\n        LDR      r0,[r1,#4]\n        CMP      r3,r0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r2,#0\n        CMP      r3,#0\n        BLE      |L1.200|\n        LDR      r0,[r1,#0]\n        LDR      r12,[r12,#0]\n|L1.164|\n        LDR      r1,[r12,r2,LSL #2]\n        LDR      lr,[r0,r2,LSL #2]\n        CMP      r1,lr\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.164|\n|L1.200|\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nfreeSet__FP3Set PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* data;\n    int size;\n} Set;\n\nSet* createSet(int size) {\n    Set* set = (Set*)malloc(sizeof(Set));\n    if (set == NULL) return NULL;\n    set->data = (int*)malloc(size * sizeof(int));\n    if (set->data == NULL) {\n        free(set);\n        return NULL;\n    }\n    set->size = size;\n    memset(set->data, 0, size * sizeof(int));\n    return set;\n}\n\n\nint setsAreEqual(Set* set1, Set* set2) {\n    if (set1 == NULL || set2 == NULL) return 0;\n    if (set1->size != set2->size) return 0;\n    for (int i = 0; i < set1->size; i++) {\n        if (set1->data[i] != set2->data[i]) return 0;\n    }\n    return 1;\n}\n\nvoid freeSet(Set* set) {\n    if (set != NULL) {\n        free(set->data);\n        free(set);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nround_to_nearest_int__Fd PROC\n        STMFD    sp!,{r3,lr}\n        ADR      r2,|L1.24|\n        LDMIA    r2,{r2,r3}\n        BL       _dadd\n        LDMFD    sp!,{r3,lr}\n        B        _dfix\n|L1.24|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nint round_to_nearest_int(double num) {\n    return (int)(num + 0.5);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisAnagram__FPcT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x400\n        SUB      sp,sp,#4\n        MOV      r6,r1\n        MOV      r5,r0\n        BL       strlen\n        MOV      r4,r0\n        MOV      r0,r6\n        BL       strlen\n        CMP      r4,r0\n        ADDNE    sp,sp,#0x400\n        ADDNE    sp,sp,#4\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r7,sp,#4\n        MOV      r0,r7\n        MOV      r1,#0x400\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.140|\n|L1.88|\n        LDRB     r1,[r5,r0]\n        ADD      r1,r7,r1,LSL #2\n        LDR      r2,[r1,#0]\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        LDRB     r1,[r6,r0]\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        ADD      r1,r7,r1,LSL #2\n        LDR      r2,[r1,#0]\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0]\n        BLT      |L1.88|\n|L1.140|\n        MOV      r0,#0\n|L1.144|\n        LDR      r1,[r7,r0,LSL #2]\n        CMP      r1,#0\n        ADDNE    sp,sp,#0x400\n        ADDNE    sp,sp,#4\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r0,r0,#1\n        CMP      r0,#0x100\n        BLT      |L1.144|\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isAnagram(char *str1, char *str2) {\n    int len1 = strlen(str1);\n    int len2 = strlen(str2);\n    if (len1 != len2) return 0;\n    int count[256] = {0};\n    for (int i = 0; i < len1; i++) {\n        count[str1[i]]++;\n        count[str2[i]]--;\n    }\n    for (int i = 0; i < 256; i++) {\n        if (count[i] != 0) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncomplex_add__F7complexT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_subtract__F7complexT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dsub\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dsub\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_multiply__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x4c\n        LDMIA    r7,{r4-r7}\n        MOV      r10,r2\n        MOV      r9,r1\n        MOV      r11,r3\n        MOV      r3,r5\n        MOV      r0,r9\n        MOV      r1,r10\n        MOV      r2,r4\n        LDR      r8,[sp,#0x48]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r2,r6\n        ADD      r6,sp,#0xc\n        STMIA    r6,{r0,r1}\n        MOV      r1,r10\n        MOV      r0,r9\n        MOV      r3,r7\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x38]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDR      r1,[sp,#0x10]\n        STR      r1,[r2,#4]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r2,#0]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    double real;\n    double imag;\n} complex;\n\ncomplex complex_add(complex a, complex b) {\n    complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\ncomplex complex_subtract(complex a, complex b) {\n    complex result;\n    result.real = a.real - b.real;\n    result.imag = a.imag - b.imag;\n    return result;\n}\n\ncomplex complex_multiply(complex a, complex b) {\n    complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrecognizeImage__F5Image PROC\n        STMFD    sp!,{r0-r3}\n        MOV      r2,sp\n        MOV      r1,#0\n        MOV      r0,#0\n|L1.16|\n        LDR      r3,[r2,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,#0x64\n        ADD      r1,r3,r1\n        BLT      |L1.16|\n        LDR      r0,|L1.148|\n        ADD      sp,sp,#0x10\n        SMULL    r3,r2,r0,r1\n        MOV      r0,r2,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r1,r0,LSL #1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n// Placeholder for CNN functionality.  Replace with actual CNN implementation.\n// This is a highly simplified example and would need a significant library\n//  (like OpenCV with a deep learning backend) for real-world use.\ntypedef struct {\n    int data[100]; //Simulate image data\n} Image;\n\ntypedef struct {\n    int prediction; // Simulate prediction result.\n} Prediction;\n\n\nPrediction recognizeImage(Image img){\n    Prediction p;\n    //Simulate prediction:  Sum all image data values modulo 10.\n    int sum = 0;\n    for (int i = 0; i < 100; i++){\n        sum += img.data[i];\n    }\n    p.prediction = sum % 10;\n    return p;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbubbleSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        SUB      r6,r1,#1\n        CMP      r6,#0\n        MOV      lr,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.24|\n        SUB      r3,r1,lr\n        SUB      r5,r3,#1\n        CMP      r5,#0\n        MOV      r2,#0\n        BLE      |L1.80|\n|L1.44|\n        LDR      r3,[r0,r2,LSL #2]\n        ADD      r4,r0,r2,LSL #2\n        LDR      r12,[r4,#4]\n        CMP      r3,r12\n        STRGT    r12,[r0,r2,LSL #2]\n        STRGT    r3,[r4,#4]\n        ADD      r2,r2,#1\n        CMP      r5,r2\n        BGT      |L1.44|\n|L1.80|\n        ADD      lr,lr,#1\n        CMP      lr,r6\n        BLT      |L1.24|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitElevator__FP8Elevator PROC\n        MOV      r1,#1\n        STRH     r1,[r0,#0]\n        MOV      r1,#0\n        STRH     r1,[r0,#2]\n        STRH     r1,[r0,#0xcc]\n        BX       lr\n        ENDP\n\naddRequest__FP8ElevatorUs PROC\n        LDRH     r2,[r0,#0xcc]\n        CMP      r2,#0x64\n        BXCS     lr\n        ADD      r3,r2,#1\n        STRH     r3,[r0,#0xcc]\n        ADD      r0,r0,r2,LSL #1\n        STRH     r1,[r0,#4]\n        BX       lr\n        ENDP\n\nmoveElevator__FP8Elevator PROC\n        LDRH     r3,[r0,#0xcc]\n        CMP      r3,#0\n        BXEQ     lr\n        LDRH     r2,[r0,#4]\n        LDRH     r1,[r0,#0]\n        CMP      r1,r2\n        BCS      |L1.104|\n        MOV      r2,#0\n        STRH     r2,[r0,#2]\n        ADD      r1,r1,#1\n        STRH     r1,[r0,#0]\n        BX       lr\n|L1.104|\n        BLS      |L1.128|\n        MOV      r2,#1\n        STRH     r2,[r0,#2]\n        SUB      r1,r1,#1\n        STRH     r1,[r0,#0]\n        BX       lr\n|L1.128|\n        SUB      r1,r3,#1\n        MOV      r1,r1,LSL #16\n        MOV      r1,r1,LSR #16\n        STRH     r1,[r0,#0xcc]\n        ADD      r1,r0,r1,LSL #1\n        LDRH     r1,[r1,#4]\n        STRH     r1,[r0,#4]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_FLOORS 10\n#define MAX_REQUESTS 100\n\ntypedef unsigned short int uint16_t;\n\nstruct Request {\n    uint16_t floor;\n    uint16_t direction; // 0: up, 1: down\n};\n\n\nstruct Elevator {\n    uint16_t currentFloor;\n    uint16_t direction; // 0: up, 1: down\n    uint16_t requests[MAX_REQUESTS];\n    uint16_t numRequests;\n};\n\n\nvoid initElevator(Elevator* elevator) {\n    elevator->currentFloor = 1;\n    elevator->direction = 0;\n    elevator->numRequests = 0;\n}\n\n\nvoid addRequest(Elevator* elevator, uint16_t floor) {\n    if (elevator->numRequests < MAX_REQUESTS) {\n        elevator->requests[elevator->numRequests++] = floor;\n    }\n}\n\n\nvoid moveElevator(Elevator* elevator) {\n    if (elevator->numRequests > 0) {\n        uint16_t nextFloor = elevator->requests[0];\n        if (elevator->currentFloor < nextFloor) {\n            elevator->direction = 0;\n            elevator->currentFloor++;\n        } else if (elevator->currentFloor > nextFloor) {\n            elevator->direction = 1;\n            elevator->currentFloor--;\n\n        } else {\n            elevator->requests[0] = elevator->requests[--elevator->numRequests];\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsphereVolume__Fd PROC\n        STMFD    sp!,{r4-r6,lr}\n        ADR      r6,|L1.84|\n        LDMIA    r6,{r2,r3}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       _dcmple\n        LDMCCIA  r6,{r0,r1}\n        LDMCCFD  sp!,{r4-r6,lr}\n        BXCC     lr\n        MOV      r1,r5\n        ADR      r0,|L1.92|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r6,lr}\n        B        _dmul\n|L1.84|\n        DCFD     0x0000000000000000\n|L1.92|\n        DCFD     0x4010c152382d7365\n        ENDP\n```",
        "output": "```cpp\n\ndouble sphereVolume(double radius) {\n    if (radius < 0) return 0;\n    return 4.0/3.0 * 3.14159265358979323846 * radius * radius * radius;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndwt__FPfi PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r5,r0\n        CMP      r1,#1\n        LDMLEFD  sp!,{r3-r11,lr}\n        BXLE     lr\n        ADD      r0,r1,r1,LSR #31\n        MOV      r6,r0,ASR #1\n        MOV      r11,r6,LSL #2\n        MOV      r0,r11\n        BL       malloc\n        MOV      r8,r0\n        MOV      r0,r11\n        BL       malloc\n        MOV      r7,r0\n        CMP      r8,#0\n        CMPNE    r7,#0\n        BNE      |L1.84|\n        ADR      r0,|L1.228|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.84|\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.164|\n        MOV      r10,#0x3f000000\n|L1.100|\n        ADD      r9,r5,r4,LSL #3\n        LDR      r1,[r9,#4]\n        LDR      r0,[r5,r4,LSL #3]\n        BL       _fadd\n        MOV      r1,r10\n        BL       _fmul\n        STR      r0,[r8,r4,LSL #2]\n        LDR      r1,[r9,#4]\n        LDR      r0,[r5,r4,LSL #3]\n        BL       _fsub\n        MOV      r1,r10\n        BL       _fmul\n        STR      r0,[r7,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.100|\n|L1.164|\n        MOV      r2,r11\n        MOV      r1,r8\n        MOV      r0,r5\n        BL       __rt_memcpy_w\n        ADD      r0,r5,r6,LSL #2\n        MOV      r2,r11\n        MOV      r1,r7\n        BL       __rt_memcpy_w\n        MOV      r0,r8\n        BL       free\n        MOV      r0,r7\n        BL       free\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r11,lr}\n        B        dwt__FPfi\n|L1.228|\n        DCB      \"Memo\"\n        DCB      \"ry a\"\n        DCB      \"lloc\"\n        DCB      \"atio\"\n        DCB      \"n fa\"\n        DCB      \"iled\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 1024\n\n//Haar wavelet transform function\nvoid dwt(float *data, int len) {\n    if (len <= 1) return;\n    int halfLen = len / 2;\n    float *approx = (float *)malloc(halfLen * sizeof(float));\n    float *detail = (float *)malloc(halfLen * sizeof(float));\n    if (!approx || !detail) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n\n\n    for (int i = 0; i < halfLen; i++) {\n        approx[i] = (data[2 * i] + data[2 * i + 1]) / 2.0f;\n        detail[i] = (data[2 * i] - data[2 * i + 1]) / 2.0f;\n    }\n\n    memcpy(data, approx, halfLen * sizeof(float));\n    memcpy(data + halfLen, detail, halfLen * sizeof(float));\n\n    free(approx);\n    free(detail);\n    dwt(data, halfLen);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrotateRight__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nrotateLeft__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.336|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.336|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.368|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.396|\n|L1.368|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.396|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rotateRight__FP4Node\n        CMN      r0,#1\n        BGE      |L1.500|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      rotateLeft__FP4Node\n        B        |L1.552|\n|L1.500|\n        CMP      r0,#1\n        BLE      |L1.544|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.588|\n        BL       rotateLeft__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rotateRight__FP4Node\n|L1.544|\n        CMN      r0,#1\n        BGE      |L1.588|\n|L1.552|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.588|\n        BL       rotateRight__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rotateLeft__FP4Node\n|L1.588|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nfindDeepest__FP4NodeRiiRP4Node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r3\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        MOV      r3,r6\n        CMP      r0,r2\n        STRLT    r2,[r5,#0]\n        STRLT    r4,[r6,#0]\n        ADD      r2,r2,#1\n        MOV      r7,r2\n        LDR      r0,[r4,#8]\n        MOV      r1,r5\n        BL       findDeepest__FP4NodeRiiRP4Node\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       findDeepest__FP4NodeRiiRP4Node\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *node) {\n    return node ? node->height : 0;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rotateRight(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\n\nNode* rotateLeft(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if(N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rotateRight(node);\n\n    if (balance < -1 && key > node->right->key)\n        return rotateLeft(node);\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = rotateLeft(node->left);\n        return rotateRight(node);\n    }\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rotateRight(node->right);\n        return rotateLeft(node);\n    }\n\n    return node;\n}\n\n\nint findDeepest(Node* node, int& maxDepth, int currentDepth, Node*& deepestNode){\n    if(node == NULL) return 0;\n    if(currentDepth > maxDepth){\n        maxDepth = currentDepth;\n        deepestNode = node;\n    }\n    findDeepest(node->left, maxDepth, currentDepth + 1, deepestNode);\n    findDeepest(node->right, maxDepth, currentDepth + 1, deepestNode);\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nprocess_file__FPc PROC\n        STMFD    sp!,{r3-r7,lr}\n        ADR      r1,|L1.188|\n        BL       fopen\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r6,#0\n        MOV      r4,#0\n        MOV      r7,sp\n        MOV      r2,sp\n        ADR      r1,|L1.192|\n        MOV      r0,r5\n        BL       _fscanf\n        CMP      r0,#1\n        BNE      |L1.100|\n|L1.64|\n        LDR      r0,[sp,#0]\n        ADD      r4,r4,#1\n        ADD      r6,r6,r0\n        MOV      r0,r5\n        MOV      r2,r7\n        ADR      r1,|L1.192|\n        BL       _fscanf\n        CMP      r0,#1\n        BEQ      |L1.64|\n|L1.100|\n        MOV      r0,r5\n        BL       fclose\n        CMP      r4,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r0,r6\n        BL       _dflt\n        MOV      r5,r0\n        MOV      r0,r4\n        MOV      r6,r1\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _drdiv\n        MOV      r2,r1\n        MOV      r1,r0\n        ADR      r0,|L1.196|\n        BL       printf\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.188|\n        DCB      \"r\\0\\0\\0\"\n|L1.192|\n        DCB      \"%d\\0\\0\"\n|L1.196|\n        DCB      \"%f\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint process_file(char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) return 1;\n\n    int sum = 0;\n    int count = 0;\n    int num;\n\n    while (fscanf(file, \"%d\", &num) == 1) {\n        sum += num;\n        count++;\n    }\n\n    fclose(file);\n\n    if (count == 0) return 1;\n\n    printf(\"%f\\n\", (double)sum / count);\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nenqueue__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        LDR      lr,|L1.528|\n        LDR      r3,|L1.532|\n        LDR      r2,[lr,#4]  ; tail\n        ADD      r1,r2,#1\n        SMULL    r4,r12,r3,r1\n        MOV      r12,r12,ASR #5\n        SUB      r12,r12,r12,ASR #31\n        SUB      r12,r12,r12,LSL #1\n        ADD      r12,r12,r12,LSL #2\n        ADD      r12,r12,r12,LSL #2\n        LDR      r4,[lr,#0]  ; head\n        ADD      r12,r1,r12,LSL #2\n        CMP      r12,r4\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r12,|L1.536|\n        STR      r0,[r12,r2,LSL #2]\n        SMULL    r2,r0,r3,r1\n        MOV      r0,r0,ASR #5\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r1,r0,LSL #2\n        STR      r0,[lr,#4]  ; tail\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__Fv PROC\n        LDR      r12,|L1.528|\n        LDR      r0,[r12,#4]  ; head, tail\n        LDR      r1,[r12,#0]\n        CMP      r1,r0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STR      lr,[sp,#-4]!\n        LDR      r0,|L1.536|\n        LDR      r2,|L1.532|\n        LDR      r0,[r0,r1,LSL #2]\n        ADD      r1,r1,#1\n        SMULL    lr,r3,r2,r1\n        MOV      r2,r3,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADD      r1,r1,r2,LSL #2\n        STR      r1,[r12,#0]  ; head\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nisBipartite__FPA100_ii PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x194\n        ADD      r9,sp,#4\n        MOV      r10,r0\n        MOV      r6,r1\n        MVN      r1,#0\n        MOV      r0,r9\n        MOV      r2,#0x190\n        BL       __rt_memset\n        MOV      r7,#0\n        CMP      r6,#0\n        BLE      |L1.436|\n        LDR      r11,|L1.528|\n|L1.256|\n        LDR      r0,[r9,r7,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.424|\n        MOV      r0,r7\n        BL       enqueue__Fi\n        MOV      r0,#0\n        STR      r0,[r9,r7,LSL #2]\n        LDMIA    r11,{r0,r1}  ; head, tail\n        CMP      r0,r1\n        BEQ      |L1.424|\n|L1.296|\n        BL       dequeue__Fv\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.412|\n        ADD      r0,r5,r5,LSL #3\n        ADD      r0,r0,r5,LSL #4\n        ADD      r8,r10,r0,LSL #4\n|L1.328|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#1\n        BNE      |L1.400|\n        LDR      r0,[r9,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.376|\n        LDR      r0,[r9,r5,LSL #2]\n        RSB      r0,r0,#1\n        STR      r0,[r9,r4,LSL #2]\n        MOV      r0,r4\n        BL       enqueue__Fi\n        B        |L1.400|\n|L1.376|\n        LDR      r1,[r9,r5,LSL #2]\n        CMP      r0,r1\n        ADDEQ    sp,sp,#0x194\n        LDMEQFD  sp!,{r4-r11,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n|L1.400|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.328|\n|L1.412|\n        LDMIA    r11,{r0,r1}  ; head, tail\n        CMP      r0,r1\n        BNE      |L1.296|\n|L1.424|\n        ADD      r7,r7,#1\n        CMP      r7,r6\n        BLT      |L1.256|\n|L1.436|\n        ADD      sp,sp,#0x194\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\nint queue[MAX_SIZE];\nint head = 0;\nint tail = 0;\n\nint enqueue(int value) {\n    if ((tail + 1) % MAX_SIZE == head) return 0;\n    queue[tail] = value;\n    tail = (tail + 1) % MAX_SIZE;\n    return 1;\n}\n\nint dequeue() {\n    if (head == tail) return -1;\n    int value = queue[head];\n    head = (head + 1) % MAX_SIZE;\n    return value;\n}\n\n\nint isBipartite(int graph[MAX_SIZE][MAX_SIZE], int numNodes) {\n    int color[MAX_SIZE];\n    memset(color, -1, sizeof(color));\n\n    for (int i = 0; i < numNodes; i++) {\n        if (color[i] == -1) {\n            enqueue(i);\n            color[i] = 0;\n\n            while (head != tail) {\n                int node = dequeue();\n                for (int j = 0; j < numNodes; j++) {\n                    if (graph[node][j] == 1 && color[j] == -1) {\n                        color[j] = 1 - color[node];\n                        enqueue(j);\n                    } else if (graph[node][j] == 1 && color[j] == color[node]) {\n                        return 0; \n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntrapezoidalRule__FPFd_ddT2i PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r10,r3\n        SUB      sp,sp,#0xc\n        LDR      r9,[sp,#0x30]\n        MOV      r3,r2\n        MOV      r7,r2\n        MOV      r2,r1\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r0,r10\n        MOV      r1,r9\n        LDR      r4,[sp,#0x34]\n        BL       _dsub\n        MOV      r8,r0\n        MOV      r0,r4\n        MOV      r11,r1\n        BL       _dflt\n        MOV      r3,r11\n        MOV      r2,r8\n        BL       _drdiv\n        MOV      r8,r0\n        STR      r1,[sp,#8]\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      lr,pc\n        BX       r5\n        MOV      r11,r0\n        STR      r1,[sp,#4]\n        MOV      r1,r9\n        MOV      r0,r10\n        MOV      lr,pc\n        BX       r5\n        MOV      r2,r11\n        LDR      r3,[sp,#4]\n        BL       _dadd\n        ADR      r2,|L1.272|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r9,#1\n        CMP      r4,#1\n        BLE      |L1.244|\n|L1.172|\n        MOV      r0,r9\n        BL       _dflt\n        MOV      r2,r8\n        LDR      r3,[sp,#8]\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      lr,pc\n        BX       r5\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dadd\n        ADD      r9,r9,#1\n        CMP      r9,r4\n        MOV      r10,r0\n        MOV      r11,r1\n        BLT      |L1.172|\n|L1.244|\n        LDR      r3,[sp,#8]\n        ADD      sp,sp,#0xc\n        MOV      r2,r8\n        MOV      r1,r11\n        MOV      r0,r10\n        LDMFD    sp!,{r4-r11,lr}\n        B        _dmul\n|L1.272|\n        DCFD     0x3fe0000000000000\n        ENDP\n\nmyFunc__Fd PROC\n        MOV      r3,r1\n        MOV      r2,r0\n        B        _dmul\n        ENDP\n```",
        "output": "```cpp\n\ndouble trapezoidalRule(double (*func)(double), double a, double b, int n) {\n    double h = (b - a) / n;\n    double sum = 0.5 * (func(a) + func(b));\n    for (int i = 1; i < n; i++) {\n        sum += func(a + i * h);\n    }\n    return sum * h;\n}\n\ndouble myFunc(double x) {\n    return x * x;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r1\n        LDMEQFD  sp!,{r4,lr}\n        BEQ      createNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.88|\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.100|\n|L1.88|\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.100|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nminValueNode__FP4Node PROC\n        B        |L1.120|\n|L1.116|\n        MOV      r0,r1\n|L1.120|\n        CMP      r0,#0\n        LDRNE    r1,[r0,#4]\n        CMPNE    r1,#0\n        BNE      |L1.116|\n        BX       lr\n        ENDP\n\ndeleteNode__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r4,r0\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r1\n        BLE      |L1.188|\n        LDR      r0,[r4,#4]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.304|\n|L1.188|\n        BGE      |L1.208|\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.304|\n|L1.208|\n        LDR      r5,[r4,#4]\n        CMP      r5,#0\n        BNE      |L1.244|\n        LDR      r5,[r4,#8]\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.244|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.276|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.276|\n        BL       minValueNode__FP4Node\n        LDR      r1,[r0,#0]\n        STR      r1,[r4,#0]\n        LDR      r1,[r0,#0]\n        LDR      r0,[r4,#8]\n        BL       deleteNode__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.304|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsearch__FP4Nodei PROC\n|L1.316|\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        CMPNE    r2,r1\n        BXEQ     lr\n        LDRLE    r0,[r0,#8]\n        LDRGT    r0,[r0,#4]\n        B        |L1.316|\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\n\nstruct Node* insert(struct Node* root, int data) {\n    if (root == NULL) return createNode(data);\n    if (data < root->data) root->left = insert(root->left, data);\n    else root->right = insert(root->right, data);\n    return root;\n}\n\n\nstruct Node* minValueNode(struct Node* node) {\n    struct Node* current = node;\n    while (current && current->left != NULL) current = current->left;\n    return current;\n}\n\n\nstruct Node* deleteNode(struct Node* root, int data) {\n    if (root == NULL) return root;\n    if (data < root->data) root->left = deleteNode(root->left, data);\n    else if (data > root->data) root->right = deleteNode(root->right, data);\n    else {\n        if (root->left == NULL) {\n            struct Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        struct Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\n\nstruct Node* search(struct Node* root, int data) {\n    if (root == NULL || root->data == data) return root;\n    if (data < root->data) return search(root->left, data);\n    return search(root->right, data);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninorderTraversal__FP4NodePFi_v PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       inorderTraversal__FP4NodePFi_v\n        LDR      r0,[r4,#0]\n        MOV      lr,pc\n        BX       r5\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        B        inorderTraversal__FP4NodePFi_v\n        ENDP\n\nprintInt__Fi PROC\n        MOV      r1,r0\n        ADR      r0,|L1.72|\n        B        _printf\n|L1.72|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid inorderTraversal(Node *root, void (*func)(int)) {\n    if (root == NULL) return;\n    inorderTraversal(root->left, func);\n    func(root->data);\n    inorderTraversal(root->right, func);\n}\n\nvoid printInt(int i) {\n    printf(\"%d \", i);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\naddNeighbor__FP4NodeT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        CMPNE    r6,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r4,#8]\n        CMP      r1,r0\n        BNE      |L1.144|\n        CMP      r0,#0\n        MOVNE    r5,r0,LSL #1\n        MOVEQ    r5,#1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#4]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#4]\n        STR      r5,[r4,#0xc]\n|L1.144|\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#8]\n        LDR      r1,[r4,#4]\n        STR      r6,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node Node;\n\nstruct Node {\n    int data;\n    Node** neighbors;\n    int neighborCount;\n    int neighborCapacity;\n};\n\nNode* createNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    if (node == NULL) return NULL;\n    node->data = data;\n    node->neighbors = NULL;\n    node->neighborCount = 0;\n    node->neighborCapacity = 0;\n    return node;\n}\n\nint addNeighbor(Node* node, Node* neighbor) {\n    if (node == NULL || neighbor == NULL) return 0;\n    if (node->neighborCount == node->neighborCapacity) {\n        int newCapacity = node->neighborCapacity == 0 ? 1 : node->neighborCapacity * 2;\n        Node** newNeighbors = (Node**)realloc(node->neighbors, newCapacity * sizeof(Node*));\n        if (newNeighbors == NULL) return 0;\n        node->neighbors = newNeighbors;\n        node->neighborCapacity = newCapacity;\n    }\n    node->neighbors[node->neighborCount++] = neighbor;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhanoi__FiN31 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        MOV      r4,r0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        SUB      r0,r4,#1\n        MOV      r8,r0\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r5\n        BL       hanoi__FiN31\n        MOV      r3,r6\n        MOV      r2,r5\n        MOV      r1,r4\n        ADR      r0,|L1.100|\n        BL       _printf\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r7\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r8,lr}\n        B        hanoi__FiN31\n|L1.100|\n        DCB      \"%d %\"\n        DCB      \"d %d\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid hanoi(int n, int source, int destination, int auxiliary) {\n    if (n > 0) {\n        hanoi(n - 1, source, auxiliary, destination);\n        printf(\"%d %d %d\\n\", n, source, destination);\n        hanoi(n - 1, auxiliary, destination, source);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncomplex_add__F7complexT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dadd\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_sub__F7complexT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r10,r0\n        MOV      r0,r1\n        MOV      r1,r2\n        ADD      r5,sp,#0x24\n        MOV      r9,r3\n        LDMIA    r5,{r2-r5}\n        LDR      r6,[sp,#0x20]\n        BL       _dsub\n        MOV      r7,r0\n        MOV      r8,r1\n        MOV      r1,r6\n        MOV      r0,r9\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dsub\n        STMIA    r10,{r7,r8}\n        ADD      r2,r10,#8\n        STMIA    r2,{r0,r1}\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ncomplex_mul__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x4c\n        LDMIA    r7,{r4-r7}\n        MOV      r10,r2\n        MOV      r9,r1\n        MOV      r11,r3\n        MOV      r3,r5\n        MOV      r0,r9\n        MOV      r1,r10\n        MOV      r2,r4\n        LDR      r8,[sp,#0x48]\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        MOV      r2,r6\n        ADD      r6,sp,#0xc\n        STMIA    r6,{r0,r1}\n        MOV      r1,r10\n        MOV      r0,r9\n        MOV      r3,r7\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r8\n        MOV      r0,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x38]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDR      r1,[sp,#0x10]\n        STR      r1,[r2,#4]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r2,#0]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\ncomplex_div__F7complexT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x14\n        ADD      r7,sp,#0x4c\n        LDMIA    r7,{r4-r7}\n        MOV      r11,r1\n        MOV      r1,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r0,r4\n        LDR      r10,[sp,#0x48]\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        MOV      r8,r0\n        MOV      r9,r1\n        LDR      r1,[sp,#0x40]\n        MOV      r0,r11\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        LDR      r0,[sp,#0x44]\n        MOV      r1,r10\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _dadd\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n        MOV      r2,r4\n        ADD      r4,sp,#0xc\n        STMIA    r4,{r0,r1}\n        LDR      r0,[sp,#0x44]\n        MOV      r1,r10\n        MOV      r3,r5\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        LDR      r1,[sp,#0x40]\n        MOV      r0,r11\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _ddiv\n        LDR      r2,[sp,#0x38]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        LDR      r1,[sp,#0x10]\n        STR      r1,[r2,#4]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r2,#0]\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    double real;\n    double imag;\n} complex;\n\ncomplex complex_add(complex a, complex b) {\n    complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\ncomplex complex_sub(complex a, complex b) {\n    complex result;\n    result.real = a.real - b.real;\n    result.imag = a.imag - b.imag;\n    return result;\n}\n\ncomplex complex_mul(complex a, complex b) {\n    complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\ncomplex complex_div(complex a, complex b) {\n    complex result;\n    double denominator = b.real * b.real + b.imag * b.imag;\n    result.real = (a.real * b.real + a.imag * b.imag) / denominator;\n    result.imag = (a.imag * b.real - a.real * b.imag) / denominator;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhasCycle__FP4Node PROC\n        MOV      r1,r0\n        B        |L1.28|\n|L1.8|\n        LDR      r1,[r1,#4]\n        LDR      r0,[r0,#4]\n        CMP      r1,r0\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.28|\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        CMPNE    r0,#0\n        BNE      |L1.8|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nint hasCycle(struct Node *head) {\n    struct Node *slow = head;\n    struct Node *fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) return 1;\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nvalidate_input__FiN21 PROC\n        CMP      r0,r1\n        BLT      |L1.16|\n        CMP      r0,r2\n        BXLE     lr\n|L1.16|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint validate_input(int input, int min, int max) {\n    if (input >= min && input <= max) {\n        return input;\n    } else {\n        return -1; \n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncombinations__FiT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r0\n        MOV      r5,r1\n        CMP      r1,#0\n        BLT      |L1.28|\n        CMP      r5,r6\n        BLE      |L1.44|\n|L1.28|\n        ADR      r1,|L1.164|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.44|\n        CMP      r5,#0\n        CMPNE    r5,r6\n        ADR      r1,|L1.172|\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        ADD      r0,r6,r6,LSR #31\n        MOV      r0,r0,ASR #1\n        CMP      r0,r5\n        SUBLT    r5,r6,r5\n        CMP      r5,#1\n        LDMIA    r1,{r0,r1}\n        MOV      r4,#1\n        LDMLTFD  sp!,{r4-r8,lr}\n        BXLT     lr\n|L1.104|\n        SUB      r2,r6,r4\n        ADD      r2,r2,#1\n        UMULL    r7,r12,r0,r2\n        MLA      r12,r2,r1,r12\n        MOV      r3,r2,ASR #31\n        MLA      r3,r0,r3,r12\n        MOV      r0,r4\n        MOV      r2,r7\n        MOV      r1,r4,ASR #31\n        BL       _ll_srdv\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLE      |L1.104|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.164|\n        DCQ      0x0000000000000000\n|L1.172|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nlong long combinations(int n, int r) {\n    if (r < 0 || r > n) return 0;\n    if (r == 0 || r == n) return 1;\n    if (r > n / 2) r = n - r;\n    long long res = 1;\n    for (int i = 1; i <= r; ++i) {\n        res = res * (n - i + 1) / i;\n    }\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverseString__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        SUB      r0,r0,#1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.32|\n        LDRB     r3,[r4,r0]\n        LDRB     r2,[r4,r1]\n        STRB     r3,[r4,r1]\n        STRB     r2,[r4,r0]\n        SUB      r0,r0,#1\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.32|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverseString(char *str) {\n    int n = strlen(str);\n    int start = 0;\n    int end = n - 1;\n    while (start < end) {\n        char temp = str[start];\n        str[start] = str[end];\n        str[end] = temp;\n        start++;\n        end--;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisdigit_impl__Fc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       __rt_ctype_table\n        LDR      r0,[r0,#0]\n        LDRB     r0,[r0,r4]\n        LDMFD    sp!,{r4,lr}\n        AND      r0,r0,#0x20\n        BX       lr\n        ENDP\n\nparseNumber__Fv PROC\n        STMFD    sp!,{r3-r5,lr}\n        LDR      r5,|L1.408|\n        MOV      r4,#0\n        LDR      r0,[r5,#4]  ; input, pos\n        LDR      r1,[r5,#0]\n        LDRB     r0,[r0,r1]\n        BL       isdigit_impl__Fc\n        CMP      r0,#0\n        BEQ      |L1.116|\n|L1.68|\n        LDR      r0,[r5,#4]  ; input, pos\n        LDR      r1,[r5,#0]\n        ADD      r3,r4,r4,LSL #2\n        LDRB     r2,[r0,r1]\n        ADD      r1,r1,#1\n        STR      r1,[r5,#0]  ; pos\n        ADD      r2,r2,r3,LSL #1\n        SUB      r4,r2,#0x30\n        LDRB     r0,[r0,r1]\n        BL       isdigit_impl__Fc\n        CMP      r0,#0\n        BNE      |L1.68|\n|L1.116|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nparseExpr__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        BL       parseTerm__Fv\n        MOV      r4,r0\n        LDR      r6,|L1.408|\n        B        |L1.172|\n|L1.148|\n        ADD      r0,r0,#1\n        STR      r0,[r6,#0]  ; pos\n        BL       parseTerm__Fv\n        CMP      r5,#0x2b\n        SUBNE    r4,r4,r0\n        ADDEQ    r4,r4,r0\n|L1.172|\n        LDMIA    r6,{r0,r1}  ; input, pos\n        LDRB     r5,[r1,r0]\n        CMP      r5,#0x2b\n        CMPNE    r5,#0x2d\n        BEQ      |L1.148|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nparseTerm__Fv PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.408|\n        LDR      r0,[r4,#4]  ; input, pos\n        LDR      r1,[r4,#0]\n        LDRB     r0,[r0,r1]\n        CMP      r0,#0x28\n        BNE      |L1.280|\n        ADD      r0,r1,#1\n        STR      r0,[r4,#0]  ; pos\n        BL       parseExpr__Fv\n        LDR      r1,[r4,#4]  ; input, pos\n        LDR      r2,[r4,#0]\n        LDRB     r1,[r1,r2]\n        CMP      r1,#0x29\n        ADDEQ    r1,r2,#1\n        STREQ    r1,[r4,#0]  ; pos\n        LDMFD    sp!,{r4,lr}\n        MVNNE    r0,#0\n        BX       lr\n|L1.280|\n        BL       isdigit_impl__Fc\n        CMP      r0,#0\n        MVNEQ    r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        BNE      parseNumber__Fv\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nparse__FPc PROC\n        LDR      r1,|L1.408|\n        STMFD    sp!,{r3,lr}\n        STR      r0,[r1,#4]  ; input\n        MOV      r0,#0\n        STR      r0,[r1,#0]  ; pos\n        BL       parseExpr__Fv\n        LDMFD    sp!,{r3,lr}\n        CMN      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint pos = 0;\nchar *input;\n\nint isdigit_impl(char c){\n    return isdigit(c);\n}\n\nint parseNumber() {\n    int result = 0;\n    while (isdigit_impl(input[pos])) {\n        result = result * 10 + (input[pos] - '0');\n        pos++;\n    }\n    return result;\n}\n\nint parseExpr();\n\nint parseTerm() {\n    int result;\n    if (input[pos] == '(') {\n        pos++;\n        result = parseExpr();\n        if (input[pos] != ')') return -1;\n        pos++;\n    } else if (isdigit_impl(input[pos])) {\n        result = parseNumber();\n    } else {\n        return -1;\n    }\n    return result;\n}\n\nint parseExpr() {\n    int left = parseTerm();\n    while (input[pos] == '+' || input[pos] == '-') {\n        char op = input[pos];\n        pos++;\n        int right = parseTerm();\n        if (op == '+') left += right;\n        else left -= right;\n    }\n    return left;\n}\n\n\nint parse(char *expression){\n    input = expression;\n    pos = 0;\n    int result = parseExpr();\n    return result == -1 ? -1 : result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisIsomorphic__FP4NodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#4]\n        BL       isIsomorphic__FP4NodeT1\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#8]\n        BL       isIsomorphic__FP4NodeT1\n        CMP      r0,#0\n        BNE      |L1.192|\n|L1.152|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#4]\n        BL       isIsomorphic__FP4NodeT1\n        CMP      r0,#0\n        BEQ      |L1.204|\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#8]\n        BL       isIsomorphic__FP4NodeT1\n        CMP      r0,#0\n        BEQ      |L1.204|\n|L1.192|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.204|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint isIsomorphic(struct Node *root1, struct Node *root2) {\n    if (root1 == NULL && root2 == NULL) return 1;\n    if (root1 == NULL || root2 == NULL) return 0;\n\n    if (root1->data != root2->data) return 0;\n\n    return (isIsomorphic(root1->left, root2->left) && isIsomorphic(root1->right, root2->right)) ||\n           (isIsomorphic(root1->left, root2->right) && isIsomorphic(root1->right, root2->left));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nlca__FP4NodeiT2 PROC\n|L1.608|\n        CMP      r0,#0\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        CMP      r3,r1\n        CMPGT    r3,r2\n        LDRGT    r0,[r0,#4]\n        BGT      |L1.608|\n        CMP      r3,r1\n        CMPLT    r3,r2\n        LDRLT    r0,[r0,#8]\n        BLT      |L1.608|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return(node);\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n    node->height = 1 + max(height(node->left),height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nNode* lca(Node* root, int n1, int n2) {\n    if (root == NULL) return NULL;\n    if (root->data > n1 && root->data > n2)\n        return lca(root->left, n1, n2);\n    if (root->data < n1 && root->data < n2)\n        return lca(root->right, n1, n2);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0xc]\n        STMIA    r0,{r4,r5}\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbuildTree__FPiT1iN23 PROC\n        STMFD    sp!,{r3-r9,lr}\n        LDR      r8,[sp,#0x20]\n        MOV      r9,r1\n        MOV      r7,r2\n        MOV      r6,r0\n        MOV      r4,r3\n        CMP      r3,r2\n        BGE      |L1.88|\n        LDR      r0,[r6,r4,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.100|\n|L1.88|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.100|\n        MOV      r1,r8\n        BL       newNode__FiT1\n        ADD      r3,r8,#1\n        MOV      r5,r0\n        MOV      r0,#1\n        MOV      r8,r3\n        STR      r3,[sp,#0]\n        ADD      r3,r0,r4,LSL #1\n        MOV      r0,r6\n        MOV      r2,r7\n        MOV      r1,r9\n        BL       buildTree__FPiT1iN23\n        STR      r0,[r5,#8]\n        MOV      r0,#2\n        ADD      r3,r0,r4,LSL #1\n        MOV      r0,r6\n        STR      r8,[sp,#0]\n        MOV      r2,r7\n        MOV      r1,r9\n        BL       buildTree__FPiT1iN23\n        STR      r0,[r5,#0xc]\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    int level;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data, int level) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->level = level;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* buildTree(int* arr, int* levelArr, int n, int index, int level) {\n    if (index >= n || arr[index] == -1) return NULL;\n\n    struct Node* root = newNode(arr[index], level);\n    root->left = buildTree(arr, levelArr, n, 2 * index + 1, level + 1);\n    root->right = buildTree(arr, levelArr, n, 2 * index + 2, level + 1);\n\n    return root;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsolveQuadratic__FdN21PdT4 PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#4\n        ADD      r11,sp,#0x40\n        MOV      r9,r3\n        ADR      r3,|L1.340|\n        LDMIA    r11,{r10,r11}\n        LDMIB    sp,{r0,r1}\n        MOV      r8,r2\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r7,r1\n        MOV      r6,r0\n        MOV      r0,r8\n        MOV      r1,r9\n        EOR      r5,r9,#0x80000000\n        MOV      r4,r8\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        MOV      r8,r0\n        ADR      r0,|L1.348|\n        LDMIA    r0,{r2,r3}\n        MOV      r9,r1\n        LDMIB    sp,{r0,r1}\n        BL       _dmul\n        ADD      r3,sp,#0x38\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _drsb\n        MOV      r8,r0\n        ADR      r0,|L1.356|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r9,r1\n        BL       _dcmple\n        ADDCC    sp,sp,#0x14\n        LDMCCFD  sp!,{r4-r11,lr}\n        MOVCC    r0,#0\n        BXCC     lr\n        MOV      r1,r9\n        ADR      r0,|L1.356|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        BL       _dcmpeq\n        BNE      |L1.228|\n        MOV      r2,r4\n        MOV      r3,r5\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _drdiv\n        STMIA    r10,{r0,r1}\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.228|\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _drdiv\n        STMIA    r10,{r0,r1}\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _drsb\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _drdiv\n        STMIA    r11,{r0,r1}\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#2\n        BX       lr\n|L1.340|\n        DCFD     0x4000000000000000\n|L1.348|\n        DCFD     0x4010000000000000\n|L1.356|\n        DCFD     0x0000000000000000\n        ENDP\n\nfindIntersectionPoints__F6CircleT1P5PointT3 PROC\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x44\n        MOV      r9,r3\n        ADD      r3,sp,#0x70\n        MOV      r8,r2\n        LDMIA    r3,{r2,r3}\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       _dsub\n        MOV      r4,r0\n        MOV      r0,#2\n        MOV      r5,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __softfp_pow\n        ADD      r3,sp,#0x78\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        LDMIA    r3,{r2,r3}\n        BL       _dsub\n        MOV      r10,r0\n        MOV      r0,#2\n        MOV      r11,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        BL       __softfp_pow\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        BL       __softfp_sqrt\n        MOV      r5,r1\n        ADD      r1,sp,#0x68\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        ADD      r3,sp,#0x80\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dcmple\n        BCC      |L1.600|\n        ADD      r1,sp,#0x68\n        LDMIA    r1,{r0,r1}\n        ADD      r3,sp,#0x80\n        LDMIA    r3,{r2,r3}\n        BL       _dsub\n        BIC      r1,r1,#0x80000000\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dcmpge\n        BLS      |L1.616|\n|L1.600|\n        ADD      sp,sp,#0x44\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.616|\n        ADD      r1,sp,#0x70\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dsub\n        ADR      r2,|L1.340|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADD      r4,sp,#0x34\n        STMIA    r4,{r0,r1}\n        ADD      r1,sp,#0x78\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dsub\n        ADR      r2,|L1.340|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADD      r3,sp,#0x68\n        LDMIA    r3,{r2,r3}\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r3\n        MOV      r0,r2\n        BL       _dmul\n        STR      r0,[sp,#0x40]\n        STR      r1,[sp,#0x3c]\n        ADD      r3,sp,#0x80\n        LDMIA    r3,{r2,r3}\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r3\n        MOV      r0,r2\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        ADD      r10,sp,#0x24\n        STMIA    r10,{r0,r1}\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        ADD      r3,sp,#0x70\n        LDMIA    r3,{r2,r3}\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r3\n        MOV      r0,r2\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        ADD      r10,sp,#0x2c\n        STMIA    r10,{r0,r1}\n        MOV      r1,r9\n        MOV      r0,r8\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        ADD      r3,sp,#0x78\n        LDMIA    r3,{r2,r3}\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r1,r3\n        MOV      r0,r2\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        ADD      r3,sp,#0x2c\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        MOV      r10,r0\n        MOV      r11,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        ADD      r2,sp,#0xc\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x40]\n        LDR      r1,[sp,#0x3c]\n        MOV      r2,r4\n        MOV      r3,r5\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        ADD      r2,sp,#0x1c\n        STMIA    r2,{r0,r1}\n        ADR      r2,|L1.340|\n        LDMIA    r2,{r2,r3}\n        ADD      r1,sp,#0x34\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _dmul\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        ADD      r3,sp,#0x34\n        LDMIA    r3,{r2,r3}\n        MOV      r0,r2\n        MOV      r1,r3\n        BL       _dmul\n        ADD      r12,sp,#0xc\n        STMIA    r12,{r0,r1}\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        ADD      r3,sp,#0x24\n        ADD      r2,sp,#0x2c\n        ADD      r12,sp,#8\n        STMIA    r12,{r2,r3}\n        ADD      r3,sp,#0x1c\n        LDMIA    r3,{r2,r3}\n        STMIA    sp,{r2,r3}\n        ADD      r3,sp,#0x14\n        LDMIA    r3,{r2,r3}\n        BL       solveQuadratic__FdN21PdT4\n        CMP      r0,#0\n        ADDEQ    sp,sp,#0x44\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        ADD      r3,sp,#0x2c\n        LDMIA    r3,{r2,r3}\n        CMP      r0,#1\n        BNE      |L1.1296|\n        ADD      r1,sp,#0x34\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ddiv\n        MOV      r5,r1\n        ADD      r1,sp,#0x2c\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x88]\n        MOV      r3,r9\n        STMIA    r2,{r0,r1}\n        MOV      r2,r8\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dadd\n        LDR      r2,[sp,#0x88]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        ADD      sp,sp,#0x44\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.1296|\n        ADD      r1,sp,#0x34\n        LDMIA    r1,{r0,r1}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ddiv\n        ADD      r2,sp,#0x1c\n        STMIA    r2,{r0,r1}\n        ADD      r1,sp,#0x34\n        LDMIA    r1,{r0,r1}\n        ADD      r3,sp,#0x24\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _drsb\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _ddiv\n        MOV      r5,r1\n        ADD      r1,sp,#0x2c\n        MOV      r4,r0\n        LDMIA    r1,{r0,r1}\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x88]\n        MOV      r3,r9\n        STMIA    r2,{r0,r1}\n        ADD      r1,sp,#0x1c\n        LDMIA    r1,{r0,r1}\n        MOV      r2,r8\n        BL       _dadd\n        LDR      r2,[sp,#0x88]\n        MOV      r3,r7\n        ADD      r7,r2,#8\n        STMIA    r7,{r0,r1}\n        ADD      r1,sp,#0x24\n        LDMIA    r1,{r0,r1}\n        MOV      r2,r6\n        BL       _dadd\n        LDR      r2,[sp,#0x8c]\n        MOV      r3,r9\n        STMIA    r2,{r0,r1}\n        MOV      r2,r8\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dadd\n        LDR      r2,[sp,#0x8c]\n        ADD      r3,r2,#8\n        STMIA    r3,{r0,r1}\n        ADD      sp,sp,#0x44\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point {\n    double x;\n    double y;\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\nint solveQuadratic(double a, double b, double c, double* x1, double* x2) {\n    double discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) return 0;\n    if (discriminant == 0) {\n        *x1 = -b / (2 * a);\n        return 1;\n    }\n    *x1 = (-b + sqrt(discriminant)) / (2 * a);\n    *x2 = (-b - sqrt(discriminant)) / (2 * a);\n    return 2;\n}\n\n\nint findIntersectionPoints(Circle c1, Circle c2, Point* p1, Point* p2) {\n    double d = sqrt(pow(c1.center.x - c2.center.x, 2) + pow(c1.center.y - c2.center.y, 2));\n    if (d > c1.radius + c2.radius || d < fabs(c1.radius - c2.radius)) return 0;\n    double a = 2 * (c2.center.x - c1.center.x);\n    double b = 2 * (c2.center.y - c1.center.y);\n    double c = c1.radius * c1.radius - c2.radius * c2.radius - (c1.center.x * c1.center.x - c2.center.x * c2.center.x) - (c1.center.y * c1.center.y - c2.center.y * c2.center.y);\n    double x1, x2;\n    int numSolutions = solveQuadratic(a * a + b * b, 2 * a * c, c * c - c1.radius * c1.radius * b*b, &x1, &x2);\n    if (numSolutions == 0) return 0;\n    if (numSolutions == 1) {\n        double y = (c-a*x1)/b;\n        p1->x = x1 + c1.center.x;\n        p1->y = y + c1.center.y;\n        return 1;\n    }\n    double y1 = (c - a * x1) / b;\n    double y2 = (c - a * x2) / b;\n    p1->x = x1 + c1.center.x;\n    p1->y = y1 + c1.center.y;\n    p2->x = x2 + c1.center.x;\n    p2->y = y2 + c1.center.y;\n    return 2;\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#4]\n        BL       height__FP4node\n        MOV      r4,r0\n        CMN      r0,#1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#8]\n        BL       height__FP4node\n        CMN      r0,#1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        SUB      r1,r4,r0\n        ADD      r1,r1,#1\n        CMP      r1,#2\n        LDMHIFD  sp!,{r4,r5,lr}\n        MVNHI    r0,#0\n        BXHI     lr\n        CMP      r4,r0\n        MOVGT    r0,r4\n        LDMFD    sp!,{r4,r5,lr}\n        ADD      r0,r0,#1\n        BX       lr\n        ENDP\n\nisBalanced__FP4node PROC\n        STR      lr,[sp,#-4]!\n        BL       height__FP4node\n        ADDS     r0,r0,#1\n        LDR      lr,[sp],#4\n        MOVNE    r0,#1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nint height(struct node *node) {\n    if (node == NULL)\n        return 0;\n    int lh = height(node->left);\n    if (lh == -1)\n        return -1;\n    int rh = height(node->right);\n    if (rh == -1)\n        return -1;\n    if (abs(lh - rh) > 1)\n        return -1;\n    return (lh > rh ? lh : rh) + 1;\n}\n\nint isBalanced(struct node *root) {\n    return height(root) != -1;\n}\n\n\nstruct node* newNode(int data) {\n  struct node* node = (struct node*) malloc(sizeof(struct node));\n  node->data = data;\n  node->left = NULL;\n  node->right = NULL;\n  return(node);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        CMP      r0,#0\n        ADRLT    r1,|L1.92|\n        MOV      r5,r0\n        LDMLTIA  r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n        MOV      r4,#1\n        CMP      r5,#1\n        ADR      r1,|L1.100|\n        LDMIA    r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n|L1.52|\n        UMULL    lr,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r3,r4,ASR #31\n        MLA      r1,r3,r0,r12\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r0,lr\n        BLE      |L1.52|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.92|\n        DCQ      0x0000000000000000\n|L1.100|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nlong long factorial(int n) {\n    if (n < 0) return 0; //Error handling for negative input.\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nidenticalTrees__FP4nodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        BNE      |L1.152|\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#4]\n        BL       identicalTrees__FP4nodeT1\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#8]\n        BL       identicalTrees__FP4nodeT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.152|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nint identicalTrees(struct node* a, struct node* b) {\n    if (a == NULL && b == NULL) return 1;\n    if (a == NULL || b == NULL) return 0;\n    return (a->data == b->data) && identicalTrees(a->left, b->left) && identicalTrees(a->right, b->right);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngrayscale__FPUciT2 PROC\n        MUL      r1,r2,r1\n        CMP      r1,#0\n        MOV      r0,#0\n        BXLE     lr\n|L1.16|\n        ADD      r0,r0,#1\n        CMP      r1,r0\n        BGT      |L1.16|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n// Assume a simplified image representation: a 1D array of unsigned chars.\n//  This is not realistic but it meets the constraints of the problem.\n\n\ntypedef unsigned char byte;\n\n//  Simulate grayscale conversion.  A real image library would be needed for real work.\nvoid grayscale(byte* image, int width, int height) {\n    for (int i = 0; i < width * height; i++) {\n        // Average of RGB channels.  Assume RGB data is interleaved.\n        // This part would greatly vary depending on the real image library\n        // and the image format being handled.\n        //   This is simplified to just a single channel.\n        \n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisValidIPv4__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        LDRB     r0,[r0,#0]\n        MOV      r6,#0\n        MOV      r5,#0\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.160|\n        BL       __rt_ctype_table\n        LDR      r1,[r0,#0]\n|L1.40|\n        LDRB     r0,[r7,r5]\n        LDRB     r2,[r1,r0]\n        TST      r2,#0x20\n        BEQ      |L1.88|\n        ADD      r2,r4,r4,LSL #2\n        ADD      r0,r0,r2,LSL #1\n        SUB      r4,r0,#0x30\n        CMP      r4,#0xff\n        LDMGTFD  sp!,{r3-r7,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        B        |L1.136|\n|L1.88|\n        CMP      r0,#0x2e\n        LDMNEFD  sp!,{r3-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        CMP      r4,#0\n        BNE      |L1.128|\n        CMP      r6,#0\n        LDMGTFD  sp!,{r3-r7,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n|L1.128|\n        ADD      r6,r6,#1\n        MOV      r4,#0\n|L1.136|\n        ADD      r5,r5,#1\n        LDRB     r0,[r7,r5]\n        CMP      r0,#0\n        BNE      |L1.40|\n        CMP      r6,#3\n        BEQ      |L1.172|\n|L1.160|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.172|\n        MOVS     r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        MOVNE    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isValidIPv4(char* ip) {\n    int count = 0;\n    int i = 0;\n    int num = 0;\n    while (ip[i] != '\\0') {\n        if (isdigit(ip[i])) {\n            num = num * 10 + (ip[i] - '0');\n            if (num > 255) return 0;\n        } else if (ip[i] == '.') {\n            if (num == 0 && count > 0) return 0;\n            count++;\n            num = 0;\n        } else {\n            return 0;\n        }\n        i++;\n    }\n    if (count != 3) return 0;\n    if (num == 0 && count ==3 ) return 0;\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nselectionSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        SUB      r5,r1,#1\n        CMP      r5,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOV      r12,#0\n        BXLE     lr\n|L1.24|\n        ADD      r2,r12,#1\n        MOV      r4,r2\n        CMP      r2,r1\n        MOV      r3,r12\n        BGE      |L1.72|\n|L1.44|\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r6,[r0,r3,LSL #2]\n        CMP      lr,r6\n        MOVLT    r3,r2\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.44|\n|L1.72|\n        LDR      lr,[r0,r12,LSL #2]\n        LDR      r2,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r2,[r0,r12,LSL #2]\n        MOV      r12,r4\n        CMP      r4,r5\n        BLT      |L1.24|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n    for (i = 0; i < n - 1; i++) {\n        min_idx = i;\n        for (j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitGraph__FP5Graphi PROC\n        MOV      r2,#0xdd0\n        ADD      r2,r2,#0x9000\n        STR      r1,[r2,r0]\n        MOV      r2,#0\n        CMP      r1,#0\n        BXLE     lr\n        MOV      r3,#0\n|L1.28|\n        ADD      r12,r2,r2,LSL #5\n        ADD      r12,r12,r2,LSL #6\n        ADD      r12,r12,r2,LSL #2\n        ADD      r12,r0,r12,LSL #2\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        STR      r3,[r12,#0x190]\n        BLT      |L1.28|\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        CMP      r1,#0\n        MOVGE    r3,#0xdd0\n        ADDGE    r3,r3,#0x9000\n        LDRGE    r3,[r3,r0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r3,r1,r1,LSL #5\n        ADD      r3,r3,r1,LSL #6\n        ADD      r3,r3,r1,LSL #2\n        ADD      r3,r0,r3,LSL #2\n        STR      lr,[sp,#-4]!\n        LDR      r12,[r3,#0x190]\n        ADD      lr,r12,#1\n        STR      lr,[r3,#0x190]\n        STR      r2,[r3,r12,LSL #2]\n        ADD      r12,r2,r2,LSL #5\n        ADD      r12,r12,r2,LSL #6\n        ADD      r2,r12,r2,LSL #2\n        ADD      r0,r0,r2,LSL #2\n        LDR      r2,[r0,#0x190]\n        ADD      r3,r2,#1\n        STR      r3,[r0,#0x190]\n        STR      r1,[r0,r2,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nisConnected__FP5GraphiT2 PROC\n        CMP      r1,#0\n        MOVGE    r3,#0xdd0\n        ADDGE    r3,r3,#0x9000\n        LDRGE    r3,[r3,r0]\n        CMPGE    r3,r1\n        BLE      |L1.212|\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BGT      |L1.220|\n|L1.212|\n        MOV      r0,#0\n        BX       lr\n|L1.220|\n        ADD      r12,r1,r1,LSL #5\n        ADD      r12,r12,r1,LSL #6\n        ADD      r1,r12,r1,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        LDR      r1,[r0,#0x190]\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.280|\n|L1.252|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,r2\n        MOVEQ    r0,#1\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r1,r3\n        BGT      |L1.252|\n|L1.280|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices[MAX_VERTICES];\n    int count;\n} AdjList;\n\ntypedef struct {\n    AdjList adjList[MAX_VERTICES];\n    int numVertices;\n} Graph;\n\nvoid initGraph(Graph* graph, int numVertices) {\n    graph->numVertices = numVertices;\n    for (int i = 0; i < numVertices; i++) {\n        graph->adjList[i].count = 0;\n    }\n}\n\n\nvoid addEdge(Graph* graph, int src, int dest) {\n    if (src < 0 || src >= graph->numVertices || dest < 0 || dest >= graph->numVertices) return;\n    graph->adjList[src].vertices[graph->adjList[src].count++] = dest;\n    graph->adjList[dest].vertices[graph->adjList[dest].count++] = src;\n\n}\n\nint isConnected(Graph* graph, int u, int v) {\n    if (u < 0 || u >= graph->numVertices || v < 0 || v >= graph->numVertices) return 0;\n    for (int i = 0; i < graph->adjList[u].count; i++) {\n        if (graph->adjList[u].vertices[i] == v) return 1;\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FUiT1 PROC\n        CMP      r0,#0\n        MOVEQ    r0,r1\n        BXEQ     lr\n        CMP      r1,#0\n        BXEQ     lr\n        ORR      r2,r0,r1\n        TST      r2,#1\n        MOV      r3,#0\n        BNE      |L1.60|\n|L1.36|\n        MOV      r0,r0,LSR #1\n        MOV      r1,r1,LSR #1\n        ORR      r2,r0,r1\n        TST      r2,#1\n        ADD      r3,r3,#1\n        BEQ      |L1.36|\n|L1.60|\n        TST      r0,#1\n        BNE      |L1.80|\n|L1.68|\n        MOV      r0,r0,LSR #1\n        TST      r0,#1\n        BEQ      |L1.68|\n|L1.80|\n        TST      r1,#1\n        BNE      |L1.100|\n|L1.88|\n        MOV      r1,r1,LSR #1\n        TST      r1,#1\n        BEQ      |L1.88|\n|L1.100|\n        CMP      r0,r1\n        MOVHI    r2,r0\n        MOVHI    r0,r1\n        MOVHI    r1,r2\n        SUBS     r1,r1,r0\n        BNE      |L1.80|\n        MOV      r0,r0,LSL r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\nunsigned int gcd(unsigned int a, unsigned int b)\n{\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    unsigned int shift = 0;\n    while (((a | b) & 1) == 0)\n    {\n        a >>= 1;\n        b >>= 1;\n        shift++;\n    }\n\n    while ((a & 1) == 0)\n        a >>= 1;\n\n    do\n    {\n        while ((b & 1) == 0)\n            b >>= 1;\n        if (a > b)\n        {\n            unsigned int temp = a;\n            a = b;\n            b = temp;\n        }\n        b = b - a;\n    } while (b != 0);\n\n    return a << shift;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountOccurrences__FPcc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r4,#0\n        BL       strlen\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.56|\n|L1.32|\n        LDRB     r2,[r5,r1]\n        ADD      r1,r1,#1\n        CMP      r2,r6\n        ADDEQ    r4,r4,#1\n        CMP      r1,r0\n        BLT      |L1.32|\n|L1.56|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countOccurrences(char* str, char target) {\n    int count = 0;\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (str[i] == target) {\n            count++;\n        }\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisVowel__Fc PROC\n        STMFD    sp!,{r3,lr}\n        BL       tolower\n        AND      r0,r0,#0xff\n        CMP      r0,#0x61\n        CMPNE    r0,#0x65\n        CMPNE    r0,#0x69\n        CMPNE    r0,#0x6f\n        CMPNE    r0,#0x75\n        LDMNEFD  sp!,{r3,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDMFD    sp!,{r3,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isVowel(char c) {\n    char lowerC = tolower(c);\n    return lowerC == 'a' || lowerC == 'e' || lowerC == 'i' || lowerC == 'o' || lowerC == 'u';\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nmaxPathSum__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       maxPathSum__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       maxPathSum__FP4Node\n        LDR      r1,[r4,#0]\n        CMP      r5,#0\n        ADDGT    r1,r1,r5\n        CMP      r0,#0\n        ADDGT    r1,r1,r0\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nint maxPathSum(struct Node* root) {\n    if (root == NULL) return 0;\n    int leftSum = maxPathSum(root->left);\n    int rightSum = maxPathSum(root->right);\n    int maxSum = root->data;\n    if(leftSum > 0) maxSum += leftSum;\n    if(rightSum > 0) maxSum += rightSum;\n    return maxSum;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndot_product__FPiT1i PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r12,#0\n        MOV      r3,#0\n        CMP      r2,#0\n        BLE      |L1.44|\n|L1.20|\n        LDR      lr,[r0,r3,LSL #2]\n        LDR      r4,[r1,r3,LSL #2]\n        ADD      r3,r3,#1\n        CMP      r3,r2\n        MLA      r12,r4,lr,r12\n        BLT      |L1.20|\n|L1.44|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r12\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint dot_product(int* a, int* b, int size) {\n    int result = 0;\n    for (int i = 0; i < size; i++) {\n        result += a[i] * b[i];\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndeterminant__FiN31 PROC\n        MUL      r0,r3,r0\n        MUL      r1,r2,r1\n        SUB      r0,r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint determinant(int a, int b, int c, int d) {\n    return a * d - b * c;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r) {\n        printf(\"%s\\n\", a);\n    } else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i));\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrange__FPii PROC\n|L1.0|\n        CMP      r1,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        STR      lr,[sp,#-4]!\n        LDR      r12,[r0,#0]\n        MOV      r2,#1\n        CMP      r1,#1\n        MOV      lr,r12\n        BLE      |L1.68|\n|L1.36|\n        LDR      r3,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r3,r12\n        MOVLT    r12,r3\n        CMP      r3,lr\n        MOVGT    lr,r3\n        CMP      r2,r1\n        BLT      |L1.36|\n|L1.68|\n        SUB      r0,lr,r12\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint range(int arr[], int size) {\n    if (size == 0) return 0;\n    int min = arr[0];\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < min) min = arr[i];\n        if (arr[i] > max) max = arr[i];\n    }\n    return max - min;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_leap__Fi PROC\n        TST      r0,#3\n        LDR      r1,|L1.128|\n        BNE      |L1.44|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        BNE      |L1.80|\n|L1.44|\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.80|\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_leap(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateLRUCache__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0x34\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        STR      r1,[r0,#0x30]\n        MOV      r1,#0\n        ADD      lr,r0,#8\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r12,#0\n        STMIA    lr!,{r1-r3,r12}\n        STMIA    lr!,{r1-r3,r12}\n        STMIA    lr,{r1,r2}\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\nget__FP8LRUCachei PROC\n        CMP      r0,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,|L1.1232|\n        SMULL    r12,r3,r2,r1\n        MOV      r3,r3,ASR #2\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r3,r1,r3,LSL #1\n        ADD      r3,r0,r3,LSL #2\n        LDR      r3,[r3,#8]\n        CMP      r3,#0\n        BEQ      |L1.260|\n        SMULL    r12,r3,r2,r1\n        MOV      r2,r3,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r1,r2,LSL #1\n        ADD      r2,r0,r2,LSL #2\n        LDR      r2,[r2,#8]\n        LDR      r3,[r2,#0]\n        CMP      r3,r1\n        BNE      |L1.260|\n        LDR      r1,[r0,#0]\n        CMP      r1,r2\n        BEQ      |L1.252|\n        LDR      r1,[r0,#4]\n        CMP      r1,r2\n        LDREQ    r1,[r2,#8]\n        STREQ    r1,[r0,#4]\n        LDR      r1,[r2,#0xc]\n        LDR      r3,[r2,#8]\n        STR      r1,[r3,#0xc]\n        LDR      r1,[r2,#0xc]\n        CMP      r1,#0\n        LDRNE    r3,[r2,#8]\n        STRNE    r3,[r1,#8]\n        LDR      r1,[r0,#0]\n        STR      r1,[r2,#0xc]\n        LDR      r1,[r0,#0]\n        STR      r2,[r1,#8]\n        STR      r2,[r0,#0]\n        MOV      r0,#0\n        STR      r0,[r2,#8]\n|L1.252|\n        LDR      r0,[r2,#4]\n        BX       lr\n|L1.260|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nput__FP8LRUCacheiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r8,#0\n        LDR      r7,|L1.1232|\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BEQ      |L1.908|\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        BNE      |L1.908|\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        STR      r6,[r0,#4]\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r1,[r4,#0]\n        CMP      r0,r1\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r1,[r4,#4]\n        CMP      r0,r1\n        BNE      |L1.552|\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r0,[r0,#8]\n        STR      r0,[r4,#4]\n|L1.552|\n        SMULL    r1,r0,r7,r5\n        SMULL    r2,r1,r7,r5\n        MOV      r1,r1,ASR #2\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r5,r1,LSL #1\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        ADD      r1,r4,r1,LSL #2\n        LDR      r1,[r1,#8]\n        LDR      r0,[r0,#8]\n        LDR      r1,[r1,#8]\n        LDR      r0,[r0,#0xc]\n        STR      r0,[r1,#0xc]\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r0,[r0,#0xc]\n        CMP      r0,#0\n        BEQ      |L1.748|\n        SMULL    r1,r0,r7,r5\n        SMULL    r2,r1,r7,r5\n        MOV      r1,r1,ASR #2\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r5,r1,LSL #1\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        ADD      r1,r4,r1,LSL #2\n        LDR      r1,[r1,#8]\n        LDR      r0,[r0,#8]\n        LDR      r1,[r1,#0xc]\n        LDR      r0,[r0,#8]\n        STR      r0,[r1,#8]\n|L1.748|\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#0xc]\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        LDR      r1,[r4,#0]\n        STR      r0,[r1,#8]\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        STR      r0,[r4,#0]\n        SMULL    r1,r0,r7,r5\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #1\n        ADD      r0,r0,r0,LSL #2\n        ADD      r0,r5,r0,LSL #1\n        ADD      r0,r4,r0,LSL #2\n        LDR      r0,[r0,#8]\n        STR      r8,[r0,#8]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.908|\n        MOV      r0,#0x10\n        BL       malloc\n        STMIA    r0,{r5,r6,r8}\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#0xc]\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STRNE    r0,[r1,#8]\n        STR      r0,[r4,#0]\n        LDR      r1,[r4,#4]\n        CMP      r1,#0\n        SMULL    r2,r1,r7,r5\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r5,r1,LSL #1\n        ADD      r1,r4,r1,LSL #2\n        STREQ    r0,[r4,#4]\n        STR      r0,[r1,#8]\n        LDR      r0,[r4,#0x30]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0x30]\n        CMP      r0,#0xa\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#8]\n        STR      r1,[r4,#4]\n        CMP      r1,#0\n        STRNE    r8,[r1,#0xc]\n        LDR      r1,[r0,#0]\n        SMULL    r3,r2,r7,r1\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r1,r1,r2,LSL #1\n        ADD      r1,r4,r1,LSL #2\n        STR      r8,[r1,#8]\n        BL       free\n        LDR      r0,[r4,#0x30]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#0x30]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define CACHE_SIZE 10\n\ntypedef struct CacheNode {\n    int key;\n    int value;\n    struct CacheNode* prev;\n    struct CacheNode* next;\n} CacheNode;\n\ntypedef struct LRUCache {\n    CacheNode* head;\n    CacheNode* tail;\n    CacheNode* cache[CACHE_SIZE];\n    int size;\n} LRUCache;\n\n\nLRUCache* createLRUCache() {\n    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));\n    cache->head = NULL;\n    cache->tail = NULL;\n    cache->size = 0;\n    memset(cache->cache, 0, sizeof(cache->cache));\n    return cache;\n}\n\nint get(LRUCache* cache, int key) {\n    if (cache == NULL) return -1;\n    if (cache->cache[key % CACHE_SIZE] != NULL) {\n        CacheNode* node = cache->cache[key % CACHE_SIZE];\n        if(node->key == key){\n            if (node != cache->head) {\n                if (node == cache->tail) cache->tail = node->prev;\n                node->prev->next = node->next;\n                if (node->next) node->next->prev = node->prev;\n                node->next = cache->head;\n                cache->head->prev = node;\n                cache->head = node;\n                node->prev = NULL;\n\n            }\n            return node->value;\n        }\n    }\n    return -1;\n}\n\n\nvoid put(LRUCache* cache, int key, int value) {\n    if (cache == NULL) return;\n    if (cache->cache[key % CACHE_SIZE] != NULL && cache->cache[key % CACHE_SIZE]->key == key){\n        cache->cache[key % CACHE_SIZE]->value = value;\n        if (cache->cache[key % CACHE_SIZE] != cache->head) {\n            if (cache->cache[key % CACHE_SIZE] == cache->tail) cache->tail = cache->cache[key % CACHE_SIZE]->prev;\n            cache->cache[key % CACHE_SIZE]->prev->next = cache->cache[key % CACHE_SIZE]->next;\n            if (cache->cache[key % CACHE_SIZE]->next) cache->cache[key % CACHE_SIZE]->next->prev = cache->cache[key % CACHE_SIZE]->prev;\n            cache->cache[key % CACHE_SIZE]->next = cache->head;\n            cache->head->prev = cache->cache[key % CACHE_SIZE];\n            cache->head = cache->cache[key % CACHE_SIZE];\n            cache->cache[key % CACHE_SIZE]->prev = NULL;\n        }\n        return;\n\n    }\n    CacheNode* node = (CacheNode*)malloc(sizeof(CacheNode));\n    node->key = key;\n    node->value = value;\n    node->prev = NULL;\n    node->next = cache->head;\n    if (cache->head != NULL)\n        cache->head->prev = node;\n    cache->head = node;\n\n    if (cache->tail == NULL)\n        cache->tail = node;\n\n    cache->cache[key % CACHE_SIZE] = node;\n    cache->size++;\n\n    if (cache->size > CACHE_SIZE) {\n        CacheNode* temp = cache->tail;\n        cache->tail = cache->tail->prev;\n        if(cache->tail) cache->tail->next = NULL;\n        cache->cache[temp->key % CACHE_SIZE] = NULL;\n        free(temp);\n        cache->size--;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsortedArrayToBST__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        MOV      r7,r2\n        MOV      r6,r1\n        CMP      r1,r2\n        LDMGTFD  sp!,{r4-r8,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        ADD      r0,r6,r7\n        ADD      r0,r0,r0,LSR #31\n        MOV      r5,r0,ASR #1\n        LDR      r4,[r8,r5,LSL #2]\n        MOV      r0,#0xc\n        BL       __nw__FUi\n        CMP      r0,#0\n        BEQ      |L1.80|\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n|L1.80|\n        MOV      r4,r0\n        MOV      r0,r8\n        SUB      r2,r5,#1\n        MOV      r1,r6\n        BL       sortedArrayToBST__FPiiT2\n        STR      r0,[r4,#4]\n        MOV      r0,r8\n        MOV      r2,r7\n        ADD      r1,r5,#1\n        BL       sortedArrayToBST__FPiiT2\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nNode* sortedArrayToBST(int arr[], int start, int end) {\n    if (start > end) return NULL;\n    int mid = (start + end) / 2;\n    Node* root = new Node(arr[mid]);\n    root->left = sortedArrayToBST(arr, start, mid - 1);\n    root->right = sortedArrayToBST(arr, mid + 1, end);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__Fi PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c\n        ADD      r5,sp,#0x10\n        MOV      r2,r0\n        MOV      r0,r5\n        ADR      r1,|L1.160|\n        BL       _sprintf\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#1\n        ADDLE    sp,sp,#0x1c\n        MOV      r4,r0\n        LDMLEFD  sp!,{r4,r5,lr}\n        MOVLE    r0,#1\n        BXLE     lr\n        LDRB     r0,[sp,#0x10]\n        ADD      r1,r5,r4\n        LDRB     r1,[r1,#-1]\n        CMP      r0,r1\n        ADDNE    sp,sp,#0x1c\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r1,r5,#1\n        ADD      r5,sp,#4\n        MOV      r0,r5\n        SUB      r2,r4,#2\n        BL       strncpy\n        MOV      r0,#0\n        ADD      r1,r5,r4\n        STRB     r0,[r1,#-2]\n        ADR      r1,|L1.160|\n        MOV      r0,r5\n        MOV      r2,sp\n        BL       _sscanf\n        LDR      r0,[sp,#0]\n        BL       isPalindrome__Fi\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.160|\n        DCB      \"%d\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint isPalindrome(int n) {\n    char buffer[12];\n    sprintf(buffer, \"%d\", n);\n    int len = strlen(buffer);\n    if (len <= 1) return 1;\n    if (buffer[0] != buffer[len - 1]) return 0;\n    char temp[12];\n    strncpy(temp, buffer + 1, len - 2);\n    temp[len - 2] = '\\0';\n    int num;\n    sscanf(temp, \"%d\", &num);\n    return isPalindrome(num);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetVerticalOrder__FP4NodeiT2PiPPiT4 PROC\n        STMFD    sp!,{r4-r9,lr}\n        SUB      sp,sp,#0xc\n        ADD      r6,sp,#0x28\n        LDMIA    r6,{r4,r6}\n        MOVS     r7,r0\n        ADDEQ    sp,sp,#0xc\n        MOV      r9,r1\n        MOV      r8,r3\n        MOV      r5,r2\n        LDMEQFD  sp!,{r4-r9,lr}\n        BXEQ     lr\n        LDR      r0,[r8,#0]\n        CMP      r0,r5\n        BGE      |L1.128|\n        STR      r5,[r8,#0]\n        LDR      r0,[r6,#0]\n        ADD      r0,r0,#1\n        STR      r0,[r6,#0]\n        MOV      r1,r0,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        STR      r0,[r4,#0]\n|L1.128|\n        LDR      r0,[r4,#0]\n        LDR      r2,[r7,#0]\n        LDR      r1,[r0,r5,LSL #2]\n        MOV      r3,r8\n        ADD      r1,r1,r2\n        STR      r1,[r0,r5,LSL #2]\n        STMIA    sp,{r4,r6}\n        ADD      r2,r5,#1\n        MOV      r5,r2\n        LDR      r0,[r7,#4]\n        SUB      r1,r9,#1\n        BL       getVerticalOrder__FP4NodeiT2PiPPiT4\n        STMIA    sp,{r4,r6}\n        LDR      r0,[r7,#8]\n        MOV      r3,r8\n        MOV      r2,r5\n        ADD      r1,r9,#1\n        BL       getVerticalOrder__FP4NodeiT2PiPPiT4\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid getVerticalOrder(struct Node* root, int hd, int level, int *max_level, int **arr, int *arr_size) {\n    if (root == NULL) return;\n\n    if (*max_level < level) {\n        *max_level = level;\n        *arr_size = *arr_size + 1;\n        *arr = (int*)realloc(*arr, (*arr_size)*sizeof(int));\n    }\n        \n    (*arr)[level] = (*arr)[level] + root->data;\n    \n    getVerticalOrder(root->left, hd - 1, level + 1, max_level, arr, arr_size);\n    getVerticalOrder(root->right, hd + 1, level + 1, max_level, arr, arr_size);\n\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nmaxPathSumUtil__FP4NodeRi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       maxPathSumUtil__FP4NodeRi\n        MOV      r6,r0\n        LDR      r0,[r4,#8]\n        MOV      r1,r5\n        BL       maxPathSumUtil__FP4NodeRi\n        MOV      r3,r0\n        MOV      r1,r0\n        MOV      r0,r6\n        BL       max__FiT1\n        LDR      r1,[r4,#0]\n        ADD      r0,r0,r1\n        BL       max__FiT1\n        MOV      r2,r0\n        LDR      r1,[r4,#0]\n        ADD      r0,r6,r3\n        ADD      r1,r0,r1\n        MOV      r0,r2\n        BL       max__FiT1\n        MOV      r1,r0\n        LDR      r0,[r5,#0]\n        BL       max__FiT1\n        STR      r0,[r5,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nmaxPathSum__FP4Node PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r1,#0\n        STR      r1,[sp,#0]\n        MOV      r1,sp\n        BL       maxPathSumUtil__FP4NodeRi\n        LDR      r0,[sp,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1; \n    return(node);\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else \n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\nint maxPathSumUtil(Node* root, int &max_so_far) {\n    if (root == NULL) return 0;\n\n    int ls = maxPathSumUtil(root->left, max_so_far);\n    int rs = maxPathSumUtil(root->right, max_so_far);\n\n    int max_single = max(max(ls, rs) + root->data, root->data);\n    int max_top = max(max_single, ls + rs + root->data);\n\n    max_so_far = max(max_so_far, max_top);\n    return max_single;\n}\n\nint maxPathSum(Node *root) {\n    int max_so_far = 0;\n    maxPathSumUtil(root, max_so_far);\n    return max_so_far;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nallocate_and_fill__FUii PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        CMP      r4,#0\n        LDMLSFD  sp!,{r3-r5,lr}\n        MOV      r1,#0\n        BXLS     lr\n        AND      r2,r5,#0xff\n|L1.48|\n        STRB     r2,[r0,r1]\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BCC      |L1.48|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ndeallocate__FPv PROC\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nvoid* allocate_and_fill(size_t size, int value) {\n    void* ptr = malloc(size);\n    if (ptr == NULL) return NULL;\n    for (size_t i = 0; i < size; ++i) {\n        *((char*)ptr + i) = (char)value;\n    }\n    return ptr;\n}\n\nvoid deallocate(void* ptr) {\n    free(ptr);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninsertionSort__FPPci PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r6,#1\n        MOV      r5,r0\n        CMP      r1,#1\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n|L1.28|\n        LDR      r7,[r5,r6,LSL #2]\n        SUB      r4,r6,#1\n        B        |L1.56|\n|L1.40|\n        LDR      r0,[r5,r4,LSL #2]\n        ADD      r1,r5,r4,LSL #2\n        STR      r0,[r1,#4]\n        SUB      r4,r4,#1\n|L1.56|\n        CMP      r4,#0\n        BLT      |L1.84|\n        LDR      r0,[r5,r4,LSL #2]\n        MOV      r1,r7\n        BL       strcmp\n        CMP      r0,#0\n        BGT      |L1.40|\n|L1.84|\n        ADD      r0,r5,r4,LSL #2\n        ADD      r6,r6,#1\n        CMP      r6,r8\n        STR      r7,[r0,#4]\n        BLT      |L1.28|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid insertionSort(char** arr, int n) {\n    for (int i = 1; i < n; i++) {\n        char* key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && strcmp(arr[j], key) > 0) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninit_graph__FP5Graphi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        ADD      r0,r0,#0x13000\n        STR      r1,[r0,#0xba0]\n        MOV      r1,#0\n        STR      r1,[r0,#0xba4]\n        ADD      r0,r4,#0x10000\n        ADD      r0,r0,#0x3880\n        MVN      r1,#0\n        MOV      r2,#0x190\n        BL       __rt_memset\n        ADD      r0,r4,#0x13000\n        ADD      r0,r0,#0xa10\n        LDMFD    sp!,{r4,lr}\n        MOV      r1,#0x190\n        B        __rt_memclr_w\n        ENDP\n\nadd_edge__FP5GraphiT2 PROC\n        STR      lr,[sp,#-4]!\n        ADD      r3,r0,#0x13000\n        LDR      lr,[r3,#0xba4]\n        SUBS     r12,lr,#0x2000\n        SUBGES   r12,r12,#0x710\n        LDRGE    lr,[sp],#4\n        BXGE     lr\n        STR      r2,[r0,lr,LSL #3]\n        ADD      r1,r0,r1,LSL #2\n        ADD      r1,r1,#0x13000\n        LDR      r12,[r3,#0xba4]\n        LDR      r2,[r1,#0x880]\n        ADD      r0,r0,r12,LSL #3\n        STR      r2,[r0,#4]\n        LDR      r0,[r3,#0xba4]\n        STR      r0,[r1,#0x880]\n        LDR      r0,[r1,#0xa10]\n        ADD      r0,r0,#1\n        STR      r0,[r1,#0xa10]\n        LDR      r0,[r3,#0xba4]\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xba4]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nbfs__FP5GraphiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x190\n        STR      r1,[sp,#0]\n        MOV      r4,#1\n        STR      r4,[r2,r1,LSL #2]\n        MOV      r5,sp\n        MOV      lr,#0\n        MOV      r12,#1\n|L1.192|\n        MOV      r1,lr\n        LDR      r1,[r5,r1,LSL #2]\n        ADD      lr,lr,#1\n        ADD      r1,r0,r1,LSL #2\n        ADD      r1,r1,#0x13000\n        LDR      r1,[r1,#0x880]\n        CMN      r1,#1\n        BEQ      |L1.272|\n|L1.224|\n        LDR      r3,[r0,r1,LSL #3]\n        LDR      r6,[r2,r3,LSL #2]\n        CMP      r6,#0\n        BNE      |L1.256|\n        MOV      r6,r12\n        STR      r4,[r2,r3,LSL #2]\n        STR      r3,[r5,r6,LSL #2]\n        ADD      r12,r12,#1\n|L1.256|\n        ADD      r1,r0,r1,LSL #3\n        LDR      r1,[r1,#4]\n        CMN      r1,#1\n        BNE      |L1.224|\n|L1.272|\n        CMP      lr,r12\n        BLT      |L1.192|\n        ADD      sp,sp,#0x190\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertex;\n    int next;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_VERTICES * MAX_VERTICES];\n    int head[MAX_VERTICES];\n    int degree[MAX_VERTICES];\n    int num_vertices;\n    int num_edges;\n} Graph;\n\nvoid init_graph(Graph *g, int num_vertices) {\n    g->num_vertices = num_vertices;\n    g->num_edges = 0;\n    memset(g->head, -1, sizeof(g->head));\n    memset(g->degree, 0, sizeof(g->degree));\n}\n\nvoid add_edge(Graph *g, int u, int v) {\n    if (g->num_edges >= MAX_VERTICES * MAX_VERTICES) return;\n    g->edges[g->num_edges].vertex = v;\n    g->edges[g->num_edges].next = g->head[u];\n    g->head[u] = g->num_edges;\n    g->degree[u]++;\n    g->num_edges++;\n}\n\nvoid bfs(Graph *g, int start_vertex, int *visited) {\n    int queue[MAX_VERTICES];\n    int head = 0;\n    int tail = 0;\n    int u;\n    int v;\n\n    queue[tail++] = start_vertex;\n    visited[start_vertex] = 1;\n\n    while (head < tail) {\n        u = queue[head++];\n        for (int i = g->head[u]; i != -1; i = g->edges[i].next) {\n            v = g->edges[i].vertex;\n            if (!visited[v]) {\n                visited[v] = 1;\n                queue[tail++] = v;\n            }\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nprintAncestors__FP4NodeiPiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        MOV      r5,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        ADD      r6,r3,#1\n        STR      r0,[r5,r3,LSL #2]\n        LDR      r0,[r4,#0]\n        CMP      r0,r7\n        BNE      |L1.100|\n        SUB      r6,r6,#1\n        CMP      r6,#0\n        MOV      r4,#0\n        BLE      |L1.88|\n|L1.64|\n        LDR      r1,[r5,r4,LSL #2]\n        ADR      r0,|L1.148|\n        BL       _printf\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.64|\n|L1.88|\n        ADR      r0,|L1.152|\n        LDMFD    sp!,{r3-r7,lr}\n        B        _printf\n|L1.100|\n        MOV      r3,r6\n        MOV      r2,r5\n        MOV      r1,r7\n        LDR      r0,[r4,#4]\n        BL       printAncestors__FP4NodeiPiT2\n        LDR      r0,[r4,#8]\n        ADD      sp,sp,#4\n        MOV      r3,r6\n        MOV      r2,r5\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r7,lr}\n        B        printAncestors__FP4NodeiPiT2\n|L1.148|\n        DCB      \"%d \\0\"\n|L1.152|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid printAncestors(Node* root, int target, int path[], int pathLen) {\n    if (root == NULL) return;\n\n    path[pathLen] = root->data;\n    pathLen++;\n\n    if (root->data == target) {\n        for (int i = 0; i < pathLen -1; i++) {\n            printf(\"%d \", path[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printAncestors(root->left, target, path, pathLen);\n        printAncestors(root->right, target, path, pathLen);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndeterminant__FPA100_di PROC\n|L1.0|\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r6,r0\n        MOV      r4,r1\n        CMP      r1,#1\n        SUB      sp,sp,#0x13800\n        SUB      sp,sp,#0x8c\n        LDMEQIA  r6,{r0,r1}\n        ADDEQ    sp,sp,#0x13800\n        ADDEQ    sp,sp,#0x8c\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        CMP      r4,#2\n        BNE      |L1.120|\n        LDMIA    r6,{r0,r1}\n        ADD      r3,r6,#0x328\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        ADD      r6,r6,#8\n        LDMIA    r6!,{r0,r1}\n        ADD      r3,r6,#0x310\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        ADD      sp,sp,#0x13800\n        ADD      sp,sp,#0x8c\n        MOV      r3,r5\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r11,lr}\n        B        _drsb\n|L1.120|\n        ADR      r0,|L1.396|\n        LDR      r1,[r0,#4]\n        LDR      r8,[r0,#0]\n        STR      r1,[sp,#4]\n        MOV      r7,#1\n        MOV      r5,#0\n        CMP      r4,#0\n        BLE      |L1.372|\n        SUB      r1,r4,#1\n        ADD      r12,sp,#0x13000\n        STR      r1,[r12,#0x888]\n|L1.164|\n        MOV      lr,#0\n        MOV      r3,#1\n        CMP      r4,#1\n        BLE      |L1.280|\n|L1.180|\n        MOV      r1,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.264|\n        ADD      r2,r3,r3,LSL #3\n        ADD      r2,r2,r3,LSL #4\n        ADD      r9,r6,r2,LSL #5\n        ADD      r2,lr,lr,LSL #3\n        ADD      r2,r2,lr,LSL #4\n        ADD      r12,sp,#8\n        ADD      r10,r12,r2,LSL #5\n|L1.224|\n        CMP      r0,r5\n        BEQ      |L1.252|\n        ADD      r12,r9,r0,LSL #3\n        LDMIA    r12,{r11,r12}\n        ADD      r2,r10,r1,LSL #3\n        STMIA    r2,{r11,r12}\n        ADD      r1,r1,#1\n|L1.252|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.224|\n|L1.264|\n        ADD      r3,r3,#1\n        CMP      r3,r4\n        ADD      lr,lr,#1\n        BLT      |L1.180|\n|L1.280|\n        MOV      r0,r7\n        BL       _dflt\n        ADD      r2,r6,r5,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r9,r0\n        MOV      r10,r1\n        ADD      r12,sp,#0x13000\n        LDR      r1,[r12,#0x888]\n        ADD      r0,sp,#8\n        BL       determinant__FPA100_di\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r2,r8\n        LDR      r3,[sp,#4]\n        BL       _dadd\n        ADD      r5,r5,#1\n        CMP      r5,r4\n        MOV      r8,r0\n        RSB      r7,r7,#0\n        STR      r1,[sp,#4]\n        BLT      |L1.164|\n|L1.372|\n        LDR      r1,[sp,#4]\n        ADD      sp,sp,#0x13800\n        ADD      sp,sp,#0x8c\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.396|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble determinant(double a[][100], int n) {\n    if (n == 1) return a[0][0];\n    if (n == 2) return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    double submatrix[100][100];\n    double det = 0;\n    int sign = 1;\n    for (int i = 0; i < n; i++) {\n        int subi = 0;\n        for (int j = 1; j < n; j++) {\n            int subj = 0;\n            for (int k = 0; k < n; k++) {\n                if (k != i) {\n                    submatrix[subi][subj] = a[j][k];\n                    subj++;\n                }\n            }\n            subi++;\n        }\n        det += sign * a[0][i] * determinant(submatrix, n - 1);\n        sign *= -1;\n    }\n    return det;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd_line__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        LDR      r4,|L1.144|\n        MOV      r1,r0\n        LDR      r0,[r4,#0]  ; num_lines\n        CMP      r0,#0x3e8\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r2,#0xff\n        LDR      r5,|L1.148|\n        ADD      r0,r5,r0,LSL #8\n        BL       strncpy\n        LDR      r1,[r4,#0]  ; num_lines\n        MOV      r0,#0\n        ADD      r2,r5,r1,LSL #8\n        STRB     r0,[r2,#0xff]\n        ADD      r0,r1,#1\n        STR      r0,[r4,#0]  ; num_lines\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nprint_lines__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r5,|L1.144|\n        MOV      r4,#0\n        LDR      r0,[r5,#0]  ; num_lines\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        LDR      r6,|L1.148|\n|L1.108|\n        ADD      r1,r6,r4,LSL #8\n        ADR      r0,|L1.152|\n        BL       _printf\n        LDR      r0,[r5,#0]  ; num_lines\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.108|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.144|\n        DCD      ||.bss$2||\n|L1.148|\n        DCD      ||.bss$2|| + 4\n|L1.152|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_LINES 1000\n#define MAX_LINE_LENGTH 256\n\nchar lines[MAX_LINES][MAX_LINE_LENGTH];\nint num_lines = 0;\n\nvoid add_line(const char* line) {\n    if (num_lines < MAX_LINES) {\n        strncpy(lines[num_lines], line, MAX_LINE_LENGTH - 1);\n        lines[num_lines][MAX_LINE_LENGTH - 1] = '\\0';\n        num_lines++;\n    }\n}\n\nvoid print_lines() {\n    for (int i = 0; i < num_lines; i++) {\n        printf(\"%s\\n\", lines[i]);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0x19c\n        BL       malloc\n        MVN      r1,#0\n        STR      r1,[r0,#0x194]\n        STR      r1,[r0,#0x190]\n        MOV      r1,#0\n        STR      r1,[r0,#0x198]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#0x198]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        LDR      r2,[r0,#0x198]\n        CMP      r2,#0x64\n        BXEQ     lr\n        LDR      r2,[r0,#0x190]\n        CMN      r2,#1\n        MOVEQ    r2,#0\n        STREQ    r2,[r0,#0x190]\n        LDR      r2,[r0,#0x194]\n        ADD      r2,r2,#1\n        STR      r2,[r0,#0x194]\n        STR      r1,[r0,r2,LSL #2]\n        LDR      r1,[r0,#0x198]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0x198]\n        BX       lr\n        ENDP\n\ndequeue__FP5Queue PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r2,[r1,#0x190]\n        LDR      r3,[r1,#0x194]\n        LDR      r0,[r1,r2,LSL #2]\n        CMP      r2,r3\n        ADDNE    r2,r2,#1\n        MVNEQ    r2,#0\n        STREQ    r2,[r1,#0x194]\n        STR      r2,[r1,#0x190]\n        LDR      r2,[r1,#0x198]\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0x198]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nbfs__FP5Graphi PROC\n        STMFD    sp!,{r4-r8,lr}\n        SUB      sp,sp,#0x190\n        MOV      r8,r1\n        MOV      r5,r0\n        MOV      r0,sp\n        MOV      r1,#0x190\n        MOV      r7,sp\n        BL       __rt_memclr_w\n        BL       createQueue__Fv\n        MOV      r4,r0\n        MOV      r1,r8\n        BL       enqueue__FP5Queuei\n        MOV      r6,#1\n        STR      r6,[r7,r8,LSL #2]\n        MOV      r0,r4\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        BNE      |L1.376|\n|L1.268|\n        MOV      r0,r4\n        BL       dequeue__FP5Queue\n        LDR      r1,[r5,#0]\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.360|\n        ADD      r12,r0,r0,LSL #3\n        ADD      r0,r12,r0,LSL #4\n        ADD      r8,r5,r0,LSL #4\n|L1.304|\n        ADD      r0,r8,r3,LSL #2\n        LDR      r0,[r0,#4]\n        CMP      r0,#1\n        LDREQ    r0,[r7,r3,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.344|\n        STR      r6,[r7,r3,LSL #2]\n        MOV      r1,r3\n        MOV      r0,r4\n        BL       enqueue__FP5Queuei\n|L1.344|\n        LDR      r0,[r5,#0]\n        ADD      r3,r3,#1\n        CMP      r0,r3\n        BGT      |L1.304|\n|L1.360|\n        MOV      r0,r4\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        BEQ      |L1.268|\n|L1.376|\n        MOV      r0,r4\n        BL       free\n        ADD      sp,sp,#0x190\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj_matrix[MAX_VERTICES][MAX_VERTICES];\n} Graph;\n\ntypedef struct {\n    int data[MAX_VERTICES];\n    int front;\n    int rear;\n    int size;\n} Queue;\n\n\nQueue* createQueue() {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    q->front = q->rear = -1;\n    q->size = 0;\n    return q;\n}\n\nint isEmpty(Queue* q) {\n    return q->size == 0;\n}\n\nvoid enqueue(Queue* q, int value) {\n    if (q->size == MAX_VERTICES) return;\n    if (q->front == -1) q->front = 0;\n    q->rear++;\n    q->data[q->rear] = value;\n    q->size++;\n}\n\n\nint dequeue(Queue* q) {\n    if (isEmpty(q)) return -1;\n    int value = q->data[q->front];\n    if (q->front == q->rear) {\n        q->front = q->rear = -1;\n    } else {\n        q->front++;\n    }\n    q->size--;\n    return value;\n}\n\n\nvoid bfs(Graph* graph, int start_vertex) {\n    int visited[MAX_VERTICES] = {0};\n    Queue* q = createQueue();\n    enqueue(q, start_vertex);\n    visited[start_vertex] = 1;\n\n    while (!isEmpty(q)) {\n        int vertex = dequeue(q);\n        //Process vertex\n\n        for (int i = 0; i < graph->vertices; i++) {\n            if (graph->adj_matrix[vertex][i] == 1 && !visited[i]) {\n                visited[i] = 1;\n                enqueue(q, i);\n            }\n        }\n    }\n    free(q);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__FUi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r6,[r4,#0]\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        STR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r5,#0\n        CMP      r6,#0\n        BLS      |L1.188|\n|L1.84|\n        MOV      r1,#4\n        MOV      r0,r6\n        BL       calloc\n        LDR      r1,[r4,#4]\n        CMP      r0,#0\n        STR      r0,[r1,r5,LSL #2]\n        BNE      |L1.176|\n        MOV      r6,#0\n        CMP      r5,#0\n        BLS      |L1.148|\n|L1.124|\n        LDR      r0,[r4,#4]\n        LDR      r0,[r0,r6,LSL #2]\n        BL       free\n        ADD      r6,r6,#1\n        CMP      r6,r5\n        BCC      |L1.124|\n|L1.148|\n        LDR      r0,[r4,#4]\n        BL       free\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.176|\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        BCC      |L1.84|\n|L1.188|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphUiT2 PROC\n        CMP      r0,#0\n        LDRNE    r3,[r0,#0]\n        CMPNE    r3,r1\n        CMPHI    r3,r2\n        BXLS     lr\n        LDR      r12,[r0,#4]\n        MOV      r3,#1\n        LDR      r12,[r12,r1,LSL #2]\n        STR      r3,[r12,r2,LSL #2]\n        LDR      r0,[r0,#4]\n        LDR      r0,[r0,r2,LSL #2]\n        STR      r3,[r0,r1,LSL #2]\n        BX       lr\n        ENDP\n\nfreeGraph__FP5Graph PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLS      |L1.312|\n|L1.284|\n        LDR      r0,[r5,#4]\n        LDR      r0,[r0,r4,LSL #2]\n        BL       free\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BHI      |L1.284|\n|L1.312|\n        LDR      r0,[r5,#4]\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n\ntypedef unsigned int uint;\n\nstruct Graph {\n    uint size;\n    uint** matrix;\n};\n\nstruct Graph* createGraph(uint size) {\n    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));\n    if (graph == NULL) return NULL;\n    graph->size = size;\n    graph->matrix = (uint**)malloc(size * sizeof(uint*));\n    if (graph->matrix == NULL) {\n        free(graph);\n        return NULL;\n    }\n    for (uint i = 0; i < size; i++) {\n        graph->matrix[i] = (uint*)calloc(size, sizeof(uint));\n        if (graph->matrix[i] == NULL) {\n            for (uint j = 0; j < i; j++) free(graph->matrix[j]);\n            free(graph->matrix);\n            free(graph);\n            return NULL;\n        }\n    }\n    return graph;\n}\n\n\nvoid addEdge(struct Graph* graph, uint u, uint v) {\n    if (graph == NULL || u >= graph->size || v >= graph->size) return;\n    graph->matrix[u][v] = 1;\n    graph->matrix[v][u] = 1;\n}\n\n\nvoid freeGraph(struct Graph* graph) {\n    if (graph == NULL) return;\n    for (uint i = 0; i < graph->size; i++) free(graph->matrix[i]);\n    free(graph->matrix);\n    free(graph);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmergeSortedLists__FP4NodeT1 PROC\n        STMFD    sp!,{r4,lr}\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,r1\n        BXEQ     lr\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        BGT      |L1.68|\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        BL       mergeSortedLists__FP4NodeT1\n        STR      r0,[r4,#4]\n        B        |L1.84|\n|L1.68|\n        MOV      r4,r1\n        LDR      r1,[r1,#4]\n        BL       mergeSortedLists__FP4NodeT1\n        STR      r0,[r4,#4]\n|L1.84|\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nNode* mergeSortedLists(Node* l1, Node* l2) {\n    if (l1 == NULL) return l2;\n    if (l2 == NULL) return l1;\n\n    Node* result = NULL;\n    if (l1->data <= l2->data) {\n        result = l1;\n        result->next = mergeSortedLists(l1->next, l2);\n    } else {\n        result = l2;\n        result->next = mergeSortedLists(l1, l2->next);\n    }\n    return result;\n}\n\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisIdentityMatrix__FPA100_ii PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.112|\n|L1.16|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.100|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r12,r0,r12,LSL #4\n|L1.40|\n        CMP      r3,r2\n        LDR      lr,[r12,r2,LSL #2]\n        BNE      |L1.72|\n        CMP      lr,#1\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        B        |L1.88|\n|L1.72|\n        CMP      lr,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.88|\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.40|\n|L1.100|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.16|\n|L1.112|\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isIdentityMatrix(int matrix[][100], int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            if (i == j) {\n                if (matrix[i][j] != 1) return 0;\n            } else {\n                if (matrix[i][j] != 0) return 0;\n            }\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsolve_tridiagonal__FPdN31i PROC\n|L1.0|\n        STMFD    sp!,{r0-r11,lr}\n        SUB      sp,sp,#4\n        LDR      r7,[sp,#0x38]\n        MOV      r0,r7,LSL #2\n        BL       malloc\n        MOVS     r6,r0\n        ADDEQ    sp,sp,#0x14\n        LDMEQFD  sp!,{r4-r11,lr}\n        BXEQ     lr\n        MOV      r4,r7,LSL #3\n        MOV      r0,r4\n        BL       malloc\n        MOV      r8,r0\n        MOV      r0,r4\n        BL       malloc\n        MOV      r5,r0\n        CMP      r8,#0\n        CMPNE    r5,#0\n        BNE      |L1.100|\n        MOV      r0,r6\n        BL       free\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.100|\n        LDR      r2,[sp,#8]\n        LDMIA    r2,{r2,r3}\n        LDR      r0,[sp,#0xc]\n        LDMIA    r0,{r0,r1}\n        BL       _ddiv\n        STMIA    r8,{r0,r1}\n        LDR      r2,[sp,#8]\n        LDMIA    r2,{r2,r3}\n        LDR      r0,[sp,#0x10]\n        LDMIA    r0,{r0,r1}\n        BL       _ddiv\n        MOV      r4,#1\n        CMP      r7,#1\n        STMIA    r5,{r0,r1}\n        BLE      |L1.308|\n|L1.160|\n        LDR      r1,[sp,#4]\n        ADD      r11,r8,r4,LSL #3\n        LDMDB    r11,{r2,r3}\n        ADD      r10,r1,r4,LSL #3\n        LDMIA    r10,{r0,r1}\n        BL       _dmul\n        LDR      r2,[sp,#8]\n        ADD      r2,r2,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _drsb\n        ADR      r2,|L1.424|\n        LDMIA    r2,{r2,r3}\n        BL       _drdiv\n        MOV      r9,r0\n        LDR      r0,[sp,#0xc]\n        STR      r1,[sp,#0]\n        MOV      r3,r1\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        MOV      r2,r9\n        BL       _dmul\n        STMIA    r11,{r0,r1}\n        ADD      r11,r5,r4,LSL #3\n        LDMDB    r11,{r2,r3}\n        LDMIA    r10,{r0,r1}\n        BL       _dmul\n        LDR      r2,[sp,#0x10]\n        ADD      r2,r2,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _drsb\n        MOV      r2,r9\n        LDR      r3,[sp,#0]\n        BL       _dmul\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        STMIA    r11,{r0,r1}\n        BLT      |L1.160|\n|L1.308|\n        ADD      r0,r5,r7,LSL #3\n        SUB      r0,r0,#8\n        LDMIA    r0,{r0,r1}\n        BL       _dfix\n        ADD      r1,r6,r7,LSL #2\n        STR      r0,[r1,#-4]\n        SUBS     r4,r7,#2\n        BMI      |L1.392|\n|L1.340|\n        ADD      r0,r6,r4,LSL #2\n        LDR      r0,[r0,#4]\n        BL       _dflt\n        ADD      r2,r8,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADD      r2,r5,r4,LSL #3\n        LDMIA    r2,{r2,r3}\n        BL       _drsb\n        BL       _dfix\n        STR      r0,[r6,r4,LSL #2]\n        SUBS     r4,r4,#1\n        BPL      |L1.340|\n|L1.392|\n        MOV      r0,r8\n        BL       free\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        ADD      sp,sp,#0x14\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.424|\n        DCFD     0x3ff0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nint* solve_tridiagonal(double* a, double* b, double* c, double* d, int n) {\n    int* x = (int*)malloc(n * sizeof(int));\n    if (x == NULL) return NULL;\n\n    double* c_prime = (double*)malloc(n * sizeof(double));\n    double* d_prime = (double*)malloc(n * sizeof(double));\n    if (c_prime == NULL || d_prime == NULL) {\n        free(x);\n        return NULL;\n    }\n\n    c_prime[0] = c[0] / b[0];\n    d_prime[0] = d[0] / b[0];\n\n    for (int i = 1; i < n; i++) {\n        double m = 1.0 / (b[i] - a[i] * c_prime[i - 1]);\n        c_prime[i] = c[i] * m;\n        d_prime[i] = (d[i] - a[i] * d_prime[i - 1]) * m;\n    }\n\n    x[n - 1] = (int)d_prime[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        x[i] = (int)(d_prime[i] - c_prime[i] * x[i + 1]);\n    }\n\n    free(c_prime);\n    free(d_prime);\n    return x;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__Fxi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        CMP      r2,#0\n        ADREQ    r1,|L1.144|\n        MOV      r5,r0\n        LDMEQIA  r1,{r0,r1}\n        MOV      r4,r2\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADRLT    r1,|L1.152|\n        LDMLTIA  r1,{r0,r1}\n        LDMLTFD  sp!,{r4-r6,lr}\n        BXLT     lr\n        CMP      r4,#1\n        MOVEQ    r0,r5\n        MOVEQ    r1,r6\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADD      r0,r4,r4,LSR #31\n        MOV      r2,r0,ASR #1\n        MOV      r0,r5\n        MOV      r1,r6\n        BL       power__Fxi\n        UMULL    lr,r12,r0,r0\n        MLA      r12,r0,r1,r12\n        MOV      r3,r1\n        MLA      r1,r3,r0,r12\n        AND      r2,r4,#0x80000001\n        CMP      r2,#1\n        MOV      r0,lr\n        UMULLEQ  lr,r12,r0,r5\n        MLAEQ    r12,r5,r1,r12\n        MLAEQ    r1,r6,r0,r12\n        MOVEQ    r0,lr\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.144|\n        DCQ      0x0000000000000001\n|L1.152|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nlong long power(long long base, int exp) {\n    if (exp == 0) return 1;\n    if (exp < 0) return 0; // Handle negative exponents (could also throw an error)\n    if (exp == 1) return base;\n    long long halfPower = power(base, exp / 2);\n    long long result = halfPower * halfPower;\n    if (exp % 2 == 1) result *= base;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsumNodes__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       sumNodes__FP4Node\n        LDR      r1,[r4,#0]\n        ADD      r5,r0,r1\n        LDR      r0,[r4,#8]\n        BL       sumNodes__FP4Node\n        ADD      r0,r5,r0\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\n\nint sumNodes(Node *root) {\n    if (root == NULL) return 0;\n    return root->data + sumNodes(root->left) + sumNodes(root->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhanoi__FiN31 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        MOV      r4,r0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        SUB      r0,r4,#1\n        MOV      r8,r0\n        MOV      r3,r6\n        MOV      r2,r7\n        MOV      r1,r5\n        BL       hanoi__FiN31\n        MOV      r3,r4\n        MOV      r2,r6\n        MOV      r1,r5\n        ADR      r0,|L1.100|\n        BL       _printf\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r7\n        MOV      r0,r8\n        LDMFD    sp!,{r4-r8,lr}\n        B        hanoi__FiN31\n|L1.100|\n        DCB      \"%d %\"\n        DCB      \"d %d\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid hanoi(int n, int source, int destination, int auxiliary) {\n    if (n > 0) {\n        hanoi(n - 1, source, auxiliary, destination);\n        printf(\"%d %d %d\\n\", source, destination, n);\n        hanoi(n - 1, auxiliary, destination, source);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nunpack__FUiiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r5,r0\n        MOV      r4,r1\n        CMP      r1,#0\n        BLE      |L1.32|\n        CMP      r5,#0\n        BNE      |L1.44|\n|L1.32|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.44|\n        MOV      r1,#0x20\n        MOV      r0,r4\n        BL       __rt_sdiv\n        CMP      r1,#0\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r2,#1\n        MOV      r2,r2,LSL r0\n        SUB      r2,r2,#1\n        MOV      r1,#0\n        SUB      r12,r4,#1\n|L1.92|\n        SUB      r3,r12,r1\n        MUL      r3,r0,r3\n        AND      r3,r2,r5,LSR r3\n        STR      r3,[r6,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,r4\n        BLT      |L1.92|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int unpack(unsigned int packed, int num_ints, int* unpacked_ints) {\n    if (num_ints <= 0 || packed == 0) return 0;\n\n    int bits_per_int = 32 / num_ints;\n    if (32 % num_ints != 0) return 0;\n\n    for (int i = 0; i < num_ints; ++i) {\n        unsigned int mask = (1 << bits_per_int) - 1;\n        unpacked_ints[i] = (packed >> (bits_per_int * (num_ints - 1 - i))) & mask;\n    }\n    return num_ints;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npush__Fi PROC\n|L1.0|\n        LDR      r2,|L1.316|\n        MOV      r1,r0\n        LDR      r0,[r2,#0]  ; top\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0]  ; top\n        LDR      r2,|L1.320|\n        STR      r1,[r2,r0,LSL #2]\n        BX       lr\n        ENDP\n\npop__Fv PROC\n        LDR      r1,|L1.316|\n        LDR      r0,[r1,#0]  ; top\n        SUB      r2,r0,#1\n        STR      r2,[r1,#0]  ; top\n        LDR      r1,|L1.320|\n        LDR      r0,[r1,r0,LSL #2]\n        BX       lr\n        ENDP\n\ntopologicalSortUtil__FiPA100_iT1 PROC\n        STMFD    sp!,{r4-r9,lr}\n        LDR      r9,|L1.324|\n        MOV      r6,r0\n        MOV      r0,#1\n        STR      r0,[r9,r6,LSL #2]\n        MOV      r7,r1\n        MOV      r5,r2\n        MOV      r4,#0\n        CMP      r2,#0\n        BLE      |L1.164|\n        ADD      r0,r6,r6,LSL #3\n        ADD      r0,r0,r6,LSL #4\n        ADD      r8,r7,r0,LSL #4\n|L1.112|\n        LDR      r0,[r8,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r0,[r9,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.152|\n        MOV      r2,r5\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       topologicalSortUtil__FiPA100_iT1\n|L1.152|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.112|\n|L1.164|\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r9,lr}\n        B        push__Fi\n        ENDP\n\ntopologicalSort__FPA100_ii PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r7,|L1.324|\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r1,#0x190\n        MOV      r0,r7\n        BL       __rt_memclr_w\n        LDR      r8,|L1.316|\n        MVN      r0,#0\n        STR      r0,[r8,#0]  ; top\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.268|\n|L1.228|\n        LDR      r0,[r7,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.256|\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       topologicalSortUtil__FiPA100_iT1\n|L1.256|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.228|\n|L1.268|\n        LDR      r4,[r8,#0]  ; top\n        CMP      r4,#0\n        BLT      |L1.304|\n        LDR      r5,|L1.320|\n|L1.284|\n        LDR      r1,[r5,r4,LSL #2]\n        ADR      r0,|L1.328|\n        BL       _printf\n        SUBS     r4,r4,#1\n        BPL      |L1.284|\n|L1.304|\n        ADR      r0,|L1.332|\n        LDMFD    sp!,{r4-r8,lr}\n        B        _printf\n|L1.316|\n        DCD      top\n|L1.320|\n        DCD      ||.bss$2|| + 400\n|L1.324|\n        DCD      ||.bss$2||\n|L1.328|\n        DCB      \"%d \\0\"\n|L1.332|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint stack[MAX_VERTICES];\nint top = -1;\n\nvoid push(int v) {\n    stack[++top] = v;\n}\n\nint pop() {\n    return stack[top--];\n}\n\nvoid topologicalSortUtil(int v, int graph[MAX_VERTICES][MAX_VERTICES], int n) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (graph[v][i] && !visited[i]) {\n            topologicalSortUtil(i, graph, n);\n        }\n    }\n    push(v);\n}\n\n\nvoid topologicalSort(int graph[MAX_VERTICES][MAX_VERTICES], int n) {\n    memset(visited, 0, sizeof(visited));\n    top = -1;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            topologicalSortUtil(i, graph, n);\n        }\n    }\n    for (int i = top; i >= 0; i--) {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitialize__FP5Stack PROC\n|L1.0|\n        MVN      r1,#0\n        STR      r1,[r0,#0x64]\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#0x64]\n        CMN      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisFull__FP5Stack PROC\n        LDR      r0,[r0,#0x64]\n        CMP      r0,#0x63\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\npush__FP5Stackc PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        BL       isFull__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        BXNE     lr\n        LDR      r0,[r2,#0x64]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0x64]\n        STRB     r1,[r2,r0]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r2,[r1,#0x64]\n        LDRB     r0,[r1,r2]\n        SUB      r2,r2,#1\n        STR      r2,[r1,#0x64]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nareParenthesisBalanced__FPc PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#0x68\n        MOV      r4,r0\n        MOV      r0,sp\n        MOV      r5,sp\n        BL       initialize__FP5Stack\n        MOV      r0,r4\n        BL       strlen\n        MOV      r6,r0\n        MOV      r3,#0\n        CMP      r0,#0\n        BLE      |L1.372|\n|L1.200|\n        LDRB     r1,[r4,r3]\n        CMP      r1,#0x28\n        CMPNE    r1,#0x5b\n        CMPNE    r1,#0x7b\n        BNE      |L1.232|\n        MOV      r0,r5\n        BL       push__FP5Stackc\n        B        |L1.360|\n|L1.232|\n        CMP      r1,#0x29\n        CMPNE    r1,#0x5d\n        CMPNE    r1,#0x7d\n        BNE      |L1.360|\n        MOV      r0,r5\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        ADDNE    sp,sp,#0x68\n        LDMNEFD  sp!,{r4-r6,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r0,r5\n        BL       pop__FP5Stack\n        LDRB     r1,[r4,r3]\n        CMP      r1,#0x29\n        BNE      |L1.308|\n        CMP      r0,#0x28\n        BEQ      |L1.360|\n        B        |L1.344|\n|L1.308|\n        CMP      r1,#0x5d\n        BNE      |L1.328|\n        CMP      r0,#0x5b\n        BEQ      |L1.360|\n        B        |L1.344|\n|L1.328|\n        CMP      r1,#0x7d\n        BNE      |L1.360|\n        CMP      r0,#0x7b\n        BEQ      |L1.360|\n|L1.344|\n        ADD      sp,sp,#0x68\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.360|\n        ADD      r3,r3,#1\n        CMP      r3,r6\n        BLT      |L1.200|\n|L1.372|\n        MOV      r0,r5\n        BL       isEmpty__FP5Stack\n        ADD      sp,sp,#0x68\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    char data[MAX_SIZE];\n    int top;\n} Stack;\n\nvoid initialize(Stack *s) {\n    s->top = -1;\n}\n\nint isEmpty(Stack *s) {\n    return s->top == -1;\n}\n\nint isFull(Stack *s) {\n    return s->top == MAX_SIZE - 1;\n}\n\nvoid push(Stack *s, char c) {\n    if (isFull(s)) return;\n    s->top++;\n    s->data[s->top] = c;\n}\n\nchar pop(Stack *s) {\n    if (isEmpty(s)) return '\\0';\n    char c = s->data[s->top];\n    s->top--;\n    return c;\n}\n\nint areParenthesisBalanced(char exp[]) {\n    Stack s;\n    initialize(&s);\n    int len = strlen(exp);\n    for (int i = 0; i < len; i++) {\n        if (exp[i] == '(' || exp[i] == '[' || exp[i] == '{') {\n            push(&s, exp[i]);\n        } else if (exp[i] == ')' || exp[i] == ']' || exp[i] == '}') {\n            if (isEmpty(&s)) return 0;\n            char top = pop(&s);\n            if ((exp[i] == ')' && top != '(') || (exp[i] == ']' && top != '[') || (exp[i] == '}' && top != '{'))\n                return 0;\n        }\n    }\n    return isEmpty(&s);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_digits__Fi PROC\n        CMP      r0,#0\n        RSBLT    r0,r0,#0\n        STMFD    sp!,{r4,lr}\n        CMP      r0,#0xa\n        LDMLTFD  sp!,{r4,lr}\n        BXLT     lr\n        LDR      r1,|L1.120|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r4,r0,r2,LSL #1\n        SMULL    r2,r0,r1,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        BL       sum_digits__Fi\n        ADD      r0,r4,r0\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_digits(int n) {\n    if (n < 0) n = -n;\n    if (n < 10) return n;\n    return n % 10 + sum_digits(n / 10);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateInventorySystem__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        RSB      r0,r5,r5,LSL #4\n        MOV      r0,r0,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r0,#0\n        STMIB    r4,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddItem__FP15InventorySystemPCciT3 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r7,r3\n        MOV      r6,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        CMP      r1,r0\n        BNE      |L1.176|\n        MOV      r5,r0,LSL #1\n        RSB      r1,r5,r5,LSL #4\n        MOV      r1,r1,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r5,[r4,#8]\n|L1.176|\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #4\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r8\n        BL       strcpy\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #4\n        ADD      r0,r0,r1,LSL #2\n        STR      r6,[r0,#0x34]\n        LDMIA    r4,{r0,r1}\n        RSB      r1,r1,r1,LSL #4\n        ADD      r0,r0,r1,LSL #2\n        STR      r7,[r0,#0x38]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct InventoryItem {\n    char name[50];\n    int stockLevel;\n    int reorderPoint;\n};\n\nstruct InventorySystem {\n    InventoryItem* items;\n    int numItems;\n    int capacity;\n};\n\nInventorySystem* createInventorySystem(int initialCapacity) {\n    InventorySystem* system = (InventorySystem*)malloc(sizeof(InventorySystem));\n    if (system == NULL) return NULL;\n    system->items = (InventoryItem*)malloc(initialCapacity * sizeof(InventoryItem));\n    if (system->items == NULL) {\n        free(system);\n        return NULL;\n    }\n    system->numItems = 0;\n    system->capacity = initialCapacity;\n    return system;\n}\n\nint addItem(InventorySystem* system, const char* name, int stockLevel, int reorderPoint) {\n    if (system == NULL) return 0;\n    if (system->numItems == system->capacity) {\n        int newCapacity = system->capacity * 2;\n        InventoryItem* newItems = (InventoryItem*)realloc(system->items, newCapacity * sizeof(InventoryItem));\n        if (newItems == NULL) return 0;\n        system->items = newItems;\n        system->capacity = newCapacity;\n    }\n    strcpy(system->items[system->numItems].name, name);\n    system->items[system->numItems].stockLevel = stockLevel;\n    system->items[system->numItems].reorderPoint = reorderPoint;\n    system->numItems++;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninorderPredecessor__FP4Nodei PROC\n        MOVS     r2,r0\n        MOV      r0,#0\n        BXEQ     lr\n|L1.12|\n        LDR      r3,[r2,#0]\n        CMP      r3,r1\n        MOVLT    r0,r2\n        LDRLT    r2,[r2,#8]\n        LDRGE    r2,[r2,#4]\n        CMP      r2,#0\n        BNE      |L1.12|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nNode* inorderPredecessor(Node* root, int data) {\n    Node* predecessor = NULL;\n    Node* current = root;\n    while (current != NULL) {\n        if (data <= current->data) {\n            current = current->left;\n        } else {\n            predecessor = current;\n            current = current->right;\n        }\n    }\n    return predecessor;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nvalidateData__FPciT2T1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r2\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r4,r3\n        BL       strlen\n        CMP      r0,r6\n        BLT      |L1.40|\n        CMP      r0,r7\n        BLE      |L1.52|\n|L1.40|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.52|\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.148|\n        LDRB     lr,[r4,#0]\n|L1.68|\n        LDRB     r3,[r5,r2]\n        MOV      r12,#0\n        MOV      r1,#0\n        CMP      lr,#0\n        BEQ      |L1.124|\n|L1.88|\n        LDRB     r6,[r4,r1]\n        CMP      r6,r3\n        BEQ      |L1.136|\n        ADD      r1,r1,#1\n        LDRB     r6,[r4,r1]\n        CMP      r6,#0\n        BNE      |L1.88|\n        CMP      r12,#0\n        BNE      |L1.136|\n|L1.124|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.136|\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.68|\n|L1.148|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint validateData(char *data, int minLength, int maxLength, char *allowedChars) {\n    int len = strlen(data);\n    if (len < minLength || len > maxLength) return 0;\n    for (int i = 0; i < len; i++) {\n        char c = data[i];\n        int found = 0;\n        for (int j = 0; allowedChars[j] != '\\0'; j++) {\n            if (c == allowedChars[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlinear_search__FPiiT2 PROC\n|L1.0|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.40|\n|L1.12|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,r2\n        MOVEQ    r0,r3\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.12|\n|L1.40|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint linear_search(int arr[], int size, int target) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninit_game__FPP4Room PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        MOV      r4,r0\n        ADR      r2,|L1.232|\n        LDRH     r0,[r2,#0]\n        STRH     r0,[r1,#0]\n        LDRH     r0,[r2,#2]\n        STRH     r0,[r1,#2]\n        LDRH     r0,[r2,#4]\n        MOV      r2,#0x28\n        STRH     r0,[r1,#4]\n        LDR      r0,[r4,#0]\n        ADR      r1,|L1.240|\n        ADD      r0,r0,#0x32\n        BL       __rt_memcpy\n        MOV      r2,#7\n        ADR      r1,|L1.280|\n        LDR      r0,[r4,#4]\n        BL       __rt_memcpy\n        LDR      r0,[r4,#4]\n        MOV      r2,#0x28\n        ADR      r1,|L1.288|\n        ADD      r0,r0,#0x32\n        BL       __rt_memcpy\n        MOV      r2,#5\n        ADR      r1,|L1.328|\n        LDR      r0,[r4,#8]\n        BL       __rt_memcpy\n        LDR      r0,[r4,#8]\n        MOV      r2,#0x24\n        ADR      r1,|L1.336|\n        ADD      r0,r0,#0x32\n        BL       __rt_memcpy\n        LDR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r0,[r1,#0x98]\n        LDMIA    r4,{r0,r1}\n        STR      r0,[r1,#0x9c]\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        STR      r0,[r1,#0x98]\n        LDMIB    r4,{r0,r1}\n        STR      r0,[r1,#0x9c]\n        LDR      r1,[r4,#0]\n        MOV      r0,#0\n        STR      r0,[r1,#0xa0]\n        LDR      r1,[r4,#0]\n        STR      r0,[r1,#0xa4]\n        LDR      r1,[r4,#4]\n        STR      r0,[r1,#0xa0]\n        LDR      r1,[r4,#4]\n        STR      r0,[r1,#0xa4]\n        LDR      r1,[r4,#8]\n        STR      r0,[r1,#0xa0]\n        LDR      r1,[r4,#8]\n        STR      r0,[r1,#0xa4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.232|\n        DCB      \"Star\"\n        DCB      \"t\\0\\0\\0\"\n|L1.240|\n        DCB      \"You \"\n        DCB      \"are \"\n        DCB      \"at t\"\n        DCB      \"he s\"\n        DCB      \"tart\"\n        DCB      \" of \"\n        DCB      \"your\"\n        DCB      \" adv\"\n        DCB      \"entu\"\n        DCB      \"re.\\0\"\n|L1.280|\n        DCB      \"Fore\"\n        DCB      \"st\\0\\0\"\n|L1.288|\n        DCB      \"Tree\"\n        DCB      \"s su\"\n        DCB      \"rrou\"\n        DCB      \"nd y\"\n        DCB      \"ou. \"\n        DCB      \"A pa\"\n        DCB      \"th l\"\n        DCB      \"eads\"\n        DCB      \" nor\"\n        DCB      \"th.\\0\"\n|L1.328|\n        DCB      \"Cave\"\n        DCB      \"\\0\\0\\0\\0\"\n|L1.336|\n        DCB      \"You \"\n        DCB      \"are \"\n        DCB      \"in a\"\n        DCB      \" dar\"\n        DCB      \"k ca\"\n        DCB      \"ve. \"\n        DCB      \"It\\'s\"\n        DCB      \" sca\"\n        DCB      \"ry.\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Room {\n    char name[50];\n    char description[100];\n    struct Room *north;\n    struct Room *south;\n    struct Room *east;\n    struct Room *west;\n};\n\nvoid init_game(struct Room *rooms[]) {\n    strcpy(rooms[0]->name, \"Start\");\n    strcpy(rooms[0]->description, \"You are at the start of your adventure.\");\n    strcpy(rooms[1]->name, \"Forest\");\n    strcpy(rooms[1]->description, \"Trees surround you. A path leads north.\");\n    strcpy(rooms[2]->name, \"Cave\");\n    strcpy(rooms[2]->description, \"You are in a dark cave. It's scary.\");\n\n    rooms[0]->north = rooms[1];\n    rooms[1]->south = rooms[0];\n    rooms[1]->north = rooms[2];\n    rooms[2]->south = rooms[1];\n\n    rooms[0]->east = 0;\n    rooms[0]->west = 0;\n    rooms[1]->east = 0;\n    rooms[1]->west = 0;\n    rooms[2]->east = 0;\n    rooms[2]->west = 0;\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisSubset__FPiiT1T2 PROC\n|L1.0|\n        CMP      r3,#0\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r1,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r6,lr}\n        MOV      lr,#0\n        CMP      r3,#0\n        BLE      |L1.116|\n|L1.40|\n        MOV      r5,#0\n        MOV      r12,#0\n        CMP      r1,#0\n        BLE      |L1.92|\n        LDR      r4,[r2,lr,LSL #2]\n|L1.60|\n        LDR      r6,[r0,r12,LSL #2]\n        CMP      r4,r6\n        BEQ      |L1.104|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        BLT      |L1.60|\n        CMP      r5,#0\n        BNE      |L1.104|\n|L1.92|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.104|\n        ADD      lr,lr,#1\n        CMP      lr,r3\n        BLT      |L1.40|\n|L1.116|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isSubset(int* arr1, int size1, int* arr2, int size2) {\n    if (size2 == 0) return 1;\n    if (size1 == 0) return 0;\n\n    for (int i = 0; i < size2; i++) {\n        int found = 0;\n        for (int j = 0; j < size1; j++) {\n            if (arr2[i] == arr1[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateGraph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        STR      r5,[r0,#0]\n        MUL      r0,r5,r5\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        STMFD    sp!,{r4,lr}\n        LDR      lr,[r0,#0]\n        LDR      r12,[r0,#4]\n        MOV      r3,#1\n        MLA      r4,lr,r1,r2\n        STR      r3,[r12,r4,LSL #2]\n        LDMIA    r0,{r0,r12}\n        MLA      r1,r0,r2,r1\n        STR      r3,[r12,r1,LSL #2]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ncompareGraphs__FP5GraphT1 PROC\n        STR      lr,[sp,#-4]!\n        MOV      r12,r0\n        LDR      r0,[r0,#0]\n        LDR      r2,[r1,#0]\n        CMP      r0,r2\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        MUL      r3,r0,r0\n        CMP      r3,#0\n        MOV      r2,#0\n        BLE      |L1.188|\n        LDR      r0,[r1,#4]\n        LDR      r12,[r12,#4]\n|L1.152|\n        LDR      r1,[r12,r2,LSL #2]\n        LDR      lr,[r0,r2,LSL #2]\n        CMP      r1,lr\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.152|\n|L1.188|\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nareIsomorphic__FP5GraphT1 PROC\n        LDR      r2,[r0,#0]\n        LDR      r3,[r1,#0]\n        CMP      r2,r3\n        BEQ      compareGraphs__FP5GraphT1\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Graph {\n    int V;\n    int* adj;\n};\n\nstruct Graph* createGraph(int V) {\n    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));\n    graph->V = V;\n    graph->adj = (int*)calloc(V * V, sizeof(int));\n    return graph;\n}\n\nvoid addEdge(struct Graph* graph, int u, int v) {\n    graph->adj[u * graph->V + v] = 1;\n    graph->adj[v * graph->V + u] = 1;\n}\n\nint compareGraphs(struct Graph* graph1, struct Graph* graph2) {\n    if (graph1->V != graph2->V) return 0;\n    for (int i = 0; i < graph1->V * graph1->V; ++i) {\n        if (graph1->adj[i] != graph2->adj[i]) return 0;\n    }\n    return 1;\n\n}\n\nint areIsomorphic(struct Graph* graph1, struct Graph* graph2) {\n    if (graph1->V != graph2->V) return 0;\n    return compareGraphs(graph1,graph2);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nminKey__FPiPb PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MVN      r12,#0x80000000\n        MOV      r2,#0\n|L1.12|\n        LDR      r3,[r1,r2,LSL #2]\n        CMP      r3,#0\n        BNE      |L1.40|\n        LDR      r3,[r0,r2,LSL #2]\n        CMP      r3,r12\n        MOVLT    r12,r3\n        MOVLT    lr,r2\n|L1.40|\n        ADD      r2,r2,#1\n        CMP      r2,#5\n        BLT      |L1.12|\n        MOV      r0,lr\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\nprintMST__FPiPA5_i PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        ADR      r0,|L1.136|\n        MOV      r6,r1\n        BL       _printf\n        MOV      r4,#1\n|L1.88|\n        ADD      r0,r4,r4,LSL #2\n        LDR      r1,[r5,r4,LSL #2]\n        ADD      r0,r6,r0,LSL #2\n        LDR      r3,[r0,r1,LSL #2]\n        ADR      r0,|L1.152|\n        MOV      r2,r4\n        BL       _printf\n        ADD      r4,r4,#1\n        CMP      r4,#5\n        BLT      |L1.88|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.136|\n        DCB      \"Edge\"\n        DCB      \" \\tWe\"\n        DCB      \"ight\"\n        DCB      \"\\n\\0\\0\\0\"\n|L1.152|\n        DCB      \"%d -\"\n        DCB      \" %d \"\n        DCB      \"\\t%d \"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n\nprimMST__FPA5_i PROC\n        STMFD    sp!,{r4-r9,lr}\n        SUB      sp,sp,#0x3c\n        MOV      r5,r0\n        MOV      r0,#0\n        MOV      r6,sp\n        ADD      r7,sp,#0x14\n        MVN      r2,#0x80000000\n        MOV      r1,#0\n|L1.200|\n        STR      r2,[r7,r0,LSL #2]\n        STR      r1,[r6,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,#5\n        BLT      |L1.200|\n        MVN      r0,#0\n        STR      r0,[sp,#0x28]\n        MOV      r4,#0\n        MOV      r9,#1\n        STR      r1,[sp,#0x14]\n        ADD      r8,sp,#0x28\n|L1.244|\n        MOV      r1,r6\n        MOV      r0,r7\n        BL       minKey__FPiPb\n        ADD      r2,r0,r0,LSL #2\n        ADD      r2,r5,r2,LSL #2\n        STR      r9,[r6,r0,LSL #2]\n        MOV      r1,#0\n|L1.272|\n        LDR      r3,[r2,r1,LSL #2]\n        CMP      r3,#0\n        BEQ      |L1.316|\n        LDR      r12,[r6,r1,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.316|\n        LDR      r12,[r7,r1,LSL #2]\n        CMP      r3,r12\n        STRLT    r0,[r8,r1,LSL #2]\n        LDRLT    r3,[r2,r1,LSL #2]\n        STRLT    r3,[r7,r1,LSL #2]\n|L1.316|\n        ADD      r1,r1,#1\n        CMP      r1,#5\n        BLT      |L1.272|\n        ADD      r4,r4,#1\n        CMP      r4,#4\n        BLT      |L1.244|\n        MOV      r1,r5\n        MOV      r0,r8\n        BL       printMST__FPiPA5_i\n        ADD      sp,sp,#0x3c\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define V 5\n\nint minKey(int key[], bool mstSet[]) {\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < V; v++)\n        if (mstSet[v] == false && key[v] < min)\n            min = key[v], min_index = v;\n    return min_index;\n}\n\nvoid printMST(int parent[], int graph[V][V]) {\n    printf(\"Edge \\tWeight\\n\");\n    for (int i = 1; i < V; i++)\n        printf(\"%d - %d \\t%d \\n\", parent[i], i, graph[i][parent[i]]);\n}\n\n\nvoid primMST(int graph[V][V]) {\n    int parent[V];\n    int key[V];\n    bool mstSet[V];\n\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n\n    key[0] = 0;\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++) {\n        int u = minKey(key, mstSet);\n        mstSet[u] = true;\n\n        for (int v = 0; v < V; v++)\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n    printMST(parent, graph);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsumEven__FiT1 PROC\n        MOV      r2,r0\n        CMP      r2,r1\n        MOV      r0,#0\n        BXGT     lr\n|L1.16|\n        TST      r2,#1\n        ADDEQ    r0,r0,r2\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLE      |L1.16|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sumEven(int start, int end) {\n    int sum = 0;\n    for (int i = start; i <= end; i++) {\n        if (i % 2 == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncommonNeighbors__FPC5GraphiT2 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r12,r0\n        LDR      r12,[r12,#0]\n        ADD      r1,r1,r1,LSL #1\n        ADD      r4,r12,r1,LSL #2\n        LDR      r5,[r4,#8]\n        MOV      r0,#0\n        CMP      r5,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        MOV      r3,#0\n        BXLE     lr\n        ADD      r1,r2,r2,LSL #1\n        ADD      r6,r12,r1,LSL #2\n        LDR      lr,[r6,#8]\n|L1.56|\n        MOV      r1,#0\n        CMP      lr,#0\n        BLE      |L1.104|\n        LDR      r2,[r4,#4]\n        LDR      r12,[r6,#4]\n        LDR      r2,[r2,r3,LSL #3]\n|L1.80|\n        LDR      r7,[r12,r1,LSL #3]\n        ADD      r1,r1,#1\n        CMP      r2,r7\n        ADDEQ    r0,r0,#1\n        CMP      lr,r1\n        BGT      |L1.80|\n|L1.104|\n        ADD      r3,r3,#1\n        CMP      r5,r3\n        BGT      |L1.56|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\npredictLink__FPC5GraphiT2 PROC\n        CMP      r1,#0\n        LDRGE    r3,[r0,#4]\n        CMPGE    r3,r1\n        BLE      |L1.160|\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BLE      |L1.160|\n        CMP      r1,r2\n        BNE      commonNeighbors__FPC5GraphiT2\n|L1.160|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Edge {\n    int to;\n    int weight;\n};\n\nstruct Node {\n    int id;\n    Edge* edges;\n    int edgeCount;\n};\n\nstruct Graph {\n    Node* nodes;\n    int nodeCount;\n};\n\n\nint commonNeighbors(const Graph* graph, int node1, int node2) {\n    int count = 0;\n    for (int i = 0; i < graph->nodes[node1].edgeCount; ++i) {\n        for (int j = 0; j < graph->nodes[node2].edgeCount; ++j) {\n            if (graph->nodes[node1].edges[i].to == graph->nodes[node2].edges[j].to) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\nint predictLink(const Graph* graph, int node1, int node2) {\n    if (node1 < 0 || node1 >= graph->nodeCount || node2 < 0 || node2 >= graph->nodeCount || node1 == node2) return 0;\n\n    return commonNeighbors(graph, node1, node2);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountingSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        MOV      r6,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        MOV      r0,#1\n        CMP      r7,#1\n        LDR      r5,[r6,#0]\n        BLE      |L1.64|\n|L1.40|\n        LDR      r1,[r6,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r1,r5\n        MOVGT    r5,r1\n        CMP      r0,r7\n        BLT      |L1.40|\n|L1.64|\n        CMP      r5,#0\n        LDMLTFD  sp!,{r4-r8,lr}\n        BXLT     lr\n        MOV      r0,#4\n        ADD      r8,r0,r5,LSL #2\n        MOV      r0,r8\n        BL       malloc\n        MOV      r4,r0\n        MOV      r1,r8\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r7,#0\n        BLE      |L1.148|\n|L1.116|\n        LDR      r1,[r6,r0,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r1,r4,r1,LSL #2\n        LDR      r2,[r1,#0]\n        CMP      r0,r7\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        BLT      |L1.116|\n|L1.148|\n        MOV      r3,#0\n        MOV      r0,#0\n        CMP      r5,#0\n        BLT      |L1.220|\n|L1.164|\n        LDR      r2,[r4,r0,LSL #2]\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.208|\n|L1.180|\n        MOV      r2,r3\n        STR      r0,[r6,r2,LSL #2]\n        LDR      r2,[r4,r0,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r2,r1\n        ADD      r3,r3,#1\n        BGT      |L1.180|\n|L1.208|\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLE      |L1.164|\n|L1.220|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nvoid countingSort(int arr[], int n) {\n    if (n <= 0) return;\n\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n\n    if (max < 0) return;\n\n    int* count = (int*)malloc((max + 1) * sizeof(int));\n    memset(count, 0, (max + 1) * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    int k = 0;\n    for (int i = 0; i <= max; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            arr[k++] = i;\n        }\n    }\n\n    free(count);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbigint_create__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        MOV      r5,r6,LSL #2\n        MOV      r0,r5\n        BL       malloc\n        MOV      r1,r5\n        STMIA    r4,{r0,r6}\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nbigint_destroy__FP6bigint PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nbigint_multiply__FP6biginti PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        MOV      r5,r1\n        ADD      r0,r0,#1\n        BL       bigint_create__Fi\n        LDR      r3,[r4,#4]\n        MOV      r2,#0\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.204|\n        LDR      r12,|L1.312|\n|L1.132|\n        LDR      r3,[r4,#0]\n        LDR      r3,[r3,r1,LSL #2]\n        MLA      r2,r5,r3,r2\n        SMULL    lr,r3,r12,r2\n        MOV      r3,r3,ASR #2\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        LDR      lr,[r0,#0]\n        ADD      r3,r2,r3,LSL #1\n        STR      r3,[lr,r1,LSL #2]\n        SMULL    r3,r2,r12,r2\n        LDR      r3,[r4,#4]\n        MOV      r2,r2,ASR #2\n        ADD      r1,r1,#1\n        CMP      r3,r1\n        SUB      r2,r2,r2,ASR #31\n        BGT      |L1.132|\n|L1.204|\n        LDR      r1,[r0,#0]\n        LDR      r3,[r4,#4]\n        STR      r2,[r1,r3,LSL #2]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nbigint_print__FP6bigint PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#4]\n        SUB      r4,r0,#1\n        B        |L1.248|\n|L1.244|\n        SUB      r4,r4,#1\n|L1.248|\n        CMP      r4,#0\n        ADRLT    r0,|L1.316|\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      _printf\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.244|\n|L1.280|\n        LDR      r0,[r5,#0]\n        LDR      r1,[r0,r4,LSL #2]\n        ADR      r0,|L1.320|\n        BL       _printf\n        SUBS     r4,r4,#1\n        BPL      |L1.280|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.312|\n        DCD      0x66666667\n|L1.316|\n        DCB      \"0\\0\\0\\0\"\n|L1.320|\n        DCB      \"%d\\0\\0\"\n        ENDP\n\nfactorial__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r5,#1\n        CMP      r0,#0\n        LDMLTFD  sp!,{r3-r7,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        BNE      |L1.380|\n        MOV      r0,#1\n        BL       bigint_create__Fi\n        LDR      r1,[r0,#0]\n        STR      r5,[r1,#0]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.380|\n        MOV      r0,#0x64\n        BL       bigint_create__Fi\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        CMP      r6,#2\n        STR      r5,[r0,#0]\n        MOV      r5,#2\n        BLT      |L1.452|\n|L1.412|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       bigint_multiply__FP6biginti\n        MOV      r7,r0\n        MOV      r0,r4\n        BL       bigint_destroy__FP6bigint\n        ADD      r5,r5,#1\n        CMP      r5,r6\n        MOV      r4,r7\n        BLE      |L1.412|\n|L1.452|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct bigint {\n    int *digits;\n    int size;\n};\n\nbigint* bigint_create(int size) {\n    bigint *b = (bigint*)malloc(sizeof(bigint));\n    b->digits = (int*)malloc(sizeof(int) * size);\n    b->size = size;\n    memset(b->digits, 0, sizeof(int) * size);\n    return b;\n}\n\nvoid bigint_destroy(bigint *b) {\n    free(b->digits);\n    free(b);\n}\n\n\nbigint* bigint_multiply(bigint* a, int b) {\n    bigint* result = bigint_create(a->size + 1);\n    int carry = 0;\n    for (int i = 0; i < a->size; i++) {\n        int product = a->digits[i] * b + carry;\n        result->digits[i] = product % 10;\n        carry = product / 10;\n    }\n    result->digits[a->size] = carry;\n    return result;\n\n}\n\nvoid bigint_print(bigint* a) {\n    int i = a->size -1;\n    while(i>=0 && a->digits[i] == 0) i--;\n    if (i<0) {\n        printf(\"0\");\n        return;\n    }\n    while(i>=0) {\n        printf(\"%d\", a->digits[i]);\n        i--;\n    }\n\n}\n\n\nbigint* factorial(int n) {\n    if (n < 0) return 0; \n    if (n == 0) {\n        bigint* result = bigint_create(1);\n        result->digits[0] = 1;\n        return result;\n    }\n    bigint* result = bigint_create(100);\n    result->digits[0] = 1;\n    for (int i = 2; i <= n; i++) {\n        bigint* temp = bigint_multiply(result, i);\n        bigint_destroy(result);\n        result = temp;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntopologicalSort__FPA100_ii PROC\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r11,r0\n        MOV      r9,r1,LSL #2\n        MOV      r0,r9\n        MOV      r5,r1\n        BL       malloc\n        MOV      r4,r0\n        MOV      r1,r9\n        BL       __rt_memclr_w\n        MOV      r1,#0\n        CMP      r5,#0\n        BLE      |L1.116|\n|L1.48|\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.104|\n        ADD      r2,r1,r1,LSL #3\n        ADD      r2,r2,r1,LSL #4\n        ADD      r3,r11,r2,LSL #4\n|L1.72|\n        LDR      r2,[r3,r0,LSL #2]\n        CMP      r2,#0\n        LDRNE    r2,[r4,r0,LSL #2]\n        ADDNE    r2,r2,#1\n        STRNE    r2,[r4,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.72|\n|L1.104|\n        ADD      r1,r1,#1\n        CMP      r1,r5\n        BLT      |L1.48|\n|L1.116|\n        MOV      r0,r9\n        BL       malloc\n        MOV      r7,r0\n        MOV      r0,#0\n        MOV      r8,#0\n        MOV      r6,#0\n        CMP      r5,#0\n        BLE      |L1.180|\n|L1.148|\n        LDR      r1,[r4,r0,LSL #2]\n        CMP      r1,#0\n        MOVEQ    r1,r6\n        STREQ    r0,[r7,r1,LSL #2]\n        ADD      r0,r0,#1\n        ADDEQ    r6,r6,#1\n        CMP      r0,r5\n        BLT      |L1.148|\n|L1.180|\n        MOV      r0,r9\n        BL       malloc\n        MOV      r10,r0\n        MOV      r9,#0\n        CMP      r8,r6\n        BGE      |L1.308|\n|L1.204|\n        MOV      r0,r8\n        LDR      r1,[r7,r0,LSL #2]\n        MOV      r0,r9\n        STR      r1,[r10,r0,LSL #2]\n        MOV      r0,#0\n        ADD      r9,r9,#1\n        ADD      r8,r8,#1\n        CMP      r5,#0\n        BLE      |L1.300|\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        ADD      r2,r11,r1,LSL #4\n|L1.252|\n        LDR      r1,[r2,r0,LSL #2]\n        CMP      r1,#0\n        BEQ      |L1.288|\n        LDR      r1,[r4,r0,LSL #2]\n        SUBS     r1,r1,#1\n        STR      r1,[r4,r0,LSL #2]\n        MOVEQ    r1,r6\n        STREQ    r0,[r7,r1,LSL #2]\n        ADDEQ    r6,r6,#1\n|L1.288|\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.252|\n|L1.300|\n        CMP      r8,r6\n        BLT      |L1.204|\n|L1.308|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r7\n        BL       free\n        CMP      r9,r5\n        MOV      r0,r10\n        LDMEQFD  sp!,{r3-r11,lr}\n        BXEQ     lr\n        BL       free\n        LDMFD    sp!,{r3-r11,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint* topologicalSort(int adj[][MAX_VERTICES], int numVertices) {\n    int* inDegree = (int*)malloc(numVertices * sizeof(int));\n    memset(inDegree, 0, numVertices * sizeof(int));\n    for (int u = 0; u < numVertices; u++) {\n        for (int v = 0; v < numVertices; v++) {\n            if (adj[u][v]) {\n                inDegree[v]++;\n            }\n        }\n    }\n\n    int* queue = (int*)malloc(numVertices * sizeof(int));\n    int head = 0;\n    int tail = 0;\n    for (int u = 0; u < numVertices; u++) {\n        if (inDegree[u] == 0) {\n            queue[tail++] = u;\n        }\n    }\n\n    int* sorted = (int*)malloc(numVertices * sizeof(int));\n    int count = 0;\n    while (head < tail) {\n        int u = queue[head++];\n        sorted[count++] = u;\n        for (int v = 0; v < numVertices; v++) {\n            if (adj[u][v]) {\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    queue[tail++] = v;\n                }\n            }\n        }\n    }\n\n    free(inDegree);\n    free(queue);\n    if (count != numVertices) {\n        free(sorted);\n        return NULL;\n    }\n    return sorted;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrandomWalk__FiPiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        MOV      r0,#0\n        MOV      r5,r2\n        MOV      r4,r1\n        BL       time\n        BL       srand\n        MOV      r0,#0\n        STR      r0,[r4,#0]\n        STR      r0,[r5,#0]\n        MOV      r6,#0\n        CMP      r7,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n|L1.56|\n        BL       rand\n        MOV      r1,r0,ASR #31\n        ADD      r1,r0,r1,LSR #30\n        MOV      r1,r1,ASR #2\n        SUBS     r0,r0,r1,LSL #2\n        LDREQ    r0,[r4,#0]\n        ADDEQ    r0,r0,#1\n        STREQ    r0,[r4,#0]\n        BEQ      |L1.148|\n        CMP      r0,#1\n        LDREQ    r0,[r4,#0]\n        SUBEQ    r0,r0,#1\n        STREQ    r0,[r4,#0]\n        BEQ      |L1.148|\n        CMP      r0,#2\n        LDREQ    r0,[r5,#0]\n        ADDEQ    r0,r0,#1\n        STREQ    r0,[r5,#0]\n        BEQ      |L1.148|\n        CMP      r0,#3\n        LDREQ    r0,[r5,#0]\n        SUBEQ    r0,r0,#1\n        STREQ    r0,[r5,#0]\n|L1.148|\n        ADD      r6,r6,#1\n        CMP      r6,r7\n        BLT      |L1.56|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid randomWalk(int steps, int* x, int* y) {\n    srand(time(NULL));\n    *x = 0;\n    *y = 0;\n    for (int i = 0; i < steps; i++) {\n        int r = rand() % 4;\n        switch (r) {\n            case 0: (*x)++; break;\n            case 1: (*x)--; break;\n            case 2: (*y)++; break;\n            case 3: (*y)--; break;\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nremoveDuplicates__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#4]\n        MOV      r4,r5\n        CMP      r0,#0\n        BEQ      |L1.80|\n|L1.32|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        LDR      r2,[r0,#0]\n        CMP      r1,r2\n        MOVNE    r4,r0\n        BNE      |L1.68|\n        LDR      r1,[r0,#4]\n        STR      r1,[r4,#4]\n        BL       free\n|L1.68|\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.32|\n|L1.80|\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nappendNode__FPP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        BL       createNode__Fi\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        BEQ      |L1.192|\n|L1.176|\n        LDR      r1,[r1,#4]\n        LDR      r2,[r1,#4]\n        CMP      r2,#0\n        BNE      |L1.176|\n|L1.192|\n        STR      r0,[r1,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nNode* removeDuplicates(Node* head) {\n    if (head == NULL) return NULL;\n    Node* current = head;\n    while (current->next != NULL) {\n        if (current->data == current->next->data) {\n            Node* temp = current->next;\n            current->next = current->next->next;\n            free(temp);\n        } else {\n            current = current->next;\n        }\n    }\n    return head;\n}\n\n\nNode* createNode(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid appendNode(Node** head, int data) {\n    Node* newNode = createNode(data);\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    Node* last = *head;\n    while (last->next != NULL) {\n        last = last->next;\n    }\n    last->next = newNode;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        MOV      r6,#0\n        MOV      r4,#1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r8,#1\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r1,r6\n        ADR      r0,|L1.132|\n        BL       _printf\n        MOV      r1,r4\n        ADR      r0,|L1.132|\n        BL       _printf\n        MOV      r5,#2\n        CMP      r8,#2\n        BLE      |L1.120|\n|L1.84|\n        ADD      r7,r6,r4\n        MOV      r1,r7\n        ADR      r0,|L1.132|\n        BL       _printf\n        MOV      r6,r4\n        ADD      r5,r5,#1\n        CMP      r5,r8\n        MOV      r4,r7\n        BLT      |L1.84|\n|L1.120|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.132|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint fibonacci(int limit) {\n    int a = 0, b = 1, temp;\n    if (limit <= 0) return 0;\n    if (limit == 1) return 1;\n\n    printf(\"%d \", a);\n    printf(\"%d \", b);\n\n    for (int i = 2; i < limit; i++) {\n        temp = a + b;\n        printf(\"%d \", temp);\n        a = b;\n        b = temp;\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsubsetSumRecursive__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r0\n        MOVS     r4,r2\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r1,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r7,r5,r1,LSL #2\n        LDR      r0,[r7,#-4]\n        SUB      r6,r1,#1\n        CMP      r0,r4\n        BLE      |L1.80|\n        MOV      r2,r4\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        B        subsetSumRecursive__FPiiT2\n|L1.80|\n        MOV      r2,r4\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       subsetSumRecursive__FPiiT2\n        MOV      r8,r0\n        LDR      r0,[r7,#-4]\n        MOV      r1,r6\n        SUB      r2,r4,r0\n        MOV      r0,r5\n        BL       subsetSumRecursive__FPiiT2\n        ADD      r0,r8,r0\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint subsetSumRecursive(int arr[], int n, int sum) {\n    if (sum == 0) return 1;\n    if (n == 0 && sum != 0) return 0;\n    if (arr[n - 1] > sum) return subsetSumRecursive(arr, n - 1, sum);\n    return subsetSumRecursive(arr, n - 1, sum) + subsetSumRecursive(arr, n - 1, sum - arr[n - 1]);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_safe__FiT1 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.72|\n        LDR      r12,|L1.308|\n|L1.20|\n        LDR      r3,[r12,r2,LSL #2]\n        SUB      r3,r3,r1\n        CMP      r3,#0\n        RSBLT    r3,r3,#0\n        CMP      r3,#0\n        SUBNE    lr,r0,r2\n        CMPNE    lr,r3\n        LDREQ    lr,[sp],#4\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.20|\n|L1.72|\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nsolve_nqueens_util__FiT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        CMP      r0,r1\n        BNE      |L1.128|\n        LDR      r0,|L1.312|\n        LDR      r1,[r0,#0]  ; count\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]  ; count\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.128|\n        MOV      r4,#0\n        CMP      r6,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        ADD      r7,r5,#1\n        LDR      r8,|L1.308|\n|L1.152|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       is_safe__FiT1\n        CMP      r0,#0\n        BEQ      |L1.188|\n        STR      r4,[r8,r5,LSL #2]\n        MOV      r1,r6\n        MOV      r0,r7\n        BL       solve_nqueens_util__FiT1\n|L1.188|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.152|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nsolve_nqueens__Fi PROC\n        CMP      r0,#0\n        BLE      |L1.224|\n        CMP      r0,#0x64\n        BLE      |L1.232|\n|L1.224|\n        MOV      r0,#0\n        BX       lr\n|L1.232|\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.312|\n        MOV      r1,#0\n        STR      r1,[r4,#0]  ; count\n        MOV      r1,r0\n        MOV      r0,#0\n        BL       solve_nqueens_util__FiT1\n        LDR      r0,[r4,#0]  ; count\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAXN 100\n\nint board[MAXN];\nint count;\n\nint is_safe(int row, int col) {\n    for (int prev = 0; prev < row; ++prev) {\n        int diff = abs(board[prev] - col);\n        if (diff == 0 || diff == row - prev)\n            return 0;\n    }\n    return 1;\n}\n\nvoid solve_nqueens_util(int row, int n) {\n    if (row == n) {\n        count++;\n        return;\n    }\n    for (int col = 0; col < n; ++col) {\n        if (is_safe(row, col)) {\n            board[row] = col;\n            solve_nqueens_util(row + 1, n);\n        }\n    }\n}\n\nint solve_nqueens(int n) {\n    if (n <= 0 || n > MAXN) return 0;\n    count = 0;\n    solve_nqueens_util(0, n);\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsieveOfEratosthenes__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r0,#2\n        MOVLT    r0,#0\n        LDMLTFD  sp!,{r4-r6,lr}\n        BLT      malloc\n        MOV      r0,#4\n        ADD      r6,r0,r4,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r5,#4]\n        STR      r2,[r5,#0]\n        MOV      r1,#2\n        CMP      r4,#4\n        BLT      |L1.136|\n|L1.80|\n        LDR      r0,[r5,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.120|\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BGT      |L1.120|\n|L1.104|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,r1\n        CMP      r0,r4\n        BLE      |L1.104|\n|L1.120|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BLE      |L1.80|\n|L1.136|\n        MOV      r1,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLT      |L1.176|\n|L1.152|\n        LDR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r1,r1,#1\n        CMP      r0,r4\n        BLE      |L1.152|\n|L1.176|\n        MOV      r0,r1,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        MOV      r2,#0\n        CMP      r4,#0\n        BLT      |L1.236|\n|L1.204|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        MOVNE    r1,r2\n        STRNE    r0,[r6,r1,LSL #2]\n        ADD      r0,r0,#1\n        ADDNE    r2,r2,#1\n        CMP      r0,r4\n        BLE      |L1.204|\n|L1.236|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* sieveOfEratosthenes(int limit) {\n    if (limit < 2) {\n        return (int*)malloc(0);\n    }\n    int* primes = (int*)malloc((limit + 1) * sizeof(int));\n    memset(primes, 1, (limit + 1) * sizeof(int));\n    primes[0] = primes[1] = 0;\n    for (int p = 2; p * p <= limit; p++) {\n        if (primes[p]) {\n            for (int i = p * p; i <= limit; i += p) {\n                primes[i] = 0;\n            }\n        }\n    }\n    int count = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i])\n            count++;\n    }\n\n    int* result = (int*)malloc(count * sizeof(int));\n    int k=0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) {\n            result[k++] = i;\n        }\n    }\n    free(primes);\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_string__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        ADD      r2,r0,r0,LSR #31\n        MOV      lr,r2,ASR #1\n        CMP      lr,#0\n        LDMLEFD  sp!,{r4,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.36|\n        SUB      r3,r0,r1\n        ADD      r3,r3,r4\n        LDRB     r12,[r3,#-1]\n        LDRB     r2,[r4,r1]\n        STRB     r12,[r4,r1]\n        ADD      r1,r1,#1\n        CMP      lr,r1\n        STRB     r2,[r3,#-1]\n        BGT      |L1.36|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverse_string(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nprocessData__FPCcT1 PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x400\n        MOV      r4,r1\n        ADR      r1,|L1.252|\n        SUB      sp,sp,#4\n        BL       fopen\n        MOVS     r5,r0\n        ADDEQ    sp,sp,#0x400\n        ADDEQ    sp,sp,#4\n        LDMEQFD  sp!,{r4-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r0,r4\n        ADR      r1,|L1.256|\n        BL       fopen\n        MOVS     r6,r0\n        BNE      |L1.96|\n        MOV      r0,r5\n        BL       fclose\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.96|\n        ADD      r7,sp,#4\n        MOV      r0,r7\n        MOV      r2,r5\n        MOV      r1,#0x400\n        BL       fgets\n        CMP      r0,#0\n        BEQ      |L1.216|\n|L1.124|\n        ADR      r1,|L1.260|\n        MOV      r0,r7\n        BL       strtok\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.176|\n|L1.148|\n        BL       atoi\n        ADD      r4,r0,r4\n        MOV      r0,#0\n        ADR      r1,|L1.260|\n        BL       strtok\n        CMP      r0,#0\n        BNE      |L1.148|\n|L1.176|\n        MOV      r2,r4\n        ADR      r1,|L1.264|\n        MOV      r0,r6\n        BL       _fprintf\n        MOV      r2,r5\n        MOV      r1,#0x400\n        MOV      r0,r7\n        BL       fgets\n        CMP      r0,#0\n        BNE      |L1.124|\n|L1.216|\n        MOV      r0,r5\n        BL       fclose\n        MOV      r0,r6\n        BL       fclose\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.252|\n        DCB      \"r\\0\\0\\0\"\n|L1.256|\n        DCB      \"w\\0\\0\\0\"\n|L1.260|\n        DCB      \" \\0\\0\\0\"\n|L1.264|\n        DCB      \"%d\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n\nint processData(const char* inputFile, const char* outputFile) {\n    FILE *in = fopen(inputFile, \"r\");\n    if (!in) return 1;\n    FILE *out = fopen(outputFile, \"w\");\n    if (!out) {\n        fclose(in);\n        return 1;\n    }\n\n    char buffer[1024];\n    while (fgets(buffer, sizeof(buffer), in) != NULL) {\n        char *token = strtok(buffer, \" \");\n        int sum = 0;\n        while (token != NULL) {\n            sum += atoi(token);\n            token = strtok(NULL, \" \");\n        }\n        fprintf(out, \"%d\\n\", sum);\n    }\n\n    fclose(in);\n    fclose(out);\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        CMP      r5,r0\n        ADDLE    r0,r0,#1\n        ADDGT    r0,r5,#1\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n};\n\nint height(Node* node) {\n    if (node == 0) return 0;\n    int lheight = height(node->left);\n    int rheight = height(node->right);\n    if (lheight > rheight) return(lheight + 1);\n    else return(rheight + 1);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r1\n        LDR      r7,|L1.376|\n        MOV      r1,#1\n        STR      r1,[r7,r0,LSL #2]\n        CMP      r5,#0\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.380|\n        ADD      r6,r0,r1,LSL #4\n|L1.52|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r7,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.84|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       dfs__FiT1\n|L1.84|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.52|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nis_connected__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        LDR      r5,|L1.376|\n        MOV      r4,r0\n        MOV      r0,r5\n        MOV      r1,#0x190\n        BL       __rt_memclr_w\n        MOV      r1,r4\n        MOV      r0,#0\n        BL       dfs__FiT1\n        MOV      r0,#0\n        CMP      r4,#0\n        BLE      |L1.184|\n|L1.152|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.152|\n|L1.184|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint adj_matrix[MAX_VERTICES][MAX_VERTICES];\n\nvoid dfs(int v, int n) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (adj_matrix[v][i] == 1 && !visited[i]) {\n            dfs(i, n);\n        }\n    }\n}\n\nint is_connected(int n) {\n    memset(visited, 0, sizeof(visited));\n    dfs(0, n);\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,#0x10\n        MOV      r5,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        STR      r6,[r4,#0]\n        BL       malloc\n        STR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.76|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.76|\n        MOV      r0,#0\n        ADD      r1,r4,#8\n        STMIA    r1,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\naddEdge__FP4NodeT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        CMPNE    r6,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r4,#8]\n        CMP      r1,r0\n        BNE      |L1.180|\n        MOV      r5,r0,LSL #1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#4]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#4]\n        STR      r5,[r4,#0xc]\n|L1.180|\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#8]\n        LDR      r1,[r4,#4]\n        STR      r6,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node** adj;\n    int adj_size;\n    int adj_capacity;\n};\n\nstruct Node* createNode(int data, int capacity) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    if (node == NULL) return NULL;\n    node->data = data;\n    node->adj = (struct Node**)malloc(capacity * sizeof(struct Node*));\n    if (node->adj == NULL) {\n        free(node);\n        return NULL;\n    }\n    node->adj_size = 0;\n    node->adj_capacity = capacity;\n    return node;\n}\n\nint addEdge(struct Node* src, struct Node* dest) {\n    if (src == NULL || dest == NULL) return 0;\n    if (src->adj_size == src->adj_capacity) {\n        int new_capacity = src->adj_capacity * 2;\n        struct Node** new_adj = (struct Node**)realloc(src->adj, new_capacity * sizeof(struct Node*));\n        if (new_adj == NULL) return 0;\n        src->adj = new_adj;\n        src->adj_capacity = new_capacity;\n    }\n    src->adj[src->adj_size++] = dest;\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#0]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        MOV      r5,r1\n        BL       malloc\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        STR      r1,[r0,#4]\n        STR      r0,[r4,#0]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MVNNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#0]\n        LDR      r2,[r0,#4]\n        LDR      r4,[r0,#0]\n        STR      r2,[r1,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Stack {\n    struct Node* top;\n};\n\nstruct Stack* createStack() {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->top = NULL;\n    return stack;\n}\n\nint isEmpty(struct Stack* stack) {\n    return stack->top == NULL;\n}\n\nvoid push(struct Stack* stack, int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\nint pop(struct Stack* stack) {\n    if (isEmpty(stack)) {\n        return -1; \n    }\n    struct Node* temp = stack->top;\n    int data = temp->data;\n    stack->top = temp->next;\n    free(temp);\n    return data;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringToUpper__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDRNEB   r0,[r5,#0]\n        MOVNE    r4,#0\n        CMPNE    r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n|L1.28|\n        LDRB     r0,[r5,r4]\n        BL       toupper\n        STRB     r0,[r5,r4]\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.28|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid stringToUpper(char* str) {\n    if (str == 0) return;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhypotenuse__FdT1 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r3\n        MOV      r4,r2\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDMFD    sp!,{r3-r7,lr}\n        B        __softfp_sqrt\n        ENDP\n```",
        "output": "```cpp\n\ndouble hypotenuse(double a, double b) {\n    return sqrt(a * a + b * b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r)\n        printf(\"%s\\n\", a);\n    else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i));\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FxT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        ADR      r10,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r10,{r2,r3}\n        MOV      r6,r0\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r7,r1\n        BEQ      |L1.108|\n|L1.44|\n        MOV      r8,r4\n        MOV      r9,r5\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        LDMIA    r10,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        MOV      r6,r8\n        MOV      r7,r9\n        BNE      |L1.44|\n|L1.108|\n        MOV      r0,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.124|\n        DCQ      0x0000000000000000\n        ENDP\n\nlcm__FxT1 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADR      r8,|L1.124|\n        MOV      r5,r3\n        MOV      r4,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r7,r1\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        MOV      r6,r0\n        BEQ      |L1.192|\n        LDMIA    r8,{r2,r3}\n        MOV      r0,r4\n        CMP      r5,r3\n        CMPEQ    r0,r2\n        BNE      |L1.204|\n|L1.192|\n        LDMIA    r8,{r0,r1}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.204|\n        UMULL    r8,r12,r6,r4\n        MLA      r12,r4,r7,r12\n        MLA      r9,r5,r6,r12\n        MOV      r3,r5\n        MOV      r2,r4\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       gcd__FxT1\n        MOV      r3,r9\n        MOV      r2,r8\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _ll_srdv\n        ENDP\n```",
        "output": "```cpp\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    if (a == 0 || b == 0) return 0;\n    return (a * b) / gcd(a, b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlinearRegression__FP5Pointi PROC\n|L1.0|\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#0x28\n        LDR      r0,[sp,#0x30]\n        CMP      r0,#1\n        BGT      |L1.68|\n        ADD      r0,sp,#0x14\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r4,#0\n        STMIA    r0,{r1-r4}\n        LDR      lr,[sp,#0x28]\n        LDMIA    r0,{r1-r4}\n        STMIA    lr,{r1-r4}\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.68|\n        ADR      r1,|L1.552|\n        LDMIA    r1,{r5,r6}\n        ADD      r0,sp,#0x1c\n        STMIA    r0,{r5,r6}\n        LDMIA    r1,{r0,r1}\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        MOV      r9,r5\n        MOV      r4,#0\n        MOV      r10,r6\n|L1.108|\n        LDR      r0,[sp,#0x2c]\n        MOV      r1,r6\n        ADD      r11,r0,r4,LSL #4\n        LDR      r3,[r11,#4]\n        LDR      r2,[r11,#0]\n        MOV      r0,r5\n        MOV      r7,r3\n        MOV      r8,r2\n        BL       _dadd\n        MOV      r5,r0\n        ADD      r0,r11,#8\n        LDR      r3,[r11,#0xc]\n        LDR      r2,[r0,#0]\n        MOV      r6,r1\n        MOV      r1,r10\n        MOV      r0,r9\n        MOV      r11,r3\n        STR      r2,[sp,#0x24]\n        BL       _dadd\n        MOV      r9,r0\n        MOV      r10,r1\n        MOV      r1,r7\n        MOV      r0,r8\n        MOV      r3,r11\n        LDR      r2,[sp,#0x24]\n        BL       _dmul\n        ADD      r3,sp,#0x1c\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        ADD      r11,sp,#0x1c\n        STMIA    r11,{r0,r1}\n        MOV      r1,r7\n        MOV      r0,r8\n        MOV      r3,r7\n        MOV      r2,r8\n        BL       _dmul\n        ADD      r3,sp,#0x14\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        LDR      r0,[sp,#0x30]\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.108|\n        LDR      r0,[sp,#0x30]\n        BL       _dflt\n        ADD      r3,sp,#0x1c\n        LDMIA    r3,{r2,r3}\n        MOV      r7,r1\n        MOV      r4,r0\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r11,r1\n        MOV      r1,r6\n        MOV      r0,r5\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r8\n        BL       _drsb\n        ADD      r2,sp,#0xc\n        STMIA    r2,{r0,r1}\n        ADD      r3,sp,#0x14\n        LDMIA    r3,{r2,r3}\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r11,r1\n        MOV      r1,r6\n        MOV      r0,r5\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dmul\n        MOV      r3,r11\n        MOV      r2,r8\n        BL       _drsb\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        MOV      r8,r0\n        MOV      r11,r1\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dmul\n        MOV      r3,r10\n        MOV      r2,r9\n        BL       _drsb\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r4\n        BL       _drdiv\n        MOV      lr,r1\n        MOV      r1,#0\n        ADD      r4,sp,#4\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r5,#0\n        STMIA    r4,{r1-r3,r5}\n        ADD      r1,sp,#0xc\n        STMIA    r1,{r0,lr}\n        STMIB    sp,{r8,r11}\n        LDR      lr,[sp,#0x28]\n        LDMIA    r4,{r0-r3}\n        STMIA    lr,{r0-r3}\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.552|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\nstruct Point {\n    double x;\n    double y;\n};\n\nstruct Result {\n    double slope;\n    double intercept;\n};\n\n\nResult linearRegression(Point* points, int n) {\n    if (n <= 1) {\n        Result result = {0,0};\n        return result;\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n\n    for (int i = 0; i < n; i++) {\n        sumX += points[i].x;\n        sumY += points[i].y;\n        sumXY += points[i].x * points[i].y;\n        sumX2 += points[i].x * points[i].x;\n    }\n\n    double slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    double intercept = (sumY - slope * sumX) / n;\n\n    Result result = {slope, intercept};\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\ninsert__FP12SparseMatrixiN22 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0xc]\n        STMIA    r0,{r5-r7}\n        LDR      r1,[r4,#0]\n        CMP      r1,#0\n        STREQ    r0,[r4,#0]\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        LDR      r2,[r1,#0xc]\n        CMP      r2,#0\n        BEQ      |L1.116|\n|L1.100|\n        LDR      r1,[r1,#0xc]\n        LDR      r2,[r1,#0xc]\n        CMP      r2,#0\n        BNE      |L1.100|\n|L1.116|\n        STR      r0,[r1,#0xc]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int row;\n    int col;\n    int val;\n    Node *next;\n};\n\nstruct SparseMatrix {\n    Node *head;\n};\n\nSparseMatrix* createMatrix() {\n    SparseMatrix* matrix = (SparseMatrix*)malloc(sizeof(SparseMatrix));\n    matrix->head = NULL;\n    return matrix;\n}\n\nvoid insert(SparseMatrix* matrix, int row, int col, int val) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->row = row;\n    newNode->col = col;\n    newNode->val = val;\n    newNode->next = NULL;\n\n    if (matrix->head == NULL) {\n        matrix->head = newNode;\n    } else {\n        Node* temp = matrix->head;\n        while (temp->next != NULL) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.404|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nclosestElement__FP4Nodei PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r2,r0\n        LDR      r0,[r0,#0]\n        SUB      lr,r0,r1\n        CMP      lr,#0\n        RSBLT    lr,lr,#0\n        CMP      r2,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n|L1.644|\n        LDR      r12,[r2,#0]\n        SUB      r4,r12,r1\n        MOV      r3,r4\n        CMP      r4,#0\n        RSBLT    r3,r3,#0\n        CMP      r3,lr\n        BGE      |L1.680|\n        MOV      lr,r3\n        MOV      r0,r12\n|L1.680|\n        CMP      r12,r1\n        LDRLE    r2,[r2,#0xc]\n        LDRGT    r2,[r2,#8]\n        CMP      r2,#0\n        BNE      |L1.644|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return node;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return newNode(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\nint closestElement(Node* root, int k) {\n    int diff = abs(root->key - k);\n    int closestKey = root->key;\n\n    Node* current = root;\n    while(current != NULL){\n        if (abs(current->key - k) < diff){\n            diff = abs(current->key -k);\n            closestKey = current->key;\n        }\n        if (k < current->key){\n            current = current->left;\n        } else {\n            current = current->right;\n        }\n    }\n\n    return closestKey;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nquaternion_create__FfN31 PROC\n        LDR      r12,[sp,#0]\n        STMIA    r0,{r1-r3,r12}\n        BX       lr\n        ENDP\n\nquaternion_multiply__F10quaternionT1 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x34\n        ADD      r7,sp,#0x6c\n        LDMIA    r7,{r4-r7}\n        MOV      r9,r1\n        MOV      r0,r9\n        MOV      r1,r4\n        LDR      r8,[sp,#0x68]\n        MOV      r11,r3\n        MOV      r10,r2\n        BL       _fmul\n        STR      r0,[sp,#0x30]\n        MOV      r0,r10\n        MOV      r1,r5\n        BL       _fmul\n        LDR      r1,[sp,#0x30]\n        BL       _frsb\n        STR      r0,[sp,#0x2c]\n        MOV      r0,r11\n        MOV      r1,r6\n        BL       _fmul\n        LDR      r1,[sp,#0x2c]\n        BL       _frsb\n        STR      r0,[sp,#0x28]\n        MOV      r0,r8\n        MOV      r1,r7\n        BL       _fmul\n        LDR      r1,[sp,#0x28]\n        BL       _frsb\n        STR      r0,[sp,#4]\n        MOV      r0,r9\n        MOV      r1,r5\n        BL       _fmul\n        STR      r0,[sp,#0x24]\n        MOV      r0,r10\n        MOV      r1,r4\n        BL       _fmul\n        LDR      r1,[sp,#0x24]\n        BL       _fadd\n        STR      r0,[sp,#0x20]\n        MOV      r0,r11\n        MOV      r1,r7\n        BL       _fmul\n        LDR      r1,[sp,#0x20]\n        BL       _fadd\n        STR      r0,[sp,#0x1c]\n        MOV      r0,r8\n        MOV      r1,r6\n        BL       _fmul\n        LDR      r1,[sp,#0x1c]\n        BL       _frsb\n        STR      r0,[sp,#8]\n        MOV      r0,r9\n        MOV      r1,r6\n        BL       _fmul\n        STR      r0,[sp,#0x18]\n        MOV      r0,r10\n        MOV      r1,r7\n        BL       _fmul\n        LDR      r1,[sp,#0x18]\n        BL       _frsb\n        STR      r0,[sp,#0x14]\n        MOV      r0,r11\n        MOV      r1,r4\n        BL       _fmul\n        LDR      r1,[sp,#0x14]\n        BL       _fadd\n        STR      r0,[sp,#0x10]\n        MOV      r0,r8\n        MOV      r1,r5\n        BL       _fmul\n        LDR      r1,[sp,#0x10]\n        BL       _fadd\n        STR      r0,[sp,#0xc]\n        MOV      r0,r9\n        MOV      r1,r7\n        BL       _fmul\n        MOV      r7,r0\n        MOV      r0,r10\n        MOV      r1,r6\n        BL       _fmul\n        MOV      r1,r7\n        BL       _fadd\n        MOV      r6,r0\n        MOV      r0,r11\n        MOV      r1,r5\n        BL       _fmul\n        MOV      r1,r6\n        BL       _frsb\n        MOV      r5,r0\n        MOV      r0,r8\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r1,r5\n        BL       _fadd\n        LDR      r1,[sp,#0x58]\n        STR      r0,[r1,#0xc]\n        LDR      r0,[sp,#0xc]\n        STR      r0,[r1,#8]\n        LDR      r0,[sp,#8]\n        STR      r0,[r1,#4]\n        LDR      r0,[sp,#4]\n        STR      r0,[r1,#0]\n        ADD      sp,sp,#0x34\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n        ENDP\n\nquaternion_from_axis_angle__FfN31 PROC\n        STMFD    sp!,{r4-r10,lr}\n        SUB      sp,sp,#8\n        MOV      r8,r0\n        MOV      r0,r1\n        LDR      r9,[sp,#0x28]\n        MOV      r10,#0\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r5,r1\n        BL       _fmul\n        MOV      r4,r0\n        MOV      r0,r6\n        MOV      r1,r6\n        BL       _fmul\n        MOV      r1,r4\n        BL       _fadd\n        MOV      r4,r0\n        MOV      r0,r7\n        MOV      r1,r7\n        BL       _fmul\n        MOV      r1,r4\n        BL       _fadd\n        BL       _f2d\n        BL       __softfp_sqrt\n        BL       _d2f\n        MOV      r4,r0\n        MOV      r1,r10\n        BL       _fcmpeq\n        BNE      |L1.596|\n        STR      r10,[sp,#0]\n        MOV      r3,r10\n        MOV      r2,r10\n        MOV      r1,#0x3f800000\n        MOV      r0,r8\n        BL       quaternion_create__FfN31\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n|L1.596|\n        MOV      r1,#0x3f000000\n        MOV      r0,r9\n        BL       _fmul\n        BL       _f2d\n        MOV      r10,r1\n        MOV      r9,r0\n        BL       ||__softfp_sin||\n        BL       _d2f\n        MOV      r1,r4\n        BL       _fdiv\n        MOV      r4,r0\n        MOV      r1,r0\n        MOV      r0,r7\n        BL       _fmul\n        MOV      r7,r0\n        MOV      r0,r6\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r6,r0\n        MOV      r0,r5\n        MOV      r1,r4\n        BL       _fmul\n        MOV      r4,r0\n        MOV      r0,r9\n        MOV      r1,r10\n        BL       ||__softfp_cos||\n        BL       _d2f\n        MOV      r1,r0\n        MOV      r0,r8\n        MOV      r3,r6\n        MOV      r2,r4\n        STR      r7,[sp,#0]\n        BL       quaternion_create__FfN31\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    float w;\n    float x;\n    float y;\n    float z;\n} quaternion;\n\nquaternion quaternion_create(float w, float x, float y, float z) {\n    quaternion q;\n    q.w = w;\n    q.x = x;\n    q.y = y;\n    q.z = z;\n    return q;\n}\n\nquaternion quaternion_multiply(quaternion q1, quaternion q2) {\n    quaternion q;\n    q.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;\n    q.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;\n    q.y = q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x;\n    q.z = q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w;\n    return q;\n}\n\nquaternion quaternion_from_axis_angle(float x, float y, float z, float angle) {\n    float norm = sqrt(x * x + y * y + z * z);\n    if (norm == 0) return quaternion_create(1,0,0,0);\n    float half_angle = angle * 0.5f;\n    float s = sin(half_angle) / norm;\n    return quaternion_create(cos(half_angle), x * s, y * s, z * s);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nintToString__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,#0\n        MOV      r4,r0\n        CMP      r0,#0\n        BNE      |L1.48|\n        MOV      r0,#2\n        BL       malloc\n        MOV      r1,#0x30\n        STRB     r1,[r0,#0]\n        STRB     r7,[r0,#1]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.48|\n        BGE      |L1.120|\n        RSB      r0,r4,#0\n        BL       intToString__Fi\n        MOV      r5,r0\n        BL       strlen\n        ADD      r0,r0,#2\n        BL       malloc\n        MOV      r1,#0x2d\n        STRB     r1,[r0,#0]\n        STRB     r7,[r0,#1]\n        MOV      r1,r5\n        MOV      r4,r0\n        BL       strcat\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.120|\n        LDR      r6,|L1.364|\n        MOV      r5,#0\n        MOV      r0,r4\n|L1.132|\n        SMULL    r1,r0,r6,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        CMP      r0,#0\n        ADD      r5,r5,#1\n        BGT      |L1.132|\n        ADD      r0,r5,#1\n        BL       malloc\n        STRB     r7,[r0,r5]\n        CMP      r4,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n|L1.180|\n        SMULL    r2,r1,r6,r4\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r4,r1,LSL #1\n        ADD      r1,r1,#0x30\n        SUB      r5,r5,#1\n        STRB     r1,[r0,r5]\n        SMULL    r2,r1,r6,r4\n        MOV      r1,r1,ASR #2\n        SUB      r4,r1,r1,ASR #31\n        CMP      r4,#0\n        BGT      |L1.180|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* intToString(int n) {\n    if (n == 0) {\n        char* result = (char*)malloc(2);\n        strcpy(result, \"0\");\n        return result;\n    }\n    if (n < 0) {\n        char* result = intToString(-n);\n        char* newResult = (char*)malloc(strlen(result) + 2);\n        strcpy(newResult, \"-\");\n        strcat(newResult, result);\n        free(result);\n        return newResult;\n    }\n    int len = 0;\n    int temp = n;\n    while (temp > 0) {\n        len++;\n        temp /= 10;\n    }\n    char* result = (char*)malloc(len + 1);\n    result[len] = '\\0';\n    while (n > 0) {\n        result[--len] = n % 10 + '0';\n        n /= 10;\n    }\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndist__FPC5PointT1 PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        LDMIA    r1,{r2,r3}\n        MOV      r5,r1\n        MOV      r4,r0\n        LDMIA    r0,{r0,r1}\n        BL       _dsub\n        MOV      r6,r0\n        MOV      r0,#2\n        MOV      r7,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       __softfp_pow\n        ADD      r3,r5,#8\n        MOV      r7,r1\n        ADD      r1,r4,#8\n        LDMIA    r3,{r2,r3}\n        MOV      r6,r0\n        LDMIA    r1,{r0,r1}\n        BL       _dsub\n        MOV      r4,r0\n        MOV      r0,#2\n        MOV      r5,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __softfp_pow\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDMFD    sp!,{r3-r7,lr}\n        B        __softfp_sqrt\n        ENDP\n\nknn__FPC5PointiT1T2 PROC\n        STMFD    sp!,{r0-r11,lr}\n        MOV      r11,r0\n        MOV      r0,r1,LSL #3\n        SUB      sp,sp,#0x14\n        MOV      r8,r1\n        MOV      r7,r2\n        BL       malloc\n        MOV      r10,r0\n        MOV      r0,r8,LSL #2\n        BL       malloc\n        MOV      r5,r0\n        CMP      r10,#0\n        CMPNE    r5,#0\n        ADDEQ    sp,sp,#0x24\n        LDMEQFD  sp!,{r4-r11,lr}\n        MVNEQ    r0,#0\n        BXEQ     lr\n        MOV      r4,#0\n        CMP      r8,#0\n        BLE      |L1.264|\n|L1.224|\n        ADD      r0,r4,r4,LSL #2\n        ADD      r0,r11,r0,LSL #2\n        ADD      r6,r10,r4,LSL #3\n        MOV      r1,r7\n        BL       dist__FPC5PointT1\n        STMIA    r6,{r0,r1}\n        STR      r4,[r5,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r8\n        BLT      |L1.224|\n|L1.264|\n        SUB      r0,r8,#1\n        STR      r0,[sp,#0x10]\n        CMP      r0,#0\n        MOV      r6,#0\n        BLE      |L1.384|\n|L1.284|\n        ADD      r4,r6,#1\n        STR      r4,[sp,#0xc]\n        CMP      r4,r8\n        BGE      |L1.368|\n        ADD      r7,r10,r6,LSL #3\n|L1.304|\n        ADD      r9,r10,r4,LSL #3\n        LDMIA    r9,{r2,r3}\n        LDMIA    r7,{r0,r1}\n        BL       _dcmpge\n        BLS      |L1.356|\n        LDMIA    r7,{r0,r1}\n        LDMIA    r9,{r2,r3}\n        STMIA    r7,{r2,r3}\n        STMIA    r9,{r0,r1}\n        LDR      r1,[r5,r4,LSL #2]\n        LDR      r0,[r5,r6,LSL #2]\n        STR      r1,[r5,r6,LSL #2]\n        STR      r0,[r5,r4,LSL #2]\n|L1.356|\n        ADD      r4,r4,#1\n        CMP      r4,r8\n        BLT      |L1.304|\n|L1.368|\n        LDR      r0,[sp,#0x10]\n        LDR      r6,[sp,#0xc]\n        CMP      r6,r0\n        BLT      |L1.284|\n|L1.384|\n        ADD      r1,sp,#4\n        MOV      r0,#0\n        MOV      r2,#0\n        STMIA    r1,{r0,r2}\n        LDR      r2,[sp,#0x20]\n        MOV      r0,#0\n        CMP      r2,#0\n        BLE      |L1.468|\n        MOV      r3,r1\n|L1.420|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r11,r1,LSL #2\n        LDR      r1,[r1,#0x10]\n        ADD      r1,r3,r1,LSL #2\n        LDR      r2,[r1,#0]\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        LDR      r1,[sp,#0x20]\n        CMP      r0,r1\n        BLT      |L1.420|\n|L1.468|\n        MOV      r0,r10\n        BL       free\n        MOV      r0,r5\n        BL       free\n        LDMIB    sp,{r0,r1}\n        ADD      sp,sp,#0x24\n        CMP      r0,r1\n        LDMFD    sp!,{r4-r11,lr}\n        MOVGT    r0,#0\n        MOVLE    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Point {\n    double x;\n    double y;\n    int label;\n};\n\ndouble dist(const Point* p1, const Point* p2) {\n    return sqrt(pow(p1->x - p2->x, 2) + pow(p1->y - p2->y, 2));\n}\n\nint knn(const Point* points, int num_points, const Point* query_point, int k) {\n    double* distances = (double*)malloc(num_points * sizeof(double));\n    int* indices = (int*)malloc(num_points * sizeof(int));\n    if (!distances || !indices) {\n        return -1; // Memory allocation failed\n    }\n    for (int i = 0; i < num_points; i++) {\n        distances[i] = dist(points + i, query_point);\n        indices[i] = i;\n    }\n    for (int i = 0; i < num_points -1; ++i){\n        for (int j = i + 1; j < num_points; ++j){\n            if (distances[i] > distances[j]){\n                double temp_d = distances[i];\n                distances[i] = distances[j];\n                distances[j] = temp_d;\n                int temp_i = indices[i];\n                indices[i] = indices[j];\n                indices[j] = temp_i;\n            }\n        }\n    }\n\n    int label_counts[2] = {0, 0};\n    for (int i = 0; i < k; i++) {\n        label_counts[points[indices[i]].label]++;\n    }\n    free(distances);\n    free(indices);\n    return label_counts[0] > label_counts[1] ? 0 : 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlongestCommonSubsequence__FPciT1T2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r7,r3\n        MOVS     r6,r1\n        CMPNE    r7,#0\n        MOV      r5,r2\n        MOV      r4,r0\n        LDMEQFD  sp!,{r4-r10,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r4,r6\n        LDRB     r0,[r0,#-1]\n        ADD      r1,r5,r7\n        LDRB     r1,[r1,#-1]\n        SUB      r8,r6,#1\n        SUB      r9,r7,#1\n        CMP      r0,r1\n        BNE      |L1.100|\n        MOV      r3,r9\n        MOV      r2,r5\n        MOV      r1,r8\n        MOV      r0,r4\n        BL       longestCommonSubsequence__FPciT1T2\n        LDMFD    sp!,{r4-r10,lr}\n        ADD      r0,r0,#1\n        BX       lr\n|L1.100|\n        MOV      r3,r7\n        MOV      r2,r5\n        MOV      r1,r8\n        MOV      r0,r4\n        BL       longestCommonSubsequence__FPciT1T2\n        MOV      r10,r0\n        MOV      r0,r4\n        MOV      r3,r9\n        MOV      r2,r5\n        MOV      r1,r6\n        BL       longestCommonSubsequence__FPciT1T2\n        CMP      r10,r0\n        BLE      |L1.176|\n        MOV      r3,r7\n        MOV      r2,r5\n        MOV      r1,r8\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        B        longestCommonSubsequence__FPciT1T2\n|L1.176|\n        MOV      r3,r9\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r10,lr}\n        B        longestCommonSubsequence__FPciT1T2\n        ENDP\n```",
        "output": "```cpp\n\nint longestCommonSubsequence(char *str1, int len1, char *str2, int len2) {\n    if (len1 == 0 || len2 == 0) return 0;\n    if (str1[len1 - 1] == str2[len2 - 1])\n        return 1 + longestCommonSubsequence(str1, len1 - 1, str2, len2 - 1);\n    else\n        return  (longestCommonSubsequence(str1, len1 - 1, str2, len2) > longestCommonSubsequence(str1, len1, str2, len2 - 1)) ? longestCommonSubsequence(str1, len1 - 1, str2, len2) : longestCommonSubsequence(str1, len1, str2, len2 - 1);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnextPowerOf2__FUi PROC\n        MOVS     r1,r0\n        MOV      r0,#1\n        BXEQ     lr\n        CMP      r1,#1\n        BXLS     lr\n|L1.20|\n        MOV      r0,r0,LSL #1\n        CMP      r0,r1\n        BCC      |L1.20|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int nextPowerOf2(unsigned int n) {\n    if (n <= 0) return 1;\n    unsigned int p = 1;\n    while (p < n) p <<= 1;\n    return p;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STMIA    r4,{r5,r6}\n        MUL      r0,r6,r5\n        MOV      r5,r0,LSL #2\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.84|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r1,r5\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfreeMatrix__FP6Matrix PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\naddMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r4,#4]\n        LDREQ    r2,[r5,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDMIA    r4,{r2,r3}\n        MOV      r1,#0\n        MUL      r2,r3,r2\n        CMP      r2,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.228|\n        LDR      r2,[r4,#8]\n        LDR      r3,[r5,#8]\n        LDR      r2,[r2,r1,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        ADD      r2,r2,r3\n        LDR      r3,[r0,#8]\n        STR      r2,[r3,r1,LSL #2]\n        LDMIA    r4,{r2,r3}\n        ADD      r1,r1,#1\n        MUL      r2,r3,r2\n        CMP      r2,r1\n        BGT      |L1.228|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nsubtractMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r4,#4]\n        LDREQ    r2,[r5,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDMIA    r4,{r2,r3}\n        MOV      r1,#0\n        MUL      r2,r3,r2\n        CMP      r2,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.372|\n        LDR      r2,[r4,#8]\n        LDR      r3,[r5,#8]\n        LDR      r2,[r2,r1,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        SUB      r2,r2,r3\n        LDR      r3,[r0,#8]\n        STR      r2,[r3,r1,LSL #2]\n        LDMIA    r4,{r2,r3}\n        ADD      r1,r1,#1\n        MUL      r2,r3,r2\n        CMP      r2,r1\n        BGT      |L1.372|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nmultiplyMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#0]\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r12,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n|L1.508|\n        LDR      r1,[r5,#4]\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.628|\n|L1.524|\n        LDR      r3,[r4,#4]\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.612|\n|L1.540|\n        LDR      lr,[r5,#4]\n        LDR      r7,[r4,#4]\n        LDR      r3,[r0,#8]\n        MLA      r6,lr,r12,r2\n        ADD      r3,r3,r6,LSL #2\n        LDR      r6,[r4,#8]\n        MLA      r8,r7,r12,r1\n        LDR      r6,[r6,r8,LSL #2]\n        LDR      r7,[r5,#8]\n        MLA      r8,lr,r1,r2\n        LDR      lr,[r7,r8,LSL #2]\n        LDR      r7,[r3,#0]\n        ADD      r1,r1,#1\n        MLA      r6,lr,r6,r7\n        STR      r6,[r3,#0]\n        LDR      r3,[r4,#4]\n        CMP      r3,r1\n        BGT      |L1.540|\n|L1.612|\n        LDR      r1,[r5,#4]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.524|\n|L1.628|\n        LDR      r1,[r4,#0]\n        ADD      r12,r12,#1\n        CMP      r1,r12\n        BGT      |L1.508|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\ntypedef struct {\n    int rows;\n    int cols;\n    int *data;\n} Matrix;\n\n\nMatrix* createMatrix(int rows, int cols) {\n    Matrix* matrix = (Matrix*)malloc(sizeof(Matrix));\n    if (matrix == NULL) return NULL;\n    matrix->rows = rows;\n    matrix->cols = cols;\n    matrix->data = (int*)malloc(rows * cols * sizeof(int));\n    if (matrix->data == NULL) {\n        free(matrix);\n        return NULL;\n    }\n    memset(matrix->data, 0, rows * cols * sizeof(int));\n    return matrix;\n}\n\n\nvoid freeMatrix(Matrix* matrix) {\n    if (matrix != NULL) {\n        free(matrix->data);\n        free(matrix);\n    }\n}\n\n\nMatrix* addMatrices(Matrix* a, Matrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix* result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows * a->cols; i++) {\n        result->data[i] = a->data[i] + b->data[i];\n    }\n    return result;\n}\n\n\nMatrix* subtractMatrices(Matrix* a, Matrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix* result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows * a->cols; i++) {\n        result->data[i] = a->data[i] - b->data[i];\n    }\n    return result;\n}\n\n\nMatrix* multiplyMatrices(Matrix* a, Matrix* b) {\n    if (a->cols != b->rows) return NULL;\n    Matrix* result = createMatrix(a->rows, b->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < b->cols; j++) {\n            for (int k = 0; k < a->cols; k++) {\n                result->data[i * b->cols + j] += a->data[i * a->cols + k] * b->data[k * b->cols + j];\n            }\n        }\n    }\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsearch__FPiiN22 PROC\n        CMP      r1,r2\n        BGT      |L1.76|\n|L1.48|\n        LDR      r12,[r0,r1,LSL #2]\n        CMP      r12,r3\n        MOVEQ    r0,r1\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLE      |L1.48|\n|L1.76|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nbuildTree__FPiT1iT3 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r8,r1\n        MOV      r7,r0\n        MOV      r6,r3\n        MOV      r5,r2\n        CMP      r2,r3\n        LDMGTFD  sp!,{r3-r9,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r1,|L1.348|\n        LDR      r0,[r1,#0]  ; preIndex@buildTree__FPiT1iT3_0\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; preIndex@buildTree__FPiT1iT3_0\n        LDR      r0,[r7,r0,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        CMP      r5,r6\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r8\n        LDR      r3,[r4,#0]\n        BL       search__FPiiN22\n        MOV      r9,r0\n        SUB      r3,r0,#1\n        MOV      r0,r7\n        MOV      r2,r5\n        MOV      r1,r8\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#4]\n        MOV      r0,r7\n        MOV      r3,r6\n        ADD      r2,r9,#1\n        MOV      r1,r8\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint search(int in[], int strt, int end, int val) {\n    for (int i = strt; i <= end; i++)\n        if (in[i] == val) return i;\n    return -1;\n}\n\nstruct Node* buildTree(int pre[], int in[], int strt, int end) {\n    static int preIndex = 0;\n\n    if (strt > end) return NULL;\n\n    struct Node* node = newNode(pre[preIndex++]);\n\n    if (strt == end) return node;\n\n    int inIndex = search(in, strt, end, node->data);\n\n    node->left = buildTree(pre, in, strt, inIndex - 1);\n    node->right = buildTree(pre, in, inIndex + 1, end);\n\n    return node;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_string__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        ADD      r2,r0,r0,LSR #31\n        MOV      lr,r2,ASR #1\n        CMP      lr,#0\n        LDMLEFD  sp!,{r4,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.36|\n        SUB      r3,r0,r1\n        ADD      r3,r3,r4\n        LDRB     r12,[r3,#-1]\n        LDRB     r2,[r4,r1]\n        STRB     r12,[r4,r1]\n        ADD      r1,r1,#1\n        CMP      lr,r1\n        STRB     r2,[r3,#-1]\n        BGT      |L1.36|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverse_string(char *str) {\n    int n = strlen(str);\n    for (int i = 0; i < n / 2; i++) {\n        char temp = str[i];\n        str[i] = str[n - i - 1];\n        str[n - i - 1] = temp;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculate_average__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        ADR      r0,|L1.112|\n        MOV      r7,r1\n        CMP      r1,#0\n        MOVLE    r1,r0\n        LDRLE    r1,[r1,#4]\n        LDRLE    r0,[r0,#0]\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        LDMIA    r0,{r5,r6}\n        MOV      r4,#0\n|L1.48|\n        LDR      r0,[r8,r4,LSL #2]\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dadd\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        MOV      r5,r0\n        MOV      r6,r1\n        BLT      |L1.48|\n        MOV      r0,r7\n        BL       _dflt\n        MOV      r3,r6\n        MOV      r2,r5\n        LDMFD    sp!,{r4-r8,lr}\n        B        _drdiv\n|L1.112|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble calculate_average(int arr[], int size) {\n    if (size <= 0) return 0;\n    double sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum / size;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisSymmetric__FP4nodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#4]\n        BL       isSymmetric__FP4nodeT1\n        CMP      r0,#0\n        BEQ      |L1.160|\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#8]\n        BL       isSymmetric__FP4nodeT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.160|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nisSymmetricTree__FP4node PROC\n        MOV      r1,r0\n        B        isSymmetric__FP4nodeT1\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return(node);\n}\n\nint isSymmetric(struct node* root1, struct node* root2) {\n    if (root1 == NULL && root2 == NULL)\n        return 1;\n    if (root1 == NULL || root2 == NULL)\n        return 0;\n    if (root1->data != root2->data)\n        return 0;\n    return isSymmetric(root1->left, root2->right) && isSymmetric(root1->right, root2->left);\n\n}\n\nint isSymmetricTree(struct node *root) {\n    return isSymmetric(root, root);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateCircularBuffer__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x14\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        STR      r0,[r4,#8]\n        ADD      r1,r4,#0xc\n        STMIA    r1,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddCircularBuffer__FP14CircularBufferi PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        ADD      r2,r4,#0xc\n        LDMIA    r2,{r0,r2}\n        CMP      r0,r2\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r2,[r4,#8]\n        STR      r1,[r0,r2,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0x10]\n        BL       __rt_sdiv\n        STR      r1,[r4,#8]\n        LDR      r0,[r4,#0xc]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nremoveCircularBuffer__FP14CircularBuffer PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r6,[r4,#0xc]\n        CMP      r6,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        LDR      r5,[r1,r0,LSL #2]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0x10]\n        BL       __rt_sdiv\n        SUB      r0,r6,#1\n        STR      r1,[r4,#4]!\n        STR      r0,[r4,#8]\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndestroyCircularBuffer__FP14CircularBuffer PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct CircularBuffer {\n    int* buffer;\n    int head;\n    int tail;\n    int size;\n    int capacity;\n};\n\nCircularBuffer* createCircularBuffer(int capacity) {\n    CircularBuffer* cb = (CircularBuffer*)malloc(sizeof(CircularBuffer));\n    if (cb == NULL) return NULL;\n    cb->buffer = (int*)malloc(sizeof(int) * capacity);\n    if (cb->buffer == NULL) {\n        free(cb);\n        return NULL;\n    }\n    cb->head = 0;\n    cb->tail = 0;\n    cb->size = 0;\n    cb->capacity = capacity;\n    return cb;\n}\n\nint addCircularBuffer(CircularBuffer* cb, int value) {\n    if (cb == NULL) return 0;\n    if (cb->size == cb->capacity) return 0;\n    cb->buffer[cb->tail] = value;\n    cb->tail = (cb->tail + 1) % cb->capacity;\n    cb->size++;\n    return 1;\n}\n\nint removeCircularBuffer(CircularBuffer* cb) {\n    if (cb == NULL) return 0;\n    if (cb->size == 0) return 0;\n    int value = cb->buffer[cb->head];\n    cb->head = (cb->head + 1) % cb->capacity;\n    cb->size--;\n    return value;\n}\n\nvoid destroyCircularBuffer(CircularBuffer* cb) {\n    if (cb == NULL) return;\n    free(cb->buffer);\n    free(cb);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninorder__FP4nodePiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r2\n        MOVS     r4,r0\n        BEQ      |L1.112|\n        MOV      r2,r5\n        MOV      r1,r6\n        LDR      r0,[r4,#4]\n        BL       inorder__FP4nodePiT2\n        LDR      r0,[r5,#0]\n        LDR      r1,[r4,#0]\n        ADD      r2,r0,#1\n        STR      r2,[r5,#0]\n        STR      r1,[r6,r0,LSL #2]\n        LDR      r0,[r4,#8]\n        MOV      r1,r6\n        MOV      r2,r5\n        BL       inorder__FP4nodePiT2\n|L1.112|\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nisBST__FP4node PROC\n        STMFD    sp!,{r4-r6,lr}\n        SUB      sp,sp,#8\n        MOVS     r6,r0\n        ADDEQ    sp,sp,#8\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r0,r6\n|L1.160|\n        LDR      r0,[r0,#8]\n        ADD      r4,r4,#1\n        CMP      r0,#0\n        BNE      |L1.160|\n        MOV      r0,r4,LSL #2\n        BL       malloc\n        MOV      r5,r0\n        MOV      r0,#0\n        STR      r0,[sp,#4]\n        MOV      r0,r6\n        MOV      r1,r5\n        ADD      r2,sp,#4\n        BL       inorder__FP4nodePiT2\n        MOV      r0,#1\n        CMP      r4,#1\n        BLE      |L1.280|\n|L1.224|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r2,r5,r0,LSL #2\n        LDR      r2,[r2,#-4]\n        CMP      r1,r2\n        BGT      |L1.268|\n        MOV      r0,r5\n        BL       free\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.268|\n        ADD      r0,r0,#1\n        CMP      r0,r4\n        BLT      |L1.224|\n|L1.280|\n        MOV      r0,r5\n        BL       free\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nint* inorder(struct node* root, int* arr, int* i) {\n    if (root != NULL) {\n        inorder(root->left, arr, i);\n        arr[(*i)++] = root->data;\n        inorder(root->right, arr, i);\n    }\n    return arr;\n}\n\nint isBST(struct node* root) {\n    if (root == NULL) return 1;\n    int n = 0;\n    struct node* current = root;\n    while (current != NULL) {\n        n++;\n        current = current->right;\n    }\n    int* arr = (int*)malloc(n * sizeof(int));\n    int i = 0;\n    inorder(root, arr, &i);\n    for (int j = 1; j < n; j++) {\n        if (arr[j] <= arr[j - 1]) {\n            free(arr);\n            return 0;\n        }\n    }\n    free(arr);\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r1,[r0,#8]\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        STR      r2,[r1,#0xc]\n        STR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        CMP      r3,r0\n        BLE      |L1.124|\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        B        |L1.132|\n|L1.124|\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n|L1.132|\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        CMP      r2,r0\n        BLE      |L1.180|\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        B        |L1.188|\n|L1.180|\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n|L1.188|\n        ADD      r0,r0,#1\n        STR      r0,[r1,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r1\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r1,[r0,#0xc]\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        STR      r2,[r1,#8]\n        STR      r0,[r2,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        CMP      r3,r0\n        BLE      |L1.272|\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        B        |L1.280|\n|L1.272|\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n|L1.280|\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        CMP      r2,r0\n        BLE      |L1.328|\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        B        |L1.336|\n|L1.328|\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n|L1.336|\n        ADD      r0,r0,#1\n        STR      r0,[r1,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r1\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.424|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.424|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.456|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.484|\n|L1.456|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.484|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        CMP      r1,r0\n        BLE      |L1.524|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        B        |L1.532|\n|L1.524|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n|L1.532|\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.612|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.664|\n|L1.612|\n        CMP      r0,#1\n        BLE      |L1.656|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.700|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.656|\n        CMN      r0,#1\n        BGE      |L1.700|\n|L1.664|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.700|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.700|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *node) {\n    if (node == NULL) return 0;\n    return node->height;\n}\n\nint getBalance(Node *node) {\n    if (node == NULL) return 0;\n    return height(node->left) - height(node->right);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = 1 + (height(y->left) > height(y->right) ? height(y->left) : height(y->right));\n    x->height = 1 + (height(x->left) > height(x->right) ? height(x->left) : height(x->right));\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = 1 + (height(x->left) > height(x->right) ? height(x->left) : height(x->right));\n    y->height = 1 + (height(y->left) > height(y->right) ? height(y->left) : height(y->right));\n    return y;\n}\n\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else \n        return node;\n\n    node->height = 1 + (height(node->left) > height(node->right) ? height(node->left) : height(node->right));\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__FiT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        MOV      r6,r1\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STMIA    r4,{r5,r6}\n        MUL      r0,r6,r5\n        MOV      r5,r0,LSL #3\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#8]\n        CMP      r0,#0\n        BNE      |L1.84|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r1,r5\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nfreeMatrix__FP6Matrix PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\naddMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        MOV      r8,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r5,#4]\n        LDREQ    r2,[r8,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        MOVS     r7,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDMIA    r5,{r0,r1}\n        MOV      r4,#0\n        MUL      r0,r1,r0\n        CMP      r0,#0\n        BLE      |L1.284|\n|L1.224|\n        LDR      r0,[r8,#8]\n        LDR      r2,[r7,#8]\n        ADD      r1,r0,r4,LSL #3\n        LDR      r0,[r5,#8]\n        ADD      r6,r2,r4,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dadd\n        STMIA    r6,{r0,r1}\n        LDMIA    r5,{r0,r1}\n        ADD      r4,r4,#1\n        MUL      r0,r1,r0\n        CMP      r0,r4\n        BGT      |L1.224|\n|L1.284|\n        MOV      r0,r7\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nsubtractMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0]\n        MOV      r8,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r5,#4]\n        LDREQ    r2,[r8,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        BL       createMatrix__FiT1\n        MOVS     r7,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        LDMIA    r5,{r0,r1}\n        MOV      r4,#0\n        MUL      r0,r1,r0\n        CMP      r0,#0\n        BLE      |L1.440|\n|L1.380|\n        LDR      r0,[r8,#8]\n        LDR      r2,[r7,#8]\n        ADD      r1,r0,r4,LSL #3\n        LDR      r0,[r5,#8]\n        ADD      r6,r2,r4,LSL #3\n        LDMIA    r1,{r2,r3}\n        ADD      r0,r0,r4,LSL #3\n        LDMIA    r0,{r0,r1}\n        BL       _dsub\n        STMIA    r6,{r0,r1}\n        LDMIA    r5,{r0,r1}\n        ADD      r4,r4,#1\n        MUL      r0,r1,r0\n        CMP      r0,r4\n        BGT      |L1.380|\n|L1.440|\n        MOV      r0,r7\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nmultiplyMatrices__FP6MatrixT1 PROC\n        STMFD    sp!,{r4-r10,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#4]\n        MOV      r7,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4-r10,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r7,#4]\n        LDR      r0,[r5,#0]\n        BL       createMatrix__FiT1\n        MOVS     r10,r0\n        LDMEQFD  sp!,{r4-r10,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        MOV      r9,#0\n        CMP      r0,#0\n        BLE      |L1.676|\n|L1.528|\n        LDR      r0,[r7,#4]\n        MOV      r6,#0\n        CMP      r0,#0\n        BLE      |L1.660|\n|L1.544|\n        LDR      r0,[r5,#4]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.644|\n|L1.560|\n        LDR      r0,[r7,#4]\n        LDR      r1,[r10,#8]\n        MLA      r2,r0,r9,r6\n        ADD      r8,r1,r2,LSL #3\n        LDR      r1,[r7,#8]\n        MLA      r2,r0,r4,r6\n        ADD      r1,r1,r2,LSL #3\n        LDR      r2,[r5,#4]\n        LDR      r0,[r5,#8]\n        MLA      r3,r2,r9,r4\n        ADD      r0,r0,r3,LSL #3\n        LDMIA    r1,{r2,r3}\n        LDMIA    r0,{r0,r1}\n        BL       _dmul\n        LDMIA    r8,{r2,r3}\n        BL       _dadd\n        STMIA    r8,{r0,r1}\n        LDR      r0,[r5,#4]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.560|\n|L1.644|\n        LDR      r0,[r7,#4]\n        ADD      r6,r6,#1\n        CMP      r0,r6\n        BGT      |L1.544|\n|L1.660|\n        LDR      r0,[r5,#0]\n        ADD      r9,r9,#1\n        CMP      r0,r9\n        BGT      |L1.528|\n|L1.676|\n        MOV      r0,r10\n        LDMFD    sp!,{r4-r10,lr}\n        BX       lr\n        ENDP\n\ntransposeMatrix__FP6Matrix PROC\n        STMFD    sp!,{r3-r5,lr}\n        LDR      r1,[r0,#0]\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        BL       createMatrix__FiT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        MOV      r2,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.740|\n        LDR      r3,[r4,#4]\n        MOV      r1,#0\n        CMP      r3,#0\n        BLE      |L1.820|\n|L1.756|\n        LDR      r12,[r4,#0]\n        LDR      r3,[r0,#8]\n        MLA      lr,r12,r1,r2\n        ADD      r3,r3,lr,LSL #3\n        LDR      lr,[r4,#4]\n        LDR      r12,[r4,#8]\n        MLA      r5,lr,r2,r1\n        ADD      r12,r12,r5,LSL #3\n        LDR      lr,[r12,#0]\n        LDR      r12,[r12,#4]\n        ADD      r1,r1,#1\n        STR      r12,[r3,#4]\n        STR      lr,[r3,#0]\n        LDR      r3,[r4,#4]\n        CMP      r3,r1\n        BGT      |L1.756|\n|L1.820|\n        LDR      r1,[r4,#0]\n        ADD      r2,r2,#1\n        CMP      r1,r2\n        BGT      |L1.740|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int rows;\n    int cols;\n    double *data;\n} Matrix;\n\n\nMatrix* createMatrix(int rows, int cols) {\n    Matrix* matrix = (Matrix*)malloc(sizeof(Matrix));\n    if (matrix == NULL) return NULL;\n    matrix->rows = rows;\n    matrix->cols = cols;\n    matrix->data = (double*)malloc(rows * cols * sizeof(double));\n    if (matrix->data == NULL) {\n        free(matrix);\n        return NULL;\n    }\n    memset(matrix->data, 0, rows * cols * sizeof(double));\n    return matrix;\n}\n\nvoid freeMatrix(Matrix* matrix) {\n    if (matrix != NULL) {\n        free(matrix->data);\n        free(matrix);\n    }\n}\n\nMatrix* addMatrices(Matrix* a, Matrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix* result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows * a->cols; i++) {\n        result->data[i] = a->data[i] + b->data[i];\n    }\n    return result;\n}\n\nMatrix* subtractMatrices(Matrix* a, Matrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    Matrix* result = createMatrix(a->rows, a->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows * a->cols; i++) {\n        result->data[i] = a->data[i] - b->data[i];\n    }\n    return result;\n}\n\nMatrix* multiplyMatrices(Matrix* a, Matrix* b) {\n    if (a->cols != b->rows) return NULL;\n    Matrix* result = createMatrix(a->rows, b->cols);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < b->cols; j++) {\n            for (int k = 0; k < a->cols; k++) {\n                result->data[i * b->cols + j] += a->data[i * a->cols + k] * b->data[k * b->cols + j];\n            }\n        }\n    }\n    return result;\n}\n\nMatrix* transposeMatrix(Matrix* a) {\n    Matrix* result = createMatrix(a->cols, a->rows);\n    if (result == NULL) return NULL;\n    for (int i = 0; i < a->rows; i++) {\n        for (int j = 0; j < a->cols; j++) {\n            result->data[j * a->rows + i] = a->data[i * a->cols + j];\n        }\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnthPrime__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        MOV      r0,#0x900\n        ADD      r0,r0,#0x3d0000\n        BL       malloc\n        MOV      r2,#0x900\n        ADD      r2,r2,#0x3d0000\n        MOV      r4,r0\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r4,#4]\n        STR      r2,[r4,#0]\n        MOV      r1,#2\n|L1.72|\n        LDR      r0,[r4,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.120|\n        MUL      r0,r1,r1\n        SUBS     r12,r0,#0xf4000\n        SUBGES   r12,r12,#0x240\n        BGT      |L1.120|\n|L1.100|\n        STR      r2,[r4,r0,LSL #2]\n        ADD      r0,r0,r1\n        SUBS     r12,r0,#0xf4000\n        SUBGES   r12,r12,#0x240\n        BLE      |L1.100|\n|L1.120|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        SUBS     r12,r0,#0xf4000\n        SUBGES   r12,r12,#0x240\n        BLE      |L1.72|\n        MOV      r0,#0\n        MOV      r5,#2\n|L1.148|\n        LDR      r1,[r4,r5,LSL #2]\n        CMP      r1,#0\n        BEQ      |L1.192|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BNE      |L1.192|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.192|\n        ADD      r5,r5,#1\n        SUBS     r12,r5,#0xf4000\n        SUBGES   r12,r12,#0x240\n        BLE      |L1.148|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint nthPrime(int n) {\n    if (n <= 0) return 0;\n    int* sieve = (int*)malloc(sizeof(int) * 1000000);\n    memset(sieve, 1, sizeof(int) * 1000000);\n    sieve[0] = sieve[1] = 0;\n    for (int i = 2; i * i <= 1000000; i++) {\n        if (sieve[i]) {\n            for (int j = i * i; j <= 1000000; j += i) {\n                sieve[j] = 0;\n            }\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= 1000000; i++) {\n        if (sieve[i]) {\n            count++;\n            if (count == n) {\n                free(sieve);\n                return i;\n            }\n        }\n    }\n    free(sieve);\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateLibrary__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        ADD      r0,r5,r5,LSL #2\n        ADD      r0,r0,r5,LSL #3\n        MOV      r0,r0,LSL #4\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.76|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.76|\n        MOV      r0,#0\n        STMIB    r4,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\naddBook__FP7LibraryPcT2i PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r2\n        MOV      r4,r0\n        CMP      r0,#0\n        LDMNEIB  r4,{r0,r2}\n        MOV      r6,r3\n        CMPNE    r0,r2\n        LDMGEFD  sp!,{r4-r6,lr}\n        MOVGE    r0,#0\n        BXGE     lr\n        ADD      r12,r0,r0,LSL #2\n        LDR      r2,[r4,#0]\n        ADD      r0,r12,r0,LSL #3\n        ADD      r0,r2,r0,LSL #4\n        BL       strcpy\n        LDMIA    r4,{r0,r1}\n        ADD      r12,r1,r1,LSL #2\n        ADD      r1,r12,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        ADD      r0,r0,#0x64\n        MOV      r1,r5\n        BL       strcpy\n        LDMIA    r4,{r0,r1}\n        ADD      r12,r1,r1,LSL #2\n        ADD      r1,r12,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        STR      r6,[r0,#0xc8]\n        LDMIA    r4,{r1,r2}\n        MOV      r0,#0\n        ADD      r12,r2,r2,LSL #2\n        ADD      r2,r12,r2,LSL #3\n        ADD      r1,r1,r2,LSL #4\n        STR      r0,[r1,#0xcc]\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nborrowBook__FP7Libraryi PROC\n        STR      lr,[sp,#-4]!\n        CMP      r0,#0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r3,[r0,#4]\n        MOV      r2,#0\n        CMP      r3,#0\n        BLE      |L1.364|\n        LDR      r0,[r0,#0]\n|L1.288|\n        ADD      r12,r2,r2,LSL #2\n        ADD      r12,r12,r2,LSL #3\n        ADD      r12,r0,r12,LSL #4\n        LDR      lr,[r12,#0xc8]\n        CMP      lr,r1\n        LDREQ    r12,[r12,#0xcc]\n        CMPEQ    r12,#0\n        BNE      |L1.352|\n        ADD      r12,r2,r2,LSL #2\n        ADD      r2,r12,r2,LSL #3\n        ADD      r0,r0,r2,LSL #4\n        MOV      r1,#1\n        STR      r1,[r0,#0xcc]\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n|L1.352|\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.288|\n|L1.364|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nreturnBook__FP7Libraryi PROC\n        STR      lr,[sp,#-4]!\n        CMP      r0,#0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r3,[r0,#4]\n        MOV      r2,#0\n        CMP      r3,#0\n        BLE      |L1.488|\n        LDR      r0,[r0,#0]\n|L1.412|\n        ADD      r12,r2,r2,LSL #2\n        ADD      r12,r12,r2,LSL #3\n        ADD      r12,r0,r12,LSL #4\n        LDR      lr,[r12,#0xc8]\n        CMP      lr,r1\n        LDREQ    r12,[r12,#0xcc]\n        CMPEQ    r12,#1\n        BNE      |L1.476|\n        ADD      r12,r2,r2,LSL #2\n        ADD      r2,r12,r2,LSL #3\n        ADD      r0,r0,r2,LSL #4\n        MOV      r1,#0\n        STR      r1,[r0,#0xcc]\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n|L1.476|\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.412|\n|L1.488|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Book {\n    char title[100];\n    char author[100];\n    int id;\n    int borrowed;\n};\n\nstruct Library {\n    Book *books;\n    int size;\n    int capacity;\n};\n\nLibrary* createLibrary(int capacity) {\n    Library* library = (Library*)malloc(sizeof(Library));\n    if (library == NULL) return NULL;\n    library->books = (Book*)malloc(sizeof(Book) * capacity);\n    if (library->books == NULL) {\n        free(library);\n        return NULL;\n    }\n    library->size = 0;\n    library->capacity = capacity;\n    return library;\n}\n\nint addBook(Library* library, char* title, char* author, int id) {\n    if (library == NULL || library->size >= library->capacity) return 0;\n    strcpy(library->books[library->size].title, title);\n    strcpy(library->books[library->size].author, author);\n    library->books[library->size].id = id;\n    library->books[library->size].borrowed = 0;\n    library->size++;\n    return 1;\n}\n\n\nint borrowBook(Library* library, int id) {\n    if (library == NULL) return 0;\n    for (int i = 0; i < library->size; i++) {\n        if (library->books[i].id == id && library->books[i].borrowed == 0) {\n            library->books[i].borrowed = 1;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint returnBook(Library* library, int id) {\n    if (library == NULL) return 0;\n    for (int i = 0; i < library->size; i++) {\n        if (library->books[i].id == id && library->books[i].borrowed == 1) {\n            library->books[i].borrowed = 0;\n            return 1;\n        }\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlowestCommonAncestor__FP4NodeN21 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        CMPNE    r4,r5\n        MOV      r6,r2\n        CMPNE    r4,r6\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       lowestCommonAncestor__FP4NodeN21\n        MOV      r7,r0\n        LDR      r0,[r4,#8]\n        MOV      r2,r6\n        MOV      r1,r5\n        BL       lowestCommonAncestor__FP4NodeN21\n        CMP      r7,#0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        CMP      r0,#0\n        MOVEQ    r0,r7\n        MOVNE    r0,r4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nNode* lowestCommonAncestor(Node* root, Node* p, Node* q) {\n    if (!root || root == p || root == q) return root;\n    Node* left = lowestCommonAncestor(root->left, p, q);\n    Node* right = lowestCommonAncestor(root->right, p, q);\n    if (left && right) return root;\n    return left ? left : right;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_email__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,#0\n        MOV      r6,#0\n        MOV      r5,r0\n        BL       strlen\n        MOV      r8,r0\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r4,#0\n        BLE      |L1.144|\n        BL       __rt_ctype_table\n        LDR      r1,[r0,#0]\n|L1.56|\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0x40\n        ADDEQ    r6,r6,#1\n        BEQ      |L1.80|\n        CMP      r0,#0x2e\n        ADDEQ    r7,r7,#1\n|L1.80|\n        LDRB     r2,[r1,r0]\n        TST      r2,#0x38\n        BNE      |L1.116|\n        CMP      r0,#0x40\n        CMPNE    r0,#0x2e\n        CMPNE    r0,#0x5f\n        LDMNEFD  sp!,{r4-r8,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.116|\n        ADD      r4,r4,#1\n        CMP      r4,r8\n        BLT      |L1.56|\n        CMP      r6,#1\n        BNE      |L1.144|\n        CMP      r7,#0\n        BNE      |L1.156|\n|L1.144|\n        LDMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.156|\n        LDRB     r0,[r5,#0]\n        CMP      r0,#0x40\n        CMPNE    r0,#0x2e\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r5,r8\n        LDRB     r0,[r0,#-1]\n        CMP      r0,#0x40\n        CMPNE    r0,#0x2e\n        LDMEQFD  sp!,{r4-r8,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r1,#0x40\n        MOV      r0,r5\n        BL       strchr\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        ADD      r0,r4,#1\n        MOV      r1,#0x2e\n        BL       strchr\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        SUB      r0,r0,r4\n        CMP      r0,#1\n        LDMFD    sp!,{r4-r8,lr}\n        MOVGT    r0,#1\n        MOVLE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_email(char* email) {\n    int at_count = 0;\n    int dot_count = 0;\n    int len = strlen(email);\n    if (len == 0) return 0;\n    for (int i = 0; i < len; i++) {\n        if (email[i] == '@') at_count++;\n        if (email[i] == '.') dot_count++;\n        if (!isalnum(email[i]) && email[i] != '@' && email[i] != '.' && email[i] != '_') return 0;\n\n    }\n    if (at_count != 1 || dot_count == 0) return 0;\n    if (email[0] == '@' || email[0] == '.') return 0;\n    if (email[len - 1] == '@' || email[len-1] == '.') return 0;\n    \n    char* at = strchr(email, '@');\n    if(at == NULL) return 0;\n    char* dot = strchr(at + 1, '.');\n    if(dot == NULL) return 0;\n    if(dot - at <=1 ) return 0;\n    \n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsignal_handler__Fi PROC\n        MOV      r1,r0\n        ADR      r0,|L1.12|\n        B        _printf\n|L1.12|\n        DCB      \"Sign\"\n        DCB      \"al c\"\n        DCB      \"augh\"\n        DCB      \"t: %\"\n        DCB      \"d\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid signal_handler(int signum) {\n    printf(\"Signal caught: %d\\n\",signum);\n    // Add your signal handling logic here\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountOccurrences__FPCc PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x400\n        SUB      sp,sp,#4\n        ADR      r1,|L1.172|\n        BL       fopen\n        MOVS     r4,r0\n        ADDEQ    sp,sp,#0x400\n        ADDEQ    sp,sp,#4\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        ADD      r5,sp,#4\n        MOV      r0,r5\n        MOV      r1,#0x400\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        BL       fgetc\n        CMN      r0,#1\n        BEQ      |L1.100|\n|L1.72|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r1,r1,#1\n        STR      r1,[r5,r0,LSL #2]\n        MOV      r0,r4\n        BL       fgetc\n        CMN      r0,#1\n        BNE      |L1.72|\n|L1.100|\n        MOV      r0,r4\n        BL       fclose\n        MOV      r4,#0\n|L1.112|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.140|\n        MOV      r2,r0\n        ADR      r0,|L1.176|\n        MOV      r1,r4\n        BL       _printf\n|L1.140|\n        ADD      r4,r4,#1\n        CMP      r4,#0x100\n        BLT      |L1.112|\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.172|\n        DCB      \"r\\0\\0\\0\"\n|L1.176|\n        DCB      \"%c: \"\n        DCB      \"%u\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint countOccurrences(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == 0) return 0;\n\n    unsigned int counts[256] = {0};\n    int ch;\n\n    while ((ch = fgetc(file)) != EOF) {\n        counts[ch]++;\n    }\n\n    fclose(file);\n    \n    for (int i = 0; i < 256; i++) {\n        if (counts[i] > 0) {\n            printf(\"%c: %u\\n\", i, counts[i]);\n        }\n    }\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        CMP      r12,r1\n        MOV      r3,r2\n        BGE      |L1.48|\n        LDR      r4,[r0,r12,LSL #2]\n        LDR      r5,[r0,r2,LSL #2]\n        CMP      r4,r5\n        MOVGT    r2,r12\n|L1.48|\n        CMP      lr,r1\n        BGE      |L1.72|\n        LDR      r12,[r0,lr,LSL #2]\n        LDR      r4,[r0,r2,LSL #2]\n        CMP      r12,r4\n        MOVGT    r2,lr\n|L1.72|\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nheapSort__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r5,r0,#1\n        MOV      r6,r1\n        BMI      |L1.160|\n|L1.136|\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       heapify__FPiiT2\n        SUBS     r5,r5,#1\n        BPL      |L1.136|\n|L1.160|\n        SUB      r5,r6,#1\n        CMP      r5,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.176|\n        LDR      r1,[r4,r5,LSL #2]\n        LDR      r0,[r4,#0]\n        STR      r1,[r4,#0]\n        STR      r0,[r4,r5,LSL #2]\n        MOV      r0,r4\n        MOV      r1,r5\n        MOV      r2,#0\n        BL       heapify__FPiiT2\n        SUB      r5,r5,#1\n        CMP      r5,#0\n        BGT      |L1.176|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncone_volume__FdT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        ADR      r8,|L1.120|\n        MOV      r7,r3\n        MOV      r6,r2\n        LDMIA    r8,{r2,r3}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       _dcmple\n        BCC      |L1.56|\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r8,{r2,r3}\n        BL       _dcmple\n        BCS      |L1.72|\n|L1.56|\n        ADR      r1,|L1.128|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.72|\n        ADR      r0,|L1.136|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r4\n        MOV      r1,r5\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        LDMFD    sp!,{r4-r8,lr}\n        B        _dmul\n|L1.120|\n        DCFD     0x0000000000000000\n|L1.128|\n        DCFD     0xbff0000000000000\n|L1.136|\n        DCFD     0x3ff0c152382d749c\n        ENDP\n```",
        "output": "```cpp\n\ndouble cone_volume(double radius, double height) {\n    if (radius < 0 || height < 0) return -1.0;\n    return (1.0/3.0) * 3.14159265359 * radius * radius * height;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlcg__FUlN31 PROC\n        STMFD    sp!,{r3,lr}\n        MLA      r1,r0,r1,r2\n        MOV      r0,r3\n        BL       __rt_udiv\n        LDMFD    sp!,{r3,lr}\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long lcg(unsigned long seed, unsigned long a, unsigned long c, unsigned long m) {\n    return (a * seed + c) % m;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsumArray__FPii PROC\n|L1.0|\n        MOV      r3,#0\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.36|\n|L1.16|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        ADD      r3,r12,r3\n        BLT      |L1.16|\n|L1.36|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sumArray(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\naddBinary__FPcT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r7,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r0,r8\n        BL       strlen\n        MOV      r5,r0\n        CMP      r6,r0\n        MOVLE    r0,r5\n        MOVGT    r0,r6\n        ADD      r0,r0,#2\n        BL       malloc\n        MOV      r4,r0\n        SUB      r1,r5,#1\n        MOV      r5,#0\n        SUB      r0,r6,#1\n        MOV      r2,#0\n        B        |L1.164|\n|L1.76|\n        CMP      r0,#0\n        BLT      |L1.104|\n        MOV      r3,r0\n        LDRB     r3,[r7,r3]\n        SUB      r0,r0,#1\n        ADD      r2,r3,r2\n        SUB      r2,r2,#0x30\n|L1.104|\n        CMP      r1,#0\n        BLT      |L1.132|\n        MOV      r3,r1\n        LDRB     r3,[r8,r3]\n        SUB      r1,r1,#1\n        ADD      r2,r3,r2\n        SUB      r2,r2,#0x30\n|L1.132|\n        ADD      r3,r2,r2,LSR #31\n        MOV      r3,r3,ASR #1\n        SUB      r2,r2,r3,LSL #1\n        ADD      r12,r2,#0x30\n        MOV      r2,r5\n        STRB     r12,[r4,r2]\n        MOV      r2,r3\n        ADD      r5,r5,#1\n|L1.164|\n        CMP      r0,#0\n        CMPLT    r1,#0\n        BGE      |L1.76|\n        CMP      r2,#0\n        BNE      |L1.76|\n        MOV      r7,#0\n        STRB     r7,[r4,r5]\n        ADD      r0,r5,#1\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        CMP      r5,#0\n        BLE      |L1.244|\n        SUB      r2,r5,#1\n|L1.220|\n        SUB      r1,r2,r0\n        LDRB     r1,[r4,r1]\n        STRB     r1,[r6,r0]\n        ADD      r0,r0,#1\n        CMP      r0,r5\n        BLT      |L1.220|\n|L1.244|\n        STRB     r7,[r6,r5]\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* addBinary(char* a, char* b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int max_len = (len_a > len_b) ? len_a : len_b;\n    char* result = (char*)malloc((max_len + 2) * sizeof(char));\n    int i = len_a - 1, j = len_b - 1, k = 0;\n    int carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        int sum = carry;\n        if (i >= 0) sum += a[i--] - '0';\n        if (j >= 0) sum += b[j--] - '0';\n        result[k++] = (sum % 2) + '0';\n        carry = sum / 2;\n    }\n    result[k] = '\\0';\n    char* reversed_result = (char*)malloc((k + 1) * sizeof(char));\n    for (int l = 0; l < k; ++l) {\n        reversed_result[l] = result[k - 1 - l];\n    }\n    reversed_result[k] = '\\0';\n    free(result);\n    return reversed_result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        ADR      r1,|L1.100|\n        CMP      r0,#0\n        ADRLT    r1,|L1.108|\n        MOV      r5,r0\n        LDMLTIA  r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n        LDMIA    r1,{r0,r1}\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r4,#2\n        CMP      r5,#2\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n|L1.60|\n        UMULL    lr,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r3,r4,ASR #31\n        MLA      r1,r3,r0,r12\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r0,lr\n        BLE      |L1.60|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.100|\n        DCQ      0x0000000000000001\n|L1.108|\n        DCQ      0x0000000000000000\n        ENDP\n\nnCr__FiT1 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        MOV      r4,r1\n        CMP      r1,r0\n        BGT      |L1.144|\n        CMP      r4,#0\n        BGE      |L1.160|\n|L1.144|\n        ADR      r1,|L1.108|\n        LDMIA    r1,{r0,r1}\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.160|\n        CMPNE    r4,r5\n        ADREQ    r1,|L1.100|\n        LDMEQIA  r1,{r0,r1}\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        ADD      r0,r5,r5,LSR #31\n        MOV      r0,r0,ASR #1\n        CMP      r0,r4\n        SUBLT    r4,r5,r4\n        MOV      r0,r5\n        BL       factorial__Fi\n        MOV      r8,r0\n        MOV      r0,r4\n        MOV      r9,r1\n        BL       factorial__Fi\n        MOV      r6,r0\n        SUB      r0,r5,r4\n        MOV      r7,r1\n        BL       factorial__Fi\n        UMULL    lr,r12,r0,r6\n        MLA      r12,r6,r1,r12\n        MLA      r1,r7,r0,r12\n        MOV      r0,lr\n        MOV      r3,r9\n        MOV      r2,r8\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _ll_srdv\n        ENDP\n```",
        "output": "```cpp\n\nlong long factorial(int n) {\n    if (n < 0) return 0;\n    if (n == 0) return 1;\n    long long res = 1;\n    for (int i = 2; i <= n; i++)\n        res *= i;\n    return res;\n}\n\nlong long nCr(int n, int r) {\n    if (r > n || r < 0) return 0;\n    if (r == 0 || r == n) return 1;\n    if (r > n / 2) r = n - r;\n    return factorial(n) / (factorial(r) * factorial(n - r));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        MOV      r6,#0\n        MOV      r4,#1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r7,#1\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r1,r6\n        ADR      r0,|L1.132|\n        BL       _printf\n        MOV      r1,r4\n        ADR      r0,|L1.132|\n        BL       _printf\n        MOV      r5,#2\n        CMP      r7,#2\n        BLE      |L1.120|\n|L1.84|\n        ADD      r0,r6,r4\n        MOV      r6,r4\n        MOV      r4,r0\n        MOV      r1,r0\n        ADR      r0,|L1.132|\n        BL       _printf\n        ADD      r5,r5,#1\n        CMP      r5,r7\n        BLT      |L1.84|\n|L1.120|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.132|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint fibonacci(int limit) {\n    int a = 0;\n    int b = 1;\n    int temp;\n\n    if (limit <=0) return 0;\n    if (limit == 1) return 1;\n\n\n    printf(\"%d \", a);\n    printf(\"%d \", b);\n\n    for (int i = 2; i < limit; i++) {\n        temp = a + b;\n        a = b;\n        b = temp;\n        printf(\"%d \", b);\n    }\n    return b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncompare_anagrams__FPCcT1 PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x800\n        SUB      sp,sp,#4\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r0,r5\n        BL       strlen\n        CMP      r6,r0\n        ADDNE    sp,sp,#0x800\n        ADDNE    sp,sp,#4\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r6,sp,#0x400\n        ADD      r6,r6,#4\n        MOV      r0,r6\n        MOV      r1,#0x400\n        BL       __rt_memclr_w\n        ADD      r7,sp,#4\n        MOV      r0,r7\n        MOV      r1,#0x400\n        BL       __rt_memclr_w\n        LDRB     r1,[r4,#0]\n        MOV      r0,#0\n        CMP      r1,#0\n        BEQ      |L1.148|\n|L1.112|\n        LDRB     r1,[r4,r0]\n        ADD      r0,r0,#1\n        ADD      r1,r6,r1,LSL #2\n        LDR      r2,[r1,#0]\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        LDRB     r1,[r4,r0]\n        CMP      r1,#0\n        BNE      |L1.112|\n|L1.148|\n        LDRB     r1,[r5,#0]\n        MOV      r0,#0\n        CMP      r1,#0\n        BEQ      |L1.200|\n|L1.164|\n        LDRB     r1,[r5,r0]\n        ADD      r0,r0,#1\n        ADD      r1,r7,r1,LSL #2\n        LDR      r2,[r1,#0]\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        LDRB     r1,[r5,r0]\n        CMP      r1,#0\n        BNE      |L1.164|\n|L1.200|\n        MOV      r0,#0\n|L1.204|\n        LDR      r1,[r6,r0,LSL #2]\n        LDR      r2,[r7,r0,LSL #2]\n        CMP      r1,r2\n        ADDNE    sp,sp,#0x800\n        ADDNE    sp,sp,#4\n        LDMNEFD  sp!,{r4-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r0,r0,#1\n        CMP      r0,#0x100\n        BLT      |L1.204|\n        ADD      sp,sp,#0x800\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint compare_anagrams(const char* a, const char* b) {\n    if (strlen(a) != strlen(b)) return 0;\n    int char_counts_a[256] = {0};\n    int char_counts_b[256] = {0};\n    for (int i = 0; a[i] != '\\0'; i++) {\n        char_counts_a[a[i]]++;\n    }\n    for (int i = 0; b[i] != '\\0'; i++) {\n        char_counts_b[b[i]]++;\n    }\n    for (int i = 0; i < 256; i++) {\n        if (char_counts_a[i] != char_counts_b[i]) return 0;\n    }\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringcmp__FPCvT1 PROC\n|L1.0|\n        LDR      r1,[r1,#0]\n        LDR      r0,[r0,#0]\n        B        strcmp\n        ENDP\n\nsortStrings__FPPci PROC\n        LDR      r3,|L1.72|\n        MOV      r2,#4\n        B        qsort\n        ENDP\n```",
        "output": "```cpp\n\nint stringcmp(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nvoid sortStrings(char **arr, int n) {\n    qsort(arr, n, sizeof(char *), stringcmp);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nbuildTree__FPiiT2 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        MOV      r7,r2\n        MOV      r6,r1\n        CMP      r1,r2\n        LDMGTFD  sp!,{r4-r8,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        ADD      r0,r6,r7\n        ADD      r0,r0,r0,LSR #31\n        MOV      r5,r0,ASR #1\n        LDR      r0,[r8,r5,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        MOV      r0,r8\n        SUB      r2,r5,#1\n        MOV      r1,r6\n        BL       buildTree__FPiiT2\n        STR      r0,[r4,#4]\n        MOV      r0,r8\n        MOV      r2,r7\n        ADD      r1,r5,#1\n        BL       buildTree__FPiiT2\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nstruct node* buildTree(int arr[], int start, int end) {\n    if (start > end) return NULL;\n\n    int mid = (start + end) / 2;\n    struct node* root = newNode(arr[mid]);\n\n    root->left = buildTree(arr, start, mid - 1);\n    root->right = buildTree(arr, mid + 1, end);\n\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPowerOfTwo__Fi PROC\n        CMP      r0,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        SUB      r1,r0,#1\n        TST      r0,r1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isPowerOfTwo(int n) {\n    if (n <= 0) return 0;\n    return (n & (n - 1)) == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsendMessage__FPci PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r4,|L1.388|\n        MOV      r6,r1\n        LDR      r1,[r4,#8]  ; count\n        CMP      r1,#0xa\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r1,[r4,#4]  ; tail\n        ADD      r12,r1,r1,LSL #2\n        LDR      r5,|L1.392|\n        ADD      r1,r12,r1,LSL #3\n        ADD      r2,r5,r1,LSL #3\n        MOV      r1,r0\n        MOV      r0,r2\n        BL       strcpy\n        LDR      r0,[r4,#4]  ; tail\n        ADD      r1,r0,r0,LSL #2\n        ADD      r1,r1,r0,LSL #3\n        ADD      r1,r5,r1,LSL #3\n        STR      r6,[r1,#0x64]\n        LDR      r1,|L1.396|\n        ADD      r0,r0,#1\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        STR      r0,[r4,#4]  ; tail\n        LDR      r0,[r4,#8]  ; count\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]  ; count\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nreceiveMessage__Fv PROC\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r5,|L1.388|\n        SUB      sp,sp,#0x68\n        LDR      r6,[r5,#8]  ; count\n        MOV      r4,r0\n        CMP      r6,#0\n        BNE      |L1.216|\n        MOV      r0,#0\n        STRB     r0,[sp,#0]\n        MVN      r0,#0\n        STR      r0,[sp,#0x64]\n        MOV      r0,r4\n        MOV      r2,#0x68\n        MOV      r1,sp\n        BL       __rt_memcpy_w\n        ADD      sp,sp,#0x68\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.216|\n        LDR      r7,[r5,#0]  ; head\n        LDR      r1,|L1.392|\n        ADD      r0,r7,r7,LSL #2\n        ADD      r0,r0,r7,LSL #3\n        ADD      r1,r1,r0,LSL #3\n        MOV      r0,sp\n        MOV      r2,#0x68\n        MOV      r8,sp\n        BL       __rt_memcpy_w\n        LDR      r1,|L1.396|\n        ADD      r0,r7,#1\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        STR      r0,[r5,#0]  ; head\n        SUB      r0,r6,#1\n        STR      r0,[r5,#8]  ; count\n        MOV      r0,r4\n        MOV      r1,r8\n        MOV      r2,#0x68\n        BL       __rt_memcpy_w\n        ADD      sp,sp,#0x68\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_MESSAGES 10\n#define MAX_MESSAGE_SIZE 100\n\ntypedef struct {\n    char message[MAX_MESSAGE_SIZE];\n    int sender;\n} Message;\n\nMessage queue[MAX_MESSAGES];\nint head = 0;\nint tail = 0;\nint count = 0;\n\n\nint sendMessage(char *msg, int sender) {\n    if (count == MAX_MESSAGES) return 0;\n    strcpy(queue[tail].message, msg);\n    queue[tail].sender = sender;\n    tail = (tail + 1) % MAX_MESSAGES;\n    count++;\n    return 1;\n}\n\n\nMessage receiveMessage() {\n    if (count == 0) {\n        Message empty;\n        strcpy(empty.message, \"\");\n        empty.sender = -1;\n        return empty;\n    }\n    Message msg = queue[head];\n    head = (head + 1) % MAX_MESSAGES;\n    count--;\n    return msg;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfibonacci__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        CMP      r0,#1\n        MOVLE    r0,r7\n        MOVLE    r1,r7,ASR #31\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n        MOV      r6,#2\n        CMP      r7,#2\n        ADR      r0,|L1.108|\n        LDMIA    r0,{r12,lr}\n        ADR      r0,|L1.116|\n        LDMIA    r0,{r4,r5}\n        BLT      |L1.92|\n|L1.56|\n        ADDS     r0,r12,r4\n        ADC      r1,lr,r5\n        MOV      lr,r5\n        MOV      r12,r4\n        ADD      r6,r6,#1\n        CMP      r6,r7\n        MOV      r4,r0\n        MOV      r5,r1\n        BLE      |L1.56|\n|L1.92|\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.108|\n        DCQ      0x0000000000000000\n|L1.116|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nlong long fibonacci(int n) {\n    if (n <= 1) return n;\n    long long a = 0, b = 1, temp;\n    for (int i = 2; i <= n; i++) {\n        temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntimeDifference__FRC8DateTimeT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r1\n        LDR      r1,[r0,#0]\n        SUB      sp,sp,#0x28\n        SUB      r1,r1,#0x400\n        SUB      r1,r1,#0x36c\n        STR      r1,[sp,#0x18]\n        LDR      r1,[r0,#4]\n        MVN      r6,#0\n        SUB      r1,r1,#1\n        STR      r1,[sp,#0x14]\n        LDR      r1,[r0,#8]\n        STR      r1,[sp,#0x10]\n        LDR      r1,[r0,#0xc]\n        STR      r1,[sp,#0xc]\n        LDR      r1,[r0,#0x10]\n        STR      r1,[sp,#8]\n        LDR      r0,[r0,#0x14]\n        STR      r0,[sp,#4]\n        STR      r6,[sp,#0x24]\n        ADD      r0,sp,#4\n        BL       mktime\n        MOV      r5,r0\n        LDR      r0,[r4,#0]\n        SUB      r0,r0,#0x400\n        SUB      r0,r0,#0x36c\n        STR      r0,[sp,#0x18]\n        LDR      r0,[r4,#4]\n        SUB      r0,r0,#1\n        STR      r0,[sp,#0x14]\n        LDR      r0,[r4,#8]\n        STR      r0,[sp,#0x10]\n        LDR      r0,[r4,#0xc]\n        STR      r0,[sp,#0xc]\n        LDR      r0,[r4,#0x10]\n        STR      r0,[sp,#8]\n        LDR      r0,[r4,#0x14]\n        STR      r0,[sp,#4]\n        STR      r6,[sp,#0x24]\n        ADD      r0,sp,#4\n        BL       mktime\n        MOV      r1,r0\n        MOV      r0,r5\n        ADD      sp,sp,#0x28\n        LDMFD    sp!,{r4-r6,lr}\n        B        __softfp_difftime\n        ENDP\n```",
        "output": "```cpp\n\nstruct DateTime {\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n\n    DateTime(int y, int m, int d, int h, int min, int s) : year(y), month(m), day(d), hour(h), minute(min), second(s) {}\n\n    time_t toTimeT() const {\n        struct tm tm_date;\n        tm_date.tm_year = year - 1900;\n        tm_date.tm_mon = month - 1;\n        tm_date.tm_mday = day;\n        tm_date.tm_hour = hour;\n        tm_date.tm_min = minute;\n        tm_date.tm_sec = second;\n        tm_date.tm_isdst = -1;  //Let mktime determine if DST is in effect\n\n        return mktime(&tm_date);\n    }\n};\n\n\ndouble timeDifference(const DateTime& dt1, const DateTime& dt2) {\n    time_t t1 = dt1.toTimeT();\n    time_t t2 = dt2.toTimeT();\n    return difftime(t1,t2);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfloydWarshall__FPA100_ii PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x9d00\n        ADD      r7,sp,#0xc0\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.84|\n|L1.24|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.72|\n        ADD      r4,r3,r3,LSL #3\n        ADD      r4,r4,r3,LSL #4\n        ADD      lr,r7,r4,LSL #4\n        ADD      r5,r0,r4,LSL #4\n|L1.52|\n        LDR      r4,[r5,r2,LSL #2]\n        STR      r4,[lr,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        BLT      |L1.52|\n|L1.72|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.24|\n|L1.84|\n        CMP      r1,#0\n        ADDLE    sp,sp,#0x9d00\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n|L1.104|\n        MOV      lr,#0\n        CMP      r1,#0\n        BLE      |L1.212|\n        ADD      r0,r4,r4,LSL #3\n        ADD      r0,r0,r4,LSL #4\n        ADD      r6,r7,r0,LSL #4\n|L1.128|\n        MOV      r0,#0\n        CMP      r1,#0\n        BLE      |L1.200|\n        ADD      r2,lr,lr,LSL #3\n        ADD      r2,r2,lr,LSL #4\n        ADD      r2,r7,r2,LSL #4\n|L1.152|\n        LDR      r5,[r2,r4,LSL #2]\n        CMN      r5,#0x80000001\n        LDRNE    r3,[r6,r0,LSL #2]\n        CMNNE    r3,#0x80000001\n        LDRNE    r12,[r2,r0,LSL #2]\n        ADDNE    r3,r5,r3\n        CMPNE    r3,r12\n        BGE      |L1.188|\n        STR      r3,[r2,r0,LSL #2]\n|L1.188|\n        ADD      r0,r0,#1\n        CMP      r0,r1\n        BLT      |L1.152|\n|L1.200|\n        ADD      lr,lr,#1\n        CMP      lr,r1\n        BLT      |L1.128|\n|L1.212|\n        ADD      r4,r4,#1\n        CMP      r4,r1\n        BLT      |L1.104|\n        ADD      sp,sp,#0x9d00\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\n#define INF INT_MAX\n\nvoid floydWarshall(int graph[][100], int n) {\n    int dist[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = graph[i][j];\n        }\n    }\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n\n    //The result is in dist[][]\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nverticalSumUtil__FP4NodeiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r6,r5,LSL #2]\n        LDR      r1,[r4,#0]\n        MOV      r2,r6\n        ADD      r0,r0,r1\n        STR      r0,[r6,r5,LSL #2]\n        LDR      r0,[r4,#4]\n        SUB      r1,r5,#1\n        BL       verticalSumUtil__FP4NodeiPi\n        MOV      r2,r6\n        ADD      r1,r5,#1\n        LDR      r0,[r4,#8]\n        BL       verticalSumUtil__FP4NodeiPi\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nverticalSum__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xfa0\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0\n        MOV      r1,#0\n|L1.720|\n        STR      r1,[r4,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,#0x3e8\n        BLT      |L1.720|\n        MOV      r2,r4\n        MOV      r1,#0\n        MOV      r0,r5\n        BL       verticalSumUtil__FP4NodeiPi\n        MOV      r5,#0\n        MOV      r0,#0\n|L1.760|\n        LDR      r1,[r4,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r0,#0x3e8\n        ADD      r5,r1,r5\n        BLT      |L1.760|\n        MOV      r0,r4\n        BL       free\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return(node);\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\nint verticalSumUtil(Node *root, int hd, int *sum) {\n    if(root == NULL) return 0;\n    sum[hd] += root->data;\n    verticalSumUtil(root->left, hd -1, sum);\n    verticalSumUtil(root->right, hd + 1, sum);\n    return 0;\n}\n\nint verticalSum(Node* root) {\n    int *sum = (int*)malloc(sizeof(int)*1000);\n    for(int i = 0; i < 1000; i++) sum[i] = 0;\n    verticalSumUtil(root, 0, sum);\n    int res = 0;\n    for(int i = 0; i < 1000; i++){\n        res += sum[i];\n    }\n    free(sum);\n    return res;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmsb__Fi PROC\n        CMP      r0,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        RSBLT    r0,r0,#0\n        CMP      r0,#1\n        MOV      r1,#0\n        BLE      |L1.44|\n|L1.28|\n        MOV      r0,r0,ASR #1\n        CMP      r0,#1\n        ADD      r1,r1,#1\n        BGT      |L1.28|\n|L1.44|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint msb(int n) {\n    if (n == 0) return 0;\n    if (n < 0) n = -n;\n    int msb_pos = 0;\n    while (n > 1) {\n        n >>= 1;\n        msb_pos++;\n    }\n    return msb_pos;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisFullBinaryTree__FP4node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0\n        LDRNE    r1,[r4,#8]\n        CMPNE    r1,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        BL       isFullBinaryTree__FP4node\n        CMP      r0,#0\n        BEQ      |L1.148|\n        LDR      r0,[r4,#8]\n        BL       isFullBinaryTree__FP4node\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.148|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left, *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\nint isFullBinaryTree(struct node* root) {\n    if (root == NULL)\n        return 1;\n    if (root->left == NULL && root->right == NULL)\n        return 1;\n    if ((root->left != NULL) && (root->right != NULL))\n        return isFullBinaryTree(root->left) && isFullBinaryTree(root->right);\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ntreeHeight__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       treeHeight__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       treeHeight__FP4Node\n        CMP      r5,r0\n        ADDLE    r0,r0,#1\n        ADDGT    r0,r5,#1\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nint treeHeight(Node* node) {\n    if (node == NULL) return 0;\n    int leftHeight = treeHeight(node->left);\n    int rightHeight = treeHeight(node->right);\n    return (leftHeight > rightHeight) ? (leftHeight + 1) : (rightHeight + 1);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__Fi PROC\n        CMP      r0,#0\n        LDR      r1,|L1.408|\n        RSBLT    r0,r0,#0\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        BX       lr\n        ENDP\n\ncreateHashTable__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#4\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0xa\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP9HashTableiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r7,r2\n        MOV      r6,r1\n        BL       hash__Fi\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        STMIA    r0,{r6,r7}\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #2]\n        STR      r1,[r0,#8]\n        LDR      r1,[r5,#0]\n        STR      r0,[r1,r4,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nsearch__FP9HashTablei PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        MOV      r4,r1\n        BL       hash__Fi\n        LDR      r1,[r5,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.220|\n|L1.188|\n        LDR      r1,[r0,#0]\n        CMP      r1,r4\n        LDREQ    r0,[r0,#4]\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.188|\n|L1.220|\n        LDMFD    sp!,{r4,r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nfreeHashTable__FP9HashTable PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r4,#0\n|L1.244|\n        LDR      r0,[r6,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.276|\n|L1.260|\n        LDR      r5,[r0,#8]\n        BL       free\n        MOVS     r0,r5\n        BNE      |L1.260|\n|L1.276|\n        ADD      r4,r4,#1\n        CMP      r4,#0xa\n        BLT      |L1.244|\n        LDR      r0,[r6,#0]\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define TABLE_SIZE 10\n\ntypedef struct Node {\n    int key;\n    int value;\n    struct Node* next;\n} Node;\n\ntypedef struct HashTable {\n    Node** table;\n} HashTable;\n\nunsigned int hash(int key) {\n    return abs(key) % TABLE_SIZE;\n}\n\nHashTable* createHashTable() {\n    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));\n    ht->table = (Node**)calloc(TABLE_SIZE, sizeof(Node*));\n    return ht;\n}\n\nvoid insert(HashTable* ht, int key, int value) {\n    unsigned int index = hash(key);\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->value = value;\n    newNode->next = ht->table[index];\n    ht->table[index] = newNode;\n}\n\nint search(HashTable* ht, int key) {\n    unsigned int index = hash(key);\n    Node* current = ht->table[index];\n    while (current != NULL) {\n        if (current->key == key) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return -1; \n}\n\n\nvoid freeHashTable(HashTable* ht){\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        Node* current = ht->table[i];\n        while (current != NULL) {\n            Node* next = current->next;\n            free(current);\n            current = next;\n        }\n    }\n    free(ht->table);\n    free(ht);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nperformOperation__FiT1PiT1T3 PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r5,[sp,#0x10]\n        MOV      r12,r0\n        MOVS     r0,r1\n        MOV      r6,r2\n        MOV      r4,r3\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        BLT      |L1.52|\n        CMP      r4,#0xa\n        BLT      |L1.64|\n|L1.52|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#2\n        BX       lr\n|L1.64|\n        MOV      r1,r12\n        BL       __rt_sdiv\n        LDR      r1,[r6,r4,LSL #2]\n        ADD      r0,r0,r1\n        STR      r0,[r5,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nenum ErrorCode {\n    SUCCESS = 0,\n    DIVISION_BY_ZERO,\n    INVALID_ARRAY_INDEX\n};\n\n\nErrorCode performOperation(int numerator, int denominator, int arr[], int index, int *result) {\n    if (denominator == 0) {\n        return DIVISION_BY_ZERO;\n    }\n    if (index < 0 || index >= 10) { // Assuming an array of size 10.  Adjust as needed.\n        return INVALID_ARRAY_INDEX;\n    }\n    *result = numerator / denominator + arr[index];\n    return SUCCESS;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncalculate_average__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        ADR      r1,|L1.176|\n        BL       fopen\n        MOVS     r5,r0\n        ADR      r8,|L1.180|\n        LDMEQIA  r8,{r0,r1}\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r9,sp\n        MOV      r2,sp\n        ADR      r1,|L1.188|\n        MOV      r0,r5\n        LDMIA    r8,{r6,r7}\n        BL       _fscanf\n        CMP      r0,#1\n        BNE      |L1.124|\n|L1.68|\n        LDR      r0,[sp,#0]\n        BL       _dflt\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        MOV      r6,r0\n        MOV      r7,r1\n        ADR      r1,|L1.188|\n        MOV      r0,r5\n        ADD      r4,r4,#1\n        MOV      r2,r9\n        BL       _fscanf\n        CMP      r0,#1\n        BEQ      |L1.68|\n|L1.124|\n        MOV      r0,r5\n        BL       fclose\n        CMP      r4,#0\n        LDMLEIA  r8,{r0,r1}\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        MOV      r0,r4\n        BL       _dflt\n        MOV      r3,r7\n        MOV      r2,r6\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4-r9,lr}\n        B        _drdiv\n|L1.176|\n        DCB      \"r\\0\\0\\0\"\n|L1.180|\n        DCFD     0x0000000000000000\n|L1.188|\n        DCB      \"%d\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\ndouble calculate_average(char* filename) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) return 0;\n\n    double sum = 0;\n    int count = 0;\n    int num;\n\n    while (fscanf(file, \"%d\", &num) == 1) {\n        sum += num;\n        count++;\n    }\n\n    fclose(file);\n    return count > 0 ? sum / count : 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisBalanced__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        MOV      r1,#0\n        MOV      r2,#0\n        BLE      |L1.108|\n|L1.40|\n        LDRB     r3,[r4,r2]\n        CMP      r3,#0x28\n        ADDEQ    r1,r1,#1\n        BEQ      |L1.64|\n        CMP      r3,#0x29\n        SUBEQ    r1,r1,#1\n|L1.64|\n        CMP      r1,#0\n        LDMLTFD  sp!,{r4,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.40|\n        CMP      r1,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.108|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isBalanced(char *expr) {\n    int len = strlen(expr);\n    if (len == 0) return 1;\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (expr[i] == '(') count++;\n        else if (expr[i] == ')') count--;\n        if (count < 0) return 0;\n    }\n    return count == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nallocateMemory__FP11MemoryBlocki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MVN      r5,#0\n        MOV      r4,#0\n        CMP      r0,#0\n        BEQ      |L1.152|\n|L1.20|\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        BNE      |L1.72|\n        LDR      r2,[r0,#0]\n        CMP      r2,r1\n        BLT      |L1.72|\n        SUB      r2,r2,r1\n        CMP      r4,#0\n        BEQ      |L1.64|\n        CMP      r2,r5\n        BLE      |L1.72|\n|L1.64|\n        MOV      r4,r0\n        MOV      r5,r2\n|L1.72|\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.20|\n        CMP      r4,#0\n        BEQ      |L1.152|\n        MOV      r0,#1\n        STR      r0,[r4,#4]\n        CMP      r5,#0\n        BLE      |L1.140|\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#8]\n        STR      r1,[r0,#8]\n        STR      r0,[r4,#8]\n|L1.140|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.152|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfreeMemory__FP11MemoryBlockT1 PROC\n        CMP      r1,#0\n        MOVNE    r0,#0\n        STRNE    r0,[r1,#4]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct MemoryBlock {\n    int size;\n    int used;\n    MemoryBlock *next;\n};\n\nMemoryBlock* allocateMemory(MemoryBlock *head, int size) {\n    MemoryBlock *bestFit = NULL;\n    int bestFitSizeDiff = -1;\n\n    MemoryBlock *current = head;\n    while (current) {\n        if (!current->used && current->size >= size) {\n            int sizeDiff = current->size - size;\n            if (bestFit == NULL || sizeDiff > bestFitSizeDiff) {\n                bestFit = current;\n                bestFitSizeDiff = sizeDiff;\n            }\n        }\n        current = current->next;\n    }\n\n    if (bestFit) {\n        bestFit->used = 1;\n        if (bestFitSizeDiff > 0) {\n            MemoryBlock *remainder = (MemoryBlock*)malloc(sizeof(MemoryBlock));\n            remainder->size = bestFitSizeDiff;\n            remainder->used = 0;\n            remainder->next = bestFit->next;\n            bestFit->next = remainder;\n        }\n        return bestFit;\n    }\n    return NULL;\n}\n\n\nvoid freeMemory(MemoryBlock *head, MemoryBlock *block) {\n    if(block) block->used = 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindSecondLargest__FPii PROC\n|L1.0|\n        CMP      r1,#2\n        MVNLT    r0,#0\n        BXLT     lr\n        STR      lr,[sp,#-4]!\n        LDR      r3,[r0,#0]\n        MVN      lr,#0\n        MOV      r12,#1\n|L1.28|\n        LDR      r2,[r0,r12,LSL #2]\n        CMP      r2,r3\n        MOVGT    lr,r3\n        MOVGT    r3,r2\n        BGT      |L1.64|\n        CMP      r2,lr\n        BLE      |L1.64|\n        CMP      r2,r3\n        MOVNE    lr,r2\n|L1.64|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        BLT      |L1.28|\n        MOV      r0,lr\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findSecondLargest(int arr[], int size) {\n    if (size < 2) {\n        return -1; \n    }\n\n    int largest = arr[0];\n    int secondLargest = -1;\n\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > largest) {\n            secondLargest = largest;\n            largest = arr[i];\n        } else if (arr[i] > secondLargest && arr[i] != largest) {\n            secondLargest = arr[i];\n        }\n    }\n    return secondLargest;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nflattenBinaryTree__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        MOV      r2,r0\n        MOV      r12,#0\n|L1.16|\n        LDR      r1,[r2,#4]\n        CMP      r1,#0\n        BEQ      |L1.76|\n        LDR      r3,[r1,#8]\n        CMP      r3,#0\n        BEQ      |L1.56|\n|L1.40|\n        LDR      r1,[r1,#8]\n        LDR      r3,[r1,#8]\n        CMP      r3,#0\n        BNE      |L1.40|\n|L1.56|\n        LDR      r3,[r2,#8]\n        STR      r3,[r1,#8]\n        LDR      r1,[r2,#4]\n        STR      r1,[r2,#8]\n        STR      r12,[r2,#4]\n|L1.76|\n        LDR      r2,[r2,#8]\n        CMP      r2,#0\n        BNE      |L1.16|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node *next;\n\n    Node(int data) : data(data), left(NULL), right(NULL), next(NULL) {}\n};\n\n\nNode* flattenBinaryTree(Node* root) {\n    if (!root) return NULL;\n\n    Node* tail = root;\n    Node* curr = root;\n\n    while (curr) {\n        if (curr->left) {\n            tail = curr->left;\n            while (tail->right) tail = tail->right;\n            tail->right = curr->right;\n            curr->right = curr->left;\n            curr->left = NULL;\n        }\n        curr = curr->right;\n\n    }\n    return root;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nlca__FP4NodeiT2 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        CMPNE    r0,r6\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       lca__FP4NodeiT2\n        MOV      r7,r0\n        LDR      r0,[r4,#8]\n        MOV      r2,r6\n        MOV      r1,r5\n        BL       lca__FP4NodeiT2\n        CMP      r7,#0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        CMP      r0,#0\n        MOVEQ    r0,r7\n        MOVNE    r0,r4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n\nstruct Node* lca(struct Node* root, int n1, int n2) {\n    if (root == NULL) return NULL;\n    if (root->data == n1 || root->data == n2) return root;\n\n    struct Node *left_lca = lca(root->left, n1, n2);\n    struct Node *right_lca = lca(root->right, n1, n2);\n\n    if (left_lca && right_lca) return root;\n    return (left_lca != NULL) ? left_lca : right_lca;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStudentRecordManager__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        ADD      r0,r1,r1,LSL #3\n        ADD      r0,r0,r0,LSL #1\n        MOV      r0,r0,LSL #2\n        MOV      r4,r1\n        BL       malloc\n        MOVS     r5,r0\n        BNE      |L1.52|\n        ADR      r0,|L1.76|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.52|\n        MOV      r0,#0\n        STR      r0,[r6,#8]\n        STR      r4,[r6,#4]\n        STR      r5,[r6,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.76|\n        DCB      \"Memo\"\n        DCB      \"ry a\"\n        DCB      \"lloc\"\n        DCB      \"atio\"\n        DCB      \"n fa\"\n        DCB      \"iled\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n\naddStudent__FP20StudentRecordManageriPCcT3f PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0x6c\n        LDR      r6,[sp,#0x80]\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        MOV      r7,r3\n        LDR      r3,[r4,#4]\n        CMP      r0,r3\n        ADDGE    sp,sp,#0x6c\n        LDMGEFD  sp!,{r4-r7,lr}\n        ADRGE    r0,|L1.244|\n        BGE      _printf\n        STR      r1,[sp,#0]\n        MOV      r1,r2\n        MOV      r5,sp\n        ADD      r0,sp,#4\n        BL       strcpy\n        MOV      r1,r7\n        ADD      r0,r5,#0x36\n        BL       strcpy\n        STR      r6,[sp,#0x68]\n        LDR      r1,[r4,#8]\n        LDR      r0,[r4,#0]\n        ADD      r1,r1,r1,LSL #3\n        ADD      r1,r1,r1,LSL #1\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r5\n        MOV      r2,#0x6c\n        BL       __rt_memcpy_w\n        LDR      r0,[r4,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        ADD      sp,sp,#0x6c\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.244|\n        DCB      \"Data\"\n        DCB      \"base\"\n        DCB      \" is \"\n        DCB      \"full\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n\ndeleteStudent__FP20StudentRecordManageri PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#8]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.404|\n        LDR      r2,[r5,#0]\n|L1.292|\n        ADD      r3,r4,r4,LSL #3\n        ADD      r3,r3,r3,LSL #1\n        LDR      r3,[r2,r3,LSL #2]\n        CMP      r3,r1\n        BNE      |L1.392|\n        SUB      r0,r0,#1\n        CMP      r0,r4\n        BLE      |L1.372|\n|L1.324|\n        ADD      r1,r4,r4,LSL #3\n        LDR      r0,[r5,#0]\n        ADD      r1,r1,r1,LSL #1\n        ADD      r0,r0,r1,LSL #2\n        ADD      r1,r0,#0x6c\n        MOV      r2,#0x6c\n        BL       __rt_memcpy_w\n        LDR      r0,[r5,#8]\n        ADD      r4,r4,#1\n        SUB      r0,r0,#1\n        CMP      r0,r4\n        BGT      |L1.324|\n|L1.372|\n        LDR      r0,[r5,#8]\n        SUB      r0,r0,#1\n        STR      r0,[r5,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.392|\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.292|\n|L1.404|\n        ADR      r0,|L1.416|\n        LDMFD    sp!,{r3-r5,lr}\n        B        _printf\n|L1.416|\n        DCB      \"Stud\"\n        DCB      \"ent \"\n        DCB      \"not \"\n        DCB      \"foun\"\n        DCB      \"d\\n\\0\\0\"\n        ENDP\n\nupdateStudent__FP20StudentRecordManageriPCcT3f PROC\n        STMFD    sp!,{r3-r7,lr}\n        LDR      r6,[sp,#0x18]\n        MOV      r4,r0\n        LDR      lr,[r4,#8]\n        MOV      r0,#0\n        MOV      r7,r3\n        CMP      lr,#0\n        BLE      |L1.568|\n        LDR      r3,[r4,#0]\n|L1.472|\n        ADD      r12,r0,r0,LSL #3\n        ADD      r12,r12,r12,LSL #1\n        LDR      r12,[r3,r12,LSL #2]\n        CMP      r12,r1\n        BNE      |L1.556|\n        ADD      r5,r0,r0,LSL #3\n        ADD      r5,r5,r5,LSL #1\n        ADD      r0,r3,r5,LSL #2\n        ADD      r0,r0,#4\n        MOV      r1,r2\n        BL       strcpy\n        LDR      r0,[r4,#0]\n        MOV      r1,r7\n        ADD      r0,r0,r5,LSL #2\n        ADD      r0,r0,#0x36\n        BL       strcpy\n        LDR      r0,[r4,#0]\n        ADD      r0,r0,r5,LSL #2\n        STR      r6,[r0,#0x68]\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n|L1.556|\n        ADD      r0,r0,#1\n        CMP      lr,r0\n        BGT      |L1.472|\n|L1.568|\n        ADR      r0,|L1.416|\n        LDMFD    sp!,{r3-r7,lr}\n        B        _printf\n        ENDP\n\ngetStudent__FP20StudentRecordManageri PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r3,[r0,#8]\n        SUB      sp,sp,#8\n        MOV      r2,#0\n        CMP      r3,#0\n        BLE      |L1.696|\n        LDR      r4,[r0,#0]\n|L1.608|\n        ADD      r0,r2,r2,LSL #3\n        ADD      r0,r0,r0,LSL #1\n        LDR      r0,[r4,r0,LSL #2]\n        CMP      r0,r1\n        BNE      |L1.684|\n        ADD      r6,r2,r2,LSL #3\n        ADD      r6,r6,r6,LSL #1\n        ADD      r5,r4,r6,LSL #2\n        LDR      r0,[r5,#0x68]\n        BL       _f2d\n        STMIA    sp,{r0,r1}\n        LDR      r1,[r4,r6,LSL #2]\n        ADR      r0,|L1.712|\n        ADD      r3,r5,#0x36\n        ADD      r2,r5,#4\n        BL       printf\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.684|\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.608|\n|L1.696|\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r6,lr}\n        ADR      r0,|L1.416|\n        B        _printf\n|L1.712|\n        DCB      \"%d %\"\n        DCB      \"s %s\"\n        DCB      \" %.2\"\n        DCB      \"f\\n\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Student {\n    int id;\n    char name[50];\n    char major[50];\n    float gpa;\n};\n\nstruct StudentRecordManager {\n    Student* records;\n    int capacity;\n    int count;\n};\n\n\nstruct StudentRecordManager createStudentRecordManager(int capacity) {\n    struct StudentRecordManager manager;\n    manager.records = (Student*)malloc(capacity * sizeof(Student));\n    if (manager.records == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    manager.capacity = capacity;\n    manager.count = 0;\n    return manager;\n}\n\nvoid addStudent(struct StudentRecordManager* manager, int id, const char* name, const char* major, float gpa) {\n    if (manager->count >= manager->capacity) {\n        printf(\"Database is full\\n\");\n        return;\n    }\n    Student newStudent;\n    newStudent.id = id;\n    strcpy(newStudent.name, name);\n    strcpy(newStudent.major, major);\n    newStudent.gpa = gpa;\n    manager->records[manager->count] = newStudent;\n    manager->count++;\n}\n\nvoid deleteStudent(struct StudentRecordManager* manager, int id) {\n    for (int i = 0; i < manager->count; i++) {\n        if (manager->records[i].id == id) {\n            for (int j = i; j < manager->count - 1; j++) {\n                manager->records[j] = manager->records[j + 1];\n            }\n            manager->count--;\n            return;\n        }\n    }\n    printf(\"Student not found\\n\");\n}\n\nvoid updateStudent(struct StudentRecordManager* manager, int id, const char* name, const char* major, float gpa){\n    for (int i = 0; i < manager->count; i++){\n        if (manager->records[i].id == id){\n            strcpy(manager->records[i].name, name);\n            strcpy(manager->records[i].major, major);\n            manager->records[i].gpa = gpa;\n            return;\n        }\n    }\n    printf(\"Student not found\\n\");\n}\n\nvoid getStudent(struct StudentRecordManager* manager, int id) {\n    for (int i = 0; i < manager->count; i++) {\n        if (manager->records[i].id == id) {\n            printf(\"%d %s %s %.2f\\n\", manager->records[i].id, manager->records[i].name, manager->records[i].major, manager->records[i].gpa);\n            return;\n        }\n    }\n     printf(\"Student not found\\n\");\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nlinearSearch__FPiiT2 PROC\n|L1.0|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.40|\n|L1.12|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,r2\n        MOVEQ    r0,r3\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.12|\n|L1.40|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint linearSearch(int arr[], int size, int key) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == key) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfindSecondSmallest__FPii PROC\n|L1.0|\n        CMP      r1,#2\n        MVNLT    r0,#0\n        BXLT     lr\n        LDMIA    r0,{r2,r3}\n        STR      lr,[sp,#-4]!\n        CMP      r2,r3\n        MOVGT    r12,r2\n        MOVGT    r2,r3\n        MOVGT    r3,r12\n        CMP      r1,#2\n        MOV      lr,#2\n        BLE      |L1.96|\n|L1.48|\n        LDR      r12,[r0,lr,LSL #2]\n        CMP      r12,r2\n        MOVLT    r3,r2\n        MOVLT    r2,r12\n        BLT      |L1.84|\n        CMP      r12,r3\n        BGE      |L1.84|\n        CMP      r12,r2\n        MOVNE    r3,r12\n|L1.84|\n        ADD      lr,lr,#1\n        CMP      lr,r1\n        BLT      |L1.48|\n|L1.96|\n        LDR      lr,[sp],#4\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint findSecondSmallest(int arr[], int size) {\n    if (size < 2) return -1; // Handle cases with less than 2 elements\n\n    int smallest = arr[0];\n    int secondSmallest = arr[1];\n\n    if (smallest > secondSmallest) {\n        int temp = smallest;\n        smallest = secondSmallest;\n        secondSmallest = temp;\n    }\n\n    for (int i = 2; i < size; i++) {\n        if (arr[i] < smallest) {\n            secondSmallest = smallest;\n            smallest = arr[i];\n        } else if (arr[i] < secondSmallest && arr[i] != smallest) {\n            secondSmallest = arr[i];\n        }\n    }\n    return secondSmallest;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateFileSystem__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\naddFile__FP10FileSystemPCcT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        CMPNE    r6,#0\n        MOV      r7,r2\n        CMPNE    r7,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        LDR      r1,[r4,#4]\n        CMP      r0,r1\n        BNE      |L1.136|\n        CMP      r0,#0\n        MOVNE    r0,r0,LSL #1\n        MOVEQ    r0,#1\n        STR      r0,[r4,#8]\n        MOV      r1,r0,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.136|\n        MOV      r0,#8\n        BL       malloc\n        MOV      r5,r0\n        MOV      r0,r6\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        MOV      r1,r6\n        STR      r0,[r5,#0]\n        BL       strcpy\n        MOV      r0,r7\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        MOV      r1,r7\n        STR      r0,[r5,#4]\n        BL       strcpy\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\ndeleteFile__FP10FileSystemPCc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        CMPNE    r6,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.444|\n|L1.280|\n        LDR      r0,[r4,#0]\n        MOV      r1,r6\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r0,[r0,#0]\n        BL       strcmp\n        CMP      r0,#0\n        BNE      |L1.428|\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r0,[r0,#0]\n        BL       free\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r0,[r0,#4]\n        BL       free\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        BL       free\n        LDR      r0,[r4,#4]\n        SUB      r0,r0,#1\n        CMP      r0,r5\n        BLE      |L1.404|\n|L1.368|\n        LDR      r0,[r4,#0]\n        ADD      r1,r0,r5,LSL #2\n        LDR      r1,[r1,#4]\n        STR      r1,[r0,r5,LSL #2]\n        LDR      r0,[r4,#4]\n        ADD      r5,r5,#1\n        SUB      r0,r0,#1\n        CMP      r0,r5\n        BGT      |L1.368|\n|L1.404|\n        LDR      r0,[r4,#4]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.428|\n        LDR      r0,[r4,#4]\n        ADD      r5,r5,#1\n        CMP      r0,r5\n        BGT      |L1.280|\n|L1.444|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nrenameFile__FP10FileSystemPCcT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r1\n        MOVS     r5,r0\n        CMPNE    r6,#0\n        MOV      r7,r2\n        CMPNE    r7,#0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r5,#4]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.616|\n|L1.508|\n        LDR      r0,[r5,#0]\n        MOV      r1,r6\n        LDR      r0,[r0,r4,LSL #2]\n        LDR      r0,[r0,#0]\n        BL       strcmp\n        CMP      r0,#0\n        BNE      |L1.600|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r7\n        BL       strlen\n        ADD      r0,r0,#1\n        BL       malloc\n        LDR      r1,[r5,#0]\n        LDR      r1,[r1,r4,LSL #2]\n        STR      r0,[r1,#0]\n        MOV      r1,r7\n        BL       strcpy\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.600|\n        LDR      r0,[r5,#4]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.508|\n|L1.616|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct File {\n    char* name;\n    char* type; //\"file\" or \"dir\"\n};\n\n\nstruct FileSystem {\n    File** files;\n    int size;\n    int capacity;\n};\n\n\nFileSystem* createFileSystem() {\n    FileSystem* fs = (FileSystem*)malloc(sizeof(FileSystem));\n    fs->files = NULL;\n    fs->size = 0;\n    fs->capacity = 0;\n    return fs;\n}\n\n\nint addFile(FileSystem* fs, const char* name, const char* type) {\n    if (fs == NULL || name == NULL || type == NULL) return 1;\n    if (fs->capacity == fs->size) {\n        fs->capacity = fs->capacity == 0 ? 1 : fs->capacity * 2;\n        fs->files = (File**)realloc(fs->files, fs->capacity * sizeof(File*));\n        if (fs->files == NULL) return 1;\n    }\n\n    File* newFile = (File*)malloc(sizeof(File));\n    newFile->name = (char*)malloc(strlen(name) + 1);\n    strcpy(newFile->name, name);\n    newFile->type = (char*)malloc(strlen(type) + 1);\n    strcpy(newFile->type, type);\n    fs->files[fs->size++] = newFile;\n    return 0;\n\n}\n\n\nint deleteFile(FileSystem* fs, const char* name) {\n    if (fs == NULL || name == NULL) return 1;\n    for (int i = 0; i < fs->size; i++) {\n        if (strcmp(fs->files[i]->name, name) == 0) {\n            free(fs->files[i]->name);\n            free(fs->files[i]->type);\n            free(fs->files[i]);\n            for (int j = i; j < fs->size - 1; j++) {\n                fs->files[j] = fs->files[j + 1];\n            }\n            fs->size--;\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\nint renameFile(FileSystem* fs, const char* oldName, const char* newName) {\n    if (fs == NULL || oldName == NULL || newName == NULL) return 1;\n    for (int i = 0; i < fs->size; i++) {\n        if (strcmp(fs->files[i]->name, oldName) == 0) {\n            free(fs->files[i]->name);\n            fs->files[i]->name = (char*)malloc(strlen(newName) + 1);\n            strcpy(fs->files[i]->name, newName);\n            return 0;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nallocate__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        LDR      r0,|L1.292|\n        MOV      r4,#0\n        LDR      r0,[r0,#0]  ; head\n        MVN      r1,#0\n        CMP      r0,#0\n        BEQ      |L1.180|\n|L1.32|\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        BNE      |L1.84|\n        LDR      r2,[r0,#0]\n        CMP      r2,r5\n        BLT      |L1.84|\n        SUB      r2,r2,r5\n        CMN      r1,#1\n        BEQ      |L1.76|\n        CMP      r2,r1\n        BGE      |L1.84|\n|L1.76|\n        MOV      r1,r2\n        MOV      r4,r0\n|L1.84|\n        LDR      r0,[r0,#8]\n        CMP      r0,#0\n        BNE      |L1.32|\n        CMP      r4,#0\n        BEQ      |L1.180|\n        LDR      r0,[r4,#0]\n        MOV      r6,#1\n        CMP      r0,r5\n        STREQ    r6,[r4,#4]\n        BEQ      |L1.168|\n        MOV      r0,#0xc\n        BL       malloc\n        LDR      r1,[r4,#0]\n        SUB      r1,r1,r5\n        STR      r1,[r0,#0]\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        LDR      r1,[r4,#8]\n        STR      r1,[r0,#8]\n        STR      r0,[r4,#8]\n        STMIA    r4,{r5,r6}\n|L1.168|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.180|\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfreeMemory__FP11MemoryBlock PROC\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct MemoryBlock {\n    int size;\n    int used;\n    MemoryBlock* next;\n};\n\nMemoryBlock* head = NULL;\n\nMemoryBlock* allocate(int size) {\n    MemoryBlock* bestFit = NULL;\n    MemoryBlock* current = head;\n    MemoryBlock* prev = NULL;\n    int minDiff = -1;\n\n    while (current) {\n        if (!current->used && current->size >= size) {\n            int diff = current->size - size;\n            if (minDiff == -1 || diff < minDiff) {\n                minDiff = diff;\n                bestFit = current;\n                prev = current;\n            }\n        }\n        current = current->next;\n    }\n\n    if (bestFit) {\n        if (bestFit->size == size) {\n            bestFit->used = 1;\n        } else {\n            MemoryBlock* newBlock = (MemoryBlock*)malloc(sizeof(MemoryBlock));\n            newBlock->size = bestFit->size - size;\n            newBlock->used = 0;\n            newBlock->next = bestFit->next;\n            bestFit->size = size;\n            bestFit->used = 1;\n            bestFit->next = newBlock;\n\n        }\n        return bestFit;\n\n    }\n    return NULL;\n}\n\n\nvoid freeMemory(MemoryBlock* block) {\n    block->used = 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverseString__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       strlen\n        ADD      r0,r4,r0\n        SUB      r0,r0,#1\n        CMP      r4,r0\n        LDMCSFD  sp!,{r4,lr}\n        BXCS     lr\n|L1.44|\n        LDRB     r2,[r0,#0]\n        LDRB     r1,[r4,#0]\n        STRB     r2,[r4],#1\n        STRB     r1,[r0],#-1\n        CMP      r4,r0\n        BCC      |L1.44|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverseString(char *str) {\n    if (str == 0) return;\n    int n = strlen(str);\n    char *start = str;\n    char *end = str + n - 1;\n    char temp;\n    while (start < end) {\n        temp = *start;\n        *start = *end;\n        *end = temp;\n        start++;\n        end--;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountSetBits__Fi PROC\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.32|\n|L1.12|\n        AND      r2,r0,#1\n        MOV      r0,r0,ASR #1\n        CMP      r0,#0\n        ADD      r1,r2,r1\n        BGT      |L1.12|\n|L1.32|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n\nhaveSameSetBits__FiT1 PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r1\n        BL       countSetBits__Fi\n        MOV      r3,r0\n        MOV      r0,r4\n        BL       countSetBits__Fi\n        CMP      r3,r0\n        LDMFD    sp!,{r4,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += (n & 1);\n        n >>= 1;\n    }\n    return count;\n}\n\nint haveSameSetBits(int a, int b) {\n    return countSetBits(a) == countSetBits(b);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MVN      r1,#0\n        STMIB    r0,{r1,r5}\n        MOV      r4,r0\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#4]\n        CMN      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisFull__FP5Stack PROC\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#4]\n        SUB      r1,r1,#1\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       isFull__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.140|\n        ADR      r0,|L1.168|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.140|\n        LDR      r0,[r4,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.168|\n        DCB      \"Stac\"\n        DCB      \"k Ov\"\n        DCB      \"erfl\"\n        DCB      \"ow\\n\\0\"\n        ENDP\n\npop__FP5Stack PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.220|\n        ADR      r0,|L1.248|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.220|\n        LDR      r0,[r4,#4]\n        SUB      r1,r0,#1\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n|L1.248|\n        DCB      \"Stac\"\n        DCB      \"k Un\"\n        DCB      \"derf\"\n        DCB      \"low\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Stack {\n    int* arr;\n    int top;\n    int capacity;\n};\n\nstruct Stack* createStack(int capacity) {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->arr = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\n\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n\nint isFull(struct Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nvoid push(struct Stack* stack, int item) {\n    if (isFull(stack)) {\n        printf(\"Stack Overflow\\n\");\n        exit(1);\n    }\n    stack->arr[++stack->top] = item;\n}\n\n\nint pop(struct Stack* stack) {\n    if (isEmpty(stack)) {\n        printf(\"Stack Underflow\\n\");\n        exit(1);\n    }\n    return stack->arr[stack->top--];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__F8RationalT1 PROC\n|L1.0|\n        LDR      r12,[sp,#0]\n        MUL      r1,r12,r1\n        MLA      r1,r2,r3,r1\n        MUL      r2,r12,r2\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n\nsubtract__F8RationalT1 PROC\n        LDR      r12,[sp,#0]\n        MUL      r3,r2,r3\n        MUL      r1,r12,r1\n        SUB      r1,r1,r3\n        MUL      r2,r12,r2\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n\ndivide__F8RationalT1 PROC\n        LDR      r12,[sp,#0]\n        MUL      r2,r3,r2\n        MUL      r1,r12,r1\n        STMIA    r0,{r1,r2}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int num;\n    int den;\n} Rational;\n\nRational add(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.den + r2.num * r1.den;\n    result.den = r1.den * r2.den;\n    return result;\n}\n\nRational subtract(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.den - r2.num * r1.den;\n    result.den = r1.den * r2.den;\n    return result;\n}\n\nRational divide(Rational r1, Rational r2) {\n    Rational result;\n    result.num = r1.num * r2.den;\n    result.den = r1.den * r2.num;\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisIsomorphic__FP4nodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#4]\n        BL       isIsomorphic__FP4nodeT1\n        CMP      r0,#0\n        BEQ      |L1.152|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#8]\n        BL       isIsomorphic__FP4nodeT1\n        CMP      r0,#0\n        BNE      |L1.192|\n|L1.152|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#4]\n        BL       isIsomorphic__FP4nodeT1\n        CMP      r0,#0\n        BEQ      |L1.204|\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#8]\n        BL       isIsomorphic__FP4nodeT1\n        CMP      r0,#0\n        BEQ      |L1.204|\n|L1.192|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.204|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct node {\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node* newNode(int data) {\n    struct node* node = (struct node*) malloc(sizeof(struct node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint isIsomorphic(struct node *root1, struct node *root2) {\n    if (root1 == NULL && root2 == NULL)\n        return 1;\n    if (root1 == NULL || root2 == NULL)\n        return 0;\n    if (root1->data != root2->data)\n        return 0;\n    return (isIsomorphic(root1->left, root2->left) && isIsomorphic(root1->right, root2->right)) ||\n           (isIsomorphic(root1->left, root2->right) && isIsomorphic(root1->right, root2->left));\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_array__Fi PROC\n        CMP      r0,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r3,lr}\n        MOV      r0,r0,LSL #2\n        BL       malloc\n        LDMFD    sp!,{r3,lr}\n        CMP      r0,#0\n        BX       lr\n        ENDP\n\nfree_array__FPi PROC\n        CMP      r0,#0\n        BNE      free\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint* create_array(int size) {\n    if (size <= 0) return NULL;\n    int* arr = (int*)malloc(size * sizeof(int));\n    if (arr == NULL) return NULL;\n    return arr;\n}\n\nvoid free_array(int* arr) {\n    if (arr != NULL) free(arr);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        ADD      r1,r4,#8\n        STMIA    r1,{r0,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        MOV      r5,r0\n        BL       __rt_sdiv\n        LDR      r0,[r4,#4]\n        CMP      r1,r0\n        BNE      |L1.264|\n        MOV      r5,r5,LSL #1\n        MOV      r1,r5,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BLE      |L1.260|\n        MOV      r0,#0\n|L1.196|\n        LDR      r1,[r4,#0]\n        LDR      r3,[r4,#0xc]\n        LDR      r2,[r1,r0,LSL #2]\n        ADD      r3,r3,r0\n        STR      r2,[r1,r3,LSL #2]\n        LDR      r1,[r4,#4]\n        ADD      r0,r0,#1\n        CMP      r1,r0\n        BGT      |L1.196|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r4,#4]\n        ADD      r1,r1,r0\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#8]\n        ADD      r0,r1,r0\n        STR      r0,[r4,#8]\n|L1.260|\n        STR      r5,[r4,#0xc]\n|L1.264|\n        LDR      r0,[r4,#0]\n        LDR      r1,[r4,#8]\n        STR      r6,[r0,r1,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#8]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5QueuePi PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMNEIB  r4,{r0,r2}\n        CMPNE    r0,r2\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,[r4,#0]\n        LDR      r0,[r2,r0,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#4]\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nfreeQueue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int *data;\n    int head;\n    int tail;\n    int capacity;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    if (q == NULL) return NULL;\n    q->data = (int*)malloc(capacity * sizeof(int));\n    if (q->data == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->head = 0;\n    q->tail = 0;\n    q->capacity = capacity;\n    return q;\n}\n\nint enqueue(Queue* q, int value) {\n    if (q == NULL) return 0;\n    if ((q->tail + 1) % q->capacity == q->head) {\n        int newCapacity = q->capacity * 2;\n        int* newData = (int*)realloc(q->data, newCapacity * sizeof(int));\n        if (newData == NULL) return 0;\n        q->data = newData;\n        if (q->head > 0) {\n            for (int i = 0; i < q->head; i++) {\n                q->data[q->capacity + i] = q->data[i];\n            }\n            q->head += q->capacity;\n            q->tail +=q->capacity;\n        }\n        q->capacity = newCapacity;\n    }\n    q->data[q->tail] = value;\n    q->tail = (q->tail + 1) % q->capacity;\n    return 1;\n}\n\nint dequeue(Queue* q, int* value) {\n    if (q == NULL || q->head == q->tail) return 0;\n    *value = q->data[q->head];\n    q->head = (q->head + 1) % q->capacity;\n    return 1;\n}\n\nvoid freeQueue(Queue* q) {\n    if (q != NULL) {\n        free(q->data);\n        free(q);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\narraysEqual__FPiT1i PROC\n|L1.0|\n        CMP      r0,#0\n        CMPNE    r1,#0\n        CMPNE    r2,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r3,lr}\n        MOV      r2,r2,LSL #2\n        BL       memcmp\n        RSBS     r0,r0,#1\n        LDMFD    sp!,{r3,lr}\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint arraysEqual(int* arr1, int* arr2, int size) {\n    if (arr1 == 0 || arr2 == 0 || size <= 0) return 0;\n    return memcmp(arr1, arr2, size * sizeof(int)) == 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisBalanced__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        SUB      r0,r1,r0\n        ADD      r0,r0,#1\n        CMP      r0,#2\n        BHI      |L1.704|\n        LDR      r0,[r4,#4]\n        BL       isBalanced__FP4Node\n        CMP      r0,#0\n        BEQ      |L1.704|\n        LDR      r0,[r4,#8]\n        BL       isBalanced__FP4Node\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.704|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return (node);\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n    if (data < node->data)\n        node->left = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nint isBalanced(Node *root) {\n    if (root == NULL)\n        return 1;\n    int lh = height(root->left);\n    int rh = height(root->right);\n    if (abs(lh - rh) <= 1 && isBalanced(root->left) && isBalanced(root->right))\n        return 1;\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nprecedence__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVEQ    r0,#2\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\nisOperator__Fc PROC\n        CMP      r0,#0x2b\n        CMPNE    r0,#0x2d\n        CMPNE    r0,#0x2a\n        CMPNE    r0,#0x2f\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ninfixToPostfix__FPc PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r0\n        MOV      r0,#0x64\n        SUB      sp,sp,#0x68\n        BL       malloc\n        MOV      r6,r0\n        LDRB     r0,[r8,#0]\n        MVN      r4,#0\n        MOV      r7,#0\n        MOV      r5,#0\n        CMP      r0,#0\n        BEQ      |L1.388|\n        BL       __rt_ctype_table\n        MOV      r3,r0\n        ADD      r2,sp,#4\n|L1.128|\n        LDRB     r1,[r8,r7]\n        LDR      r0,[r3,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        MOVNE    r0,r5\n        STRNEB   r1,[r6,r0]\n        ADDNE    r5,r5,#1\n        BNE      |L1.332|\n        CMP      r1,#0x28\n        ADDEQ    r4,r4,#1\n        STREQB   r1,[r2,r4]\n        BEQ      |L1.332|\n        CMP      r1,#0x29\n        BNE      |L1.240|\n        B        |L1.212|\n|L1.188|\n        MOV      r0,r4\n        LDRB     r1,[r2,r0]\n        MOV      r0,r5\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        STRB     r1,[r6,r0]\n|L1.212|\n        CMN      r4,#1\n        BLE      |L1.232|\n        LDRB     r0,[r2,r4]\n        CMP      r0,#0x28\n        BNE      |L1.188|\n|L1.232|\n        SUB      r4,r4,#1\n        B        |L1.332|\n|L1.240|\n        MOV      r0,r1\n        BL       isOperator__Fc\n        CMP      r0,#0\n        BEQ      |L1.332|\n        B        |L1.284|\n|L1.260|\n        MOV      r0,r4\n        LDRB     r1,[r2,r0]\n        MOV      r0,r5\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        STRB     r1,[r6,r0]\n|L1.284|\n        CMN      r4,#1\n        BLE      |L1.320|\n        LDRB     r0,[r2,r4]\n        BL       precedence__Fc\n        MOV      r1,r0\n        LDRB     r0,[r8,r7]\n        BL       precedence__Fc\n        CMP      r1,r0\n        BGE      |L1.260|\n|L1.320|\n        LDRB     r0,[r8,r7]\n        ADD      r4,r4,#1\n        STRB     r0,[r2,r4]\n|L1.332|\n        ADD      r7,r7,#1\n        LDRB     r0,[r8,r7]\n        CMP      r0,#0\n        BNE      |L1.128|\n        CMN      r4,#1\n        BLE      |L1.388|\n|L1.356|\n        MOV      r0,r4\n        LDRB     r1,[r2,r0]\n        MOV      r0,r5\n        SUB      r4,r4,#1\n        CMN      r4,#1\n        ADD      r5,r5,#1\n        STRB     r1,[r6,r0]\n        BGT      |L1.356|\n|L1.388|\n        MOV      r0,#0\n        STRB     r0,[r6,r5]\n        ADD      sp,sp,#0x68\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\nint precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n\nint isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nchar* infixToPostfix(char* infix) {\n    char* postfix = (char*)malloc(MAX_SIZE * sizeof(char));\n    char stack[MAX_SIZE];\n    int top = -1;\n    int i = 0, j = 0;\n\n    while (infix[i] != '\\0') {\n        if (isalnum(infix[i])) {\n            postfix[j++] = infix[i];\n        } else if (infix[i] == '(') {\n            stack[++top] = infix[i];\n        } else if (infix[i] == ')') {\n            while (top > -1 && stack[top] != '(') {\n                postfix[j++] = stack[top--];\n            }\n            top--; \n        } else if (isOperator(infix[i])) {\n            while (top > -1 && precedence(stack[top]) >= precedence(infix[i])) {\n                postfix[j++] = stack[top--];\n            }\n            stack[++top] = infix[i];\n        }\n        i++;\n    }\n\n    while (top > -1) {\n        postfix[j++] = stack[top--];\n    }\n    postfix[j] = '\\0';\n    return postfix;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__Fdi PROC\n        STMFD    sp!,{r4-r8,lr}\n        ADR      r7,|L1.140|\n        MOV      r6,r1\n        MOV      r5,r0\n        CMP      r2,#0\n        LDMEQIA  r7,{r0,r1}\n        ADR      r8,|L1.148|\n        MOV      r4,r2\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        BGE      |L1.100|\n        MOV      r1,r6\n        MOV      r0,r5\n        LDMIA    r8,{r2,r3}\n        BL       _dcmpeq\n        LDMEQIA  r8,{r0,r1}\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        RSB      r2,r4,#0\n        MOV      r1,r6\n        MOV      r0,r5\n        BL       power__Fdi\n        LDMIA    r7,{r2,r3}\n        LDMFD    sp!,{r4-r8,lr}\n        B        _drdiv\n|L1.100|\n        LDMIA    r7,{r0,r1}\n        MOV      r7,#0\n|L1.108|\n        MOV      r3,r6\n        MOV      r2,r5\n        BL       _dmul\n        ADD      r7,r7,#1\n        CMP      r7,r4\n        BLT      |L1.108|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.140|\n        DCFD     0x3ff0000000000000\n|L1.148|\n        DCFD     0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\ndouble power(double base, int exp) {\n    if (exp == 0) return 1;\n    if (exp < 0) {\n        if (base == 0) return 0; // Handle 0^-n case\n        return 1.0 / power(base, -exp);\n    }\n    double result = 1.0;\n    for (int i = 0; i < exp; i++) {\n        result *= base;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncubic_root__FdN31PdN25 PROC\n        STMFD    sp!,{r4-r11,lr}\n        MOV      r7,r3\n        ADR      r3,|L1.872|\n        MOV      r6,r2\n        LDR      r2,[r3,#0]\n        ADR      r3,|L1.872|\n        LDR      r3,[r3,#4]\n        SUB      sp,sp,#0x1c\n        MOV      r9,r1\n        MOV      r8,r0\n        BL       _dmul\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r2,r6\n        MOV      r3,r7\n        BL       _drdiv\n        ADD      r3,sp,#0x40\n        MOV      r11,r1\n        MOV      r10,r0\n        MOV      r0,r4\n        MOV      r1,r5\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        ADD      r12,sp,#0xc\n        STMIA    r12,{r0,r1}\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _drsb\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        MOV      r2,r8\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r9\n        BL       _dmul\n        ADD      r3,sp,#0x14\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        MOV      r4,r0\n        ADR      r0,|L1.880|\n        LDMIA    r0,{r2,r3}\n        MOV      r5,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        STMIB    sp,{r0,r1}\n        ADR      r0,|L1.888|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        ADD      r3,sp,#0x40\n        LDMIA    r3,{r2,r3}\n        BL       _dmul\n        LDMIB    sp,{r2,r3}\n        BL       _drsb\n        ADD      r2,sp,#0xc\n        STMIA    r2,{r0,r1}\n        ADR      r0,|L1.896|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dmul\n        ADD      r3,sp,#0x48\n        LDMIA    r3,{r2,r3}\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       _dmul\n        ADD      r3,sp,#0xc\n        LDMIA    r3,{r2,r3}\n        BL       _dadd\n        ADD      r2,sp,#0x14\n        STMIA    r2,{r0,r1}\n        MOV      r2,r8\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r9\n        BL       _dmul\n        ADD      r3,sp,#0x14\n        LDMIA    r3,{r2,r3}\n        BL       _drdiv\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        ADR      r2,|L1.904|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        ADR      r2,|L1.896|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        MOV      r8,r0\n        ADR      r0,|L1.912|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r9,r1\n        BL       _dcmpge\n        BLS      |L1.704|\n        ADR      r2,|L1.920|\n        LDMIA    r2,{r2,r3}\n        MOV      r0,r6\n        EOR      r1,r7,#0x80000000\n        BL       _dmul\n        MOV      r4,r0\n        MOV      r5,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_sqrt\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dadd\n        BL       __softfp_cbrt\n        ADR      r2,|L1.920|\n        MOV      r4,r0\n        MOV      r5,r1\n        EOR      r1,r7,#0x80000000\n        MOV      r0,r6\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r9\n        MOV      r0,r8\n        BL       __softfp_sqrt\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _drsb\n        BL       __softfp_cbrt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _dadd\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        BL       _drsb\n        LDR      r2,[sp,#0x50]\n        STMIA    r2,{r0,r1}\n        ADR      r1,|L1.928|\n        LDMIA    r1,{r0,r1}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.704|\n        ADR      r0,|L1.912|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r8\n        MOV      r1,r9\n        BL       _dcmpeq\n        MOV      r1,r7\n        MOV      r0,r6\n        BNE      |L1.936|\n        ADR      r2,|L1.920|\n        LDMIA    r2,{r2,r3}\n        EOR      r1,r1,#0x80000000\n        BL       _dmul\n        BL       __softfp_cbrt\n        ADR      r8,|L1.880|\n        LDMIA    r8,{r2,r3}\n        MOV      r4,r0\n        MOV      r5,r1\n        BL       _dmul\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        ADR      r6,|L1.872|\n        BL       _drsb\n        LDR      r2,[sp,#0x50]\n        MOV      r7,r0\n        STR      r0,[r2,#0]\n        STR      r1,[r2,#4]\n        MOV      r9,r1\n        MOV      r1,r5\n        LDMIA    r6,{r2,r3}\n        MOV      r0,r4\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r7\n        BL       _drsb\n        LDR      r2,[sp,#0x54]\n        STMIA    r2,{r0,r1}\n        LDMIA    r8,{r0,r1}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.872|\n        DCFD     0x4008000000000000\n|L1.880|\n        DCFD     0x4000000000000000\n|L1.888|\n        DCFD     0x4022000000000000\n|L1.896|\n        DCFD     0x403b000000000000\n|L1.904|\n        DCFD     0x3fd0000000000000\n|L1.912|\n        DCFD     0x0000000000000000\n|L1.920|\n        DCFD     0x3fe0000000000000\n|L1.928|\n        DCFD     0x3ff0000000000000\n|L1.936|\n        EOR      r7,r1,#0x80000000\n        MOV      r6,r0\n        MOV      r0,r4\n        EOR      r1,r5,#0x80000000\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        ADR      r2,|L1.896|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        BL       __softfp_sqrt\n        ADR      r8,|L1.880|\n        LDMIA    r8,{r2,r3}\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _drdiv\n        BL       __softfp_acos\n        MOV      r6,r0\n        MOV      r0,r4\n        ADR      r4,|L1.872|\n        MOV      r7,r1\n        EOR      r1,r5,#0x80000000\n        LDMIA    r4,{r2,r3}\n        BL       _ddiv\n        BL       __softfp_sqrt\n        LDMIA    r8,{r2,r3}\n        BL       _dmul\n        MOV      r5,r0\n        MOV      r8,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        LDMIA    r4,{r2,r3}\n        BL       _ddiv\n        BL       ||__softfp_cos||\n        MOV      r3,r8\n        MOV      r2,r5\n        BL       _dmul\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        BL       _drsb\n        LDR      r2,[sp,#0x50]\n        STMIA    r2,{r0,r1}\n        ADR      r0,|L1.1288|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dadd\n        LDMIA    r4,{r2,r3}\n        BL       _ddiv\n        BL       ||__softfp_cos||\n        MOV      r3,r8\n        MOV      r2,r5\n        BL       _dmul\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        BL       _drsb\n        LDR      r2,[sp,#0x54]\n        STMIA    r2,{r0,r1}\n        ADR      r0,|L1.1296|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _dadd\n        LDMIA    r4,{r2,r3}\n        BL       _ddiv\n        BL       ||__softfp_cos||\n        MOV      r3,r8\n        MOV      r2,r5\n        BL       _dmul\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r11\n        MOV      r0,r10\n        BL       _drsb\n        LDR      r2,[sp,#0x58]\n        STMIA    r2,{r0,r1}\n        LDMIA    r4,{r0,r1}\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n|L1.1288|\n        DCFD     0x401921fb54442eea\n|L1.1296|\n        DCFD     0x402921fb54442eea\n        ENDP\n```",
        "output": "```cpp\n\ndouble cubic_root(double a, double b, double c, double d, double *r1, double *r2, double *r3){\n    double p = (3.0*a*c - b*b)/(3.0*a*a);\n    double q = (2.0*b*b*b - 9.0*a*b*c + 27.0*a*a*d)/(27.0*a*a*a);\n    double delta = q*q/4.0 + p*p*p/27.0;\n\n    if(delta > 0){\n        double u = cbrt(-q/2.0 + sqrt(delta));\n        double v = cbrt(-q/2.0 - sqrt(delta));\n        *r1 = u + v - b/(3.0*a);\n        return 1;\n    } else if (delta == 0){\n        double u = cbrt(-q/2.0);\n        *r1 = 2.0*u - b/(3.0*a);\n        *r2 = *r1 - 3.0*u;\n        return 2;\n    } else {\n        double theta = acos(-q/(2.0*sqrt(-p*p*p/27.0)));\n        double u = 2.0*sqrt(-p/3.0);\n        *r1 = u*cos(theta/3.0) - b/(3.0*a);\n        *r2 = u*cos((theta + 2.0*3.14159265359)/3.0) - b/(3.0*a);\n        *r3 = u*cos((theta + 4.0*3.14159265359)/3.0) - b/(3.0*a);\n        return 3;\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nremoveElement__FPP4Nodei PROC\n        LDR      r2,[r0,#0]\n        MOV      r3,#0\n        CMP      r2,#0\n        BXEQ     lr\n        LDR      r12,[r2,#0]\n        CMP      r12,r1\n        BNE      |L1.60|\n        LDR      r1,[r2,#4]\n        STR      r1,[r0,#0]\n        MOV      r0,r2\n        B        free\n|L1.44|\n        MOV      r3,r2\n        LDR      r2,[r2,#4]\n        CMP      r2,#0\n        BXEQ     lr\n|L1.60|\n        LDR      r0,[r2,#0]\n        CMP      r0,r1\n        BNE      |L1.44|\n        LDR      r0,[r2,#4]\n        STR      r0,[r3,#4]\n        MOV      r0,r2\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *next;\n};\n\nvoid removeElement(Node** head, int key) {\n    Node* temp = *head, *prev = NULL;\n\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;\n        free(temp);\n        return;\n    }\n\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) return;\n\n    prev->next = temp->next;\n    free(temp);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        CMP      r0,#0\n        ADRLT    r1,|L1.92|\n        MOV      r5,r0\n        LDMLTIA  r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n        MOV      r4,#1\n        CMP      r5,#1\n        ADR      r1,|L1.100|\n        LDMIA    r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n|L1.52|\n        UMULL    lr,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r3,r4,ASR #31\n        MLA      r1,r3,r0,r12\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r0,lr\n        BLE      |L1.52|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.92|\n        DCQ      0xffffffffffffffff\n|L1.100|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nlong long factorial(int n) {\n    if (n < 0) return -1; //Error handling for negative input.\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        CMP      r12,r1\n        LDRLT    r4,[r0,r12,LSL #2]\n        LDRLT    r5,[r0,r2,LSL #2]\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        MOV      r3,r2\n        CMPLT    r4,r5\n        MOVLT    r2,r12\n        CMP      lr,r1\n        LDRLT    r12,[r0,lr,LSL #2]\n        LDRLT    r4,[r0,r2,LSL #2]\n        CMPLT    r12,r4\n        MOVLT    r2,lr\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nbuildHeap__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r4,r0,#1\n        MOV      r5,r1\n        LDMMIFD  sp!,{r4-r6,lr}\n        BXMI     lr\n|L1.132|\n        MOV      r2,r4\n        MOV      r1,r5\n        MOV      r0,r6\n        BL       heapify__FPiiT2\n        SUBS     r4,r4,#1\n        BPL      |L1.132|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid heapify(int arr[], int n, int i) {\n    int smallest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] < arr[smallest])\n        smallest = l;\n\n    if (r < n && arr[r] < arr[smallest])\n        smallest = r;\n\n    if (smallest != i) {\n        int temp = arr[i];\n        arr[i] = arr[smallest];\n        arr[smallest] = temp;\n        heapify(arr, n, smallest);\n    }\n}\n\nvoid buildHeap(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountingSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        CMP      r0,#0\n        CMPNE    r7,#0\n        MOV      r5,r0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        MOV      r0,#1\n        CMP      r7,#1\n        LDR      r6,[r5,#0]\n        BLE      |L1.68|\n|L1.44|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r1,r6\n        MOVGT    r6,r1\n        CMP      r0,r7\n        BLT      |L1.44|\n|L1.68|\n        MOV      r0,#4\n        ADD      r8,r0,r6,LSL #2\n        MOV      r0,r8\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r1,r8\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        CMP      r7,#0\n        BLE      |L1.152|\n|L1.120|\n        LDR      r1,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        ADD      r1,r4,r1,LSL #2\n        LDR      r2,[r1,#0]\n        CMP      r0,r7\n        ADD      r2,r2,#1\n        STR      r2,[r1,#0]\n        BLT      |L1.120|\n|L1.152|\n        MOV      r3,#0\n        MOV      r0,#0\n        CMP      r6,#0\n        BLT      |L1.224|\n|L1.168|\n        LDR      r2,[r4,r0,LSL #2]\n        MOV      r1,#0\n        CMP      r2,#0\n        BLE      |L1.212|\n|L1.184|\n        MOV      r2,r3\n        STR      r0,[r5,r2,LSL #2]\n        LDR      r2,[r4,r0,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r2,r1\n        ADD      r3,r3,#1\n        BGT      |L1.184|\n|L1.212|\n        ADD      r0,r0,#1\n        CMP      r0,r6\n        BLE      |L1.168|\n|L1.224|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nvoid countingSort(int *arr, int n) {\n    if (arr == 0 || n <= 0) return;\n\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n\n    int *count = (int *)malloc((max + 1) * sizeof(int));\n    if (count == 0) return;\n    memset(count, 0, (max + 1) * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    int k = 0;\n    for (int i = 0; i <= max; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            arr[k++] = i;\n        }\n    }\n\n    free(count);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninOrderTraversal__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       inOrderTraversal__FP4Node\n        ADR      r0,|L1.48|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        inOrderTraversal__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(0), right(0) {}\n};\n\n\nvoid inOrderTraversal(Node* node) {\n    if (node != 0) {\n        inOrderTraversal(node->left);\n        printf(\"%d \", node->data);\n        inOrderTraversal(node->right);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nserialize__FP4Node PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r0,#0x400\n        BL       malloc\n        MOV      r4,r0\n        ADR      r1,|L1.164|\n        LDR      r2,[r5,#0]\n        BL       _sprintf\n        MOV      r0,r4\n        BL       strlen\n        LDR      r0,[r5,#4]\n        BL       serialize__FP4Node\n        MOVS     r6,r0\n        BEQ      |L1.88|\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       strcat\n        MOV      r0,r6\n        BL       free\n        B        |L1.100|\n|L1.88|\n        ADR      r1,|L1.168|\n        MOV      r0,r4\n        BL       strcat\n|L1.100|\n        LDR      r0,[r5,#8]\n        BL       serialize__FP4Node\n        MOVS     r5,r0\n        BEQ      |L1.140|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       strcat\n        MOV      r0,r5\n        BL       free\n        B        |L1.152|\n|L1.140|\n        ADR      r1,|L1.168|\n        MOV      r0,r4\n        BL       strcat\n|L1.152|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.164|\n        DCB      \"%d \\0\"\n|L1.168|\n        DCB      \"# \\0\\0\"\n        ENDP\n\ndeserialize__FPc PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOVS     r4,r0\n        BEQ      |L1.204|\n        ADR      r1,|L1.168|\n        MOV      r0,r4\n        BL       strcmp\n        CMP      r0,#0\n        BNE      |L1.216|\n|L1.204|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.216|\n        MOV      r7,sp\n        MOV      r2,sp\n        ADR      r1,|L1.164|\n        MOV      r0,r4\n        BL       _sscanf\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r5,r0\n        LDR      r0,[sp,#0]\n        STR      r0,[r5,#0]\n        MOV      r0,r7\n        BL       strlen\n        ADD      r0,r0,r4\n        ADD      r0,r0,#1\n        MOV      r1,#0x23\n        BL       strchr\n        CMP      r0,#0\n        MOVEQ    r6,#0\n        BEQ      |L1.320|\n        MOV      r1,#0\n        STRB     r1,[r0,#0]\n        ADD      r6,r0,#2\n        MOV      r0,r7\n        BL       strlen\n        ADD      r0,r0,r4\n        ADD      r0,r0,#1\n|L1.320|\n        BL       deserialize__FPc\n        STR      r0,[r5,#4]\n        MOV      r0,r6\n        BL       deserialize__FPc\n        STR      r0,[r5,#8]\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nchar* serialize(struct Node* root) {\n    if (root == NULL) return NULL;\n    char* s = (char*)malloc(1024);\n    int i = 0;\n    \n    char* tmp;\n    sprintf(s, \"%d \", root->data);\n    i += strlen(s);\n    \n    tmp = serialize(root->left);\n    if(tmp){\n        strcat(s,tmp);\n        free(tmp);\n    }else strcat(s, \"# \");\n\n    tmp = serialize(root->right);\n    if(tmp){\n        strcat(s, tmp);\n        free(tmp);\n    }else strcat(s,\"# \");\n\n    return s;\n}\n\n\n\nstruct Node* deserialize(char* data) {\n    if (data == NULL || strcmp(data, \"# \") == 0) return NULL;\n    int val;\n    sscanf(data, \"%d \", &val);\n\n    struct Node* root = (struct Node*)malloc(sizeof(struct Node));\n    root->data = val;\n\n    char* left_str;\n    char* right_str;\n    char* p = strchr(data + strlen( (char*)&val) + 1, '#');\n    if (p) {\n        *p = '\\0';\n        p += 2;\n        left_str = data + strlen( (char*)&val) + 1;\n        right_str = p;\n    }\n    else {\n        left_str = NULL;\n        right_str = NULL;\n    }\n    root->left = deserialize(left_str);\n    root->right = deserialize(right_str);\n    return root;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitializeBigNumber__FP9BigNumber PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r1,#0xfa0\n        BL       __rt_memclr_w\n        MOV      r0,#1\n        STR      r0,[r4,#0xfa0]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nmultiplyBigNumber__FP9BigNumberi PROC\n        LDR      r12,[r0,#0xfa0]\n        MOV      r3,#0\n        MOV      r2,#0\n        CMP      r12,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        LDR      lr,|L1.256|\n|L1.60|\n        LDR      r12,[r0,r2,LSL #2]\n        MLA      r3,r1,r12,r3\n        SMULL    r4,r12,lr,r3\n        MOV      r12,r12,ASR #2\n        SUB      r12,r12,r12,ASR #31\n        SUB      r12,r12,r12,LSL #1\n        ADD      r12,r12,r12,LSL #2\n        ADD      r12,r3,r12,LSL #1\n        STR      r12,[r0,r2,LSL #2]\n        SMULL    r12,r3,lr,r3\n        LDR      r12,[r0,#0xfa0]\n        MOV      r3,r3,ASR #2\n        ADD      r2,r2,#1\n        CMP      r12,r2\n        SUB      r3,r3,r3,ASR #31\n        BGT      |L1.60|\n        CMP      r3,#0\n        LDMLEFD  sp!,{r4,lr}\n        BXLE     lr\n|L1.136|\n        SMULL    r2,r1,lr,r3\n        MOV      r1,r1,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r2,r3,r1,LSL #1\n        LDR      r1,[r0,#0xfa0]\n        ADD      r12,r1,#1\n        STR      r12,[r0,#0xfa0]\n        STR      r2,[r0,r1,LSL #2]\n        SMULL    r2,r1,lr,r3\n        MOV      r1,r1,ASR #2\n        SUB      r3,r1,r1,ASR #31\n        CMP      r3,#0\n        BGT      |L1.136|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintBigNumber__FP9BigNumber PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        LDR      r0,[r0,#0xfa0]\n        SUBS     r4,r0,#1\n        BMI      |L1.244|\n|L1.224|\n        LDR      r1,[r5,r4,LSL #2]\n        ADR      r0,|L1.260|\n        BL       _printf\n        SUBS     r4,r4,#1\n        BPL      |L1.224|\n|L1.244|\n        ADR      r0,|L1.264|\n        LDMFD    sp!,{r3-r5,lr}\n        B        _printf\n|L1.256|\n        DCD      0x66666667\n|L1.260|\n        DCB      \"%d\\0\\0\"\n|L1.264|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n\nfactorial__Fi PROC\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        MOV      r7,r0\n        MOV      r0,sp\n        MOV      r6,sp\n        MOV      r5,r1\n        BL       initializeBigNumber__FP9BigNumber\n        MOV      r0,#1\n        STR      r0,[sp,#0]\n        MOV      r4,#2\n        CMP      r5,#2\n        BLT      |L1.344|\n|L1.320|\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       multiplyBigNumber__FP9BigNumberi\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLE      |L1.320|\n|L1.344|\n        MOV      r2,#0x3a4\n        ADD      r2,r2,#0xc00\n        MOV      r1,r6\n        MOV      r0,r7\n        BL       __rt_memcpy_w\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_DIGITS 1000\n\ntypedef struct {\n    int digits[MAX_DIGITS];\n    int size;\n} BigNumber;\n\nvoid initializeBigNumber(BigNumber *n) {\n    memset(n->digits, 0, sizeof(n->digits));\n    n->size = 1;\n}\n\nvoid multiplyBigNumber(BigNumber *a, int b) {\n    int carry = 0;\n    for (int i = 0; i < a->size; ++i) {\n        int product = a->digits[i] * b + carry;\n        a->digits[i] = product % 10;\n        carry = product / 10;\n    }\n    while (carry > 0) {\n        a->digits[a->size++] = carry % 10;\n        carry /= 10;\n    }\n}\n\nvoid printBigNumber(BigNumber *n) {\n    for (int i = n->size - 1; i >= 0; --i) {\n        printf(\"%d\", n->digits[i]);\n    }\n    printf(\"\\n\");\n}\n\n\nBigNumber factorial(int n) {\n    BigNumber result;\n    initializeBigNumber(&result);\n    result.digits[0] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        multiplyBigNumber(&result, i);\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_leap__Fi PROC\n        CMP      r0,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        TST      r0,#3\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,|L1.144|\n        SMULL    r3,r2,r1,r0\n        MOV      r2,r2,ASR #5\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r2,r2,LSL #2\n        ADDS     r2,r0,r2,LSL #2\n        MOVNE    r0,#1\n        BXNE     lr\n        SMULL    r3,r2,r1,r0\n        MOV      r1,r2,ASR #7\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r1,r1,r1,LSL #2\n        ADDS     r0,r0,r1,LSL #4\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_leap(int year) {\n    if (year <= 0) return 0;\n    if (year % 4 != 0) return 0;\n    if (year % 100 == 0) {\n        if (year % 400 == 0) return 1;\n        return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreadConfig__FPcPA256_c PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r1\n        ADR      r1,|L1.112|\n        BL       fopen\n        MOVS     r6,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        MOV      r8,#0\n        B        |L1.60|\n|L1.40|\n        ADR      r1,|L1.116|\n        MOV      r0,r5\n        BL       strcspn\n        STRB     r8,[r5,r0]\n        ADD      r4,r4,#1\n|L1.60|\n        ADD      r0,r7,r4,LSL #8\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#0x100\n        BL       fgets\n        CMP      r0,#0\n        CMPNE    r4,#0x400\n        BLT      |L1.40|\n        MOV      r0,r6\n        BL       fclose\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.112|\n        DCB      \"r\\0\\0\\0\"\n|L1.116|\n        DCB      \"\\r\\n\\0\\0\"\n        ENDP\n\nwriteConfig__FPcPA256_ci PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        ADR      r1,|L1.212|\n        MOV      r6,r2\n        BL       fopen\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.192|\n|L1.164|\n        ADD      r2,r7,r4,LSL #8\n        ADR      r1,|L1.216|\n        MOV      r0,r5\n        BL       _fprintf\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.164|\n|L1.192|\n        MOV      r0,r5\n        BL       fclose\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.212|\n        DCB      \"w\\0\\0\\0\"\n|L1.216|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_LINE_LENGTH 256\n#define MAX_CONFIG_SIZE 1024\n\n\nint readConfig(char* filename, char config[][MAX_LINE_LENGTH]) {\n    FILE* file = fopen(filename, \"r\");\n    if (file == NULL) return 0;\n\n    int i = 0;\n    while (fgets(config[i], MAX_LINE_LENGTH, file) != NULL && i < MAX_CONFIG_SIZE) {\n        config[i][strcspn(config[i], \"\\r\\n\")] = 0;\n        i++;\n    }\n    fclose(file);\n    return i;\n}\n\n\nint writeConfig(char* filename, char config[][MAX_LINE_LENGTH], int count) {\n    FILE* file = fopen(filename, \"w\");\n    if (file == NULL) return 0;\n\n    for (int i = 0; i < count; i++) {\n        fprintf(file, \"%s\\n\", config[i]);\n    }\n    fclose(file);\n    return 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPiT1 PROC\n|L1.0|\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\npartition__FPiiT2 PROC\n        STMFD    sp!,{r4-r9,lr}\n        SUB      r9,r2,#1\n        CMP      r1,r9\n        LDR      r8,[r0,r2,LSL #2]\n        MOV      r7,r2\n        SUB      r6,r1,#1\n        MOV      r5,r0\n        MOV      r4,r1\n        BGT      |L1.96|\n|L1.56|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,r8\n        BGE      |L1.84|\n        ADD      r6,r6,#1\n        ADD      r0,r5,r6,LSL #2\n        ADD      r1,r5,r4,LSL #2\n        BL       swap__FPiT1\n|L1.84|\n        ADD      r4,r4,#1\n        CMP      r4,r9\n        BLE      |L1.56|\n|L1.96|\n        ADD      r0,r5,r6,LSL #2\n        ADD      r0,r0,#4\n        ADD      r1,r5,r7,LSL #2\n        BL       swap__FPiT1\n        ADD      r0,r6,#1\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n\nquickSort__FPiiT2 PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r0\n        MOV      r5,r2\n        MOV      r4,r1\n        CMP      r1,r2\n        LDMGEFD  sp!,{r4-r7,lr}\n        BXGE     lr\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       partition__FPiiT2\n        MOV      r7,r0\n        SUB      r2,r0,#1\n        MOV      r0,r6\n        MOV      r1,r4\n        BL       quickSort__FPiiT2\n        MOV      r2,r5\n        ADD      r1,r7,#1\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r7,lr}\n        B        quickSort__FPiiT2\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(int *a, int *b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\naddItem__FPCci PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r4,|L1.376|\n        MOV      r2,r0\n        LDR      r0,[r4,#0]  ; numItems\n        MOV      r6,r1\n        CMP      r0,#0x64\n        LDMGEFD  sp!,{r4-r6,lr}\n        BXGE     lr\n        RSB      r0,r0,r0,LSL #3\n        MOV      r1,r2\n        LDR      r5,|L1.380|\n        ADD      r0,r5,r0,LSL #3\n        BL       strcpy\n        LDR      r0,[r4,#0]  ; numItems\n        RSB      r1,r0,r0,LSL #3\n        ADD      r1,r5,r1,LSL #3\n        STR      r6,[r1,#0x34]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0]  ; numItems\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nremoveItem__FPCci PROC\n        STMFD    sp!,{r3-r9,lr}\n        LDR      r8,|L1.376|\n        MOV      r7,r0\n        LDR      r0,[r8,#0]  ; numItems\n        MOV      r6,r1\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r9,lr}\n        BXLE     lr\n        LDR      r9,|L1.380|\n|L1.124|\n        RSB      r0,r4,r4,LSL #3\n        ADD      r0,r9,r0,LSL #3\n        MOV      r5,r0\n        MOV      r1,r7\n        BL       strcmp\n        CMP      r0,#0\n        BNE      |L1.276|\n        LDR      r0,[r5,#0x34]\n        CMP      r0,r6\n        BLT      |L1.276|\n        RSB      r0,r4,r4,LSL #3\n        ADD      r0,r9,r0,LSL #3\n        LDR      r0,[r0,#0x34]\n        SUBS     r0,r0,r6\n        STR      r0,[r5,#0x34]\n        LDMNEFD  sp!,{r3-r9,lr}\n        BXNE     lr\n        LDR      r0,[r8,#0]  ; numItems\n        SUB      r0,r0,#1\n        CMP      r4,r0\n        BGE      |L1.256|\n|L1.208|\n        RSB      r0,r4,r4,LSL #3\n        ADD      r0,r9,r0,LSL #3\n        ADD      lr,r0,#0x38\n        LDMIA    lr!,{r1-r3,r5-r7,r12}\n        STMIA    r0!,{r1-r3,r5-r7,r12}\n        LDMIA    lr,{r1-r3,r5-r7,r12}\n        STMIA    r0,{r1-r3,r5-r7,r12}\n        LDR      r0,[r8,#0]  ; numItems\n        ADD      r4,r4,#1\n        SUB      r0,r0,#1\n        CMP      r4,r0\n        BLT      |L1.208|\n|L1.256|\n        LDR      r0,[r8,#0]  ; numItems\n        SUB      r0,r0,#1\n        STR      r0,[r8,#0]  ; numItems\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.276|\n        LDR      r0,[r8,#0]  ; numItems\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.124|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n\nlistItems__Fv PROC\n        STMFD    sp!,{r4-r6,lr}\n        LDR      r5,|L1.376|\n        LDR      r0,[r5,#0]  ; numItems\n        CMP      r0,#0\n        MOVNE    r4,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        LDR      r6,|L1.380|\n|L1.332|\n        RSB      r0,r4,r4,LSL #3\n        ADD      r1,r6,r0,LSL #3\n        LDR      r2,[r1,#0x34]\n        ADR      r0,|L1.384|\n        BL       _printf\n        LDR      r0,[r5,#0]  ; numItems\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.332|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.376|\n        DCD      ||.bss$2||\n|L1.380|\n        DCD      ||.bss$2|| + 4\n|L1.384|\n        DCB      \"%s: \"\n        DCB      \"%d\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_ITEMS 100\n#define MAX_ITEM_NAME 50\n\nstruct Item {\n    char name[MAX_ITEM_NAME];\n    int quantity;\n};\n\nItem inventory[MAX_ITEMS];\nint numItems = 0;\n\nvoid addItem(const char* name, int quantity) {\n    if (numItems >= MAX_ITEMS) return;\n    strcpy(inventory[numItems].name, name);\n    inventory[numItems].quantity = quantity;\n    numItems++;\n}\n\nvoid removeItem(const char* name, int quantity) {\n    for (int i = 0; i < numItems; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            if (inventory[i].quantity >= quantity) {\n                inventory[i].quantity -= quantity;\n                if (inventory[i].quantity == 0) {\n                    for (int j = i; j < numItems - 1; j++) {\n                        inventory[j] = inventory[j + 1];\n                    }\n                    numItems--;\n                }\n                return;\n            }\n            \n        }\n    }\n}\n\n\nvoid listItems() {\n    if (numItems == 0) return;\n    for (int i = 0; i < numItems; i++) {\n        printf(\"%s: %d\\n\", inventory[i].name, inventory[i].quantity);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreatePriorityQueue__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,#0x190\n        BL       malloc\n        MOV      r1,#0\n        STMIA    r4,{r0,r1}\n        MOV      r1,#0x64\n        STR      r1,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nheapifyUp__FP13PriorityQueuei PROC\n        CMP      r1,#0\n        BXLE     lr\n        B        |L1.76|\n|L1.64|\n        CMP      r1,#0\n        BXLE     lr\n        B        |L1.80|\n|L1.76|\n        STR      lr,[sp,#-4]!\n|L1.80|\n        SUB      r2,r1,#1\n        LDR      lr,[r0,#0]\n        ADD      r2,r2,r2,LSR #31\n        MOV      r2,r2,ASR #1\n        LDR      r3,[lr,r1,LSL #2]\n        LDR      r12,[lr,r2,LSL #2]\n        CMP      r3,r12\n        LDRLE    lr,[sp],#4\n        BXLE     lr\n        STR      r12,[lr,r1,LSL #2]\n        LDR      r1,[r0,#0]\n        STR      r3,[r1,r2,LSL #2]\n        MOV      r1,r2\n        B        |L1.64|\n        ENDP\n\ninsert__FP13PriorityQueuei PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP13PriorityQueuei\n        ENDP\n\nheapifyDown__FP13PriorityQueuei PROC\n        STMFD    sp!,{r4,r5,lr}\n        LDR      lr,[r0,#4]\n        MOV      r3,#1\n        ADD      r3,r3,r1,LSL #1\n        MOV      r12,#2\n        ADD      r12,r12,r1,LSL #1\n        CMP      lr,r3\n        MOV      r2,r1\n        BLE      |L1.232|\n        LDR      r4,[r0,#0]\n        LDR      r5,[r4,r3,LSL #2]\n        LDR      r4,[r4,r1,LSL #2]\n        CMP      r5,r4\n        MOVGT    r1,r3\n|L1.232|\n        CMP      lr,r12\n        BLE      |L1.260|\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r12,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        CMP      lr,r3\n        MOVGT    r1,r12\n|L1.260|\n        CMP      r1,r2\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r1,LSL #2]\n        LDR      r12,[r3,r2,LSL #2]\n        STR      lr,[r3,r2,LSL #2]\n        LDR      r2,[r0,#0]\n        STR      r12,[r2,r1,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP13PriorityQueuei\n        ENDP\n\nextractMax__FP13PriorityQueue PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        BL       heapifyDown__FP13PriorityQueuei\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define HEAP_SIZE 100\n\ntypedef struct {\n    int* arr;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nPriorityQueue* createPriorityQueue() {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    pq->arr = (int*)malloc(sizeof(int) * HEAP_SIZE);\n    pq->size = 0;\n    pq->capacity = HEAP_SIZE;\n    return pq;\n}\n\n\nvoid heapifyUp(PriorityQueue* pq, int index) {\n    if (index <= 0) return;\n    int parent = (index - 1) / 2;\n    if (pq->arr[index] > pq->arr[parent]) {\n        int temp = pq->arr[index];\n        pq->arr[index] = pq->arr[parent];\n        pq->arr[parent] = temp;\n        heapifyUp(pq, parent);\n    }\n}\n\nvoid insert(PriorityQueue* pq, int value) {\n    if (pq->size == pq->capacity) return; \n    pq->arr[pq->size] = value;\n    pq->size++;\n    heapifyUp(pq, pq->size - 1);\n}\n\n\nvoid heapifyDown(PriorityQueue* pq, int index) {\n    int largest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < pq->size && pq->arr[left] > pq->arr[largest]) {\n        largest = left;\n    }\n    if (right < pq->size && pq->arr[right] > pq->arr[largest]) {\n        largest = right;\n    }\n    if (largest != index) {\n        int temp = pq->arr[index];\n        pq->arr[index] = pq->arr[largest];\n        pq->arr[largest] = temp;\n        heapifyDown(pq, largest);\n    }\n}\n\nint extractMax(PriorityQueue* pq) {\n    if (pq->size == 0) return -1; //Error handling for empty queue.\n    int max = pq->arr[0];\n    pq->arr[0] = pq->arr[pq->size - 1];\n    pq->size--;\n    heapifyDown(pq, 0);\n    return max;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateIntSet__Fv PROC\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3,lr}\n        BXEQ     lr\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\naddToIntSet__FP6IntSeti PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOV      r0,#0\n        BXEQ     lr\n        LDR      r1,[r4,#4]\n        CMP      r1,#0\n        BLE      |L1.120|\n        LDR      r2,[r4,#0]\n|L1.88|\n        LDR      r3,[r2,r0,LSL #2]\n        CMP      r3,r5\n        LDMEQFD  sp!,{r4-r6,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r1,r0\n        BGT      |L1.88|\n|L1.120|\n        LDR      r0,[r4,#8]\n        CMP      r1,r0\n        BNE      |L1.176|\n        CMP      r0,#0\n        MOVNE    r6,r0,LSL #1\n        MOVEQ    r6,#1\n        MOV      r1,r6,LSL #2\n        LDR      r0,[r4,#0]\n        BL       realloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        STR      r0,[r4,#0]\n        STR      r6,[r4,#8]\n|L1.176|\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        STR      r1,[r4,#4]\n        LDR      r1,[r4,#0]\n        STR      r5,[r1,r0,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ncontainsIntSet__FP6IntSeti PROC\n        CMP      r0,#0\n        BXEQ     lr\n        LDR      r3,[r0,#4]\n        MOV      r2,#0\n        CMP      r3,#0\n        BLE      |L1.264|\n        LDR      r0,[r0,#0]\n|L1.236|\n        LDR      r12,[r0,r2,LSL #2]\n        CMP      r12,r1\n        MOVEQ    r0,#1\n        BXEQ     lr\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        BGT      |L1.236|\n|L1.264|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nfreeIntSet__FP6IntSet PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\nstruct IntSet {\n    int* data;\n    int size;\n    int capacity;\n};\n\nstruct IntSet* createIntSet() {\n    struct IntSet* set = (struct IntSet*)malloc(sizeof(struct IntSet));\n    if (set == NULL) return NULL;\n    set->data = NULL;\n    set->size = 0;\n    set->capacity = 0;\n    return set;\n}\n\nint addToIntSet(struct IntSet* set, int value) {\n    if (set == NULL) return 0;\n    int i;\n    for (i = 0; i < set->size; i++) {\n        if (set->data[i] == value) return 1;\n    }\n    if (set->size == set->capacity) {\n        int newCapacity = set->capacity == 0 ? 1 : set->capacity * 2;\n        int* newData = (int*)realloc(set->data, newCapacity * sizeof(int));\n        if (newData == NULL) return 0;\n        set->data = newData;\n        set->capacity = newCapacity;\n    }\n    set->data[set->size++] = value;\n    return 1;\n}\n\nint containsIntSet(struct IntSet* set, int value) {\n    if (set == NULL) return 0;\n    for (int i = 0; i < set->size; i++) {\n        if (set->data[i] == value) return 1;\n    }\n    return 0;\n}\n\n\nvoid freeIntSet(struct IntSet* set) {\n    if (set != NULL) {\n        free(set->data);\n        free(set);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nflatten__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        MOV      r1,r0\n        MOV      r3,#0\n|L1.16|\n        LDR      r0,[r1,#4]\n        CMP      r0,#0\n        BEQ      |L1.76|\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        BEQ      |L1.56|\n|L1.40|\n        LDR      r0,[r0,#8]\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        BNE      |L1.40|\n|L1.56|\n        LDR      r2,[r1,#8]\n        STR      r2,[r0,#8]\n        LDR      r0,[r1,#4]\n        STR      r0,[r1,#8]\n        STR      r3,[r1,#4]\n|L1.76|\n        LDR      r1,[r1,#8]\n        CMP      r1,#0\n        BNE      |L1.16|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node *next;\n\n    Node(int data) : data(data), left(NULL), right(NULL), next(NULL) {}\n};\n\n\nvoid flatten(Node *root) {\n    if (!root) return;\n\n    Node* curr = root;\n    Node* prev = NULL;\n\n    while (curr) {\n        if (curr->left) {\n            Node* rightmost = curr->left;\n            while (rightmost->right) rightmost = rightmost->right;\n            rightmost->right = curr->right;\n            curr->right = curr->left;\n            curr->left = NULL;\n        }\n        prev = curr;\n        curr = curr->right;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#0xc]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#4]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#8]\n        MOV      r1,#1\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#4]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#4]\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#4]\n        STR      r3,[r2,#4]\n        STR      r0,[r3,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#0xc]\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#4]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#4]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n|L1.404|\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#4]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#8]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#4]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nfindPathsWithSumUtil__FP4NodeiPiT2 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r2\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        ADD      r5,r3,#1\n        STR      r0,[r6,r3,LSL #2]\n        LDR      r0,[r4,#0]\n        SUBS     r7,r1,r0\n        LDREQ    r0,[r4,#4]\n        CMPEQ    r0,#0\n        LDREQ    r0,[r4,#8]\n        CMPEQ    r0,#0\n        BNE      |L1.716|\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.704|\n|L1.680|\n        LDR      r1,[r6,r4,LSL #2]\n        ADR      r0,|L1.764|\n        BL       _printf\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.680|\n|L1.704|\n        ADR      r0,|L1.768|\n        LDMFD    sp!,{r3-r7,lr}\n        B        _printf\n|L1.716|\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r7\n        LDR      r0,[r4,#4]\n        BL       findPathsWithSumUtil__FP4NodeiPiT2\n        LDR      r0,[r4,#8]\n        ADD      sp,sp,#4\n        MOV      r3,r5\n        MOV      r2,r6\n        MOV      r1,r7\n        LDMFD    sp!,{r4-r7,lr}\n        B        findPathsWithSumUtil__FP4NodeiPiT2\n|L1.764|\n        DCB      \"%d \\0\"\n|L1.768|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n\nfindPathsWithSum__FP4Nodei PROC\n        STR      lr,[sp,#-4]!\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        ADD      r2,sp,#4\n        MOV      r3,#0\n        BL       findPathsWithSumUtil__FP4NodeiPiT2\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    int height;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int data) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return(node);\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int data) {\n    if (node == NULL)\n        return(newNode(data));\n    if (data < node->data)\n        node->left  = insert(node->left, data);\n    else if (data > node->data)\n        node->right = insert(node->right, data);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && data < node->left->data)\n        return rightRotate(node);\n    if (balance < -1 && data > node->right->data)\n        return leftRotate(node);\n    if (balance > 1 && data > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && data < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nvoid findPathsWithSumUtil(Node* root, int sum, int* path, int pathLen) {\n    if (!root) return;\n\n    path[pathLen] = root->data;\n    pathLen++;\n    sum -= root->data;\n\n    if(sum == 0 && !root->left && !root->right) {\n        for(int i = 0; i < pathLen; ++i) {\n            printf(\"%d \", path[i]);\n        }\n        printf(\"\\n\");\n    }\n    else{\n        findPathsWithSumUtil(root->left, sum, path, pathLen);\n        findPathsWithSumUtil(root->right, sum, path, pathLen);\n    }\n}\n\nvoid findPathsWithSum(Node* root, int sum) {\n    int path[1000];\n    findPathsWithSumUtil(root, sum, path, 0);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateStack__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        MVN      r1,#0\n        STMIA    r4,{r0,r1,r5}\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Stack PROC\n        LDR      r0,[r0,#4]\n        CMN      r0,#1\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisFull__FP5Stack PROC\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#4]\n        SUB      r1,r1,#1\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        MOV      r3,r1\n        BL       isFull__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        BXNE     lr\n        LDR      r0,[r2,#4]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      r1,[r2,#0]\n        STR      r3,[r1,r0,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\npop__FP5Stack PROC\n        STR      lr,[sp,#-4]!\n        MOV      r1,r0\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r1,#4]\n        SUB      r2,r0,#1\n        STR      r2,[r1,#4]\n        LDR      r1,[r1,#0]\n        LDR      r0,[r1,r0,LSL #2]\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ncreateQueue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        MOV      r0,r5\n        BL       createStack__Fi\n        STR      r0,[r4,#0]\n        MOV      r0,r5\n        BL       createStack__Fi\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        LDR      r0,[r0,#0]\n        B        push__FP5Stacki\n        ENDP\n\ndequeue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#4]\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.372|\n        LDR      r0,[r4,#0]\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r4,#0]\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        BNE      |L1.372|\n|L1.336|\n        LDR      r0,[r4,#0]\n        BL       pop__FP5Stack\n        MOV      r1,r0\n        LDR      r0,[r4,#4]\n        BL       push__FP5Stacki\n        LDR      r0,[r4,#0]\n        BL       isEmpty__FP5Stack\n        CMP      r0,#0\n        BEQ      |L1.336|\n|L1.372|\n        LDR      r0,[r4,#4]\n        LDMFD    sp!,{r4,lr}\n        B        pop__FP5Stack\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int *data;\n    int top;\n    int capacity;\n} Stack;\n\nStack* createStack(int capacity) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->data = (int*)malloc(capacity * sizeof(int));\n    stack->top = -1;\n    stack->capacity = capacity;\n    return stack;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == -1;\n}\n\nint isFull(Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nvoid push(Stack* stack, int item) {\n    if (isFull(stack)) return;\n    stack->data[++stack->top] = item;\n}\n\nint pop(Stack* stack) {\n    if (isEmpty(stack)) return 0; \n    return stack->data[stack->top--];\n}\n\n\ntypedef struct {\n    Stack* stack1;\n    Stack* stack2;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->stack1 = createStack(capacity);\n    queue->stack2 = createStack(capacity);\n    return queue;\n}\n\nvoid enqueue(Queue* queue, int item) {\n    push(queue->stack1, item);\n}\n\nint dequeue(Queue* queue) {\n    if (isEmpty(queue->stack2)) {\n        if (isEmpty(queue->stack1)) return 0;\n        while (!isEmpty(queue->stack1)) {\n            push(queue->stack2, pop(queue->stack1));\n        }\n    }\n    return pop(queue->stack2);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x410\n        BL       malloc\n        MOV      r1,#0\n        MOV      r2,#0\n        STR      r4,[r0,#0]\n|L1.28|\n        ADD      r3,r0,r1,LSL #2\n        ADD      r1,r1,#1\n        CMP      r1,#0x100\n        STR      r2,[r3,#4]\n        BLT      |L1.28|\n        MVN      r1,#0\n        STR      r1,[r0,#0x408]\n        STR      r2,[r0,#0x404]\n        STR      r1,[r0,#0x40c]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsert__FP4NodePciT3 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        MOV      r0,r1\n        MOV      r7,r3\n        MOV      r6,r1\n        MOV      r5,r2\n        BL       strlen\n        CMP      r0,r5\n        MOVEQ    r0,#1\n        STREQ    r0,[r4,#0x404]!\n        STREQ    r7,[r4,#8]\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        LDRB     r0,[r6,r5]\n        SUB      r0,r0,#0x41\n        ADD      r4,r4,r0,LSL #2\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        BNE      |L1.160|\n        MOV      r0,r7\n        BL       newNode__Fi\n        STR      r0,[r4,#4]\n|L1.160|\n        LDR      r0,[r4,#4]\n        ADD      sp,sp,#4\n        MOV      r3,r7\n        ADD      r2,r5,#1\n        MOV      r1,r6\n        LDMFD    sp!,{r4-r7,lr}\n        B        insert__FP4NodePciT3\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_CHAR 256\n\ntypedef struct Node {\n    int id;\n    struct Node* children[MAX_CHAR];\n    int leaf;\n    int start;\n    int end;\n} Node;\n\nNode* newNode(int id) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->id = id;\n    for (int i = 0; i < MAX_CHAR; i++)\n        node->children[i] = NULL;\n    node->leaf = 0;\n    node->start = -1;\n    node->end = -1;\n    return node;\n}\n\nvoid insert(Node* root, char* str, int index, int id) {\n    if (index == strlen(str)) {\n        root->leaf = 1;\n        root->end = id;\n        return;\n    }\n    int c = str[index] - 'A';\n    if (root->children[c] == NULL)\n        root->children[c] = newNode(id);\n    insert(root->children[c], str, index + 1, id);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsearch_data__FP4DataiT2 PROC\n|L1.0|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.48|\n|L1.12|\n        RSB      r12,r3,r3,LSL #3\n        LDR      r12,[r0,r12,LSL #3]\n        CMP      r12,r2\n        RSBEQ    r1,r3,r3,LSL #3\n        ADDEQ    r0,r0,r1,LSL #3\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.12|\n|L1.48|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Data {\n    int id;\n    char name[50];\n};\n\nData* search_data(Data* arr, int size, int id_to_find) {\n    for (int i = 0; i < size; ++i) {\n        if (arr[i].id == id_to_find) {\n            return &arr[i];\n        }\n    }\n    return NULL;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nmy_strcat__FPcPCc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r0,r5\n        BL       strlen\n        MOV      r1,#0\n|L1.32|\n        LDRB     r2,[r5,r1]\n        ADD      r3,r6,r1\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        STRB     r2,[r4,r3]\n        BLS      |L1.32|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* my_strcat(char* dest, const char* src) {\n    size_t dest_len = strlen(dest);\n    size_t src_len = strlen(src);\n    size_t i;\n    for (i = 0; i <= src_len; ++i) {\n        dest[dest_len + i] = src[i];\n    }\n\n    return dest;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreplaceChar__FPccT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r0,r4\n        BL       strlen\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.48|\n        LDRB     r2,[r4,r1]\n        CMP      r2,r5\n        STREQB   r6,[r4,r1]\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.48|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid replaceChar(char* str, char oldChar, char newChar) {\n    if (str == NULL) return;\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (str[i] == oldChar) {\n            str[i] = newChar;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhexToDecimal__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r0\n        MOV      r5,#1\n        MOV      r4,#0\n        BL       strlen\n        SUBS     r6,r0,#1\n        BMI      |L1.108|\n        BL       __rt_ctype_table\n        LDR      r3,[r0,#0]\n|L1.36|\n        LDRB     r0,[r7,r6]\n        LDRB     r1,[r3,r0]\n        TST      r1,#0x20\n        SUBNE    r0,r0,#0x30\n        MLANE    r4,r5,r0,r4\n        BNE      |L1.96|\n        TST      r1,#0xa0\n        LDMEQFD  sp!,{r3-r7,lr}\n        MVNEQ    r0,#0\n        BXEQ     lr\n        SUB      r1,r0,#0x41\n        CMP      r1,#5\n        SUBHI    r0,r0,#0x57\n        SUBLS    r0,r0,#0x37\n        MLA      r4,r5,r0,r4\n|L1.96|\n        MOV      r5,r5,LSL #4\n        SUBS     r6,r6,#1\n        BPL      |L1.36|\n|L1.108|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nlong hexToDecimal(const char* hex) {\n    long decimal = 0;\n    long power = 1;\n    int len = strlen(hex);\n\n    for (int i = len - 1; i >= 0; i--) {\n        if (isdigit(hex[i])) {\n            decimal += (hex[i] - '0') * power;\n        } else if (isxdigit(hex[i])) {\n            if (hex[i] >= 'A' && hex[i] <= 'F') {\n                decimal += (hex[i] - 'A' + 10) * power;\n            } else {\n                decimal += (hex[i] - 'a' + 10) * power;\n            }\n        } else {\n            return -1; //Error handling for invalid hex characters.\n        }\n        power *= 16;\n    }\n    return decimal;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_prime__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        CMP      r0,#1\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#0\n        BXLE     lr\n        CMP      r4,#3\n        LDMLEFD  sp!,{r3-r5,lr}\n        MOVLE    r0,#1\n        BXLE     lr\n        TST      r4,#1\n        BEQ      |L1.72|\n        LDR      r1,|L1.224|\n        SMULL    r2,r0,r1,r4\n        SUB      r0,r0,r0,ASR #31\n        SUB      r0,r0,r0,LSL #2\n        ADDS     r0,r0,r4\n        BNE      |L1.84|\n|L1.72|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.84|\n        MOV      r5,#5\n        CMP      r4,#0x19\n        BLT      |L1.164|\n|L1.96|\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BEQ      |L1.136|\n        MOV      r1,r4\n        ADD      r0,r5,#2\n        BL       __rt_sdiv\n        CMP      r1,#0\n        BNE      |L1.148|\n|L1.136|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.148|\n        ADD      r5,r5,#6\n        MUL      r0,r5,r5\n        CMP      r0,r4\n        BLE      |L1.96|\n|L1.164|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncrc32__FPUcUi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MVN      r2,#0\n        MOV      r12,#0\n        CMP      r1,#0\n        BLS      |L1.72|\n        LDR      r4,|L1.160|\n|L1.24|\n        LDRB     r3,[r0,r12]\n        EOR      r2,r3,r2\n        MOV      r3,#0\n|L1.36|\n        TST      r2,#1\n        MOVEQ    r2,r2,LSR #1\n        EORNE    r2,r4,r2,LSR #1\n        ADD      r3,r3,#1\n        CMP      r3,#8\n        BCC      |L1.36|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        BCC      |L1.24|\n|L1.72|\n        LDMFD    sp!,{r4,lr}\n        MVN      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int crc32(unsigned char *message, unsigned int nBytes) {\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i, j;\n    for (i = 0; i < nBytes; i++) {\n        crc ^= message[i];\n        for (j = 0; j < 8; j++) {\n            if (crc & 0x00000001)\n                crc = (crc >> 1) ^ 0xEDB88320;\n            else\n                crc >>= 1;\n        }\n    }\n    return ~crc;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nsearch__FPiiN22 PROC\n        CMP      r1,r2\n        BGT      |L1.76|\n|L1.48|\n        LDR      r12,[r0,r1,LSL #2]\n        CMP      r12,r3\n        MOVEQ    r0,r1\n        BXEQ     lr\n        ADD      r1,r1,#1\n        CMP      r1,r2\n        BLE      |L1.48|\n|L1.76|\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\nbuildTree__FPiT1iT3 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r8,r0\n        MOV      r7,r1\n        MOV      r6,r3\n        MOV      r5,r2\n        CMP      r2,r3\n        LDMGTFD  sp!,{r3-r9,lr}\n        MOVGT    r0,#0\n        BXGT     lr\n        LDR      r1,|L1.348|\n        LDR      r0,[r1,#0]  ; pIndex@buildTree__FPiT1iT3_0\n        ADD      r2,r0,#1\n        STR      r2,[r1,#0]  ; pIndex@buildTree__FPiT1iT3_0\n        LDR      r0,[r7,r0,LSL #2]\n        BL       newNode__Fi\n        MOV      r4,r0\n        CMP      r5,r6\n        MOVEQ    r0,r4\n        LDMEQFD  sp!,{r3-r9,lr}\n        BXEQ     lr\n        MOV      r2,r6\n        MOV      r1,r5\n        MOV      r0,r8\n        LDR      r3,[r4,#0]\n        BL       search__FPiiN22\n        MOV      r9,r0\n        SUB      r3,r0,#1\n        MOV      r0,r8\n        MOV      r2,r5\n        MOV      r1,r7\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#4]\n        MOV      r0,r8\n        MOV      r3,r6\n        ADD      r2,r9,#1\n        MOV      r1,r7\n        BL       buildTree__FPiT1iT3\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint search(int arr[], int strt, int end, int value) {\n    for (int i = strt; i <= end; i++)\n        if (arr[i] == value) return i;\n    return -1;\n}\n\nstruct Node* buildTree(int inorder[], int postorder[], int inStrt, int inEnd) {\n    static int pIndex = 0;\n\n    if (inStrt > inEnd) return NULL;\n\n    struct Node* node = newNode(postorder[pIndex++]);\n\n    if (inStrt == inEnd) return node;\n\n    int inIndex = search(inorder, inStrt, inEnd, node->data);\n\n    node->left = buildTree(inorder, postorder, inStrt, inIndex - 1);\n    node->right = buildTree(inorder, postorder, inIndex + 1, inEnd);\n\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nwriteData__FPCcRC4Data PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        ADR      r1,|L1.60|\n        BL       fopen\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r3,r4\n        MOV      r2,#1\n        MOV      r1,#0x18\n        MOV      r0,r5\n        BL       fwrite\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        fclose\n|L1.60|\n        DCB      \"wb\\0\\0\"\n        ENDP\n\nreadData__FPCc PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,r1\n        SUB      sp,sp,#0x18\n        MOV      r6,sp\n        MOV      r1,#0\n        MOV      lr,#0\n        MOV      r4,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        MOV      r12,#0\n        STMIA    r6,{r1-r4,r12,lr}\n        ADR      r1,|L1.192|\n        BL       fopen\n        MOVS     r4,r0\n        LDMEQIA  r6,{r1-r3,r6,r12,lr}\n        STMEQIA  r5,{r1-r3,r6,r12,lr}\n        ADDEQ    sp,sp,#0x18\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r3,r4\n        MOV      r2,#1\n        MOV      r1,#0x18\n        MOV      r0,r6\n        BL       fread\n        MOV      r0,r4\n        BL       fclose\n        LDMIA    r6,{r1-r4,r12,lr}\n        STMIA    r5,{r1-r4,r12,lr}\n        ADD      sp,sp,#0x18\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.192|\n        DCB      \"rb\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Data {\n    int num;\n    char str[20];\n};\n\nvoid writeData(const char* filename, const Data& data) {\n    FILE* fp = fopen(filename, \"wb\");\n    if (fp == 0) return;\n    fwrite(&data, sizeof(Data), 1, fp);\n    fclose(fp);\n}\n\nData readData(const char* filename) {\n    Data data = {0};\n    FILE* fp = fopen(filename, \"rb\");\n    if (fp == 0) return data;\n    fread(&data, sizeof(Data), 1, fp);\n    fclose(fp);\n    return data;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nvector_magnitude__FdN21 PROC\n        STMFD    sp!,{r3-r9,lr}\n        ADD      r5,sp,#0x20\n        MOV      r7,r3\n        MOV      r6,r2\n        MOV      r2,r0\n        MOV      r3,r1\n        LDMIA    r5,{r4,r5}\n        BL       _dmul\n        MOV      r8,r0\n        MOV      r9,r1\n        MOV      r1,r7\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dmul\n        MOV      r3,r9\n        MOV      r2,r8\n        BL       _dadd\n        MOV      r6,r0\n        MOV      r7,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        MOV      r3,r5\n        MOV      r2,r4\n        BL       _dmul\n        MOV      r3,r7\n        MOV      r2,r6\n        BL       _dadd\n        LDMFD    sp!,{r3-r9,lr}\n        B        __softfp_sqrt\n        ENDP\n```",
        "output": "```cpp\n\ndouble vector_magnitude(double x, double y, double z) {\n    return sqrt(x * x + y * y + z * z);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_array__FPii PROC\n|L1.0|\n        MOV      r3,#0\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.36|\n|L1.16|\n        LDR      r12,[r0,r2,LSL #2]\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        ADD      r3,r12,r3\n        BLT      |L1.16|\n|L1.36|\n        MOV      r0,r3\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_array(int arr[], int len) {\n    int sum = 0;\n    for (int i = 0; i < len; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fv PROC\n|L1.0|\n        STMFD    sp!,{r3,lr}\n        MOV      r0,#0x14\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#0]\n        STR      r1,[r0,#4]\n        STR      r1,[r0,#8]\n        STR      r1,[r0,#0xc]\n        STR      r1,[r0,#0x10]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n\nclassify__FP4NodePf PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        MOV      r5,r1\n        CMP      r0,#0\n        LDREQ    r0,[r4,#0x10]\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDMIA    r4,{r0,r1}\n        LDR      r0,[r5,r0,LSL #2]\n        BL       _fcmple\n        MOVCC    r1,r5\n        LDRCC    r0,[r4,#8]\n        LDMCCFD  sp!,{r3-r5,lr}\n        BCC      classify__FP4NodePf\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        B        classify__FP4NodePf\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int feature;\n    float threshold;\n    Node *left;\n    Node *right;\n    int prediction;\n};\n\n\nNode* createNode() {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->feature = 0;\n    node->threshold = 0.0;\n    node->left = 0;\n    node->right = 0;\n    node->prediction = 0;\n    return node;\n}\n\nint classify(Node* node, float* sample) {\n    if (node->left == 0) return node->prediction;\n    if (sample[node->feature] < node->threshold)\n        return classify(node->left, sample);\n    else\n        return classify(node->right, sample);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncelsiusToFahrenheit__Ff PROC\n        STMFD    sp!,{r3,lr}\n        BL       _f2d\n        ADR      r2,|L1.52|\n        LDMIA    r2,{r2,r3}\n        BL       _dmul\n        ADR      r2,|L1.60|\n        LDMIA    r2,{r2,r3}\n        BL       _ddiv\n        ADR      r2,|L1.68|\n        LDMIA    r2,{r2,r3}\n        BL       _dadd\n        LDMFD    sp!,{r3,lr}\n        B        _d2f\n|L1.52|\n        DCFD     0x4022000000000000\n|L1.60|\n        DCFD     0x4014000000000000\n|L1.68|\n        DCFD     0x4040000000000000\n        ENDP\n```",
        "output": "```cpp\n\nfloat celsiusToFahrenheit(float celsius) {\n    return (celsius * 9.0 / 5.0) + 32.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nshellSort__FPii PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        ADD      r2,r1,r1,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n|L1.24|\n        MOV      r12,r3\n        CMP      r3,r1\n        BGE      |L1.92|\n|L1.36|\n        LDR      lr,[r0,r12,LSL #2]\n        MOV      r2,r12\n        B        |L1.56|\n|L1.48|\n        STR      r5,[r0,r2,LSL #2]\n        MOV      r2,r4\n|L1.56|\n        CMP      r2,r3\n        SUBGE    r4,r2,r3\n        LDRGE    r5,[r0,r4,LSL #2]\n        CMPGE    r5,lr\n        BGT      |L1.48|\n        ADD      r12,r12,#1\n        CMP      r12,r1\n        STR      lr,[r0,r2,LSL #2]\n        BLT      |L1.36|\n|L1.92|\n        ADD      r2,r3,r3,LSR #31\n        MOV      r3,r2,ASR #1\n        CMP      r3,#0\n        BGT      |L1.24|\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid shellSort(int arr[], int n) {\n    int gap, i, j, temp;\n    for (gap = n / 2; gap > 0; gap /= 2) {\n        for (i = gap; i < n; i++) {\n            temp = arr[i];\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n            arr[j] = temp;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringToUpper__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDRNEB   r0,[r5,#0]\n        MOVNE    r4,#0\n        CMPNE    r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n|L1.28|\n        LDRB     r0,[r5,r4]\n        BL       toupper\n        STRB     r0,[r5,r4]\n        ADD      r4,r4,#1\n        LDRB     r0,[r5,r4]\n        CMP      r0,#0\n        BNE      |L1.28|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid stringToUpper(char* str) {\n    if (str == 0) return;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        str[i] = toupper(str[i]);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n        MOV      r2,r0\n        MOVS     r0,r1\n        STMFD    sp!,{r4,lr}\n        BEQ      |L1.40|\n|L1.16|\n        MOV      r4,r0\n        MOV      r1,r2\n        BL       __rt_sdiv\n        MOVS     r0,r1\n        MOV      r2,r4\n        BNE      |L1.16|\n|L1.40|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r2\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateMatrix__FiT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x13800\n        SUB      sp,sp,#0x8c\n        ADD      r4,sp,#4\n        MOV      r5,r0\n        ADD      r0,r4,#0x13000\n        ADD      r3,r0,#0x880\n        STMIA    r3,{r1,r2}\n        MOV      r1,#0x3880\n        ADD      r1,r1,#0x10000\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r2,#0x88\n        ADD      r2,r2,#0x13800\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       __rt_memcpy_w\n        ADD      sp,sp,#0x13800\n        ADD      sp,sp,#0x8c\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n\nsetMatrixValue__FP6MatrixiT2d PROC\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        ADD      r0,r0,r1,LSL #5\n        STR      lr,[sp,#-4]!\n        LDR      lr,[sp,#4]\n        ADD      r0,r0,r2,LSL #3\n        STMIA    r0,{r3,lr}\n        LDR      lr,[sp],#4\n        BX       lr\n        ENDP\n\ngetMatrixValue__F6MatrixiT2 PROC\n        STMFD    sp!,{r0-r3}\n        ADD      r12,sp,#0x13000\n        ADD      r1,r12,#0x890\n        LDMDB    r1,{r0,r1}\n        ADD      r12,r0,r0,LSL #3\n        ADD      r0,r12,r0,LSL #4\n        ADD      r0,sp,r0,LSL #5\n        ADD      r1,r0,r1,LSL #3\n        LDMIA    r1,{r0,r1}\n        ADD      sp,sp,#0x10\n        BX       lr\n        ENDP\n\nsvd__F6MatrixP6MatrixN22 PROC\n        STMFD    sp!,{r0-r3}\n        STMFD    sp!,{r4-r11,lr}\n        SUB      sp,sp,#0x13800\n        SUB      sp,sp,#0x84\n        ADD      r12,sp,#0x27000\n        ADD      r10,r12,#0x130\n        ADD      r4,sp,#0x13800\n        ADD      r4,r4,#0xa8\n        ADD      r6,r4,#0x13000\n        LDMIA    r10,{r8-r10}\n        LDR      r1,[r12,#0x128]\n        LDR      r2,[r6,#0x884]\n        CMP      r1,r2\n        BNE      |L1.520|\n        CMP      r1,#0x64\n        BGT      |L1.520|\n        MOV      r0,r8\n        BL       createMatrix__FiT1\n        ADD      r2,r6,#0x880\n        LDMIA    r2,{r1,r2}\n        MOV      r0,r9\n        BL       createMatrix__FiT1\n        ADD      r2,r6,#0x880\n        LDMIA    r2,{r1,r2}\n        MOV      r0,r10\n        BL       createMatrix__FiT1\n        LDR      r0,[r6,#0x880]\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.520|\n        ADD      r11,r4,#0x10\n        ADR      r7,|L1.540|\n|L1.292|\n        LDR      r0,[r6,#0x884]\n        MOV      r4,#0\n        CMP      r0,#0\n        BLE      |L1.504|\n|L1.308|\n        CMP      r5,r4\n        ADREQ    r0,|L1.548|\n        LDREQ    r3,[r0,#0]\n        LDREQ    r0,[r0,#4]\n        MOV      r2,r4\n        LDRNE    r0,[r7,#4]\n        LDRNE    r3,[r7,#0]\n        STR      r0,[sp,#0]\n        MOV      r0,r8\n        MOV      r1,r5\n        BL       setMatrixValue__FP6MatrixiT2d\n        CMP      r5,r4\n        LDMNEIA  r7,{r0,r1}\n        BNE      |L1.420|\n        ADD      r12,sp,#0x13000\n        STR      r4,[r12,#0x87c]\n        MOV      r2,#0x78\n        ADD      r2,r2,#0x13800\n        STR      r5,[r12,#0x878]\n        MOV      r1,r11\n        MOV      r0,sp\n        BL       __rt_memcpy_w\n        ADD      r12,sp,#0x13000\n        ADD      r3,r12,#0x800\n        ADD      r3,r3,#0xa8\n        LDMIA    r3,{r0-r3}\n        BL       getMatrixValue__F6MatrixiT2\n        BIC      r1,r1,#0x80000000\n|L1.420|\n        MOV      r3,r0\n        STR      r1,[sp,#0]\n        MOV      r1,r5\n        MOV      r0,r9\n        MOV      r2,r4\n        BL       setMatrixValue__FP6MatrixiT2d\n        CMP      r5,r4\n        ADREQ    r0,|L1.548|\n        LDREQ    r3,[r0,#0]\n        LDREQ    r0,[r0,#4]\n        MOV      r2,r4\n        LDRNE    r0,[r7,#4]\n        LDRNE    r3,[r7,#0]\n        STR      r0,[sp,#0]\n        MOV      r0,r10\n        MOV      r1,r5\n        BL       setMatrixValue__FP6MatrixiT2d\n        LDR      r0,[r6,#0x884]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.308|\n|L1.504|\n        LDR      r0,[r6,#0x880]\n        ADD      r5,r5,#1\n        CMP      r0,r5\n        BGT      |L1.292|\n|L1.520|\n        ADD      sp,sp,#0x13800\n        ADD      sp,sp,#0x84\n        LDMFD    sp!,{r4-r11}\n        LDR      lr,[sp],#0x14\n        BX       lr\n|L1.540|\n        DCFD     0x0000000000000000\n|L1.548|\n        DCFD     0x3ff0000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    double data[MAX_SIZE][MAX_SIZE];\n    int rows;\n    int cols;\n} Matrix;\n\nMatrix createMatrix(int rows, int cols) {\n    Matrix m;\n    m.rows = rows;\n    m.cols = cols;\n    memset(m.data, 0, sizeof(m.data));\n    return m;\n}\n\nvoid setMatrixValue(Matrix* m, int row, int col, double value) {\n    m->data[row][col] = value;\n}\n\ndouble getMatrixValue(Matrix m, int row, int col) {\n    return m.data[row][col];\n}\n\n\n// This is a simplified SVD implementation.  A robust implementation would require significantly more code and error handling.\n\nvoid svd(Matrix A, Matrix* U, Matrix* S, Matrix* VT) {\n    // This is a placeholder.  A real SVD implementation would be extensive.\n    // Replace with a proper SVD algorithm (e.g., using LAPACK or a similar library).\n    if (A.rows != A.cols || A.rows > MAX_SIZE) return;\n\n    *U = createMatrix(A.rows, A.cols);\n    *S = createMatrix(A.rows, A.cols);\n    *VT = createMatrix(A.rows, A.cols);\n\n    for (int i = 0; i < A.rows; i++){\n        for (int j = 0; j < A.cols; j++){\n            setMatrixValue(U, i, j, (i == j) ? 1.0 : 0.0);\n            setMatrixValue(S, i, j, (i == j) ? fabs(getMatrixValue(A, i, j)) : 0.0);\n            setMatrixValue(VT, i, j, (i == j) ? 1.0 : 0.0);\n\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\npredecessor__FP4Nodei PROC\n        MOVS     r2,r0\n        MOV      r0,#0\n        BXEQ     lr\n|L1.616|\n        LDR      r3,[r2,#0]\n        CMP      r3,r1\n        BNE      |L1.672|\n        LDR      r1,[r2,#8]\n        CMP      r1,#0\n        MOVNE    r0,r1\n        LDRNE    r1,[r1,#0xc]\n        CMPNE    r1,#0\n        BXEQ     lr\n|L1.652|\n        LDR      r0,[r0,#0xc]\n        LDR      r1,[r0,#0xc]\n        CMP      r1,#0\n        BNE      |L1.652|\n        BX       lr\n|L1.672|\n        LDRLE    r2,[r2,#0xc]\n        MOVGT    r0,r2\n        LDRGT    r2,[r2,#8]\n        CMP      r2,#0\n        BNE      |L1.616|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n\nNode* predecessor(Node* root, int key){\n    Node* current = root;\n    Node* predecessor = NULL;\n    while(current != NULL){\n        if(current->key == key){\n            if(current->left != NULL){\n                current = current->left;\n                while(current->right != NULL) current = current->right;\n                predecessor = current;\n            }\n            break;\n        } else if(key < current->key){\n            predecessor = current;\n            current = current->left;\n        } else {\n            current = current->right;\n        }\n    }\n    return predecessor;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncube_volume__Fd PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        MOV      r3,r1\n        MOV      r2,r0\n        BL       _dmul\n        MOV      r3,r5\n        MOV      r2,r4\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dmul\n        ENDP\n```",
        "output": "```cpp\n\ndouble cube_volume(double side) {\n    return side * side * side;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountingSort__FPPci PROC\n|L1.0|\n        STMFD    sp!,{r3-r11,lr}\n        MOV      r10,r1\n        CMP      r0,#0\n        CMPNE    r10,#0\n        MOV      r5,r0\n        LDMLEFD  sp!,{r3-r11,lr}\n        BXLE     lr\n        MOV      r7,#0\n        MOV      r4,#0\n|L1.36|\n        LDR      r0,[r5,r4,LSL #2]\n        BL       strlen\n        CMP      r0,r7\n        BLS      |L1.64|\n        LDR      r0,[r5,r4,LSL #2]\n        BL       strlen\n        MOV      r7,r0\n|L1.64|\n        ADD      r4,r4,#1\n        CMP      r4,r10\n        BLT      |L1.36|\n        MOV      r0,#4\n        ADD      r0,r0,r7,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        MOV      r1,#0\n        CMP      r7,#0\n        BLT      |L1.124|\n|L1.108|\n        STR      r0,[r6,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,r7\n        BLE      |L1.108|\n|L1.124|\n        MOV      r8,#0\n        CMP      r10,#0\n        BLE      |L1.264|\n|L1.136|\n        LDR      r0,[r5,r8,LSL #2]\n        BL       strlen\n        MOV      r9,r0\n        LDR      r0,[r6,r0,LSL #2]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDRNE    r1,[r0,#0]\n        CMPNE    r1,#0\n        BEQ      |L1.188|\n|L1.172|\n        ADD      r4,r4,#1\n        LDR      r1,[r0,r4,LSL #2]\n        CMP      r1,#0\n        BNE      |L1.172|\n|L1.188|\n        MOV      r1,#8\n        ADD      r1,r1,r4,LSL #2\n        BL       realloc\n        MOVS     r11,r0\n        BNE      |L1.224|\n        ADR      r0,|L1.364|\n        BL       _printf\n        MOV      r0,#1\n        BL       exit\n|L1.224|\n        STR      r11,[r6,r9,LSL #2]\n        LDR      r0,[r5,r8,LSL #2]\n        ADD      r8,r8,#1\n        STR      r0,[r11,r4,LSL #2]\n        LDR      r1,[r6,r9,LSL #2]\n        MOV      r0,#0\n        ADD      r1,r1,r4,LSL #2\n        STR      r0,[r1,#4]\n        CMP      r8,r10\n        BLT      |L1.136|\n|L1.264|\n        MOV      r8,#0\n        MOV      r4,#0\n        CMP      r7,#0\n        BLT      |L1.352|\n|L1.280|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0]\n        MOVNE    r1,#0\n        CMPNE    r2,#0\n        BEQ      |L1.336|\n|L1.304|\n        LDR      r3,[r0,r1,LSL #2]\n        MOV      r2,r8\n        STR      r3,[r5,r2,LSL #2]\n        ADD      r1,r1,#1\n        LDR      r2,[r0,r1,LSL #2]\n        ADD      r8,r8,#1\n        CMP      r2,#0\n        BNE      |L1.304|\n|L1.336|\n        BL       free\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.280|\n|L1.352|\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r11,lr}\n        B        free\n|L1.364|\n        DCB      \"Memo\"\n        DCB      \"ry a\"\n        DCB      \"lloc\"\n        DCB      \"atio\"\n        DCB      \"n fa\"\n        DCB      \"iled\"\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid countingSort(char **arr, int n) {\n    if (arr == NULL || n <= 0) return;\n\n    int maxLen = 0;\n    for (int i = 0; i < n; i++) {\n        if (strlen(arr[i]) > maxLen) maxLen = strlen(arr[i]);\n    }\n\n    char ***buckets = (char ***)malloc((maxLen + 1) * sizeof(char **));\n    for (int i = 0; i <= maxLen; i++) buckets[i] = NULL;\n\n    for (int i = 0; i < n; i++) {\n        int len = strlen(arr[i]);\n        char **bucket = buckets[len];\n        int count = 0;\n        if(bucket != NULL){\n            while(bucket[count] != NULL) count++;\n        }\n        \n        int newSize = (count + 2) * sizeof(char *);\n        char **newBucket = (char **)realloc(bucket,newSize);\n        if(newBucket == NULL){\n            printf(\"Memory allocation failed\\n\");\n            exit(1);\n        }\n        buckets[len] = newBucket;\n\n        buckets[len][count] = arr[i];\n        buckets[len][count + 1] = NULL;\n\n    }\n\n    int index = 0;\n    for (int i = 0; i <= maxLen; i++) {\n        char **bucket = buckets[i];\n        if (bucket != NULL){\n            for (int j = 0; bucket[j] != NULL; j++) {\n                arr[index++] = bucket[j];\n            }\n        }\n        free(bucket);\n    }\n    free(buckets);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nreverse_string__FPc PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        BL       strlen\n        SUB      r0,r0,#1\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4,lr}\n        MOV      r1,#0\n        BXLE     lr\n|L1.32|\n        LDRB     r3,[r4,r0]\n        LDRB     r2,[r4,r1]\n        STRB     r3,[r4,r1]\n        STRB     r2,[r4,r0]\n        SUB      r0,r0,#1\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.32|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid reverse_string(char *str) {\n    int n = strlen(str);\n    int start = 0;\n    int end = n - 1;\n    while (start < end) {\n        char temp = str[start];\n        str[start] = str[end];\n        str[end] = temp;\n        start++;\n        end--;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisSafe__FiN21 PROC\n|L1.0|\n        STR      lr,[sp,#-4]!\n        MOV      r2,#0\n        CMP      r0,#0\n        BLE      |L1.80|\n        LDR      r12,|L1.308|\n|L1.20|\n        LDR      r3,[r12,r2,LSL #2]\n        CMP      r3,r1\n        BEQ      |L1.56|\n        SUB      r3,r3,r1\n        CMP      r3,#0\n        RSBLT    r3,r3,#0\n        SUB      lr,r0,r2\n        CMP      r3,lr\n        BNE      |L1.68|\n|L1.56|\n        LDR      lr,[sp],#4\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        ADD      r2,r2,#1\n        CMP      r2,r0\n        BLT      |L1.20|\n|L1.80|\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nsolveNQUtil__FiT1 PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r6,r0\n        MOV      r5,r1\n        CMP      r0,r1\n        BNE      |L1.136|\n        LDR      r0,|L1.312|\n        LDR      r1,[r0,#0]  ; count\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]  ; count\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.136|\n        MOV      r4,#0\n        CMP      r5,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        ADD      r7,r6,#1\n        LDR      r8,|L1.308|\n|L1.160|\n        MOV      r2,r5\n        MOV      r1,r4\n        MOV      r0,r6\n        BL       isSafe__FiN21\n        CMP      r0,#0\n        BEQ      |L1.200|\n        STR      r4,[r8,r6,LSL #2]\n        MOV      r1,r5\n        MOV      r0,r7\n        BL       solveNQUtil__FiT1\n|L1.200|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.160|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nsolveNQ__Fi PROC\n        CMP      r0,#0\n        MOVLE    r0,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        MOV      r1,#0\n        LDR      r4,|L1.312|\n        STR      r1,[r4,#0]  ; count\n        MOV      r1,r0\n        MOV      r0,#0\n        BL       solveNQUtil__FiT1\n        LDR      r0,[r4,#0]  ; count\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint board[100];\nint count = 0;\n\n\nint isSafe(int row, int col, int n) {\n    for (int i = 0; i < row; i++) {\n        if (board[i] == col || abs(board[i] - col) == row - i)\n            return 0;\n    }\n    return 1;\n}\n\nvoid solveNQUtil(int row, int n) {\n    if (row == n) {\n        count++;\n        return;\n    }\n    for (int col = 0; col < n; col++) {\n        if (isSafe(row, col, n)) {\n            board[row] = col;\n            solveNQUtil(row + 1, n);\n        }\n    }\n}\n\nint solveNQ(int n) {\n    if (n <= 0) return 0;\n    count = 0;\n    solveNQUtil(0, n);\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       inorder__FP4Node\n        ADR      r0,|L1.48|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        inorder__FP4Node\n|L1.48|\n        DCB      \"%d \\0\"\n        ENDP\n\npreorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r1,[r4,#0]\n        ADR      r0,|L1.48|\n        BL       _printf\n        LDR      r0,[r4,#4]\n        BL       preorder__FP4Node\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4,lr}\n        B        preorder__FP4Node\n        ENDP\n\npostorder__FP4Node PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        BL       postorder__FP4Node\n        LDR      r0,[r4,#8]\n        BL       postorder__FP4Node\n        LDR      r1,[r4,#0]\n        LDMFD    sp!,{r4,lr}\n        ADR      r0,|L1.48|\n        B        _printf\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nvoid inorder(Node *root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nvoid preorder(Node *root) {\n    if (root) {\n        printf(\"%d \", root->data);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\n\nvoid postorder(Node *root) {\n    if (root) {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"%d \", root->data);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPiT1 PROC\n|L1.0|\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nsort__FPii PROC\n        STMFD    sp!,{r4-r9,lr}\n        SUB      r9,r1,#1\n        CMP      r9,#0\n        MOV      r8,r1\n        MOV      r6,r0\n        MOV      r5,#0\n        LDMLEFD  sp!,{r4-r9,lr}\n        BXLE     lr\n|L1.52|\n        SUB      r0,r8,r5\n        SUB      r7,r0,#1\n        CMP      r7,#0\n        MOV      r4,#0\n        BLE      |L1.108|\n|L1.72|\n        LDR      r1,[r6,r4,LSL #2]\n        ADD      r0,r6,r4,LSL #2\n        LDR      r2,[r0,#4]\n        CMP      r1,r2\n        ADDGT    r1,r0,#4\n        BLGT     swap__FPiT1\n        ADD      r4,r4,#1\n        CMP      r7,r4\n        BGT      |L1.72|\n|L1.108|\n        ADD      r5,r5,#1\n        CMP      r5,r9\n        BLT      |L1.52|\n        LDMFD    sp!,{r4-r9,lr}\n        BX       lr\n        ENDP\n\ncalculate_median__FPii PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r4,r1\n        BL       sort__FPii\n        ADD      r0,r4,r4,LSR #31\n        MOV      r0,r0,ASR #1\n        TST      r4,#1\n        LDRNE    r0,[r5,r0,LSL #2]\n        LDMNEFD  sp!,{r3-r5,lr}\n        BNE      _dflt\n        SUB      r1,r4,#1\n        ADD      r1,r1,r1,LSR #31\n        MOV      r1,r1,ASR #1\n        LDR      r1,[r5,r1,LSL #2]\n        LDR      r0,[r5,r0,LSL #2]\n        ADD      r0,r1,r0\n        BL       _dflt\n        ADR      r2,|L1.216|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dmul\n|L1.216|\n        DCFD     0x3fe0000000000000\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(int *xp, int *yp) {\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid sort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++)\n        for (int j = 0; j < n - i - 1; j++)\n            if (arr[j] > arr[j + 1])\n                swap(&arr[j], &arr[j + 1]);\n}\n\n\ndouble calculate_median(int arr[], int n) {\n    sort(arr,n);\n    if (n % 2 != 0)\n        return (double)arr[n / 2];\n    return (double)(arr[(n - 1) / 2] + arr[n / 2]) / 2.0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncaesar_cipher__FPciT2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r8,r1\n        MOV      r7,r2\n        MOV      r5,r0\n        BL       strlen\n        MOV      r6,r0\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r8,lr}\n        BXLE     lr\n        BL       __rt_ctype_table\n        RSB      r2,r8,#0\n        CMP      r7,#0\n        MOVNE    r2,r8\n        LDR      r1,|L1.264|\n        MOV      r8,r2\n|L1.64|\n        LDRB     r3,[r5,r4]\n        LDR      r2,[r0,#0]\n        LDRB     r2,[r2,r3]\n        TST      r2,#0x18\n        BEQ      |L1.144|\n        TST      r2,#8\n        MOVEQ    r2,#0x41\n        MOVNE    r2,#0x61\n        SUB      r3,r3,r2\n        ADD      r3,r3,r8\n        ADD      r3,r3,#0x1a\n        SMULL    lr,r12,r1,r3\n        MOV      r12,r12,ASR #3\n        SUB      lr,r12,r12,ASR #31\n        SUB      r12,lr,lr,LSL #1\n        ADD      r12,r12,r12,LSL #4\n        ADD      r12,r12,lr,LSL #2\n        ADD      r3,r3,r12,LSL #1\n        ADD      r2,r3,r2\n        STRB     r2,[r5,r4]\n|L1.144|\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.64|\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid caesar_cipher(char* str, int shift, int encode) {\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(str[i])) {\n            char base = islower(str[i]) ? 'a' : 'A';\n            str[i] = base + (str[i] - base + (encode ? shift : -shift) + 26) % 26;\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreatePriorityQueue__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0x190\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.64|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        MOV      r0,#0x64\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndestroyPriorityQueue__FP13PriorityQueue PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nheapifyUp__FPii PROC\n        SUB      r2,r1,#1\n        ADD      r2,r2,r2,LSR #31\n        MOV      r2,r2,ASR #1\n        B        |L1.160|\n|L1.136|\n        STR      r12,[r0,r1,LSL #2]\n        STR      r3,[r0,r2,LSL #2]\n        MOV      r1,r2\n        SUB      r2,r2,#1\n        ADD      r2,r2,r2,LSR #31\n        MOV      r2,r2,ASR #1\n|L1.160|\n        CMP      r1,#0\n        LDRGT    r3,[r0,r1,LSL #2]\n        LDRGT    r12,[r0,r2,LSL #2]\n        CMPGT    r3,r12\n        BGT      |L1.136|\n        BX       lr\n        ENDP\n\nenqueue__FP13PriorityQueuei PROC\n        LDMIB    r0,{r2,r3}\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#4]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#4]\n        LDR      r0,[r0,#0]\n        SUB      r1,r1,#1\n        B        heapifyUp__FPii\n        ENDP\n\ndequeue__FP13PriorityQueue PROC\n        LDR      r2,[r0,#4]\n        CMP      r2,#0\n        MVNEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r8,lr}\n        LDR      r1,[r0,#0]\n        MOV      lr,#1\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r5,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        MOV      r2,#0\n        SUB      r3,r1,#1\n        STR      r3,[r0,#4]\n        CMP      r3,#1\n        MOV      r1,r2\n        MOV      r7,#1\n        MOV      r6,#2\n        MOV      r4,#2\n        BLE      |L1.332|\n        LDR      r12,[r0,#0]\n        LDR      r8,[r12,#4]\n        LDR      r12,[r12,#0]\n        CMP      r8,r12\n        MOVGT    r1,lr\n|L1.332|\n        CMP      r3,#2\n        BLE      |L1.360|\n        LDR      r3,[r0,#0]\n        LDR      r12,[r3,#8]\n        LDR      r3,[r3,r1,LSL #2]\n        CMP      r12,r3\n        MOVGT    r1,r4\n|L1.360|\n        CMP      r1,#0\n        BEQ      |L1.464|\n|L1.368|\n        LDR      r3,[r0,#0]\n        LDR      r12,[r3,r1,LSL #2]\n        LDR      r4,[r3,r2,LSL #2]\n        STR      r12,[r3,r2,LSL #2]\n        LDR      r2,[r0,#0]\n        ADD      r3,r7,r1,LSL #1\n        STR      r4,[r2,r1,LSL #2]\n        LDR      lr,[r0,#4]\n        MOV      r2,r1\n        CMP      lr,r3\n        LDRGT    r8,[r0,#0]\n        ADD      r12,r6,r1,LSL #1\n        LDRGT    r8,[r8,r3,LSL #2]\n        CMPGT    r8,r4\n        MOVGT    r1,r3\n        CMP      lr,r12\n        BLE      |L1.456|\n        LDR      r3,[r0,#0]\n        LDR      lr,[r3,r12,LSL #2]\n        LDR      r3,[r3,r1,LSL #2]\n        CMP      lr,r3\n        MOVGT    r1,r12\n|L1.456|\n        CMP      r1,r2\n        BNE      |L1.368|\n|L1.464|\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int* array;\n    int size;\n    int capacity;\n} PriorityQueue;\n\n\nPriorityQueue* createPriorityQueue() {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    if (pq == NULL) return NULL;\n    pq->array = (int*)malloc(sizeof(int) * MAX_SIZE);\n    if (pq->array == NULL) {\n        free(pq);\n        return NULL;\n    }\n    pq->size = 0;\n    pq->capacity = MAX_SIZE;\n    return pq;\n}\n\nvoid destroyPriorityQueue(PriorityQueue* pq) {\n    free(pq->array);\n    free(pq);\n}\n\nvoid heapifyUp(int* array, int index) {\n    int parent = (index - 1) / 2;\n    while (index > 0 && array[index] > array[parent]) {\n        int temp = array[index];\n        array[index] = array[parent];\n        array[parent] = temp;\n        index = parent;\n        parent = (index - 1) / 2;\n    }\n}\n\nvoid enqueue(PriorityQueue* pq, int value) {\n    if (pq->size == pq->capacity) return;\n    pq->array[pq->size] = value;\n    pq->size++;\n    heapifyUp(pq->array, pq->size - 1);\n}\n\nint dequeue(PriorityQueue* pq) {\n    if (pq->size == 0) return -1;\n    int value = pq->array[0];\n    pq->array[0] = pq->array[pq->size - 1];\n    pq->size--;\n    int index = 0;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n    int largest = index;\n\n    if(left < pq->size && pq->array[left] > pq->array[largest])\n        largest = left;\n    if(right < pq->size && pq->array[right] > pq->array[largest])\n        largest = right;\n\n\n    while(largest != index){\n        int temp = pq->array[index];\n        pq->array[index] = pq->array[largest];\n        pq->array[largest] = temp;\n\n        index = largest;\n        left = 2 * index + 1;\n        right = 2 * index + 2;\n        largest = index;\n        if(left < pq->size && pq->array[left] > pq->array[largest])\n            largest = left;\n        if(right < pq->size && pq->array[right] > pq->array[largest])\n            largest = right;\n    }\n    return value;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitTicTacToe__FP9TicTacToe PROC\n        MOV      r2,#0\n        MOV      r3,#0\n|L1.8|\n        ADD      r12,r2,r2,LSL #1\n        ADD      r12,r12,r0\n        MOV      r1,#0\n|L1.20|\n        STRB     r3,[r12,r1]\n        ADD      r1,r1,#1\n        CMP      r1,#3\n        BLT      |L1.20|\n        ADD      r2,r2,#1\n        CMP      r2,#3\n        BLT      |L1.8|\n        MOV      r1,#1\n        STRB     r1,[r0,#9]\n        BX       lr\n        ENDP\n\nmakeMove__FP9TicTacToeiT2 PROC\n        CMP      r1,#0\n        BLT      |L1.112|\n        CMP      r1,#3\n        BGE      |L1.112|\n        CMP      r2,#0\n        BLT      |L1.112|\n        CMP      r2,#3\n        BGE      |L1.112|\n        ADD      r1,r1,r1,LSL #1\n        ADD      r1,r1,r0\n        LDRB     r3,[r1,r2]\n        CMP      r3,#0\n        BEQ      |L1.120|\n|L1.112|\n        MOV      r0,#0\n        BX       lr\n|L1.120|\n        LDRB     r3,[r0,#9]\n        STRB     r3,[r1,r2]\n        LDRB     r1,[r0,#9]\n        CMP      r1,#1\n        MOVNE    r1,#1\n        MOVEQ    r1,#2\n        STRB     r1,[r0,#9]\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ncheckWin__FP9TicTacToe PROC\n        MOV      r1,#0\n|L1.160|\n        ADD      r2,r1,r1,LSL #1\n        LDRB     r12,[r0,r2]\n        CMP      r12,#0\n        BEQ      |L1.204|\n        ADD      r3,r2,r0\n        LDRB     r2,[r3,#1]\n        CMP      r12,r2\n        LDREQB   r3,[r3,#2]\n        CMPEQ    r2,r3\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.204|\n        LDRB     r12,[r0,r1]\n        CMP      r12,#0\n        BEQ      |L1.244|\n        ADD      r3,r0,r1\n        LDRB     r2,[r3,#3]\n        CMP      r12,r2\n        LDREQB   r3,[r3,#6]\n        CMPEQ    r2,r3\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.244|\n        ADD      r1,r1,#1\n        CMP      r1,#3\n        BLT      |L1.160|\n        LDRB     r2,[r0,#0]\n        CMP      r2,#0\n        BEQ      |L1.292|\n        LDRB     r1,[r0,#4]\n        CMP      r2,r1\n        LDREQB   r2,[r0,#8]\n        CMPEQ    r1,r2\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.292|\n        LDRB     r2,[r0,#2]\n        CMP      r2,#0\n        BEQ      |L1.328|\n        LDRB     r1,[r0,#4]\n        CMP      r2,r1\n        LDREQB   r0,[r0,#6]\n        CMPEQ    r1,r0\n        MOVEQ    r0,#1\n        BXEQ     lr\n|L1.328|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define BOARD_SIZE 3\n\ntypedef enum {\n    EMPTY,\n    X,\n    O\n} Player;\n\ntypedef struct {\n    Player board[BOARD_SIZE][BOARD_SIZE];\n    Player currentPlayer;\n} TicTacToe;\n\n\nvoid initTicTacToe(TicTacToe* game) {\n    for (int i = 0; i < BOARD_SIZE; i++) {\n        for (int j = 0; j < BOARD_SIZE; j++) {\n            game->board[i][j] = EMPTY;\n        }\n    }\n    game->currentPlayer = X;\n}\n\nint makeMove(TicTacToe* game, int row, int col) {\n    if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE || game->board[row][col] != EMPTY) {\n        return 0; \n    }\n    game->board[row][col] = game->currentPlayer;\n    game->currentPlayer = (game->currentPlayer == X) ? O : X;\n    return 1;\n}\n\nint checkWin(TicTacToe* game) {\n    for (int i = 0; i < BOARD_SIZE; i++) {\n        if (game->board[i][0] != EMPTY && game->board[i][0] == game->board[i][1] && game->board[i][1] == game->board[i][2]) return 1;\n        if (game->board[0][i] != EMPTY && game->board[0][i] == game->board[1][i] && game->board[1][i] == game->board[2][i]) return 1;\n    }\n    if (game->board[0][0] != EMPTY && game->board[0][0] == game->board[1][1] && game->board[1][1] == game->board[2][2]) return 1;\n    if (game->board[0][2] != EMPTY && game->board[0][2] == game->board[1][1] && game->board[1][1] == game->board[2][0]) return 1;\n    return 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nbigInt_create__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOV      r4,r0\n        MOV      r5,r6,LSL #2\n        MOV      r0,r5\n        BL       malloc\n        MOV      r1,r5\n        STMIA    r4,{r0,r6}\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nbigInt_destroy__FP6BigInt PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n\nfactorial__Fi PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r7,r0\n        MOV      r5,#1\n        CMP      r0,#0\n        LDMLTFD  sp!,{r4-r8,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        BNE      |L1.140|\n        MOV      r0,#1\n        BL       bigInt_create__Fi\n        LDR      r1,[r0,#0]\n        STR      r5,[r1,#0]\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n|L1.140|\n        MOV      r0,#0x64\n        BL       bigInt_create__Fi\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        CMP      r7,#2\n        STR      r5,[r0,#0]\n        MOV      r5,#2\n        BLT      |L1.288|\n        LDR      r8,|L1.408|\n|L1.176|\n        MOV      r0,#0x64\n        BL       bigInt_create__Fi\n        MOV      r6,r0\n        MOV      r0,#0\n        MOV      r1,#0\n|L1.196|\n        LDR      r2,[r4,#0]\n        LDR      r2,[r2,r0,LSL #2]\n        MLA      r1,r5,r2,r1\n        SMULL    r3,r2,r8,r1\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        LDR      r3,[r6,#0]\n        ADD      r2,r1,r2,LSL #1\n        STR      r2,[r3,r0,LSL #2]\n        SMULL    r2,r1,r8,r1\n        MOV      r1,r1,ASR #2\n        ADD      r0,r0,#1\n        CMP      r0,#0x64\n        SUB      r1,r1,r1,ASR #31\n        BLT      |L1.196|\n        MOV      r0,r4\n        BL       bigInt_destroy__FP6BigInt\n        ADD      r5,r5,#1\n        CMP      r5,r7\n        MOV      r4,r6\n        BLE      |L1.176|\n|L1.288|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct BigInt {\n    int *digits;\n    int size;\n};\n\nBigInt *bigInt_create(int size) {\n    BigInt *bi = (BigInt *)malloc(sizeof(BigInt));\n    bi->digits = (int *)malloc(sizeof(int) * size);\n    bi->size = size;\n    memset(bi->digits, 0, sizeof(int) * size);\n    return bi;\n}\n\nvoid bigInt_destroy(BigInt *bi) {\n    free(bi->digits);\n    free(bi);\n}\n\nBigInt *factorial(int n) {\n    if (n < 0) return 0;\n    if (n == 0) {\n        BigInt *result = bigInt_create(1);\n        result->digits[0] = 1;\n        return result;\n    }\n    BigInt *result = bigInt_create(100); \n    result->digits[0] = 1;\n    for (int i = 2; i <= n; i++) {\n        BigInt *temp = bigInt_create(100);\n        int carry = 0;\n        for (int j = 0; j < 100; j++) {\n            int product = result->digits[j] * i + carry;\n            temp->digits[j] = product % 10;\n            carry = product / 10;\n        }\n        bigInt_destroy(result);\n        result = temp;\n\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninsert__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#8\n        BL       malloc\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        STR      r4,[r0,#0]\n        LDR      r2,|L1.184|\n        LDR      r1,[r2,#0]  ; head\n        STR      r1,[r0,#4]\n        STR      r0,[r2,#0]  ; head\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndeleteNode__Fi PROC\n        LDR      r12,|L1.184|\n        MOV      r2,r0\n        LDR      r0,[r12,#0]  ; head\n        MOV      r1,#0\n        B        |L1.84|\n|L1.76|\n        MOV      r1,r0\n        LDR      r0,[r0,#4]\n|L1.84|\n        CMP      r0,#0\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        CMP      r3,r2\n        BNE      |L1.76|\n        CMP      r1,#0\n        LDRNE    r2,[r0,#4]\n        STRNE    r2,[r1,#4]\n        LDREQ    r1,[r0,#4]\n        STREQ    r1,[r12,#0]  ; head\n        B        free\n        ENDP\n\ntraverse__Fv PROC\n        LDR      r0,|L1.184|\n        STMFD    sp!,{r4,lr}\n        LDR      r4,[r0,#0]  ; head\n        CMP      r4,#0\n        BEQ      |L1.172|\n|L1.148|\n        ADR      r0,|L1.188|\n        LDR      r1,[r4,#0]\n        BL       _printf\n        LDR      r4,[r4,#4]\n        CMP      r4,#0\n        BNE      |L1.148|\n|L1.172|\n        ADR      r0,|L1.192|\n        LDMFD    sp!,{r4,lr}\n        B        _printf\n|L1.184|\n        DCD      ||.bss$2||\n|L1.188|\n        DCB      \"%d \\0\"\n|L1.192|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* head = NULL;\n\nvoid insert(int data) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode == NULL) return;\n    newNode->data = data;\n    newNode->next = head;\n    head = newNode;\n}\n\nvoid deleteNode(int data) {\n    Node* temp = head;\n    Node* prev = NULL;\n    while (temp != NULL && temp->data != data) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return;\n    if (prev == NULL) {\n        head = temp->next;\n    } else {\n        prev->next = temp->next;\n    }\n    free(temp);\n}\n\nvoid traverse() {\n    Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\npower__FxN21 PROC\n        STMFD    sp!,{r3-r11,lr}\n        ADD      r11,sp,#0x28\n        MOV      r6,r2\n        ADR      r2,|L1.228|\n        LDMIA    r11,{r10,r11}\n        ADR      r2,|L1.228|\n        LDMIA    r2,{r8,r9}\n        MOV      r7,r3\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        ADR      r0,|L1.236|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BGE      |L1.212|\n|L1.72|\n        ADR      r0,|L1.244|\n        LDMIA    r0,{r2,r3}\n        MOV      r0,r6\n        MOV      r1,r7\n        BL       _ll_sdiv\n        MOV      r6,r0\n        MOV      r0,r2\n        MOV      r7,r1\n        MOV      r1,r3\n        ADR      r2,|L1.228|\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        BNE      |L1.160|\n        UMULL    r0,r12,r8,r4\n        MLA      r12,r4,r9,r12\n        MLA      r1,r5,r8,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r8,r2\n        MOV      r9,r3\n|L1.160|\n        UMULL    r0,r12,r4,r4\n        MLA      r12,r4,r5,r12\n        MLA      r1,r5,r4,r12\n        MOV      r3,r11\n        MOV      r2,r10\n        BL       _ll_sdiv\n        MOV      r4,r2\n        MOV      r5,r3\n        ADR      r0,|L1.236|\n        LDMIA    r0,{r2,r3}\n        SUBS     r0,r2,r6\n        SBCS     r1,r3,r7\n        BLT      |L1.72|\n|L1.212|\n        MOV      r0,r8\n        MOV      r1,r9\n        LDMFD    sp!,{r3-r11,lr}\n        BX       lr\n|L1.228|\n        DCQ      0x0000000000000001\n|L1.236|\n        DCQ      0x0000000000000000\n|L1.244|\n        DCQ      0x0000000000000002\n        ENDP\n```",
        "output": "```cpp\n\nlong long power(long long base, long long exp, long long mod) {\n    long long res = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountLinesWordsChars__FPCc PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r6,r0\n        MOV      r0,r1\n        SUB      sp,sp,#0x400\n        SUB      sp,sp,#0xc\n        ADR      r1,|L1.268|\n        BL       fopen\n        MOVS     r4,r0\n        BNE      |L1.80|\n        ADD      r0,sp,#0x400\n        MOV      r1,#0\n        MOV      r2,#0\n        MOV      r3,#0\n        STMIA    r0,{r1-r3}\n        LDMIA    r0,{r1-r3}\n        STMIA    r6,{r1-r3}\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.80|\n        ADD      r7,sp,#0x400\n        MOV      r0,#0\n        MOV      r1,#0\n        MOV      r2,#0\n        STMIA    r7,{r0-r2}\n        MOV      r2,r4\n        MOV      r1,#0x400\n        MOV      r0,sp\n        MOV      r5,sp\n        BL       fgets\n        CMP      r0,#0\n        BEQ      |L1.236|\n|L1.128|\n        LDR      r0,[sp,#0x400]\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0x400]\n        MOV      r0,r5\n        BL       strlen\n        LDR      r1,[sp,#0x408]\n        ADD      r0,r0,r1\n        STR      r0,[sp,#0x408]\n        MOV      r0,r5\n        ADR      r1,|L1.272|\n        BL       strtok\n        CMP      r0,#0\n        BEQ      |L1.212|\n|L1.180|\n        LDR      r0,[sp,#0x404]\n        ADR      r1,|L1.272|\n        ADD      r0,r0,#1\n        STR      r0,[sp,#0x404]\n        MOV      r0,#0\n        BL       strtok\n        CMP      r0,#0\n        BNE      |L1.180|\n|L1.212|\n        MOV      r2,r4\n        MOV      r1,#0x400\n        MOV      r0,r5\n        BL       fgets\n        CMP      r0,#0\n        BNE      |L1.128|\n|L1.236|\n        MOV      r0,r4\n        BL       fclose\n        LDMIA    r7,{r1-r3}\n        STMIA    r6,{r1-r3}\n        ADD      sp,sp,#0x400\n        ADD      sp,sp,#0xc\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.268|\n        DCB      \"r\\0\\0\\0\"\n|L1.272|\n        DCB      \" \\t\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct FileData {\n    int lines;\n    int words;\n    int chars;\n};\n\nFileData countLinesWordsChars(const char* filename) {\n    FILE* fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        FileData data = {0, 0, 0};\n        return data;\n    }\n\n    FileData data = {0, 0, 0};\n    char buffer[1024];\n\n    while (fgets(buffer, sizeof(buffer), fp) != NULL) {\n        data.lines++;\n        data.chars += strlen(buffer);\n        char* word = strtok(buffer, \" \\t\\n\");\n        while (word != NULL) {\n            data.words++;\n            word = strtok(NULL, \" \\t\\n\");\n        }\n    }\n\n    fclose(fp);\n    return data;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsieve__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r0,#2\n        LDMLTFD  sp!,{r4-r6,lr}\n        MOV      r0,#4\n        BLT      malloc\n        ADD      r6,r0,r4,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r5,#4]\n        STR      r2,[r5,#0]\n        MOV      r1,#2\n        CMP      r4,#4\n        BLT      |L1.132|\n|L1.76|\n        LDR      r0,[r5,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BGT      |L1.116|\n|L1.100|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,r1\n        CMP      r0,r4\n        BLE      |L1.100|\n|L1.116|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BLE      |L1.76|\n|L1.132|\n        MOV      r1,#0\n        MOV      r0,#2\n        CMP      r4,#2\n        BLT      |L1.172|\n|L1.148|\n        LDR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r1,r1,#1\n        CMP      r0,r4\n        BLE      |L1.148|\n|L1.172|\n        MOV      r0,r1,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#2\n        MOV      r2,#0\n        CMP      r4,#2\n        BLT      |L1.232|\n|L1.200|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        MOVNE    r1,r2\n        STRNE    r0,[r6,r1,LSL #2]\n        ADD      r0,r0,#1\n        ADDNE    r2,r2,#1\n        CMP      r0,r4\n        BLE      |L1.200|\n|L1.232|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100000\n\nint* sieve(int limit) {\n    if (limit < 2) {\n        return (int*) malloc(sizeof(int) * 1);\n    }\n    int* prime = (int*)malloc(sizeof(int) * (limit + 1));\n    memset(prime, 1, sizeof(int) * (limit + 1));\n    prime[0] = prime[1] = 0;\n\n    for (int p = 2; p * p <= limit; p++) {\n        if (prime[p]) {\n            for (int i = p * p; i <= limit; i += p)\n                prime[i] = 0;\n        }\n    }\n\n    int count = 0;\n    for (int i = 2; i <= limit; i++){\n        if(prime[i]) count++;\n    }\n\n    int* result = (int*)malloc(sizeof(int) * count);\n    int k=0;\n    for (int i = 2; i <= limit; i++){\n        if(prime[i]){\n            result[k++] = i;\n        }\n    }\n    free(prime);\n    return result;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsum_digits__Fi PROC\n        CMP      r0,#0\n        RSBLT    r0,r0,#0\n        CMP      r0,#0\n        MOV      r1,#0\n        BLE      |L1.72|\n        LDR      r3,|L1.120|\n|L1.24|\n        SMULL    r12,r2,r3,r0\n        MOV      r2,r2,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r2,r0,r2,LSL #1\n        ADD      r1,r2,r1\n        SMULL    r2,r0,r3,r0\n        MOV      r0,r0,ASR #2\n        SUB      r0,r0,r0,ASR #31\n        CMP      r0,#0\n        BGT      |L1.24|\n|L1.72|\n        MOV      r0,r1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint sum_digits(int n) {\n    int sum = 0;\n    if (n < 0) n = -n;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngenerateRandomNumber__FiT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0\n        MOV      r5,r1\n        BL       time\n        BL       srand\n        BL       rand\n        MOV      r1,r0\n        SUB      r0,r5,r4\n        ADD      r0,r0,#1\n        BL       __rt_sdiv\n        ADD      r0,r1,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint generateRandomNumber(int min, int max) {\n    srand(time(0));\n    return min + rand() % (max - min + 1);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisMirror__FP4NodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#4]\n        BL       isMirror__FP4NodeT1\n        CMP      r0,#0\n        BEQ      |L1.160|\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#8]\n        BL       isMirror__FP4NodeT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.160|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint isMirror(struct Node* a, struct Node* b) {\n    if (a == NULL && b == NULL) return 1;\n    if (a == NULL || b == NULL) return 0;\n    if (a->data != b->data) return 0;\n    return isMirror(a->left, b->right) && isMirror(a->right, b->left);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x24\n        BL       malloc\n        MOV      r1,#0\n        ADD      r2,r0,#0x1c\n        STMIA    r2,{r1,r4}\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ninsertNonFull__FP9BTreeNodei PROC\n|L1.36|\n        LDR      r2,[r0,#0x1c]\n        LDR      r3,[r0,#0x20]\n        SUB      r2,r2,#1\n        CMP      r3,#0\n        BEQ      |L1.116|\n        B        |L1.72|\n|L1.60|\n        ADD      r12,r0,r2,LSL #2\n        STR      r3,[r12,#4]\n        SUB      r2,r2,#1\n|L1.72|\n        CMP      r2,#0\n        LDRGE    r3,[r0,r2,LSL #2]\n        CMPGE    r3,r1\n        BGT      |L1.60|\n        ADD      r2,r0,r2,LSL #2\n        STR      r1,[r2,#4]\n        LDR      r1,[r0,#0x1c]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0x1c]\n        BX       lr\n|L1.112|\n        SUB      r2,r2,#1\n|L1.116|\n        CMP      r2,#0\n        LDRGE    r3,[r0,r2,LSL #2]\n        CMPGE    r3,r1\n        BGT      |L1.112|\n        ADD      r2,r2,#1\n        ADD      r0,r0,r2,LSL #2\n        LDR      r0,[r0,#0xc]\n        B        |L1.36|\n        ENDP\n\ninsert__FPP9BTreeNodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        CMP      r0,#0\n        BNE      |L1.208|\n        MOV      r0,#1\n        BL       createNode__Fi\n        STR      r0,[r4,#0]\n        STR      r5,[r0,#0]\n        LDR      r1,[r4,#0]\n        MOV      r0,#1\n        STR      r0,[r1,#0x1c]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.208|\n        LDR      r1,[r0,#0x1c]\n        CMP      r1,#5\n        MOVNE    r1,r5\n        LDMNEFD  sp!,{r3-r5,lr}\n        BNE      insertNonFull__FP9BTreeNodei\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_DEGREE 3\n\ntypedef struct BTreeNode {\n    int keys[MAX_DEGREE];\n    struct BTreeNode *children[MAX_DEGREE + 1];\n    int numKeys;\n    int isLeaf;\n} BTreeNode;\n\n\nBTreeNode* createNode(int isLeaf) {\n    BTreeNode* node = (BTreeNode*)malloc(sizeof(BTreeNode));\n    node->numKeys = 0;\n    node->isLeaf = isLeaf;\n    return node;\n}\n\nvoid insertNonFull(BTreeNode* node, int key) {\n    int i = node->numKeys - 1;\n    if (node->isLeaf) {\n        while (i >= 0 && key < node->keys[i]) {\n            node->keys[i + 1] = node->keys[i];\n            i--;\n        }\n        node->keys[i + 1] = key;\n        node->numKeys++;\n    } else {\n        while (i >= 0 && key < node->keys[i])\n            i--;\n        i++;\n        if (node->children[i]->numKeys == MAX_DEGREE * 2 -1) {\n            \n        }\n        insertNonFull(node->children[i], key);\n    }\n}\n\n\nvoid insert(BTreeNode** root, int key) {\n    BTreeNode* node = *root;\n    if (node == NULL) {\n        *root = createNode(1);\n        (*root)->keys[0] = key;\n        (*root)->numKeys = 1;\n\n    } else if (node->numKeys == MAX_DEGREE *2 -1) {\n\n    } else {\n        insertNonFull(node, key);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateNode__FPUci PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        MOV      r5,r1\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STMIA    r0,{r4,r5}\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nhash__FPUci PROC\n        MOV      r3,#0\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.80|\n|L1.56|\n        LDRB     r12,[r0,r2]\n        ADD      r2,r2,#1\n        ADD      r3,r3,r3,LSL #5\n        ADD      r3,r3,r12\n        CMP      r2,r1\n        BLT      |L1.56|\n|L1.80|\n        CMP      r3,#0\n        RSBLT    r0,r3,#0\n        MOVGE    r0,r3\n        BX       lr\n        ENDP\n\naddChar__FPUcUc PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        MOV      r6,r0\n        BL       strlen\n        MOV      r5,r0\n        ADD      r0,r0,#2\n        BL       malloc\n        MOV      r4,r0\n        MOV      r1,r6\n        BL       strcpy\n        STRB     r7,[r4,r5]\n        MOV      r1,#0\n        ADD      r0,r4,r5\n        STRB     r1,[r0,#1]\n        MOV      r0,r6\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nlz77Compress__FPUcPi PROC\n        STMFD    sp!,{r0,r1,r4-r11,lr}\n        SUB      sp,sp,#0x14\n        LDR      r0,[sp,#0x14]\n        BL       strlen\n        STR      r0,[sp,#0x10]\n        MOV      r0,#0x400\n        STR      r0,[sp,#0xc]\n        MOV      r1,#4\n        BL       calloc\n        STR      r0,[sp,#8]\n        LDR      r0,[sp,#0x10]\n        MOV      r0,r0,LSL #1\n        BL       malloc\n        STR      r0,[sp,#4]\n        MOV      r0,#1\n        MOV      r9,#0\n        MOV      r4,#1\n        BL       malloc\n        MOV      r5,#0\n        STRB     r5,[r0,#0]\n        MOV      r0,#1\n        BL       malloc\n        STRB     r5,[r0,#0]\n        LDR      r0,[sp,#0x10]\n        MOV      r6,#0\n        CMP      r0,#0\n        BLE      |L1.536|\n        ADD      r11,r4,#1\n|L1.284|\n        LDR      r0,[sp,#0xc]\n        MOV      r7,#0\n        MVN      r8,#0\n        MOV      r5,#0\n        CMP      r0,#0\n        BLE      |L1.440|\n        LDR      r0,[sp,#0x14]\n        ADD      r10,r0,r6\n|L1.316|\n        LDR      r0,[sp,#8]\n        LDR      r4,[r0,r5,LSL #2]\n        CMP      r4,#0\n        BEQ      |L1.384|\n|L1.332|\n        MOV      r2,r11\n        MOV      r1,r10\n        LDR      r0,[r4,#0]\n        BL       strncmp\n        CMP      r0,#0\n        BNE      |L1.372|\n        LDR      r0,[r4,#0]\n        BL       strlen\n        MOV      r7,r0\n        MOV      r8,r5\n|L1.372|\n        LDR      r4,[r4,#8]\n        CMP      r4,#0\n        BNE      |L1.332|\n|L1.384|\n        LDR      r0,[sp,#0xc]\n        ADD      r5,r5,#1\n        CMP      r5,r0\n        BLT      |L1.316|\n        CMP      r7,#0\n        BEQ      |L1.440|\n        LDR      r1,[sp,#4]\n        ADD      r0,r9,#1\n        STRB     r8,[r1,r9]\n        LDR      r1,[sp,#4]\n        ADD      r9,r0,#1\n        ADD      r6,r6,r7\n        STRB     r7,[r1,r0]\n        B        |L1.468|\n|L1.440|\n        LDR      r0,[sp,#0x14]\n        LDRB     r1,[r0,r6]\n        LDR      r2,[sp,#4]\n        MOV      r0,r9\n        STRB     r1,[r2,r0]\n        ADD      r9,r9,#1\n        ADD      r6,r6,#1\n|L1.468|\n        LDR      r0,[sp,#0x14]\n        MOV      r1,#1\n        ADD      r4,r0,r6\n        MOV      r0,r4\n        BL       hash__FPUci\n        MOV      r5,r0\n        MOV      r0,r4\n        MOV      r1,#1\n        BL       createNode__FPUci\n        LDR      r1,[sp,#8]\n        LDR      r1,[r1,r5,LSL #2]\n        STR      r1,[r0,#8]\n        LDR      r1,[sp,#8]\n        STR      r0,[r1,r5,LSL #2]\n        LDR      r0,[sp,#0x10]\n        CMP      r6,r0\n        BLT      |L1.284|\n|L1.536|\n        LDR      r0,[sp,#0x18]\n        STR      r9,[r0,#0]\n        LDR      r0,[sp,#4]\n        ADD      sp,sp,#0x1c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef unsigned char uchar;\n\nstruct node {\n    uchar* key;\n    int val;\n    struct node* next;\n};\n\nstruct node* createNode(uchar* key, int val) {\n    struct node* newNode = (struct node*)malloc(sizeof(struct node));\n    newNode->key = key;\n    newNode->val = val;\n    newNode->next = 0;\n    return newNode;\n}\n\nint hash(uchar* str, int size) {\n    int hashVal = 0;\n    for (int i = 0; i < size; i++)\n        hashVal = (hashVal << 5) + hashVal + str[i];\n    return abs(hashVal);\n}\n\nuchar* addChar(uchar* str, uchar ch) {\n    int len = strlen((char*)str);\n    uchar* newStr = (uchar*)malloc(len + 2);\n    strcpy((char*)newStr, (char*)str);\n    newStr[len] = ch;\n    newStr[len + 1] = 0;\n    free(str);\n    return newStr;\n}\n\n\nuchar* lz77Compress(uchar* input, int* compressedSize) {\n    int inputSize = strlen((char*)input);\n    int dictSize = 1024;\n    struct node** dict = (struct node**)calloc(dictSize, sizeof(struct node*));\n    uchar* compressed = (uchar*)malloc(inputSize * 2); \n    int compressedIndex = 0;\n    int lookAheadSize = 1;\n\n\n    uchar* lookAhead = (uchar*)malloc(1);\n    lookAhead[0] = 0;\n    uchar* current = (uchar*)malloc(1);\n    current[0] = 0;\n    int i = 0;\n\n\n    while(i < inputSize) {\n        int matchLen = 0;\n        int matchPos = -1;\n        uchar* matchStr = 0;\n        for(int j = 0; j<dictSize; j++){\n            struct node* curr = dict[j];\n            while(curr){\n                if(strncmp((char*)curr->key, (char*)&input[i], lookAheadSize +1 ) == 0){\n                    matchLen = strlen((char*)curr->key) ;\n                    matchPos = j;\n                    matchStr = curr->key;\n                }\n                curr = curr->next;\n            }\n        }\n\n        if(matchLen){\n            compressed[compressedIndex++] = (uchar) matchPos;\n            compressed[compressedIndex++] = (uchar) matchLen;\n            \n            i += matchLen; \n        } else{\n            compressed[compressedIndex++] = input[i];\n            i++;\n        }\n\n        int hashVal = hash(&input[i], 1);\n        struct node* newEntry = createNode((uchar*)&input[i],1);\n        newEntry->next = dict[hashVal];\n        dict[hashVal] = newEntry;\n    }\n\n     *compressedSize = compressedIndex;\n    return compressed;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheapify__FPiiT2 PROC\n|L1.0|\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r12,#1\n        ADD      r12,r12,r2,LSL #1\n        MOV      lr,#2\n        ADD      lr,lr,r2,LSL #1\n        CMP      r12,r1\n        MOV      r3,r2\n        BGE      |L1.48|\n        LDR      r4,[r0,r12,LSL #2]\n        LDR      r5,[r0,r2,LSL #2]\n        CMP      r4,r5\n        MOVGT    r2,r12\n|L1.48|\n        CMP      lr,r1\n        BGE      |L1.72|\n        LDR      r12,[r0,lr,LSL #2]\n        LDR      r4,[r0,r2,LSL #2]\n        CMP      r12,r4\n        MOVGT    r2,lr\n|L1.72|\n        CMP      r2,r3\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      lr,[r0,r2,LSL #2]\n        LDR      r12,[r0,r3,LSL #2]\n        STR      lr,[r0,r3,LSL #2]\n        STR      r12,[r0,r2,LSL #2]\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapify__FPiiT2\n        ENDP\n\nheapSort__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        ADD      r0,r1,r1,LSR #31\n        MOV      r0,r0,ASR #1\n        SUBS     r5,r0,#1\n        MOV      r6,r1\n        BMI      |L1.160|\n|L1.136|\n        MOV      r2,r5\n        MOV      r1,r6\n        MOV      r0,r4\n        BL       heapify__FPiiT2\n        SUBS     r5,r5,#1\n        BPL      |L1.136|\n|L1.160|\n        SUB      r5,r6,#1\n        CMP      r5,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.176|\n        LDR      r1,[r4,r5,LSL #2]\n        LDR      r0,[r4,#0]\n        STR      r1,[r4,#0]\n        STR      r0,[r4,r5,LSL #2]\n        MOV      r0,r4\n        MOV      r1,r5\n        MOV      r2,#0\n        BL       heapify__FPiiT2\n        SUB      r5,r5,#1\n        CMP      r5,#0\n        BGT      |L1.176|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountOccurrences__FPCcc PROC\n|L1.0|\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r5,r0\n        MOV      r4,#0\n        BL       strlen\n        MOV      r1,#0\n        CMP      r0,#0\n        BLE      |L1.56|\n|L1.32|\n        LDRB     r2,[r5,r1]\n        ADD      r1,r1,#1\n        CMP      r2,r6\n        ADDEQ    r4,r4,#1\n        CMP      r1,r0\n        BLT      |L1.32|\n|L1.56|\n        MOV      r0,r4\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint countOccurrences(const char* str, char ch) {\n    int count = 0;\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (str[i] == ch) {\n            count++;\n        }\n    }\n    return count;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnode2vec__FP5Graphi PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r7,r0\n        LDR      r0,[r0,#4]\n        MOV      r8,r1\n        MUL      r0,r1,r0\n        MOV      r0,r0,LSL #3\n        BL       malloc\n        MOVS     r6,r0\n        LDMEQFD  sp!,{r3-r9,lr}\n        MOV      r0,#0\n        BXEQ     lr\n        BL       time\n        BL       srand\n        LDR      r0,[r7,#4]\n        MOV      r4,#0\n        MUL      r0,r8,r0\n        CMP      r0,#0\n        BLE      |L1.120|\n        ADR      r9,|L1.132|\n|L1.76|\n        BL       rand\n        BL       _dflt\n        ADD      r5,r6,r4,LSL #3\n        LDMIA    r9,{r2,r3}\n        BL       _ddiv\n        STMIA    r5,{r0,r1}\n        LDR      r0,[r7,#4]\n        ADD      r4,r4,#1\n        MUL      r0,r8,r0\n        CMP      r0,r4\n        BGT      |L1.76|\n|L1.120|\n        MOV      r0,r6\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.132|\n        DCFD     0x41dfffffffc00000\n        ENDP\n```",
        "output": "```cpp\n\n\nstruct Node {\n    int id;\n    int* neighbors;\n    int num_neighbors;\n};\n\nstruct Graph {\n    Node* nodes;\n    int num_nodes;\n};\n\n\n//Very basic implementation, lacks crucial aspects of node2vec\ndouble* node2vec(Graph* graph, int embedding_dim){\n    double* embedding = (double*)malloc(graph->num_nodes * embedding_dim * sizeof(double));\n    if (embedding == NULL) return NULL;\n    srand(time(NULL));\n    for (int i = 0; i < graph->num_nodes * embedding_dim; ++i){\n        embedding[i] = (double)rand() / RAND_MAX;\n    }\n    return embedding;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_graph__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x44\n        ADD      r0,r0,#0x9c00\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#0x1c40\n        ADD      r1,r1,#0x8000\n        STR      r5,[r4,#0]\n        ADD      r0,r4,#4\n        BL       __rt_memclr_w\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP5GraphiT2 PROC\n        CMP      r0,#0\n        BXEQ     lr\n        CMP      r1,#0\n        LDRGE    r3,[r0,#0]\n        CMPGE    r3,r1\n        BXLE     lr\n        CMP      r2,#0\n        CMPGE    r3,r2\n        BXLE     lr\n        ADD      r12,r1,r1,LSL #3\n        ADD      r1,r12,r1,LSL #4\n        ADD      r0,r0,r1,LSL #4\n        ADD      r0,r0,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r0,#4]\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj_matrix[MAX_VERTICES][MAX_VERTICES];\n} Graph;\n\nGraph* create_graph(int vertices) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == NULL) return NULL;\n    graph->vertices = vertices;\n    memset(graph->adj_matrix, 0, sizeof(graph->adj_matrix));\n    return graph;\n}\n\nvoid add_edge(Graph* graph, int u, int v) {\n    if (graph == NULL || u < 0 || u >= graph->vertices || v < 0 || v >= graph->vertices) return;\n    graph->adj_matrix[u][v] = 1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateCircularBuffer__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0x10\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0x28\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.64|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        MOV      r0,#0\n        STR      r0,[r4,#4]\n        STR      r0,[r4,#8]\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nenqueue__FP14CircularBufferi PROC\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0xc]\n        CMPNE    r2,#0xa\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,[r0,#0]\n        LDR      r3,[r0,#8]\n        STR      r1,[r2,r3,LSL #2]\n        LDR      r1,[r0,#8]\n        LDR      r2,|L1.416|\n        ADD      r1,r1,#1\n        SMULL    r12,r3,r2,r1\n        MOV      r2,r3,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r1,r1,r2,LSL #1\n        STR      r1,[r0,#8]\n        LDR      r1,[r0,#0xc]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0xc]\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP14CircularBufferPi PROC\n        CMP      r0,#0\n        LDRNE    r2,[r0,#0xc]\n        CMPNE    r2,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDMIA    r0,{r2,r3}\n        LDR      r2,[r2,r3,LSL #2]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#4]\n        LDR      r2,|L1.416|\n        ADD      r1,r1,#1\n        SMULL    r12,r3,r2,r1\n        MOV      r2,r3,ASR #2\n        SUB      r2,r2,r2,ASR #31\n        SUB      r2,r2,r2,LSL #1\n        ADD      r2,r2,r2,LSL #2\n        ADD      r1,r1,r2,LSL #1\n        STR      r1,[r0,#4]\n        LDR      r1,[r0,#0xc]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#0xc]\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndestroyCircularBuffer__FP14CircularBuffer PROC\n        STMFD    sp!,{r4,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define BUFFER_SIZE 10\n\ntypedef struct {\n    int *buffer;\n    int head;\n    int tail;\n    int size;\n} CircularBuffer;\n\nCircularBuffer* createCircularBuffer() {\n    CircularBuffer* cb = (CircularBuffer*)malloc(sizeof(CircularBuffer));\n    if (cb == NULL) return NULL;\n    cb->buffer = (int*)malloc(sizeof(int) * BUFFER_SIZE);\n    if (cb->buffer == NULL) {\n        free(cb);\n        return NULL;\n    }\n    cb->head = 0;\n    cb->tail = 0;\n    cb->size = 0;\n    return cb;\n}\n\nint enqueue(CircularBuffer* cb, int value) {\n    if (cb == NULL || cb->size == BUFFER_SIZE) return 0;\n    cb->buffer[cb->tail] = value;\n    cb->tail = (cb->tail + 1) % BUFFER_SIZE;\n    cb->size++;\n    return 1;\n}\n\nint dequeue(CircularBuffer* cb, int* value) {\n    if (cb == NULL || cb->size == 0) return 0;\n    *value = cb->buffer[cb->head];\n    cb->head = (cb->head + 1) % BUFFER_SIZE;\n    cb->size--;\n    return 1;\n}\n\nvoid destroyCircularBuffer(CircularBuffer* cb) {\n    if (cb == NULL) return;\n    free(cb->buffer);\n    free(cb);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateSparseMatrix__FiN21 PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#0x18\n        MOV      r7,r1\n        MOV      r5,r2\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        STR      r5,[r4,#0x14]\n        MOV      r5,r5,LSL #2\n        MOV      r0,r5\n        STMIA    r4,{r6,r7}\n        BL       malloc\n        STR      r0,[r4,#8]\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#0xc]\n        MOV      r0,r5\n        BL       malloc\n        STR      r0,[r4,#0x10]\n        LDR      r1,[r4,#8]\n        CMP      r1,#0\n        LDRNE    r2,[r4,#0xc]\n        CMPNE    r2,#0\n        CMPNE    r0,#0\n        MOVNE    r0,r4\n        LDMNEFD  sp!,{r3-r7,lr}\n        BXNE     lr\n        MOV      r0,r1\n        BL       free\n        LDR      r0,[r4,#0xc]\n        BL       free\n        LDR      r0,[r4,#0x10]\n        BL       free\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\naddSparseMatrices__FP12SparseMatrixT1 PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        MOV      r5,r1\n        LDR      r1,[r1,#0]\n        CMP      r0,r1\n        LDREQ    r1,[r4,#4]\n        LDREQ    r2,[r5,#4]\n        CMPEQ    r1,r2\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r2,[r4,#0x14]\n        LDR      r3,[r5,#0x14]\n        ADD      r2,r2,r3\n        BL       createSparseMatrix__FiN21\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        LDR      r3,[r4,#0x14]\n        MOV      r1,#0\n        MOV      r2,#0\n        CMP      r3,#0\n        BLE      |L1.328|\n|L1.256|\n        LDR      r3,[r4,#8]\n        LDR      r12,[r0,#8]\n        LDR      r3,[r3,r2,LSL #2]\n        STR      r3,[r12,r1,LSL #2]\n        LDR      r3,[r4,#0xc]\n        LDR      r12,[r0,#0xc]\n        LDR      r3,[r3,r2,LSL #2]\n        STR      r3,[r12,r1,LSL #2]\n        LDR      r3,[r4,#0x10]\n        LDR      lr,[r0,#0x10]\n        LDR      r12,[r3,r2,LSL #2]\n        MOV      r3,r1\n        STR      r12,[lr,r3,LSL #2]\n        LDR      r3,[r4,#0x14]\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        ADD      r1,r1,#1\n        BGT      |L1.256|\n|L1.328|\n        LDR      r3,[r5,#0x14]\n        MOV      r2,#0\n        CMP      r3,#0\n        LDMLEFD  sp!,{r3-r5,lr}\n        BXLE     lr\n|L1.348|\n        LDR      r3,[r5,#8]\n        LDR      r12,[r0,#8]\n        LDR      r3,[r3,r2,LSL #2]\n        STR      r3,[r12,r1,LSL #2]\n        LDR      r3,[r5,#0xc]\n        LDR      r12,[r0,#0xc]\n        LDR      r3,[r3,r2,LSL #2]\n        STR      r3,[r12,r1,LSL #2]\n        LDR      r3,[r5,#0x10]\n        LDR      lr,[r0,#0x10]\n        LDR      r12,[r3,r2,LSL #2]\n        MOV      r3,r1\n        STR      r12,[lr,r3,LSL #2]\n        LDR      r3,[r5,#0x14]\n        ADD      r2,r2,#1\n        CMP      r3,r2\n        ADD      r1,r1,#1\n        BGT      |L1.348|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct SparseMatrix {\n    int rows;\n    int cols;\n    int* data;\n    int* row_index;\n    int* col_index;\n    int nnz;\n};\n\n\nSparseMatrix* createSparseMatrix(int rows, int cols, int nnz) {\n    SparseMatrix* matrix = (SparseMatrix*)malloc(sizeof(SparseMatrix));\n    if (matrix == NULL) return NULL;\n    matrix->rows = rows;\n    matrix->cols = cols;\n    matrix->nnz = nnz;\n    matrix->data = (int*)malloc(sizeof(int) * nnz);\n    matrix->row_index = (int*)malloc(sizeof(int) * nnz);\n    matrix->col_index = (int*)malloc(sizeof(int) * nnz);\n    if (matrix->data == NULL || matrix->row_index == NULL || matrix->col_index == NULL) {\n        free(matrix->data);\n        free(matrix->row_index);\n        free(matrix->col_index);\n        free(matrix);\n        return NULL;\n    }\n    return matrix;\n}\n\n\nSparseMatrix* addSparseMatrices(SparseMatrix* a, SparseMatrix* b) {\n    if (a->rows != b->rows || a->cols != b->cols) return NULL;\n    SparseMatrix* result = createSparseMatrix(a->rows, a->cols, a->nnz + b->nnz);\n    if (result == NULL) return NULL;\n    int k = 0;\n    for (int i = 0; i < a->nnz; ++i) {\n        result->data[k] = a->data[i];\n        result->row_index[k] = a->row_index[i];\n        result->col_index[k++] = a->col_index[i];\n    }\n    for (int i = 0; i < b->nnz; ++i) {\n        result->data[k] = b->data[i];\n        result->row_index[k] = b->row_index[i];\n        result->col_index[k++] = b->col_index[i];\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nelementExists__FPiiT2 PROC\n|L1.0|\n        MOV      r3,#0\n        CMP      r1,#0\n        BLE      |L1.40|\n|L1.12|\n        LDR      r12,[r0,r3,LSL #2]\n        CMP      r12,r2\n        MOVEQ    r0,#1\n        BXEQ     lr\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.12|\n|L1.40|\n        MOV      r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint elementExists(int arr[], int size, int element) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitializeGraph__FP5Graph PROC\n        MOV      r2,#0\n        ADD      r1,r0,#0x13000\n        STR      r2,[r1,#0xa10]\n        STR      r2,[r1,#0xa14]\n        MVN      r2,#0\n        MOV      r1,#0\n|L1.24|\n        ADD      r3,r0,r1,LSL #2\n        ADD      r3,r3,#0x13000\n        ADD      r1,r1,#1\n        CMP      r1,#0x64\n        STR      r2,[r3,#0x880]\n        BLT      |L1.24|\n        BX       lr\n        ENDP\n\naddEdge__FP5GraphiT2 PROC\n        MOV      r3,r2\n        ADD      r2,r0,#0x13000\n        LDR      r12,[r2,#0xa10]\n        ADD      r1,r0,r1,LSL #2\n        STR      r3,[r0,r12,LSL #3]\n        LDR      r12,[r2,#0xa10]\n        ADD      r1,r1,#0x13000\n        LDR      r3,[r1,#0x880]\n        ADD      r0,r0,r12,LSL #3\n        STR      r3,[r0,#4]\n        LDR      r0,[r2,#0xa10]\n        STR      r0,[r1,#0x880]\n        LDR      r0,[r2,#0xa10]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xa10]\n        BX       lr\n        ENDP\n\ndfs__FP5GraphiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        STR      r0,[r2,r1,LSL #2]\n        ADD      r0,r5,r1,LSL #2\n        ADD      r0,r0,#0x13000\n        LDR      r4,[r0,#0x880]\n        MOV      r6,r2\n        CMN      r4,#1\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n|L1.160|\n        LDR      r1,[r5,r4,LSL #3]\n        LDR      r0,[r6,r1,LSL #2]\n        CMP      r0,#0\n        MOVEQ    r2,r6\n        MOVEQ    r0,r5\n        BLEQ     dfs__FP5GraphiPi\n        ADD      r0,r5,r4,LSL #3\n        LDR      r4,[r0,#4]\n        CMN      r4,#1\n        BNE      |L1.160|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertex;\n    int next;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_VERTICES * MAX_VERTICES];\n    int head[MAX_VERTICES];\n    int edgeCount;\n    int vertexCount;\n} Graph;\n\nvoid initializeGraph(Graph* graph) {\n    graph->edgeCount = 0;\n    graph->vertexCount = 0;\n    for (int i = 0; i < MAX_VERTICES; ++i) {\n        graph->head[i] = -1;\n    }\n}\n\nvoid addEdge(Graph* graph, int u, int v) {\n    graph->edges[graph->edgeCount].vertex = v;\n    graph->edges[graph->edgeCount].next = graph->head[u];\n    graph->head[u] = graph->edgeCount;\n    graph->edgeCount++;\n\n}\n\nvoid dfs(Graph* graph, int u, int* visited) {\n    visited[u] = 1;\n    for (int i = graph->head[u]; i != -1; i = graph->edges[i].next) {\n        int v = graph->edges[i].vertex;\n        if (!visited[v]) {\n            dfs(graph, v, visited);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        BNE      |L1.340|\n        MOV      r0,#0x10\n        BL       __nw__FUi\n        CMP      r0,#0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r5,[r0,#0]\n        STR      r1,[r0,#0xc]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.340|\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.372|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.400|\n|L1.372|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.400|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.504|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.556|\n|L1.504|\n        CMP      r0,#1\n        BLE      |L1.548|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.592|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.548|\n        CMN      r0,#1\n        BGE      |L1.592|\n|L1.556|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.592|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.592|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    Node *left;\n    Node *right;\n    Node(int k) : key(k), height(1), left(NULL), right(NULL) {}\n};\n\nint height(Node *N) {\n    if (N == NULL) return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL) return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndecToBin__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,#0\n        MOV      r5,r0\n        CMP      r0,#0\n        BNE      |L1.48|\n        MOV      r0,#2\n        BL       malloc\n        MOV      r1,#0x30\n        STRB     r1,[r0,#0]\n        STRB     r6,[r0,#1]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.48|\n        BGE      |L1.80|\n        MOV      r0,#2\n        BL       malloc\n        MOV      r1,#0x2d\n        STRB     r1,[r0,#0]\n        STRB     r6,[r0,#1]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.80|\n        MOV      r0,r5\n        MOV      r4,#0\n|L1.88|\n        ADD      r0,r0,r0,LSR #31\n        MOV      r0,r0,ASR #1\n        CMP      r0,#0\n        ADD      r4,r4,#1\n        BGT      |L1.88|\n        ADD      r0,r4,#1\n        BL       malloc\n        STRB     r6,[r0,r4]\n        SUBS     r1,r4,#1\n        LDMMIFD  sp!,{r4-r6,lr}\n        BXMI     lr\n|L1.132|\n        MOV      r2,r5\n        ADD      r3,r5,r5,LSR #31\n        MOV      r5,r3,ASR #1\n        SUB      r2,r2,r5,LSL #1\n        ADD      r2,r2,#0x30\n        STRB     r2,[r0,r1]\n        SUBS     r1,r1,#1\n        BPL      |L1.132|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nchar* decToBin(int n) {\n    if (n == 0) {\n        char* result = (char*)malloc(2 * sizeof(char));\n        result[0] = '0';\n        result[1] = '\\0';\n        return result;\n    }\n    if (n < 0) {\n        char* result = (char*)malloc(2 * sizeof(char));\n        result[0] = '-';\n        result[1] = '\\0';\n        return result;\n\n    }\n    int temp = n;\n    int len = 0;\n    while (temp > 0) {\n        len++;\n        temp /= 2;\n    }\n    char* bin = (char*)malloc((len + 1) * sizeof(char));\n    bin[len] = '\\0';\n    for (int i = len - 1; i >= 0; i--) {\n        bin[i] = (n % 2) + '0';\n        n /= 2;\n    }\n    return bin;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\niterativePostorder__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,r5,lr}\n        SUB      sp,sp,#0x1c00\n        SUB      sp,sp,#0x344\n        MOV      r1,r0\n        ADD      r3,sp,#0xc00\n        ADD      r3,r3,#0x3a4\n        STR      r1,[sp,#0xfa4]\n        MOV      r0,#0\n        ADD      lr,sp,#4\n        MVN      r4,#0\n|L1.88|\n        MOV      r1,r0\n        LDR      r1,[r3,r1,LSL #2]\n        ADD      r4,r4,#1\n        STR      r1,[lr,r4,LSL #2]\n        LDR      r2,[r1,#4]\n        SUB      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r0,r0,#1\n        STRNE    r2,[r3,r0,LSL #2]\n        LDR      r1,[r1,#8]\n        CMP      r1,#0\n        ADDNE    r0,r0,#1\n        STRNE    r1,[r3,r0,LSL #2]\n        CMN      r0,#1\n        BNE      |L1.88|\n        CMN      r4,#1\n        ADDEQ    sp,sp,#0x1c00\n        ADDEQ    sp,sp,#0x344\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        MOV      r5,lr\n|L1.172|\n        MOV      r0,r4\n        LDR      r0,[r5,r0,LSL #2]\n        SUB      r4,r4,#1\n        LDR      r1,[r0,#0]\n        ADR      r0,|L1.220|\n        BL       _printf\n        CMN      r4,#1\n        BNE      |L1.172|\n        ADD      sp,sp,#0x1c00\n        ADD      sp,sp,#0x344\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n|L1.220|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid iterativePostorder(struct Node* root) {\n    if (root == NULL)\n        return;\n\n    struct Node* stack1[1000];\n    struct Node* stack2[1000];\n    int top1 = -1;\n    int top2 = -1;\n\n    stack1[++top1] = root;\n    while (top1 != -1) {\n        struct Node* node = stack1[top1--];\n        stack2[++top2] = node;\n\n        if (node->left)\n            stack1[++top1] = node->left;\n        if (node->right)\n            stack1[++top1] = node->right;\n    }\n\n    while (top2 != -1) {\n        printf(\"%d \", stack2[top2--]->data);\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncombinations__FPciT1T2 PROC\n|L1.0|\n        STMFD    sp!,{r4-r8,lr}\n        CMP      r1,r3\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,r2\n        MOVEQ    r1,r4\n        MOV      r7,r3\n        LDMEQFD  sp!,{r4-r8,lr}\n        ADREQ    r0,|L1.124|\n        BEQ      _printf\n        ADD      r1,r5,#1\n        MOV      r8,r1\n        MOV      r3,r7\n        MOV      r2,r4\n        MOV      r0,r6\n        BL       combinations__FPciT1T2\n        MOV      r0,r4\n        BL       strlen\n        LDRB     r1,[r6,r5]\n        STRB     r1,[r4,r0]\n        MOV      r0,r4\n        BL       strlen\n        ADD      r0,r0,r4\n        MOV      r1,#0\n        STRB     r1,[r0,#1]\n        MOV      r1,r8\n        MOV      r0,r6\n        MOV      r3,r7\n        MOV      r2,r4\n        LDMFD    sp!,{r4-r8,lr}\n        B        combinations__FPciT1T2\n|L1.124|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid combinations(char *str, int index, char *current, int length) {\n    if (index == length) {\n        printf(\"%s\\n\", current);\n        return;\n    }\n    combinations(str, index + 1, current, length);\n    current[strlen(current)] = str[index];\n    current[strlen(current) + 1] = '\\0';\n    combinations(str, index + 1, current, length);\n\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nstringLength__FPc PROC\n|L1.0|\n        LDRB     r2,[r0,#0]\n        MOV      r1,r0\n        CMP      r2,#0\n        BEQ      |L1.28|\n|L1.16|\n        LDRB     r2,[r1,#1]!\n        CMP      r2,#0\n        BNE      |L1.16|\n|L1.28|\n        SUB      r0,r1,r0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint stringLength(char* str) {\n    char* ptr = str;\n    while (*ptr != '\\0') {\n        ptr++;\n    }\n    return ptr - str;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateRNN__Fv PROC\n        STMFD    sp!,{r4-r8,lr}\n        MOV      r0,#0x364\n        ADD      r0,r0,#0x800\n        BL       malloc\n        MOVS     r7,r0\n        LDMEQFD  sp!,{r4-r8,lr}\n        BXEQ     lr\n        MOV      r5,#0\n        MOV      r8,#0x30000000\n|L1.36|\n        ADD      r0,r5,r5,LSL #3\n        ADD      r0,r0,r0,LSL #1\n        ADD      r6,r7,r0,LSL #2\n        MOV      r4,#0\n|L1.52|\n        BL       rand\n        BL       _fflt\n        MOV      r1,r8\n        BL       _fmul\n        STR      r0,[r6,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,#0x1b\n        BLT      |L1.52|\n        ADD      r5,r5,#1\n        CMP      r5,#0x1b\n        BLT      |L1.36|\n        MOV      r0,r7\n        LDMFD    sp!,{r4-r8,lr}\n        BX       lr\n        ENDP\n\nfreeRNN__FP3RNN PROC\n        B        free\n        ENDP\n\ncharToInt__Fc PROC\n        CMP      r0,#0x20\n        SUBNE    r0,r0,#0x61\n        MOVEQ    r0,#0x1a\n        BX       lr\n        ENDP\n\nintToChar__Fi PROC\n        CMP      r0,#0x1a\n        ADDNE    r0,r0,#0x61\n        ANDNE    r0,r0,#0xff\n        MOVEQ    r0,#0x20\n        BX       lr\n        ENDP\n\ngenerateText__FP3RNNPci PROC\n        STMFD    sp!,{r0-r2,r4-r11,lr}\n        SUB      sp,sp,#0x70\n        MOV      r11,r1\n        MOV      r10,r2\n        MOV      r0,#0x20\n        BL       charToInt__Fc\n        MOV      r6,#0\n        CMP      r10,#0\n        BLE      |L1.404|\n        ADD      r8,sp,#4\n|L1.188|\n        ADD      r0,r0,r0,LSL #3\n        LDR      r2,[sp,#0x70]\n        ADD      r0,r0,r0,LSL #1\n        ADD      r2,r2,r0,LSL #2\n        MOV      r1,#0\n|L1.208|\n        LDR      r0,[r2,r1,LSL #2]\n        STR      r0,[r8,r1,LSL #2]\n        ADD      r1,r1,#1\n        CMP      r1,#0x1b\n        BLT      |L1.208|\n        MOV      r5,#0\n        MOV      r4,#0\n|L1.236|\n        LDR      r1,[r8,r4,LSL #2]\n        MOV      r0,r5\n        BL       _fadd\n        ADD      r4,r4,#1\n        CMP      r4,#0x1b\n        MOV      r5,r0\n        BLT      |L1.236|\n        MOV      r4,#0\n|L1.268|\n        LDR      r0,[r8,r4,LSL #2]\n        MOV      r1,r5\n        BL       _fdiv\n        STR      r0,[r8,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,#0x1b\n        BLT      |L1.268|\n        BL       rand\n        BL       _fflt\n        MOV      r1,#0x30000000\n        BL       _fmul\n        MOV      r9,r0\n        MOV      r5,#0\n        MOV      r7,#0\n        MOV      r4,#0\n|L1.328|\n        LDR      r1,[r8,r4,LSL #2]\n        MOV      r0,r5\n        BL       _fadd\n        MOV      r5,r0\n        MOV      r1,r0\n        MOV      r0,r9\n        BL       _fcmple\n        MOVCC    r7,r4\n        BCC      |L1.376|\n        ADD      r4,r4,#1\n        CMP      r4,#0x1b\n        BLT      |L1.328|\n|L1.376|\n        MOV      r0,r7\n        BL       intToChar__Fi\n        STRB     r0,[r11,r6]\n        ADD      r6,r6,#1\n        CMP      r6,r10\n        MOV      r0,r7\n        BLT      |L1.188|\n|L1.404|\n        MOV      r0,#0\n        STRB     r0,[r11,r10]\n        ADD      sp,sp,#0x7c\n        LDMFD    sp!,{r4-r11,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SEQ_LEN 100\n#define VOCAB_SIZE 27 // a-z + space\n\ntypedef struct {\n    float weights[VOCAB_SIZE][VOCAB_SIZE];\n} RNN;\n\n\nRNN* createRNN() {\n    RNN* rnn = (RNN*)malloc(sizeof(RNN));\n    if (rnn == NULL) return NULL;\n    for (int i = 0; i < VOCAB_SIZE; ++i) {\n        for (int j = 0; j < VOCAB_SIZE; ++j) {\n            rnn->weights[i][j] = (float)rand() / RAND_MAX;\n        }\n    }\n    return rnn;\n}\n\nvoid freeRNN(RNN* rnn) {\n    free(rnn);\n}\n\nint charToInt(char c) {\n    if (c == ' ') return 26;\n    return c - 'a';\n}\n\nchar intToChar(int i) {\n    if (i == 26) return ' ';\n    return i + 'a';\n}\n\nvoid generateText(RNN* rnn, char* text, int len) {\n    int prevChar = charToInt(' ');\n    for (int i = 0; i < len; ++i) {\n        float probabilities[VOCAB_SIZE];\n        for (int j = 0; j < VOCAB_SIZE; ++j) {\n            probabilities[j] = rnn->weights[prevChar][j];\n        }\n\n        float sum = 0;\n        for (int j = 0; j < VOCAB_SIZE; ++j) {\n            sum += probabilities[j];\n        }\n        for (int j = 0; j < VOCAB_SIZE; ++j) {\n            probabilities[j] /= sum;\n        }\n\n        float random = (float)rand() / RAND_MAX;\n        float cumulative = 0;\n        int nextChar = 0;\n        for (int j = 0; j < VOCAB_SIZE; ++j) {\n            cumulative += probabilities[j];\n            if (random < cumulative) {\n                nextChar = j;\n                break;\n            }\n        }\n        text[i] = intToChar(nextChar);\n        prevChar = nextChar;\n\n    }\n    text[len] = '\\0';\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nprintPath__FPii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        MOV      r5,r1\n        MOV      r4,#0\n        CMP      r1,#0\n        BLE      |L1.88|\n|L1.64|\n        LDR      r1,[r6,r4,LSL #2]\n        ADR      r0,|L1.100|\n        BL       _printf\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.64|\n|L1.88|\n        ADR      r0,|L1.104|\n        LDMFD    sp!,{r4-r6,lr}\n        B        _printf\n|L1.100|\n        DCB      \"%d \\0\"\n|L1.104|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n\nfindPaths__FP4NodePii PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        ADD      r6,r2,#1\n        STR      r0,[r5,r2,LSL #2]\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        MOVEQ    r1,r6\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r4-r6,lr}\n        BEQ      printPath__FPii\n        MOV      r2,r6\n        MOV      r1,r5\n        BL       findPaths__FP4NodePii\n        MOV      r2,r6\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        LDMFD    sp!,{r4-r6,lr}\n        B        findPaths__FP4NodePii\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid printPath(int path[], int pathLen) {\n    for (int i = 0; i < pathLen; i++)\n        printf(\"%d \", path[i]);\n    printf(\"\\n\");\n}\n\n\nvoid findPaths(struct Node* node, int path[], int pathLen) {\n    if (node == NULL) return;\n\n    path[pathLen] = node->data;\n    pathLen++;\n\n    if (node->left == NULL && node->right == NULL)\n        printPath(path, pathLen);\n    else {\n        findPaths(node->left, path, pathLen);\n        findPaths(node->right, path, pathLen);\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsphereVolume__Fd PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#3\n        MOV      r5,r1\n        BL       _dflt\n        MOV      r2,r0\n        MOV      r3,r1\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       __softfp_pow\n        ADR      r2,|L1.60|\n        LDMIA    r2,{r2,r3}\n        ADD      sp,sp,#4\n        LDMFD    sp!,{r4,r5,lr}\n        B        _dmul\n|L1.60|\n        DCFD     0x4010c152382d7365\n        ENDP\n```",
        "output": "```cpp\n\ndouble sphereVolume(double radius) {\n    return (4.0/3.0) * 3.14159265358979323846 * pow(radius, 3);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitialize_graph__FP5Graphi PROC\n        MOV      r3,#0\n        STR      r1,[r0,#0]\n        CMP      r1,#0\n        BXLE     lr\n        STMFD    sp!,{r4,lr}\n        MOV      lr,#0\n|L1.24|\n        MOV      r2,#0\n        CMP      r1,#0\n        BLE      |L1.68|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r12,r0,r12,LSL #4\n|L1.48|\n        ADD      r4,r12,r2,LSL #2\n        ADD      r2,r2,#1\n        CMP      r2,r1\n        STR      lr,[r4,#4]\n        BLT      |L1.48|\n|L1.68|\n        ADD      r3,r3,#1\n        CMP      r3,r1\n        BLT      |L1.24|\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP5GraphiT2 PROC\n        ADD      r12,r1,r1,LSL #3\n        ADD      r12,r12,r1,LSL #4\n        ADD      r12,r0,r12,LSL #4\n        ADD      r12,r12,r2,LSL #2\n        MOV      r3,#1\n        STR      r3,[r12,#4]\n        ADD      r12,r2,r2,LSL #3\n        ADD      r2,r12,r2,LSL #4\n        ADD      r0,r0,r2,LSL #4\n        ADD      r0,r0,r1,LSL #2\n        STR      r3,[r0,#4]\n        BX       lr\n        ENDP\n\ndfs__FP5GraphiPi PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        STR      r0,[r2,r1,LSL #2]\n        LDR      r0,[r5,#0]\n        MOV      r6,r2\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r0,r1,r1,LSL #3\n        ADD      r0,r0,r1,LSL #4\n        ADD      r7,r5,r0,LSL #4\n|L1.188|\n        ADD      r0,r7,r4,LSL #2\n        LDR      r0,[r0,#4]\n        CMP      r0,#0\n        BEQ      |L1.232|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.232|\n        MOV      r2,r6\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       dfs__FP5GraphiPi\n|L1.232|\n        LDR      r0,[r5,#0]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.188|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nbfs__FP5Graphi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOV      r1,#0x190\n        SUB      sp,sp,#0x320\n        ADD      r5,sp,r1\n        MOV      r4,r0\n        MOV      r0,r5\n        BL       __rt_memclr_w\n        MOV      r3,#1\n        STR      r6,[sp,#0]\n        STR      r3,[r5,r6,LSL #2]\n        MOV      r2,#0\n        MOV      r1,#1\n        MOV      lr,sp\n|L1.312|\n        MOV      r0,r2\n        LDR      r6,[lr,r0,LSL #2]\n        LDR      r12,[r4,#0]\n        MOV      r0,#0\n        ADD      r2,r2,#1\n        CMP      r12,#0\n        BLE      |L1.412|\n        ADD      r12,r6,r6,LSL #3\n        ADD      r12,r12,r6,LSL #4\n        ADD      r6,r4,r12,LSL #4\n|L1.352|\n        ADD      r12,r6,r0,LSL #2\n        LDR      r12,[r12,#4]\n        CMP      r12,#0\n        BEQ      |L1.396|\n        LDR      r12,[r5,r0,LSL #2]\n        CMP      r12,#0\n        BNE      |L1.396|\n        MOV      r12,r1\n        STR      r3,[r5,r0,LSL #2]\n        STR      r0,[lr,r12,LSL #2]\n        ADD      r1,r1,#1\n|L1.396|\n        LDR      r12,[r4,#0]\n        ADD      r0,r0,#1\n        CMP      r12,r0\n        BGT      |L1.352|\n|L1.412|\n        CMP      r2,r1\n        BLT      |L1.312|\n        ADD      sp,sp,#0x320\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices;\n    int adj_matrix[MAX_VERTICES][MAX_VERTICES];\n} Graph;\n\nvoid initialize_graph(Graph* g, int vertices) {\n    g->vertices = vertices;\n    for (int i = 0; i < vertices; i++) {\n        for (int j = 0; j < vertices; j++) {\n            g->adj_matrix[i][j] = 0;\n        }\n    }\n}\n\nvoid add_edge(Graph* g, int u, int v) {\n    g->adj_matrix[u][v] = 1;\n    g->adj_matrix[v][u] = 1;\n}\n\n\nvoid dfs(Graph* g, int v, int* visited) {\n    visited[v] = 1;\n    for (int i = 0; i < g->vertices; i++) {\n        if (g->adj_matrix[v][i] && !visited[i]) {\n            dfs(g, i, visited);\n        }\n    }\n}\n\nvoid bfs(Graph* g, int start_node) {\n    int visited[MAX_VERTICES] = {0};\n    int queue[MAX_VERTICES];\n    int head = 0, tail = 0;\n\n    queue[tail++] = start_node;\n    visited[start_node] = 1;\n\n    while (head < tail) {\n        int u = queue[head++];\n        for (int v = 0; v < g->vertices; v++) {\n            if (g->adj_matrix[u][v] && !visited[v]) {\n                visited[v] = 1;\n                queue[tail++] = v;\n            }\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncountLeafNodes__FP4Node PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#4]\n        CMP      r0,#0\n        LDREQ    r1,[r4,#8]\n        CMPEQ    r1,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        BL       countLeafNodes__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#8]\n        BL       countLeafNodes__FP4Node\n        ADD      r0,r5,r0\n        LDMFD    sp!,{r4,r5,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(NULL), right(NULL) {}\n};\n\nint countLeafNodes(Node* root) {\n    if (root == NULL) return 0;\n    if (root->left == NULL && root->right == NULL) return 1;\n    return countLeafNodes(root->left) + countLeafNodes(root->right);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfirst_bit_set__FUi PROC\n        CMP      r0,#0\n        BXEQ     lr\n        MOV      r1,#0\n        TST      r0,#1\n        BNE      |L1.36|\n|L1.20|\n        MOV      r0,r0,LSR #1\n        TST      r0,#1\n        ADD      r1,r1,#1\n        BEQ      |L1.20|\n|L1.36|\n        ADD      r0,r1,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned int first_bit_set(unsigned int n) {\n    if (n == 0) return 0;\n    unsigned int pos = 0;\n    while (!(n & 1)) {\n        n >>= 1;\n        pos++;\n    }\n    return pos + 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nswap__FPcT1 PROC\n|L1.0|\n        LDRB     r3,[r1,#0]\n        LDRB     r2,[r0,#0]\n        STRB     r3,[r0,#0]\n        STRB     r2,[r1,#0]\n        BX       lr\n        ENDP\n\npermute__FPciT2 PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r0\n        CMP      r1,r2\n        MOVEQ    r1,r5\n        MOV      r7,r2\n        LDMEQFD  sp!,{r3-r9,lr}\n        ADREQ    r0,|L1.136|\n        BEQ      _printf\n        MOV      r4,r1\n        LDMGTFD  sp!,{r3-r9,lr}\n        BXGT     lr\n        ADD      r9,r1,#1\n        ADD      r8,r5,r1\n|L1.72|\n        ADD      r6,r5,r4\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        MOV      r2,r7\n        MOV      r1,r9\n        MOV      r0,r5\n        BL       permute__FPciT2\n        MOV      r1,r6\n        MOV      r0,r8\n        BL       swap__FPcT1\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLE      |L1.72|\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.136|\n        DCB      \"%s\\n\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nvoid swap(char *x, char *y) {\n    char t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid permute(char *a, int l, int r) {\n    if (l == r) {\n        printf(\"%s\\n\", a);\n    } else {\n        for (int i = l; i <= r; i++) {\n            swap((a + l), (a + i));\n            permute(a, l + 1, r);\n            swap((a + l), (a + i)); \n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nSet_init__FP3Set PROC\n        MOV      r1,#0x80\n        B        __rt_memclr_w\n        ENDP\n\nSet_add__FP3Seti PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        BLT      |L1.32|\n        CMP      r1,#0x400\n        BLT      |L1.44|\n|L1.32|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.44|\n        MOV      r0,r1,ASR #31\n        ADD      r0,r1,r0,LSR #26\n        MOV      r4,r0,ASR #6\n        SUB      r2,r1,r4,LSL #6\n        ADR      r0,|L1.112|\n        LDMIA    r0,{r0,r1}\n        BL       _ll_shift_l\n        MOV      r2,r0\n        MOV      r3,r1\n        ADD      r4,r5,r4,LSL #3\n        LDMIA    r4,{r0,r1}\n        ORR      r0,r0,r2\n        ORR      r1,r1,r3\n        STMIA    r4,{r0,r1}\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.112|\n        DCQ      0x0000000000000001\n        ENDP\n\nSet_contains__FPC3Seti PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        BLT      |L1.144|\n        CMP      r1,#0x400\n        BLT      |L1.156|\n|L1.144|\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.156|\n        MOV      r0,r1,ASR #31\n        ADD      r0,r1,r0,LSR #26\n        MOV      r4,r0,ASR #6\n        SUB      r2,r1,r4,LSL #6\n        ADR      r0,|L1.112|\n        LDMIA    r0,{r0,r1}\n        BL       _ll_shift_l\n        MOV      r3,r1\n        ADD      r1,r5,r4,LSL #3\n        MOV      r2,r0\n        LDMIA    r1,{r0,r1}\n        AND      r0,r0,r2\n        ADR      r2,|L1.240|\n        AND      r1,r1,r3\n        LDMIA    r2,{r2,r3}\n        CMP      r1,r3\n        CMPEQ    r0,r2\n        LDMFD    sp!,{r3-r5,lr}\n        MOVEQ    r0,#0\n        MOVNE    r0,#1\n        BX       lr\n|L1.240|\n        DCQ      0x0000000000000000\n        ENDP\n```",
        "output": "```cpp\n\n#define BIT_VECTOR_SIZE 1024\n\ntypedef unsigned long long bitvector_t;\n\nstruct Set {\n    bitvector_t bits[BIT_VECTOR_SIZE / 64];\n};\n\n\nvoid Set_init(struct Set* set) {\n    memset(set->bits, 0, sizeof(set->bits));\n}\n\nint Set_add(struct Set* set, int value) {\n    if (value < 0 || value >= BIT_VECTOR_SIZE) return 0;\n    set->bits[value / 64] |= (1ULL << (value % 64));\n    return 1;\n}\n\nint Set_contains(const struct Set* set, int value) {\n    if (value < 0 || value >= BIT_VECTOR_SIZE) return 0;\n    return (set->bits[value / 64] & (1ULL << (value % 64))) != 0;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nhash__FPCc PROC\n|L1.0|\n        MOV      r2,r0\n        LDRB     r1,[r2],#1\n        MOV      r0,#5\n        ADD      r0,r0,#0x1500\n        CMP      r1,#0\n        BXEQ     lr\n|L1.24|\n        ADD      r0,r0,r0,LSL #5\n        ADD      r0,r0,r1\n        LDRB     r1,[r2],#1\n        CMP      r1,#0\n        BNE      |L1.24|\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nunsigned long hash(const char* str) {\n    unsigned long hashValue = 5381;\n    int c;\n    while ((c = *str++)) {\n        hashValue = ((hashValue << 5) + hashValue) + c;\n    }\n    return hashValue;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nfactorial__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        CMP      r0,#0\n        ADRLT    r1,|L1.92|\n        MOV      r5,r0\n        LDMLTIA  r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n        MOV      r4,#2\n        CMP      r5,#2\n        ADR      r1,|L1.100|\n        LDMIA    r1,{r0,r1}\n        LDMLTFD  sp!,{r3-r5,lr}\n        BXLT     lr\n|L1.52|\n        UMULL    lr,r12,r0,r4\n        MLA      r12,r4,r1,r12\n        MOV      r3,r4,ASR #31\n        MLA      r1,r3,r0,r12\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        MOV      r0,lr\n        BLE      |L1.52|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.92|\n        DCQ      0xffffffffffffffff\n|L1.100|\n        DCQ      0x0000000000000001\n        ENDP\n```",
        "output": "```cpp\n\nlong long factorial(int n) {\n    if (n < 0) {\n        return -1; // Error: Factorial is not defined for negative numbers\n    }\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreate_graph__Fi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r6,r0\n        MOV      r0,#8\n        BL       malloc\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        STR      r6,[r5,#4]\n        MOV      r0,r6,LSL #2\n        BL       malloc\n        STR      r0,[r5,#0]\n        CMP      r0,#0\n        BNE      |L1.72|\n        MOV      r0,r5\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.72|\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.216|\n        MOV      r7,#0\n|L1.88|\n        MOV      r0,#0xc\n        BL       malloc\n        LDR      r1,[r5,#0]\n        CMP      r0,#0\n        STR      r0,[r1,r4,LSL #2]\n        BNE      |L1.176|\n        MOV      r6,#0\n        CMP      r4,#0\n        BLE      |L1.148|\n|L1.124|\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r6,LSL #2]\n        BL       free\n        ADD      r6,r6,#1\n        CMP      r6,r4\n        BLT      |L1.124|\n|L1.148|\n        LDR      r0,[r5,#0]\n        BL       free\n        MOV      r0,r5\n        BL       free\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.176|\n        STR      r4,[r0,#0]\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        STR      r7,[r0,#8]\n        LDR      r0,[r5,#0]\n        LDR      r0,[r0,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        STR      r7,[r0,#4]\n        BLT      |L1.88|\n|L1.216|\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n\nadd_edge__FP6_GraphiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r2\n        MOV      r5,r1\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r5,#0\n        LDRGE    r0,[r4,#4]\n        CMPGE    r0,r5\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        CMP      r6,#0\n        CMPGE    r0,r6\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[r0,#8]!\n        ADD      r1,r1,#1\n        STR      r1,[r0,#0]\n        LDR      r0,[r4,#0]\n        LDR      r0,[r0,r5,LSL #2]\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#4]\n        MOV      r1,r1,LSL #2\n        BL       realloc\n        LDR      r1,[r4,#0]\n        CMP      r0,#0\n        LDR      r1,[r1,r5,LSL #2]\n        STR      r0,[r1,#4]\n        LDR      r1,[r4,#0]\n        LDR      r2,[r1,r5,LSL #2]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        LDR      r2,[r2,#8]\n        LDR      r1,[r1,r6,LSL #2]\n        ADD      r0,r0,r2,LSL #2\n        STR      r1,[r0,#-4]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct _Node {\n    int data;\n    struct _Node** adj;\n    int adj_count;\n} Node;\n\ntypedef struct _Graph {\n    Node** nodes;\n    int node_count;\n} Graph;\n\nGraph* create_graph(int node_count) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    if (graph == NULL) return NULL;\n    graph->node_count = node_count;\n    graph->nodes = (Node**)malloc(sizeof(Node*) * node_count);\n    if (graph->nodes == NULL) {\n        free(graph);\n        return NULL;\n    }\n    for (int i = 0; i < node_count; i++) {\n        graph->nodes[i] = (Node*)malloc(sizeof(Node));\n        if (graph->nodes[i] == NULL) {\n            for (int j = 0; j < i; j++) free(graph->nodes[j]);\n            free(graph->nodes);\n            free(graph);\n            return NULL;\n        }\n        graph->nodes[i]->data = i;\n        graph->nodes[i]->adj_count = 0;\n        graph->nodes[i]->adj = NULL;\n    }\n    return graph;\n}\n\n\nvoid add_edge(Graph* graph, int src, int dest) {\n    if (graph == NULL || src < 0 || src >= graph->node_count || dest < 0 || dest >= graph->node_count) return;\n    graph->nodes[src]->adj_count++;\n    graph->nodes[src]->adj = (Node**)realloc(graph->nodes[src]->adj, sizeof(Node*) * graph->nodes[src]->adj_count);\n    if (graph->nodes[src]->adj == NULL) return;\n    graph->nodes[src]->adj[graph->nodes[src]->adj_count - 1] = graph->nodes[dest];\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisPalindrome__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r6,r0\n        BL       strlen\n        SUB      r4,r0,#1\n        CMP      r4,#0\n        MOV      r8,r0\n        MOV      r5,#0\n        BLE      |L1.172|\n        BL       __rt_ctype_table\n        MOV      r7,r0\n        B        |L1.48|\n|L1.44|\n        ADD      r5,r5,#1\n|L1.48|\n        CMP      r5,r8\n        BGE      |L1.84|\n        LDRB     r1,[r6,r5]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.44|\n        B        |L1.84|\n|L1.80|\n        SUB      r4,r4,#1\n|L1.84|\n        CMP      r4,#0\n        BLT      |L1.112|\n        LDRB     r1,[r6,r4]\n        LDR      r0,[r7,#0]\n        LDRB     r0,[r0,r1]\n        TST      r0,#0x38\n        BEQ      |L1.80|\n|L1.112|\n        CMP      r5,r4\n        BGE      |L1.172|\n        LDRB     r0,[r6,r5]\n        BL       tolower\n        MOV      r9,r0\n        LDRB     r0,[r6,r4]\n        BL       tolower\n        CMP      r9,r0\n        LDMNEFD  sp!,{r3-r9,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        ADD      r5,r5,#1\n        SUB      r4,r4,#1\n        CMP      r5,r4\n        BLT      |L1.48|\n|L1.172|\n        LDMFD    sp!,{r3-r9,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint isPalindrome(char* str) {\n    int len = strlen(str);\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        while (i < len && !isalnum(str[i])) i++;\n        while (j >= 0 && !isalnum(str[j])) j--;\n        if (i >= j) break;\n        if (tolower(str[i]) != tolower(str[j])) return 0;\n        i++;\n        j--;\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nadd__FfT1 PROC\n        B        _fadd\n        ENDP\n\nsubtract__FfT1 PROC\n        B        _fsub\n        ENDP\n\nmultiply__FfT1 PROC\n        B        _fmul\n        ENDP\n\ndivide__FfT1 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r1\n        MOV      r6,r0\n        MOV      r5,#0\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       _fcmpeq\n        MOVNE    r1,r4\n        MOVNE    r0,r6\n        LDMNEFD  sp!,{r4-r6,lr}\n        BNE      _fdiv\n        ADR      r0,|L1.76|\n        BL       _printf\n        MOV      r0,r5\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.76|\n        DCB      \"Erro\"\n        DCB      \"r: D\"\n        DCB      \"ivis\"\n        DCB      \"ion \"\n        DCB      \"by z\"\n        DCB      \"ero\\n\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nfloat add(float a, float b) { return a + b; }\nfloat subtract(float a, float b) { return a - b; }\nfloat multiply(float a, float b) { return a * b; }\nfloat divide(float a, float b) { \n    if (b == 0) {\n        printf(\"Error: Division by zero\\n\");\n        return 0; \n    }\n    return a / b;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nrectangle_area__FiT1 PROC\n        CMP      r0,#0\n        CMPGE    r1,#0\n        MVNLT    r0,#0\n        MULGE    r0,r1,r0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint rectangle_area(int length, int width) {\n    if (length < 0 || width < 0) {\n        return -1; // Indicate an error\n    }\n    return length * width;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisVowelOrConsonant__Fc PROC\n        STMFD    sp!,{r4,lr}\n        BL       tolower\n        AND      r4,r0,#0xff\n        CMP      r4,#0x61\n        CMPNE    r4,#0x65\n        CMPNE    r4,#0x69\n        CMPNE    r4,#0x6f\n        CMPNE    r4,#0x75\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        BL       __rt_ctype_table\n        LDR      r0,[r0,#0]\n        LDRB     r0,[r0,r4]\n        LDMFD    sp!,{r4,lr}\n        TST      r0,#0x18\n        MVNEQ    r0,#0\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint isVowelOrConsonant(char c) {\n    c = tolower(c);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n        return 1; \n    } else if (isalpha(c)) {\n        return 0; \n    } else {\n        return -1; \n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__FiT1 PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        MOV      r5,r1\n        LDR      r7,|L1.320|\n        MOV      r1,#1\n        STR      r1,[r7,r0,LSL #2]\n        CMP      r5,#0\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.324|\n        ADD      r6,r0,r1,LSL #4\n|L1.52|\n        LDR      r0,[r6,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r7,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.84|\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       dfs__FiT1\n|L1.84|\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.52|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint graph[MAX_VERTICES][MAX_VERTICES];\n\nvoid dfs(int v, int n) {\n    visited[v] = 1;\n    for (int i = 0; i < n; i++) {\n        if (graph[v][i] == 1 && visited[i] == 0) {\n            dfs(i, n);\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nisOpening__Fc PROC\n|L1.0|\n        CMP      r0,#0x28\n        CMPNE    r0,#0x5b\n        CMPNE    r0,#0x7b\n        MOVEQ    r0,#1\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\nisClosing__Fc PROC\n        CMP      r0,#0x29\n        CMPNE    r0,#0x5d\n        CMPNE    r0,#0x7d\n        MOVEQ    r0,#1\n        MOVNE    r0,#0\n        BX       lr\n        ENDP\n\nmatches__FcT1 PROC\n        CMP      r0,#0x28\n        CMPEQ    r1,#0x29\n        BEQ      |L1.88|\n        CMP      r0,#0x5b\n        CMPEQ    r1,#0x5d\n        BEQ      |L1.88|\n        CMP      r0,#0x7b\n        CMPEQ    r1,#0x7d\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.88|\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\nareParenthesesBalanced__FPc PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        LDRB     r0,[r0,#0]\n        SUB      sp,sp,#0x64\n        MVN      r2,#0\n        MOV      r3,#0\n        CMP      r0,#0\n        BEQ      |L1.296|\n        MOV      r5,sp\n|L1.132|\n        LDRB     r0,[r4,r3]\n        BL       isOpening__Fc\n        CMP      r0,#0\n        BEQ      |L1.184|\n        CMP      r2,#0x63\n        LDRLTB   r0,[r4,r3]\n        ADDLT    r2,r2,#1\n        STRLTB   r0,[r5,r2]\n        BLT      |L1.260|\n        ADD      sp,sp,#0x64\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.184|\n        LDRB     r0,[r4,r3]\n        BL       isClosing__Fc\n        CMP      r0,#0\n        BEQ      |L1.260|\n        CMN      r2,#1\n        ADDEQ    sp,sp,#0x64\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDRB     r1,[r4,r3]\n        LDRB     r0,[r5,r2]\n        BL       matches__FcT1\n        CMP      r0,#0\n        SUBNE    r2,r2,#1\n        BNE      |L1.260|\n        ADD      sp,sp,#0x64\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.260|\n        ADD      r3,r3,#1\n        LDRB     r0,[r4,r3]\n        CMP      r0,#0\n        BNE      |L1.132|\n        CMN      r2,#1\n        ADDNE    sp,sp,#0x64\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.296|\n        ADD      sp,sp,#0x64\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define STACK_SIZE 100\n\nint isOpening(char c) {\n    return c == '(' || c == '[' || c == '{';\n}\n\nint isClosing(char c) {\n    return c == ')' || c == ']' || c == '}';\n}\n\nint matches(char open, char close) {\n    return (open == '(' && close == ')') ||\n           (open == '[' && close == ']') ||\n           (open == '{' && close == '}');\n}\n\nint areParenthesesBalanced(char* expr) {\n    char stack[STACK_SIZE];\n    int top = -1;\n    int i = 0;\n\n    while (expr[i] != '\\0') {\n        if (isOpening(expr[i])) {\n            if (top >= STACK_SIZE - 1) return 0;\n            stack[++top] = expr[i];\n        } else if (isClosing(expr[i])) {\n            if (top == -1) return 0;\n            if (!matches(stack[top], expr[i])) return 0;\n            top--;\n        }\n        i++;\n    }\n    return top == -1;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fv PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r0,#0x10\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4,lr}\n        BXEQ     lr\n        MOV      r0,#0x28\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.64|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.64|\n        MOV      r0,#0\n        MVN      r1,#0\n        STMIB    r4,{r0,r1}\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#0xc]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        LDR      r0,[r0,#0xc]\n        CMP      r0,#0xa\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nenqueue__FP5Queuei PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r2,#8]\n        ADD      r0,r0,#1\n        LDR      r3,|L1.432|\n        SMULL    lr,r12,r3,r0\n        MOV      r3,r12,ASR #2\n        SUB      r3,r3,r3,ASR #31\n        SUB      r3,r3,r3,LSL #1\n        ADD      r3,r3,r3,LSL #2\n        ADD      r0,r0,r3,LSL #1\n        STR      r0,[r2,#8]\n        LDR      r3,[r2,#0]\n        STR      r1,[r3,r0,LSL #2]\n        LDR      r0,[r2,#0xc]\n        ADD      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndequeue__FP5QueuePi PROC\n        STR      lr,[sp,#-4]!\n        MOV      r2,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDRNE    lr,[sp],#4\n        MOVNE    r0,#0\n        BXNE     lr\n        LDMIA    r2,{r0,r3}\n        LDR      r0,[r0,r3,LSL #2]\n        STR      r0,[r1,#0]\n        LDR      r0,[r2,#4]\n        LDR      r1,|L1.432|\n        ADD      r0,r0,#1\n        SMULL    r12,r3,r1,r0\n        MOV      r1,r3,ASR #2\n        SUB      r1,r1,r1,ASR #31\n        SUB      r1,r1,r1,LSL #1\n        ADD      r1,r1,r1,LSL #2\n        ADD      r0,r0,r1,LSL #1\n        STR      r0,[r2,#4]\n        LDR      r0,[r2,#0xc]\n        SUB      r0,r0,#1\n        STR      r0,[r2,#0xc]\n        LDR      lr,[sp],#4\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\ndestroyQueue__FP5Queue PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\n#define QUEUE_SIZE 10\n\ntypedef struct {\n    int* data;\n    int head;\n    int tail;\n    int size;\n} Queue;\n\n\nQueue* createQueue() {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    if (q == NULL) return NULL;\n    q->data = (int*)malloc(sizeof(int) * QUEUE_SIZE);\n    if (q->data == NULL) {\n        free(q);\n        return NULL;\n    }\n    q->head = 0;\n    q->tail = -1;\n    q->size = 0;\n    return q;\n}\n\nint isEmpty(Queue* q) {\n    return q->size == 0;\n}\n\nint isFull(Queue* q) {\n    return q->size == QUEUE_SIZE;\n}\n\nint enqueue(Queue* q, int value) {\n    if (isFull(q)) return 0;\n    q->tail = (q->tail + 1) % QUEUE_SIZE;\n    q->data[q->tail] = value;\n    q->size++;\n    return 1;\n}\n\nint dequeue(Queue* q, int* value) {\n    if (isEmpty(q)) return 0;\n    *value = q->data[q->head];\n    q->head = (q->head + 1) % QUEUE_SIZE;\n    q->size--;\n    return 1;\n}\n\nvoid destroyQueue(Queue* q) {\n    free(q->data);\n    free(q);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nlevelOrder__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4-r7,lr}\n        SUB      sp,sp,#0xc00\n        SUB      sp,sp,#0x3a4\n        ADD      r7,sp,#4\n        STR      r0,[sp,#4]\n        MOV      r6,#0\n        MOV      r4,#1\n|L1.76|\n        MOV      r0,r6\n        LDR      r5,[r7,r0,LSL #2]\n        ADR      r0,|L1.164|\n        ADD      r6,r6,#1\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r1,[r5,#4]\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        LDR      r1,[r5,#8]\n        ADDNE    r4,r4,#1\n        CMP      r1,#0\n        MOVNE    r0,r4\n        STRNE    r1,[r7,r0,LSL #2]\n        ADDNE    r4,r4,#1\n        CMP      r6,r4\n        BNE      |L1.76|\n        ADD      sp,sp,#0xc00\n        ADD      sp,sp,#0x3a4\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n|L1.164|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid levelOrder(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node* queue[1000];\n    int front = 0, rear = 0;\n\n    queue[rear++] = root;\n\n    while (front != rear) {\n        struct Node* node = queue[front++];\n        printf(\"%d \", node->data);\n\n        if (node->left) queue[rear++] = node->left;\n        if (node->right) queue[rear++] = node->right;\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fci PROC\n|L1.0|\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        MOV      r5,r1\n        BL       malloc\n        STRB     r4,[r0,#0]\n        MOV      r1,#0\n        STR      r1,[r0,#0xc]\n        STR      r5,[r0,#4]\n        STR      r1,[r0,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nminHeapify__FPP4NodeiT2 PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        MOV      r0,#1\n        ADD      r0,r0,r1,LSL #1\n        MOV      r3,#2\n        ADD      r3,r3,r1,LSL #1\n        CMP      r0,r2\n        LDR      r12,[r4,r1,LSL #2]\n        MOV      r5,r1\n        BGE      |L1.108|\n        LDR      lr,[r4,r0,LSL #2]\n        LDR      lr,[lr,#4]\n        LDR      r6,[r12,#4]\n        CMP      lr,r6\n        MOVLT    r1,r0\n|L1.108|\n        CMP      r3,r2\n        BGE      |L1.140|\n        LDR      r0,[r4,r3,LSL #2]\n        LDR      lr,[r4,r1,LSL #2]\n        LDR      r0,[r0,#4]\n        LDR      lr,[lr,#4]\n        CMP      r0,lr\n        MOVLT    r1,r3\n|L1.140|\n        CMP      r1,r5\n        BEQ      |L1.168|\n        LDR      r0,[r4,r1,LSL #2]\n        STR      r12,[r4,r1,LSL #2]\n        STR      r0,[r4,r5,LSL #2]\n        MOV      r0,r4\n        BL       minHeapify__FPP4NodeiT2\n|L1.168|\n        LDR      r0,[r4,r5,LSL #2]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\nbuildHuffmanTree__FPii PROC\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r7,r0\n        MOV      r0,r1,LSL #2\n        MOV      r6,r1\n        BL       malloc\n        MOV      r5,r0\n        MOV      r4,#0\n        CMP      r6,#0\n        BLE      |L1.256|\n|L1.216|\n        LDR      r1,[r7,r4,LSL #2]\n        CMP      r1,#0\n        MOVLE    r0,#0\n        ADDGT    r0,r4,#0x61\n        AND      r0,r0,#0xff\n        BL       newNode__Fci\n        STR      r0,[r5,r4,LSL #2]\n        ADD      r4,r4,#1\n        CMP      r4,r6\n        BLT      |L1.216|\n|L1.256|\n        SUB      r7,r6,#1\n        ADD      r0,r7,r7,LSR #31\n        MOVS     r4,r0,ASR #1\n        BMI      |L1.296|\n|L1.272|\n        MOV      r2,r6\n        MOV      r1,r4\n        MOV      r0,r5\n        BL       minHeapify__FPP4NodeiT2\n        SUBS     r4,r4,#1\n        BPL      |L1.272|\n|L1.296|\n        CMP      r4,r7\n        BGE      |L1.420|\n|L1.304|\n        SUB      r9,r6,#1\n        MOV      r2,r6\n        MOV      r1,#0\n        LDR      r7,[r5,#0]\n        MOV      r0,r5\n        BL       minHeapify__FPP4NodeiT2\n        SUB      r6,r9,#1\n        MOV      r2,r9\n        MOV      r1,#0\n        LDR      r8,[r5,#0]\n        MOV      r0,r5\n        BL       minHeapify__FPP4NodeiT2\n        LDR      r0,[r7,#4]\n        LDR      r1,[r8,#4]\n        ADD      r1,r0,r1\n        MOV      r0,#0\n        BL       newNode__Fci\n        ADD      r2,r0,#8\n        STMIA    r2,{r7,r8}\n        ADD      r1,r5,r4,LSL #2\n        STR      r0,[r1,#4]\n        MOV      r1,#0\n        MOV      r0,r5\n        MOV      r2,r6\n        BL       minHeapify__FPP4NodeiT2\n        ADD      r4,r4,#1\n        SUB      r0,r6,#1\n        CMP      r4,r0\n        BLT      |L1.304|\n|L1.420|\n        LDR      r0,[r5,#0]\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n        ENDP\n\nprintCodes__FP4NodePii PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#8]\n        ADD      r7,r2,#1\n        MOV      r6,r1\n        MOV      r5,r2\n        CMP      r0,#0\n        BEQ      |L1.488|\n        MOV      r0,#0\n        STR      r0,[r6,r5,LSL #2]\n        LDR      r0,[r4,#8]\n        MOV      r2,r7\n        MOV      r1,r6\n        BL       printCodes__FP4NodePii\n|L1.488|\n        LDR      r0,[r4,#0xc]\n        CMP      r0,#0\n        BEQ      |L1.524|\n        MOV      r0,#1\n        STR      r0,[r6,r5,LSL #2]\n        LDR      r0,[r4,#0xc]\n        MOV      r2,r7\n        MOV      r1,r6\n        BL       printCodes__FP4NodePii\n|L1.524|\n        LDR      r0,[r4,#8]\n        CMP      r0,#0\n        LDREQ    r0,[r4,#0xc]\n        CMPEQ    r0,#0\n        LDMNEFD  sp!,{r3-r7,lr}\n        BXNE     lr\n        LDRB     r1,[r4,#0]\n        ADR      r0,|L1.608|\n        BL       _printf\n        MOV      r4,#0\n        CMP      r5,#0\n        BLE      |L1.596|\n|L1.572|\n        LDR      r1,[r6,r4,LSL #2]\n        ADR      r0,|L1.616|\n        BL       _printf\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.572|\n|L1.596|\n        ADR      r0,|L1.620|\n        LDMFD    sp!,{r3-r7,lr}\n        B        _printf\n|L1.608|\n        DCB      \"(%c)\"\n        DCB      \" : \\0\"\n|L1.616|\n        DCB      \"%d\\0\\0\"\n|L1.620|\n        DCB      \"\\n\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    char c;\n    int freq;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(char c, int freq) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->c = c;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct Node* minHeapify(struct Node** harr, int i, int heap_size) {\n    int smallest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < heap_size && harr[left]->freq < harr[smallest]->freq)\n        smallest = left;\n\n    if (right < heap_size && harr[right]->freq < harr[smallest]->freq)\n        smallest = right;\n\n    if (smallest != i) {\n        struct Node* temp = harr[smallest];\n        harr[smallest] = harr[i];\n        harr[i] = temp;\n        minHeapify(harr, smallest, heap_size);\n    }\n    return harr[i];\n}\n\nstruct Node* buildHuffmanTree(int freq[], int size) {\n    struct Node** harr = (struct Node**)malloc(size * sizeof(struct Node*));\n    for (int i = 0; i < size; i++)\n        harr[i] = newNode(freq[i] > 0 ? 'a'+i : '\\0', freq[i]);\n\n    int heap_size = size;\n    int i;\n    for (i = (heap_size - 1) / 2; i >= 0; i--)\n        minHeapify(harr, i, heap_size);\n\n    for (i; i < heap_size -1; i++){\n        struct Node* left = harr[0];\n        minHeapify(harr, 0, heap_size--);\n        struct Node* right = harr[0];\n        minHeapify(harr, 0, heap_size--);\n        struct Node* top = newNode('\\0', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        harr[i + 1] = top;\n        minHeapify(harr, 0, heap_size);\n    }\n    return harr[0];\n}\n\nvoid printCodes(struct Node* root, int arr[], int top) {\n    if (root->left) {\n        arr[top] = 0;\n        printCodes(root->left, arr, top + 1);\n    }\n\n    if (root->right) {\n        arr[top] = 1;\n        printCodes(root->right, arr, top + 1);\n    }\n\n    if (!root->left && !root->right){\n        printf(\"(%c) : \", root->c);\n        for (int i = 0; i < top; i++)\n            printf(\"%d\", arr[i]);\n        printf(\"\\n\");\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninit__FP5Stack PROC\n        MVN      r1,#0\n        STR      r1,[r0,#0x190]\n        MOV      r1,#0\n        STR      r1,[r0,#0x194]\n        STR      r1,[r0,#0x198]\n        BX       lr\n        ENDP\n\npush__FP5Stacki PROC\n        LDR      r2,[r0,#0x190]\n        CMP      r2,#0x63\n        MOVEQ    r1,#1\n        STREQ    r1,[r0,#0x194]\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r2,r2,#1\n        STR      r2,[r0,#0x190]\n        STR      r1,[r0,r2,LSL #2]\n        MOV      r0,#1\n        BX       lr\n        ENDP\n\npop__FP5StackPi PROC\n        LDR      r2,[r0,#0x190]\n        CMN      r2,#1\n        MOVEQ    r1,#1\n        STREQ    r1,[r0,#0x198]\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r2,[r0,r2,LSL #2]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#0x190]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#0x190]\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int data[MAX_SIZE];\n    int top;\n    int overflow;\n    int underflow;\n} Stack;\n\nvoid init(Stack *s) {\n    s->top = -1;\n    s->overflow = 0;\n    s->underflow = 0;\n}\n\nint push(Stack *s, int value) {\n    if (s->top == MAX_SIZE - 1) {\n        s->overflow = 1;\n        return 0;\n    }\n    s->top++;\n    s->data[s->top] = value;\n    return 1;\n}\n\nint pop(Stack *s, int *value) {\n    if (s->top == -1) {\n        s->underflow = 1;\n        return 0;\n    }\n    *value = s->data[s->top];\n    s->top--;\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nheight__FP4Node PROC\n        CMP      r0,#0\n        LDRNE    r0,[r0,#4]\n        MOVEQ    r0,#0\n        BX       lr\n        ENDP\n\nmax__FiT1 PROC\n        CMP      r0,r1\n        MOVLE    r0,r1\n        BX       lr\n        ENDP\n\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0x10\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#0xc]\n        MOV      r1,#1\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\nrightRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#8]\n        MOV      r3,r0\n        LDR      r0,[r2,#0xc]\n        STR      r3,[r2,#0xc]\n        STR      r0,[r3,#8]\n        LDR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\nleftRotate__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        LDR      r2,[r0,#0xc]\n        MOV      r3,r0\n        LDR      r0,[r2,#8]\n        STR      r3,[r2,#8]\n        STR      r0,[r3,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r3,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r3,#4]\n        LDR      r0,[r2,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r2,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r2,#4]\n        LDR      lr,[sp],#4\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngetBalance__FP4Node PROC\n        STR      lr,[sp,#-4]!\n        MOVS     r1,r0\n        LDREQ    lr,[sp],#4\n        BXEQ     lr\n        LDR      r0,[r1,#8]\n        BL       height__FP4Node\n        MOV      r2,r0\n        LDR      r0,[r1,#0xc]\n        BL       height__FP4Node\n        LDR      lr,[sp],#4\n        SUB      r0,r2,r0\n        BX       lr\n        ENDP\n\ninsert__FP4Nodei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOVS     r4,r0\n        MOVEQ    r0,r5\n        LDMEQFD  sp!,{r3-r5,lr}\n        BEQ      newNode__Fi\n        LDR      r0,[r4,#0]\n        CMP      r0,r5\n        BLE      |L1.376|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#8]\n        B        |L1.404|\n|L1.376|\n        MOVGE    r0,r4\n        LDMGEFD  sp!,{r3-r5,lr}\n        BXGE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#0xc]\n        BL       insert__FP4Nodei\n        STR      r0,[r4,#0xc]\n|L1.404|\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r1,r0\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        BL       max__FiT1\n        ADD      r0,r0,#1\n        STR      r0,[r4,#4]\n        MOV      r0,r4\n        BL       getBalance__FP4Node\n        CMP      r0,#1\n        LDRGT    r1,[r4,#8]\n        LDRGT    r1,[r1,#0]\n        CMPGT    r1,r5\n        MOVGT    r0,r4\n        LDMGTFD  sp!,{r3-r5,lr}\n        BGT      rightRotate__FP4Node\n        CMN      r0,#1\n        BGE      |L1.508|\n        LDR      r0,[r4,#0xc]\n        LDR      r0,[r0,#0]\n        CMP      r0,r5\n        MOVLT    r0,r4\n        LDMLTFD  sp!,{r3-r5,lr}\n        BLT      leftRotate__FP4Node\n        B        |L1.560|\n|L1.508|\n        CMP      r0,#1\n        BLE      |L1.552|\n        LDR      r0,[r4,#8]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BGE      |L1.596|\n        BL       leftRotate__FP4Node\n        STR      r0,[r4,#8]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        rightRotate__FP4Node\n|L1.552|\n        CMN      r0,#1\n        BGE      |L1.596|\n|L1.560|\n        LDR      r0,[r4,#0xc]\n        LDR      r1,[r0,#0]\n        CMP      r1,r5\n        BLE      |L1.596|\n        BL       rightRotate__FP4Node\n        STR      r0,[r4,#0xc]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        B        leftRotate__FP4Node\n|L1.596|\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ndiameter__FP4Node PROC\n        STMFD    sp!,{r4-r7,lr}\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r4-r7,lr}\n        BXEQ     lr\n        LDR      r0,[r4,#8]\n        BL       height__FP4Node\n        MOV      r6,r0\n        LDR      r0,[r4,#0xc]\n        BL       height__FP4Node\n        MOV      r7,r0\n        LDR      r0,[r4,#8]\n        BL       diameter__FP4Node\n        MOV      r5,r0\n        LDR      r0,[r4,#0xc]\n        BL       diameter__FP4Node\n        MOV      r1,r0\n        MOV      r0,r5\n        BL       max__FiT1\n        MOV      r1,r0\n        ADD      r0,r6,r7\n        ADD      r0,r0,#1\n        LDMFD    sp!,{r4-r7,lr}\n        B        max__FiT1\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int key;\n    int height;\n    struct Node *left;\n    struct Node *right;\n};\n\nint height(Node *N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1;\n    return node;\n}\n\nNode* rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nNode* leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    return node;\n}\n\n\nint diameter(Node *root) {\n    if (root == NULL) return 0;\n    int lh = height(root->left);\n    int rh = height(root->right);\n    int ld = diameter(root->left);\n    int rd = diameter(root->right);\n    return max(lh + rh + 1, max(ld, rd));\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nis_url__FPCc PROC\n|L1.0|\n        STMFD    sp!,{r3-r7,lr}\n        MOVS     r5,r0\n        BEQ      |L1.28|\n        MOV      r0,r5\n        BL       strlen\n        CMP      r0,#0\n        BNE      |L1.40|\n|L1.28|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.40|\n        MOV      r0,r5\n        BL       strlen\n        MOV      r7,r0\n        CMP      r0,#4\n        LDMLTFD  sp!,{r3-r7,lr}\n        MOVLT    r0,#0\n        BXLT     lr\n        MOV      r2,#7\n        MOV      r0,r5\n        ADR      r1,|L1.236|\n        BL       strncmp\n        CMP      r0,#0\n        MOVEQ    r4,#7\n        BEQ      |L1.132|\n        MOV      r2,#8\n        ADR      r1,|L1.244|\n        MOV      r0,r5\n        BL       strncmp\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        MOV      r4,#8\n|L1.132|\n        MOV      r6,#0\n        CMP      r4,r7\n        BGE      |L1.224|\n        BL       __rt_ctype_table\n|L1.148|\n        LDRB     r1,[r5,r4]\n        CMP      r1,#0x2e\n        ADDEQ    r6,r6,#1\n        BEQ      |L1.196|\n        LDR      r2,[r0,#0]\n        LDRB     r2,[r2,r1]\n        TST      r2,#0x38\n        BNE      |L1.196|\n        CMP      r1,#0x2d\n        LDMNEFD  sp!,{r3-r7,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n|L1.196|\n        ADD      r4,r4,#1\n        CMP      r4,r7\n        BLT      |L1.148|\n        CMP      r6,#1\n        LDMGEFD  sp!,{r3-r7,lr}\n        MOVGE    r0,#1\n        BXGE     lr\n|L1.224|\n        LDMFD    sp!,{r3-r7,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.236|\n        DCB      \"http\"\n        DCB      \"://\\0\"\n|L1.244|\n        DCB      \"http\"\n        DCB      \"s://\"\n        DCB      \"\\0\\0\\0\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nint is_url(const char* str) {\n    if (str == 0 || strlen(str) == 0) return 0;\n    int len = strlen(str);\n    if (len < 4) return 0;\n\n    int protocol_end = 0;\n    if (strncmp(str, \"http://\", 7) == 0) protocol_end = 7;\n    else if (strncmp(str, \"https://\", 8) == 0) protocol_end = 8;\n\n    if(protocol_end == 0) return 0;\n\n    int dot_count = 0;\n    for (int i = protocol_end; i < len; i++) {\n        if (str[i] == '.') dot_count++;\n        else if (!isalnum(str[i]) && str[i] != '-') return 0;\n\n    }\n\n    if(dot_count < 1) return 0;\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r6,|L1.344|\n        LDR      r7,|L1.348|\n        MOV      r1,#1\n        STR      r1,[r6,r0,LSL #2]\n        LDR      r1,[r7,#0]  ; numVertices\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.352|\n        ADD      r5,r0,r1,LSL #4\n|L1.56|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r6,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.84|\n        MOV      r0,r4\n        BL       dfs__Fi\n|L1.84|\n        LDR      r0,[r7,#0]  ; numVertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.56|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nisConnected__Fv PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.344|\n        MOV      r1,#0x190\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        BL       dfs__Fi\n        LDR      r1,|L1.348|\n        MOV      r0,#0\n        LDR      r1,[r1,#0]  ; numVertices\n        CMP      r1,#0\n        BLE      |L1.188|\n|L1.156|\n        LDR      r2,[r4,r0,LSL #2]\n        CMP      r2,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        ADD      r0,r0,#1\n        CMP      r0,r1\n        BLT      |L1.156|\n|L1.188|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint visited[MAX_VERTICES];\nint graph[MAX_VERTICES][MAX_VERTICES];\nint numVertices;\n\nvoid dfs(int vertex) {\n    visited[vertex] = 1;\n    for (int i = 0; i < numVertices; i++) {\n        if (graph[vertex][i] == 1 && visited[i] == 0) {\n            dfs(i);\n        }\n    }\n}\n\nint isConnected() {\n    memset(visited, 0, sizeof(visited));\n    dfs(0);\n    for (int i = 0; i < numVertices; i++) {\n        if (visited[i] == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateQueue__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0x14\n        BL       malloc\n        MOV      r1,#0\n        ADD      r2,r0,#8\n        STMIA    r2,{r1,r5}\n        STR      r1,[r0,#0]\n        SUB      r1,r5,#1\n        STR      r1,[r0,#4]\n        MOV      r4,r0\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0x10]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nisFull__FP5Queue PROC\n        LDR      r1,[r0,#8]\n        LDR      r0,[r0,#0xc]\n        CMP      r1,r0\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n\nisEmpty__FP5Queue PROC\n        LDR      r0,[r0,#8]\n        RSBS     r0,r0,#1\n        MOVCC    r0,#0\n        BX       lr\n        ENDP\n\nenqueue__FP5QueueP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r1\n        MOV      r4,r0\n        BL       isFull__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r5,lr}\n        BXNE     lr\n        LDR      r0,[r4,#4]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#4]\n        LDR      r0,[r4,#0x10]\n        STR      r5,[r0,r1,LSL #2]\n        LDR      r0,[r4,#8]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#8]\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\ndequeue__FP5Queue PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r5,lr}\n        MOVNE    r0,#0\n        BXNE     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r4,#0x10]\n        LDR      r5,[r1,r0,LSL #2]\n        ADD      r1,r0,#1\n        LDR      r0,[r4,#0xc]\n        BL       __rt_sdiv\n        STR      r1,[r4,#0]\n        LDR      r0,[r4,#8]\n        SUB      r0,r0,#1\n        STR      r0,[r4,#8]\n        MOV      r0,r5\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nlevelOrder__FP4Node PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,#0x3e8\n        BL       createQueue__Fi\n        MOV      r4,r0\n        MOV      r1,r5\n        BL       enqueue__FP5QueueP4Node\n        MOV      r0,r4\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        LDMNEFD  sp!,{r3-r5,lr}\n        BXNE     lr\n|L1.320|\n        MOV      r0,r4\n        BL       dequeue__FP5Queue\n        MOVS     r5,r0\n        BEQ      |L1.388|\n        ADR      r0,|L1.412|\n        LDR      r1,[r5,#0]\n        BL       _printf\n        LDR      r0,[r5,#4]\n        CMP      r0,#0\n        MOVNE    r1,r0\n        MOVNE    r0,r4\n        BLNE     enqueue__FP5QueueP4Node\n        LDR      r0,[r5,#8]\n        CMP      r0,#0\n        MOVNE    r1,r0\n        MOVNE    r0,r4\n        BLNE     enqueue__FP5QueueP4Node\n|L1.388|\n        MOV      r0,r4\n        BL       isEmpty__FP5Queue\n        CMP      r0,#0\n        BEQ      |L1.320|\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n|L1.412|\n        DCB      \"%d \\0\"\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct Node {\n    int data;\n    struct Node *left;\n    struct Node *right;\n} Node;\n\ntypedef struct Queue {\n    int front;\n    int rear;\n    int size;\n    int capacity;\n    Node **array;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->capacity = capacity;\n    queue->front = queue->size = 0;\n    queue->rear = capacity - 1;\n    queue->array = (Node**)malloc(queue->capacity * sizeof(Node*));\n    return queue;\n}\n\nint isFull(Queue* queue) {\n    return (queue->size == queue->capacity);\n}\n\nint isEmpty(Queue* queue) {\n    return (queue->size == 0);\n}\n\nvoid enqueue(Queue* queue, Node* item) {\n    if (isFull(queue))\n        return;\n    queue->rear = (queue->rear + 1) % queue->capacity;\n    queue->array[queue->rear] = item;\n    queue->size = queue->size + 1;\n}\n\nNode* dequeue(Queue* queue) {\n    if (isEmpty(queue))\n        return NULL;\n    Node* item = queue->array[queue->front];\n    queue->front = (queue->front + 1) % queue->capacity;\n    queue->size = queue->size - 1;\n    return item;\n}\n\n\nvoid levelOrder(Node *root) {\n    if(root == NULL) return;\n    Queue* queue = createQueue(1000);\n    enqueue(queue, root);\n    while (!isEmpty(queue)) {\n        Node* node = dequeue(queue);\n        if(node) {\n            printf(\"%d \", node->data);\n            if(node->left) enqueue(queue, node->left);\n            if(node->right) enqueue(queue, node->right);\n        }\n    }\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nnewNode__Fi PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOV      r1,#0\n        STR      r1,[r0,#8]\n        STR      r4,[r0,#0]\n        STR      r1,[r0,#4]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ngetWidth__FP4NodeiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOVS     r6,r0\n        MOV      r4,r2\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        ADD      r5,r1,#1\n        LDR      r0,[r4,#0]\n        MOV      r1,r5\n        CMP      r0,r5\n        STRLT    r5,[r4,#0]\n        LDR      r0,[r6,#4]\n        MOV      r2,r4\n        BL       getWidth__FP4NodeiPi\n        MOV      r2,r4\n        MOV      r1,r5\n        LDR      r0,[r6,#8]\n        BL       getWidth__FP4NodeiPi\n        LDR      r0,[r4,#0]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ngetMaxWidth__FP4Node PROC\n        CMP      r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r3,lr}\n        MOV      r1,#0\n        STR      r1,[sp,#0]\n        MOV      r2,sp\n        BL       getWidth__FP4NodeiPi\n        LDR      r0,[sp,#0]\n        LDMFD    sp!,{r3,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return (node);\n}\n\n\nint getWidth(struct Node* root, int level, int *maxWidth) {\n    if (root == NULL)\n        return 0;\n    if (level + 1 > *maxWidth)\n        *maxWidth = level + 1;\n    getWidth(root->left, level + 1, maxWidth);\n    getWidth(root->right, level + 1, maxWidth);\n    return *maxWidth;\n\n}\n\nint getMaxWidth(struct Node* root) {\n    if (root == NULL) return 0;\n    int maxWidth = 0;\n    getWidth(root, 0, &maxWidth);\n    return maxWidth;\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nareIdentical__FP4NodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r4,r0\n        ORRS     r0,r0,r1\n        MOV      r5,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        CMPNE    r5,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        LDR      r0,[r4,#0]\n        LDR      r1,[r5,#0]\n        CMP      r0,r1\n        BNE      |L1.112|\n        LDR      r1,[r5,#4]\n        LDR      r0,[r4,#4]\n        BL       areIdentical__FP4NodeT1\n        CMP      r0,#0\n        BEQ      |L1.112|\n        LDR      r1,[r5,#8]\n        LDR      r0,[r4,#8]\n        BL       areIdentical__FP4NodeT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n|L1.112|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#0\n        BX       lr\n        ENDP\n\nisSubtree__FP4NodeT1 PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOVS     r5,r1\n        MOV      r4,r0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#1\n        BXEQ     lr\n        CMP      r4,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n        MOV      r1,r5\n        MOV      r0,r4\n        BL       areIdentical__FP4NodeT1\n        CMP      r0,#0\n        LDMNEFD  sp!,{r4,r5,lr}\n        MOVNE    r0,#1\n        BXNE     lr\n        MOV      r1,r5\n        LDR      r0,[r4,#4]\n        BL       isSubtree__FP4NodeT1\n        CMP      r0,#0\n        BNE      |L1.236|\n        MOV      r1,r5\n        LDR      r0,[r4,#8]\n        BL       isSubtree__FP4NodeT1\n        CMP      r0,#0\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n|L1.236|\n        LDMFD    sp!,{r4,r5,lr}\n        MOV      r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) : data(data), left(0), right(0) {}\n};\n\nint areIdentical(Node *root1, Node *root2) {\n    if (root1 == 0 && root2 == 0) return 1;\n    if (root1 == 0 || root2 == 0) return 0;\n    return (root1->data == root2->data && areIdentical(root1->left, root2->left) && areIdentical(root1->right, root2->right));\n}\n\nint isSubtree(Node *T, Node *S) {\n    if (S == 0) return 1;\n    if (T == 0) return 0;\n    if (areIdentical(T, S)) return 1;\n    return isSubtree(T->left, S) || isSubtree(T->right, S);\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ngcd__FiT1 PROC\n|L1.0|\n        MOV      r2,r0\n        MOVS     r0,r1\n        STMFD    sp!,{r4,lr}\n        BEQ      |L1.40|\n|L1.16|\n        MOV      r4,r0\n        MOV      r1,r2\n        BL       __rt_sdiv\n        MOVS     r0,r1\n        MOV      r2,r4\n        BNE      |L1.16|\n|L1.40|\n        LDMFD    sp!,{r4,lr}\n        MOV      r0,r2\n        BX       lr\n        ENDP\n\ngcd_many__FiPi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r1\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        CMP      r5,#1\n        LDREQ    r0,[r6,#0]\n        LDMEQFD  sp!,{r4-r6,lr}\n        BXEQ     lr\n        MOV      r4,#1\n        LDR      r0,[r6,#0]\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.104|\n        LDR      r1,[r6,r4,LSL #2]\n        BL       gcd__FiT1\n        ADD      r4,r4,#1\n        CMP      r4,r5\n        BLT      |L1.104|\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nint gcd(int a, int b) {\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint gcd_many(int count, int* nums) {\n    if (count == 0) return 0;\n    if (count == 1) return nums[0];\n    int result = nums[0];\n    for (int i = 1; i < count; i++) {\n        result = gcd(result, nums[i]);\n    }\n    return result;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndfs__Fi PROC\n|L1.0|\n        STMFD    sp!,{r4-r7,lr}\n        LDR      r6,|L1.436|\n        LDR      r7,|L1.440|\n        MOV      r1,#1\n        STR      r1,[r6,r0,LSL #2]\n        LDR      r1,[r7,#0]  ; num_vertices\n        MOV      r4,#0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4-r7,lr}\n        BXLE     lr\n        ADD      r1,r0,r0,LSL #3\n        ADD      r1,r1,r0,LSL #4\n        LDR      r0,|L1.444|\n        ADD      r5,r0,r1,LSL #4\n|L1.56|\n        LDR      r0,[r5,r4,LSL #2]\n        CMP      r0,#1\n        LDREQ    r0,[r6,r4,LSL #2]\n        CMPEQ    r0,#0\n        BNE      |L1.84|\n        MOV      r0,r4\n        BL       dfs__Fi\n|L1.84|\n        LDR      r0,[r7,#0]  ; num_vertices\n        ADD      r4,r4,#1\n        CMP      r4,r0\n        BLT      |L1.56|\n        LDMFD    sp!,{r4-r7,lr}\n        BX       lr\n        ENDP\n\nisTree__Fv PROC\n        STMFD    sp!,{r4,lr}\n        LDR      r4,|L1.436|\n        MOV      r1,#0x190\n        MOV      r0,r4\n        BL       __rt_memclr_w\n        MOV      r0,#0\n        BL       dfs__Fi\n        LDR      r0,|L1.440|\n        MOV      r1,#0\n        LDR      r0,[r0,#0]  ; num_vertices\n        LDR      r2,|L1.444|\n        CMP      r0,#0\n        BLE      |L1.248|\n|L1.160|\n        MOV      r3,#0\n        CMP      r0,#0\n        BLE      |L1.236|\n        ADD      r12,r1,r1,LSL #3\n        ADD      r12,r12,r1,LSL #4\n        ADD      r12,r2,r12,LSL #4\n|L1.184|\n        LDR      lr,[r12,r3,LSL #2]\n        CMP      lr,#1\n        BNE      |L1.224|\n        LDR      lr,[r4,r1,LSL #2]\n        CMP      lr,#0\n        LDRNE    lr,[r4,r3,LSL #2]\n        CMPNE    lr,#0\n        LDMEQFD  sp!,{r4,lr}\n        MOVEQ    r0,#0\n        BXEQ     lr\n|L1.224|\n        ADD      r3,r3,#1\n        CMP      r3,r0\n        BLT      |L1.184|\n|L1.236|\n        ADD      r1,r1,#1\n        CMP      r1,r0\n        BLT      |L1.160|\n|L1.248|\n        MOV      r1,#0\n        MOV      r3,#0\n        CMP      r0,#0\n        BLE      |L1.320|\n|L1.264|\n        MOV      lr,#0\n        CMP      r0,#0\n        BLE      |L1.308|\n        ADD      r12,r3,r3,LSL #3\n        ADD      r12,r12,r3,LSL #4\n        ADD      r12,r2,r12,LSL #4\n|L1.288|\n        LDR      r4,[r12,lr,LSL #2]\n        ADD      lr,lr,#1\n        CMP      lr,r0\n        ADD      r1,r4,r1\n        BLT      |L1.288|\n|L1.308|\n        ADD      r3,r3,#1\n        CMP      r3,r0\n        BLT      |L1.264|\n|L1.320|\n        SUB      r0,r0,#1\n        CMP      r0,r1\n        LDMFD    sp!,{r4,lr}\n        MOVNE    r0,#0\n        MOVEQ    r0,#1\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n#define MAX_VERTICES 100\n\nint graph[MAX_VERTICES][MAX_VERTICES];\nint visited[MAX_VERTICES];\nint num_vertices;\n\nvoid dfs(int vertex) {\n    visited[vertex] = 1;\n    for (int i = 0; i < num_vertices; i++) {\n        if (graph[vertex][i] == 1 && !visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\nint isTree() {\n    memset(visited, 0, sizeof(visited));\n    dfs(0);\n    for (int i = 0; i < num_vertices; i++) {\n        for (int j = 0; j < num_vertices; j++) {\n            if (graph[i][j] == 1 && (visited[i] == 0 || visited[j] == 0)){\n                return 0;\n            }\n            \n        }\n    }\n    int edges = 0;\n    for (int i = 0; i < num_vertices; i++) {\n        for (int j = 0; j < num_vertices; j++) {\n            edges += graph[i][j];\n        }\n    }\n    return edges == num_vertices -1;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nparseURL__FPc PROC\n|L1.0|\n        STMFD    sp!,{r3-r9,lr}\n        MOV      r5,r1\n        MOV      r9,r0\n        MOV      r0,r5\n        ADR      r1,|L1.152|\n        BL       strstr\n        MOVS     r6,r0\n        MOV      r8,#0\n        MOVEQ    r4,r8\n        BEQ      |L1.76|\n        SUB      r7,r6,r5\n        ADD      r0,r7,#1\n        BL       malloc\n        MOV      r4,r0\n        MOV      r2,r7\n        MOV      r1,r5\n        BL       strncpy\n        STRB     r8,[r4,r7]\n        ADD      r5,r6,#3\n|L1.76|\n        MOV      r0,r5\n        MOV      r1,#0x2f\n        BL       strchr\n        CMP      r0,#0\n        STRNEB   r8,[r0,#0]\n        ADDNE    r6,r0,#1\n        MOV      r0,r5\n        MOVEQ    r6,r8\n        MOV      r1,#0x3a\n        BL       strchr\n        CMP      r0,#0\n        MOVEQ    r0,#0x50\n        BEQ      |L1.136|\n        STRB     r8,[r0],#1\n        BL       atoi\n|L1.136|\n        STMIA    r9,{r4-r6}\n        STR      r0,[r9,#0xc]\n        LDMFD    sp!,{r3-r9,lr}\n        BX       lr\n|L1.152|\n        DCB      \"://\\0\"\n        ENDP\n```",
        "output": "```cpp\n\nstruct URL {\n    char* protocol;\n    char* domain;\n    char* path;\n    int port;\n};\n\nURL parseURL(char* urlString) {\n    URL url;\n    char* protocolEnd = strstr(urlString, \"://\");\n    if (protocolEnd == NULL) {\n        url.protocol = NULL;\n        url.domain = urlString;\n\n    } else {\n        url.protocol = (char*)malloc(protocolEnd - urlString + 1);\n        strncpy(url.protocol, urlString, protocolEnd - urlString);\n        url.protocol[protocolEnd - urlString] = '\\0';\n        url.domain = protocolEnd + 3;\n    }\n\n    char* pathStart = strchr(url.domain, '/');\n    if (pathStart == NULL) {\n        url.path = NULL;\n    } else {\n        *pathStart = '\\0';\n        url.path = pathStart + 1;\n    }\n\n    char* portStart = strchr(url.domain, ':');\n    if (portStart == NULL) {\n          url.port = 80; // Default port for http\n    } else {\n        *portStart = '\\0';\n        url.port = atoi(portStart + 1);\n    }\n\n    return url;\n}\n\n\nint main() {\n    char urlString[] = \"http://www.example.com:8080/path/to/resource\";\n    URL parsedURL = parseURL(urlString);\n    \n    printf(\"%s\\n\",parsedURL.protocol);\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ncreateHeap__Fi PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r5,r0\n        MOV      r0,#0xc\n        BL       malloc\n        MOVS     r4,r0\n        LDMEQFD  sp!,{r3-r5,lr}\n        BXEQ     lr\n        MOV      r0,r5,LSL #2\n        BL       malloc\n        STR      r0,[r4,#0]\n        CMP      r0,#0\n        BNE      |L1.68|\n        MOV      r0,r4\n        BL       free\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#0\n        BX       lr\n|L1.68|\n        MOV      r0,#0\n        STR      r0,[r4,#8]\n        STR      r5,[r4,#4]\n        MOV      r0,r4\n        LDMFD    sp!,{r3-r5,lr}\n        BX       lr\n        ENDP\n\nswap__FPiT1 PROC\n        LDR      r3,[r1,#0]\n        LDR      r2,[r0,#0]\n        STR      r3,[r0,#0]\n        STR      r2,[r1,#0]\n        BX       lr\n        ENDP\n\nheapifyUp__FP10BinaryHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        CMP      r1,#0\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        SUB      r0,r1,#1\n        ADD      r0,r0,r0,LSR #31\n        MOV      r4,r0,ASR #1\n        LDR      r0,[r5,#0]\n        LDR      r2,[r0,r1,LSL #2]\n        LDR      r3,[r0,r4,LSL #2]\n        CMP      r2,r3\n        LDMLEFD  sp!,{r4,r5,lr}\n        BXLE     lr\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyUp__FP10BinaryHeapi\n        ENDP\n\ninsert__FP10BinaryHeapi PROC\n        LDR      r2,[r0,#8]\n        LDR      r3,[r0,#4]\n        CMP      r2,r3\n        BXEQ     lr\n        LDR      r3,[r0,#0]\n        STR      r1,[r3,r2,LSL #2]\n        LDR      r1,[r0,#8]\n        ADD      r1,r1,#1\n        STR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        B        heapifyUp__FP10BinaryHeapi\n        ENDP\n\nheapifyDown__FP10BinaryHeapi PROC\n        STMFD    sp!,{r4,r5,lr}\n        MOV      r5,r0\n        MOV      r0,#1\n        LDR      r3,[r5,#8]\n        ADD      r0,r0,r1,LSL #1\n        MOV      r2,#2\n        ADD      r2,r2,r1,LSL #1\n        CMP      r3,r0\n        MOV      r4,r1\n        BLE      |L1.304|\n        LDR      r12,[r5,#0]\n        LDR      lr,[r12,r0,LSL #2]\n        LDR      r12,[r12,r4,LSL #2]\n        CMP      lr,r12\n        MOVGT    r4,r0\n|L1.304|\n        CMP      r3,r2\n        BLE      |L1.332|\n        LDR      r0,[r5,#0]\n        LDR      r3,[r0,r2,LSL #2]\n        LDR      r0,[r0,r4,LSL #2]\n        CMP      r3,r0\n        MOVGT    r4,r2\n|L1.332|\n        CMP      r4,r1\n        LDMEQFD  sp!,{r4,r5,lr}\n        BXEQ     lr\n        LDR      r0,[r5,#0]\n        ADD      r2,r0,r4,LSL #2\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r2\n        BL       swap__FPiT1\n        MOV      r1,r4\n        MOV      r0,r5\n        LDMFD    sp!,{r4,r5,lr}\n        B        heapifyDown__FP10BinaryHeapi\n        ENDP\n\nextractMax__FP10BinaryHeap PROC\n        LDR      r2,[r0,#8]\n        CMP      r2,#0\n        MOVEQ    r0,#0\n        BXEQ     lr\n        STMFD    sp!,{r4,lr}\n        LDR      r1,[r0,#0]\n        ADD      r2,r1,r2,LSL #2\n        LDR      r2,[r2,#-4]\n        LDR      r4,[r1,#0]\n        STR      r2,[r1,#0]\n        LDR      r1,[r0,#8]\n        SUB      r1,r1,#1\n        STR      r1,[r0,#8]\n        MOV      r1,#0\n        BL       heapifyDown__FP10BinaryHeapi\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n\ndestroyHeap__FP10BinaryHeap PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0]\n        BL       free\n        MOV      r0,r4\n        LDMFD    sp!,{r4,lr}\n        B        free\n        ENDP\n```",
        "output": "```cpp\n\ntypedef struct {\n    int* arr;\n    int capacity;\n    int size;\n} BinaryHeap;\n\nBinaryHeap* createHeap(int capacity) {\n    BinaryHeap* heap = (BinaryHeap*)malloc(sizeof(BinaryHeap));\n    if (!heap) return 0;\n    heap->arr = (int*)malloc(capacity * sizeof(int));\n    if (!heap->arr) {\n        free(heap);\n        return 0;\n    }\n    heap->capacity = capacity;\n    heap->size = 0;\n    return heap;\n}\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapifyUp(BinaryHeap* heap, int index) {\n    if (index <= 0) return;\n    int parent = (index - 1) / 2;\n    if (heap->arr[index] > heap->arr[parent]) {\n        swap(&heap->arr[index], &heap->arr[parent]);\n        heapifyUp(heap, parent);\n    }\n}\n\nvoid insert(BinaryHeap* heap, int data) {\n    if (heap->size == heap->capacity) return;\n    heap->arr[heap->size] = data;\n    heap->size++;\n    heapifyUp(heap, heap->size - 1);\n}\n\nvoid heapifyDown(BinaryHeap* heap, int index) {\n    int largest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < heap->size && heap->arr[left] > heap->arr[largest])\n        largest = left;\n    if (right < heap->size && heap->arr[right] > heap->arr[largest])\n        largest = right;\n    if (largest != index) {\n        swap(&heap->arr[index], &heap->arr[largest]);\n        heapifyDown(heap, largest);\n    }\n}\n\n\nint extractMax(BinaryHeap* heap) {\n    if (heap->size == 0) return 0;\n    int max = heap->arr[0];\n    heap->arr[0] = heap->arr[heap->size - 1];\n    heap->size--;\n    heapifyDown(heap, 0);\n    return max;\n}\n\nvoid destroyHeap(BinaryHeap* heap) {\n    free(heap->arr);\n    free(heap);\n}\n\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ndepthFirstSearch__FP9GraphNodePi PROC\n        STMFD    sp!,{r3-r7,lr}\n        MOV      r7,r1\n        MOVS     r5,r0\n        LDMEQFD  sp!,{r3-r7,lr}\n        BXEQ     lr\n        LDR      r1,[r5,#0]\n        MOV      r0,#1\n        STR      r0,[r7,r1,LSL #2]\n        LDR      r0,[r5,#8]\n        MOV      r4,#0\n        CMP      r0,#0\n        LDMLEFD  sp!,{r3-r7,lr}\n        BXLE     lr\n|L1.52|\n        LDR      r0,[r5,#4]\n        LDR      r6,[r0,r4,LSL #2]\n        LDR      r0,[r7,r6,LSL #2]\n        CMP      r0,#0\n        BNE      |L1.96|\n        MOV      r0,#0xc\n        BL       malloc\n        ADD      r1,r6,r6,LSL #1\n        ADD      r0,r0,r1,LSL #2\n        MOV      r1,r7\n        BL       depthFirstSearch__FP9GraphNodePi\n|L1.96|\n        LDR      r0,[r5,#8]\n        ADD      r4,r4,#1\n        CMP      r0,r4\n        BGT      |L1.52|\n        LDMFD    sp!,{r3-r7,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct GraphNode {\n    int data;\n    int* neighbors;\n    int neighborCount;\n};\n\n\nvoid depthFirstSearch(GraphNode* node, int* visited) {\n    if (node == NULL) return;\n    visited[node->data] = 1;\n    for (int i = 0; i < node->neighborCount; ++i) {\n        int neighborIndex = node->neighbors[i];\n        if (!visited[neighborIndex]) {\n            depthFirstSearch(&((GraphNode*)malloc(sizeof(GraphNode)))[neighborIndex], visited);\n        }\n    }\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\ninitVendingMachine__FP14VendingMachine PROC\n        MOV      r1,#0\n        STR      r1,[r0,#0x258]\n        STR      r1,[r0,#0x25c]\n        BX       lr\n        ENDP\n\naddItem__FP14VendingMachinePCcfi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0x258]\n        MOV      r6,r3\n        MOV      r5,r2\n        CMP      r0,#0xa\n        LDMGEFD  sp!,{r4-r6,lr}\n        BXGE     lr\n        RSB      r0,r0,r0,LSL #4\n        ADD      r0,r4,r0,LSL #2\n        BL       strcpy\n        LDR      r0,[r4,#0x258]\n        RSB      r0,r0,r0,LSL #4\n        ADD      r0,r4,r0,LSL #2\n        STR      r5,[r0,#0x34]\n        LDR      r0,[r4,#0x258]\n        RSB      r0,r0,r0,LSL #4\n        ADD      r0,r4,r0,LSL #2\n        STR      r6,[r0,#0x38]\n        LDR      r0,[r4,#0x258]\n        ADD      r0,r0,#1\n        STR      r0,[r4,#0x258]\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n\ndisplayItems__FP14VendingMachine PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r6,r0\n        LDR      r0,[r0,#0x258]\n        SUB      sp,sp,#8\n        CMP      r0,#0\n        ADDLE    sp,sp,#8\n        MOV      r4,#0\n        LDMLEFD  sp!,{r4-r6,lr}\n        BXLE     lr\n|L1.148|\n        RSB      r0,r4,r4,LSL #4\n        ADD      r5,r6,r0,LSL #2\n        LDR      r0,[r5,#0x34]\n        BL       _f2d\n        LDR      r3,[r5,#0x38]\n        STMIA    sp,{r1,r3}\n        MOV      r3,r0\n        ADD      r1,r4,#1\n        MOV      r4,r1\n        ADR      r0,|L1.220|\n        MOV      r2,r5\n        BL       printf\n        LDR      r0,[r6,#0x258]\n        CMP      r0,r4\n        BGT      |L1.148|\n        ADD      sp,sp,#8\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n|L1.220|\n        DCB      \"%d. \"\n        DCB      \"%s -\"\n        DCB      \" $$%.\"\n        DCB      \"2f (\"\n        DCB      \"Quan\"\n        DCB      \"tity\"\n        DCB      \": %d\"\n        DCB      \")\\n\\0\\0\"\n        ENDP\n\ndispenseItem__FP14VendingMachinei PROC\n        STMFD    sp!,{r3-r5,lr}\n        MOV      r4,r0\n        CMP      r1,#0\n        BLE      |L1.364|\n        LDR      r0,[r4,#0x258]\n        CMP      r0,r1\n        BLT      |L1.364|\n        RSB      r0,r1,r1,LSL #4\n        ADD      r5,r4,r0,LSL #2\n        LDR      r0,[r5,#-4]\n        CMP      r0,#0\n        BLE      |L1.364|\n        LDR      r1,[r5,#-8]\n        LDR      r0,[r4,#0x25c]\n        BL       _fcmpge\n        LDMCCFD  sp!,{r3-r5,lr}\n        MOVCC    r0,#0\n        BXCC     lr\n        LDR      r1,[r5,#-8]\n        LDR      r0,[r4,#0x25c]\n        BL       _fsub\n        STR      r0,[r4,#0x25c]\n        LDR      r0,[r5,#-4]\n        SUB      r0,r0,#1\n        STR      r0,[r5,#-4]\n        LDMFD    sp!,{r3-r5,lr}\n        MOV      r0,#1\n        BX       lr\n|L1.364|\n        LDMFD    sp!,{r3-r5,lr}\n        MVN      r0,#0\n        BX       lr\n        ENDP\n\naddMoney__FP14VendingMachinef PROC\n        STMFD    sp!,{r4,lr}\n        MOV      r4,r0\n        LDR      r0,[r0,#0x25c]\n        BL       _fadd\n        STR      r0,[r4,#0x25c]\n        LDMFD    sp!,{r4,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\nstruct Item {\n    char name[50];\n    float price;\n    int quantity;\n};\n\nstruct VendingMachine {\n    Item items[10];\n    int numItems;\n    float balance;\n};\n\nvoid initVendingMachine(VendingMachine* vm) {\n    vm->numItems = 0;\n    vm->balance = 0.0f;\n}\n\nvoid addItem(VendingMachine* vm, const char* name, float price, int quantity) {\n    if (vm->numItems < 10) {\n        strcpy(vm->items[vm->numItems].name, name);\n        vm->items[vm->numItems].price = price;\n        vm->items[vm->numItems].quantity = quantity;\n        vm->numItems++;\n    }\n}\n\nvoid displayItems(VendingMachine* vm) {\n    for (int i = 0; i < vm->numItems; i++) {\n        printf(\"%d. %s - $%.2f (Quantity: %d)\\n\", i + 1, vm->items[i].name, vm->items[i].price, vm->items[i].quantity);\n    }\n}\n\n\nint dispenseItem(VendingMachine* vm, int choice) {\n    if (choice > 0 && choice <= vm->numItems && vm->items[choice -1].quantity > 0) {\n        if (vm->balance >= vm->items[choice - 1].price) {\n            vm->balance -= vm->items[choice - 1].price;\n            vm->items[choice - 1].quantity--;\n            return 1;\n        }\n        else\n            return 0;\n    }\n    return -1;\n}\n\nvoid addMoney(VendingMachine* vm, float amount) {\n    vm->balance += amount;\n}\n\n```"
    },
    {
        "instruction": "You are a disassembler that translates assembly code to C++ code. You are built specifically to convert code that was compiled with the Arm Developer Suite v1.2 compiler. All input that you receive will be asembly code that was compiled with the following command: armcpp -Wi -Wp -Wb -O2 -Otime -S -g -apcs '/interwork'\n```asm\nsieveOfEratosthenes__Fi PROC\n        STMFD    sp!,{r4-r6,lr}\n        MOV      r4,r0\n        CMP      r0,#2\n        LDMLTFD  sp!,{r4-r6,lr}\n        MOV      r0,#4\n        BLT      malloc\n        ADD      r6,r0,r4,LSL #2\n        MOV      r0,r6\n        BL       malloc\n        MOV      r5,r0\n        MOV      r2,r6\n        MOV      r1,#1\n        BL       __rt_memset\n        MOV      r2,#0\n        STR      r2,[r5,#4]\n        STR      r2,[r5,#0]\n        MOV      r1,#2\n        CMP      r4,#4\n        BLT      |L1.132|\n|L1.76|\n        LDR      r0,[r5,r1,LSL #2]\n        CMP      r0,#0\n        BEQ      |L1.116|\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BGT      |L1.116|\n|L1.100|\n        STR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,r1\n        CMP      r0,r4\n        BLE      |L1.100|\n|L1.116|\n        ADD      r1,r1,#1\n        MUL      r0,r1,r1\n        CMP      r0,r4\n        BLE      |L1.76|\n|L1.132|\n        MOV      r1,#0\n        MOV      r0,#0\n        CMP      r4,#0\n        BLT      |L1.172|\n|L1.148|\n        LDR      r2,[r5,r0,LSL #2]\n        ADD      r0,r0,#1\n        CMP      r2,#0\n        ADDNE    r1,r1,#1\n        CMP      r0,r4\n        BLE      |L1.148|\n|L1.172|\n        MOV      r0,r1,LSL #2\n        BL       malloc\n        MOV      r6,r0\n        MOV      r0,#0\n        MOV      r2,#0\n        CMP      r4,#0\n        BLT      |L1.232|\n|L1.200|\n        LDR      r1,[r5,r0,LSL #2]\n        CMP      r1,#0\n        MOVNE    r1,r2\n        STRNE    r0,[r6,r1,LSL #2]\n        ADD      r0,r0,#1\n        ADDNE    r2,r2,#1\n        CMP      r0,r4\n        BLE      |L1.200|\n|L1.232|\n        MOV      r0,r5\n        BL       free\n        MOV      r0,r6\n        LDMFD    sp!,{r4-r6,lr}\n        BX       lr\n        ENDP\n```",
        "output": "```cpp\n\n\nint* sieveOfEratosthenes(int limit) {\n    if (limit < 2) {\n        return (int*)malloc(sizeof(int) * 1);\n    }\n    int* primes = (int*)malloc(sizeof(int) * (limit + 1));\n    memset(primes, 1, sizeof(int) * (limit + 1));\n    primes[0] = primes[1] = 0;\n    for (int p = 2; p * p <= limit; p++) {\n        if (primes[p]) {\n            for (int i = p * p; i <= limit; i += p)\n                primes[i] = 0;\n        }\n    }\n    int count = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) count++;\n    }\n    int* result = (int*)malloc(sizeof(int) * count);\n    int index = 0;\n    for (int i = 0; i <= limit; i++) {\n        if (primes[i]) {\n            result[index++] = i;\n        }\n    }\n    free(primes);\n    return result;\n}\n\n```"
    }
]